<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/extension.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * extension.c
 *      Commands to manipulate extensions
 *
 * Extensions in PostgreSQL allow management of collections of SQL objects.
 *
 * All we need internally to manage an extension is an OID so that the
 * dependent objects can be associated with it.  An extension is created by
 * populating the pg_extension catalog from a "control" file.
 * The extension control file is parsed with the same parser we use for
 * postgresql.conf and recovery.conf.  An extension also has an installation
 * script file, containing SQL commands to create the extension's objects.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/extension.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>


<comment type="block">/* Globally visible state variables */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>creating_extension</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Oid</name></type>            <name>CurrentExtensionObject</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Internal data structure to hold the results of parsing a control file
 */</comment>
<typedef>typedef <type><struct>struct <name>ExtensionControlFile</name>
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>            <comment type="block">/* name of the extension */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>directory</name></decl>;</decl_stmt>        <comment type="block">/* directory for script files */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>default_version</name></decl>;</decl_stmt>    <comment type="block">/* default install target version, if any */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>module_pathname</name></decl>;</decl_stmt>    <comment type="block">/* string to substitute for
                                     * MODULE_PATHNAME */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>        <comment type="block">/* comment, if any */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>schema</name></decl>;</decl_stmt>            <comment type="block">/* target schema (allowed if !relocatable) */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>relocatable</name></decl>;</decl_stmt>    <comment type="block">/* is ALTER EXTENSION SET SCHEMA supported? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>superuser</name></decl>;</decl_stmt>        <comment type="block">/* must be superuser to install? */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>encoding</name></decl>;</decl_stmt>        <comment type="block">/* encoding of the script file, or -1 */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requires</name></decl>;</decl_stmt>        <comment type="block">/* names of prerequisite extensions */</comment>
}</block></struct></type> <name>ExtensionControlFile</name>;</typedef>

<comment type="block">/*
 * Internal data structure for update path information
 */</comment>
<typedef>typedef <type><struct>struct <name>ExtensionVersionInfo</name>
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>            <comment type="block">/* name of the starting version */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>reachable</name></decl>;</decl_stmt>        <comment type="block">/* List of ExtensionVersionInfo's */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>installable</name></decl>;</decl_stmt>    <comment type="block">/* does this version have an install script? */</comment>
    <comment type="block">/* working state for Dijkstra's algorithm: */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>distance_known</name></decl>;</decl_stmt> <comment type="block">/* is distance from start known yet? */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>distance</name></decl>;</decl_stmt>        <comment type="block">/* current worst-case distance estimate */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>ExtensionVersionInfo</name></name> <modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>    <comment type="block">/* current best predecessor */</comment>
}</block></struct></type> <name>ExtensionVersionInfo</name>;</typedef>

<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>find_update_path</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>evi_list</name></decl></parameter>,
                 <parameter><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_start</name></decl></parameter>,
                 <parameter><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_target</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>reject_indirect</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>reinitialize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>get_required_extension</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>reqExtensionName</name></decl></parameter>,
                       <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>,
                       <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>origSchemaName</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_available_versions_for_extension</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl></parameter>,
                                     <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl></parameter>,
                                     <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>convert_requires_to_datum</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>requires</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ApplyExtensionUpdates</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionOid</name></decl></parameter>,
                      <parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initialVersion</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>updateVersions</name></decl></parameter>,
                      <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>origSchemaName</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>support_gis_extension</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>read_whole_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>execute_support_gis_sql_string</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>PrepareExtensionInternal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>versionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>oldVersionName</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>         <name>ExecuteExtensionInternal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>versionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>oldVersionName</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * get_extension_oid - given an extension name, look up the OID
 *
 * If missing_ok is false, throw an error if extension name not found.  If
 * true, just return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_extension_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_extension_extname</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
                <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExtensionNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We assume that there can be at most one matching tuple */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>extname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_extension_name - given an extension OID, look up the name
 *
 * Returns a palloc'd string, or NULL if no such extension.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_extension_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ext_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ext_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We assume that there can be at most one matching tuple */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_extension</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>extname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_extension_schema - given an extension OID, fetch its extnamespace
 *
 * Returns InvalidOid if no such extension.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_extension_schema</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ext_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ext_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We assume that there can be at most one matching tuple */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_extension</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>extnamespace</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Utility functions to check validity of extension and version names
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_valid_extension_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>extensionname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Disallow empty names (the parser rejects empty identifiers anyway, but
     * let's check).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension name: \"%s\""</literal></expr></argument>, <argument><expr><name>extensionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Extension names must not be empty."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No double dashes, since that would make script filenames ambiguous.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>extensionname</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension name: \"%s\""</literal></expr></argument>, <argument><expr><name>extensionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Extension names must not contain \"--\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No leading or trailing dash either.  (We could probably allow this, but
     * it would require much care in filename parsing and would make filenames
     * visually if not formally ambiguous.  Since there's no real-world use
     * case, let's just forbid it.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>extensionname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>extensionname</name><index>[<expr><name>namelen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension name: \"%s\""</literal></expr></argument>, <argument><expr><name>extensionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Extension names must not begin or end with \"-\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No directory separators either (this is sufficient to prevent ".."
     * style attacks).
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>first_dir_separator</name><argument_list>(<argument><expr><name>extensionname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension name: \"%s\""</literal></expr></argument>, <argument><expr><name>extensionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Extension names must not contain directory separator characters."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_valid_version_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>versionname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>versionname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Disallow empty names (we could possibly allow this, but there seems
     * little point).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension version name: \"%s\""</literal></expr></argument>, <argument><expr><name>versionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Version names must not be empty."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No double dashes, since that would make script filenames ambiguous.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>versionname</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension version name: \"%s\""</literal></expr></argument>, <argument><expr><name>versionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Version names must not contain \"--\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No leading or trailing dash either.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>versionname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>versionname</name><index>[<expr><name>namelen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension version name: \"%s\""</literal></expr></argument>, <argument><expr><name>versionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Version names must not begin or end with \"-\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No directory separators either (this is sufficient to prevent ".."
     * style attacks).
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>first_dir_separator</name><argument_list>(<argument><expr><name>versionname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid extension version name: \"%s\""</literal></expr></argument>, <argument><expr><name>versionname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Version names must not contain directory separator characters."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility functions to handle extension-related path names
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_extension_control_filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extension</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>extension</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>extension</name></expr></argument>, <argument><expr><literal type="string">".control"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_extension_script_filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extension</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>extension</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>extension</name></expr></argument>, <argument><expr><literal type="string">".sql"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_extension_control_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sharepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_share_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>sharepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/extension"</literal></expr></argument>, <argument><expr><name>sharepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_extension_control_filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sharepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_share_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>sharepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/extension/%s.control"</literal></expr></argument>,
             <argument><expr><name>sharepath</name></expr></argument>, <argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_extension_script_directory</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sharepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The directory parameter can be omitted, absolute, or relative to the
     * installation's share directory.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>control</name><operator>-&gt;</operator><name>directory</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>get_extension_control_directory</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>get_share_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>sharepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>sharepath</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_extension_aux_control_filename</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>scriptdir</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scriptdir</name> <operator>=</operator> <call><name>get_extension_script_directory</name><argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s--%s.control"</literal></expr></argument>,
             <argument><expr><name>scriptdir</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scriptdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_extension_script_filename</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from_version</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>scriptdir</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scriptdir</name> <operator>=</operator> <call><name>get_extension_script_directory</name><argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>from_version</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s--%s--%s.sql"</literal></expr></argument>,
                 <argument><expr><name>scriptdir</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>from_version</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s--%s.sql"</literal></expr></argument>,
                 <argument><expr><name>scriptdir</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scriptdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Parse contents of primary or auxiliary control file, and fill in
 * fields of *control.  We parse primary file if version == NULL,
 * else the optional auxiliary file for that version.
 *
 * Control files are supposed to be very short, half a dozen lines,
 * so we don't worry about memory allocation risks here.  Also we don't
 * worry about what encoding it's in; all values are expected to be ASCII.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_extension_control_file</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>head</name> <init>= <expr><name>NULL</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Locate the file to read.  Auxiliary files are optional.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_extension_aux_control_filename</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_extension_control_filename</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>version</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* no auxiliary file for this version */</comment>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open extension control file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Parse the file content, using GUC's file parsing code.  We need not
     * check the return value since any errors will be thrown at ERROR level.
     */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ParseConfigFp</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Convert the ConfigVariable list into ExtensionControlFile entries.
     */</comment>
    <for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"directory"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be set in a secondary extension control file"</literal></expr></argument>,
                                <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>directory</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"default_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be set in a secondary extension control file"</literal></expr></argument>,
                                <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>default_version</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"module_pathname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>module_pathname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"comment"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"relocatable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value"</literal></expr></argument>,
                                <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"superuser"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>superuser</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value"</literal></expr></argument>,
                                <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>pg_valid_server_encoding</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>encoding</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid encoding name"</literal></expr></argument>,
                                <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"requires"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Need a modifiable copy of string */</comment>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rawnames</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Parse string into list of identifiers */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawnames</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>requires</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* syntax error in name list */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" must be a list of extension names"</literal></expr></argument>,
                                <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized parameter \"%s\" in file \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>FreeConfigVariables</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name> <operator>&amp;&amp;</operator> <name><name>control</name><operator>-&gt;</operator><name>schema</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"schema\" cannot be specified when \"relocatable\" is true"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the primary control file for the specified extension.
 */</comment>
<function><type><specifier>static</specifier> <name>ExtensionControlFile</name> <modifier>*</modifier></type>
<name>read_extension_control_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Set up default values.  Pointer fields are initially null.
     */</comment>
    <expr_stmt><expr><name>control</name> <operator>=</operator> <operator>(</operator><name>ExtensionControlFile</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionControlFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>superuser</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Parse the primary control file.
     */</comment>
    <expr_stmt><expr><call><name>parse_extension_control_file</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>control</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read the auxiliary control file for the specified extension and version.
 *
 * Returns a new modified ExtensionControlFile struct; the original struct
 * (reflecting just the primary control file) is not modified.
 */</comment>
<function><type><specifier>static</specifier> <name>ExtensionControlFile</name> <modifier>*</modifier></type>
<name>read_extension_aux_control_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>acontrol</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Flat-copy the struct.  Pointer fields share values with original.
     */</comment>
    <expr_stmt><expr><name>acontrol</name> <operator>=</operator> <operator>(</operator><name>ExtensionControlFile</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionControlFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>acontrol</name></expr></argument>, <argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionControlFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Parse the auxiliary control file, overwriting struct fields
     */</comment>
    <expr_stmt><expr><call><name>parse_extension_control_file</name><argument_list>(<argument><expr><name>acontrol</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>acontrol</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read an SQL script file into a string, and convert to database encoding
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_extension_script_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>src_encoding</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>src_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dest_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>src_str</name> <operator>=</operator> <call><name>read_whole_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* use database encoding if not given */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>encoding</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>src_encoding</name> <operator>=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>src_encoding</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* make sure that source string is valid in the expected encoding */</comment>
    <expr_stmt><expr><call><name>pg_verify_mbstr_len</name><argument_list>(<argument><expr><name>src_encoding</name></expr></argument>, <argument><expr><name>src_str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Convert the encoding to the database encoding. read_whole_file
     * null-terminated the string, so if no conversion happens the string is
     * valid as is.
     */</comment>
    <expr_stmt><expr><name>dest_str</name> <operator>=</operator> <call><name>pg_any_to_server</name><argument_list>(<argument><expr><name>src_str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>src_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>dest_str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute given SQL string.
 *
 * filename is used only to report errors.
 *
 * Note: it's tempting to just use SPI to execute the string, but that does
 * not work very well.  The really serious problem is that SPI will parse,
 * analyze, and plan the whole string before executing any of it; of course
 * this fails if there are any plannable statements referring to objects
 * created earlier in the script.  A lesser annoyance is that SPI insists
 * on printing the whole string as errcontext in case of any error, and that
 * could be very long.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>execute_sql_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Parse the SQL string into a list of raw parse trees.
     */</comment>
    <expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* All output from SELECTs goes to the bit bucket */</comment>
    <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do parse analysis, rule rewrite, planning, and execution for each raw
     * parsetree.  We must fully execute each query before beginning parse
     * analysis on the next one, since there may be interdependencies.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stmt_list</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

        <comment type="block">/* Be sure parser can see any DDL done so far */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
                                           <argument><expr><name>sql</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>stmt_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>qdesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
                                        <argument><expr><name>sql</name></expr></argument>,
                                        <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction control statements are not allowed within an extension script"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
                               <argument><expr><name>sql</name></expr></argument>,
                               <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><name>dest</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                               <argument><expr><name>true</name></expr></argument>,    <comment type="block">/* this is created at remote node level */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <comment type="block">/* Be sure to advance the command counter after the last script command */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute the appropriate script file for installing or updating the extension
 *
 * If from_version isn't NULL, it's an update
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>execute_extension_script</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionOid</name></decl></parameter>, <parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from_version</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>requiredSchemas</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>schemaOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>support_gis_extension</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_nestlevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>pathbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Enforce superuser-ness if appropriate.  We postpone this check until
     * here so that the flag is correctly associated with the right script(s)
     * if it's set in secondary control files.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>superuser</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>from_version</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to create extension \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Must be superuser to create this extension."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to update extension \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Must be superuser to update this extension."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_extension_script_filename</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>from_version</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Force client_min_messages and log_min_messages to be at least WARNING,
     * so that we won't spam the user with useless NOTICE messages from common
     * script actions like creating shell types.
     *
     * We use the equivalent of a function SET option to allow the setting to
     * persist for exactly the duration of the script execution.  guc.c also
     * takes care of undoing the setting on error.
     */</comment>
    <expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>client_min_messages</name> <operator>&lt;</operator> <name>WARNING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"client_min_messages"</literal></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>,
                                 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
                                 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>log_min_messages</name> <operator>&lt;</operator> <name>WARNING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>,
                                 <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
                                 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set up the search path to contain the target schema, then the schemas
     * of any prerequisite extensions, and nothing else.  In particular this
     * makes the target schema be the default creation target namespace.
     *
     * Note: it might look tempting to use PushOverrideSearchPath for this,
     * but we cannot do that.  We have to actually set the search_path GUC in
     * case the extension script examines or changes it.  In any case, the
     * GUC_ACTION_SAVE method is just as convenient.
     */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>requiredSchemas</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqschema</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>reqname</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>reqschema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>reqname</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>reqname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"search_path"</literal></expr></argument>, <argument><expr><name><name>pathbuf</name><operator>.</operator><name>data</name></name></expr></argument>,
                             <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
                             <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set creating_extension and related variables so that
     * recordDependencyOnCurrentExtension and other functions do the right
     * things.  On failure, ensure we reset these variables.
     */</comment>
    <expr_stmt><expr><name>creating_extension</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentExtensionObject</name> <operator>=</operator> <name>extensionOid</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>c_sql</name> <init>= <expr><call><name>read_extension_script_file</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>t_sql</name></decl>;</decl_stmt>

        <comment type="block">/* We use various functions that want to operate on text datums */</comment>
        <expr_stmt><expr><name>t_sql</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>c_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Reduce any lines beginning with "\echo" to empty.  This allows
         * scripts to contain messages telling people not to run them via
         * psql, which has been found to be necessary due to old habits.
         */</comment>
        <expr_stmt><expr><name>t_sql</name> <operator>=</operator> <call><name>DirectFunctionCall4Coll</name><argument_list>(<argument><expr><name>textregexreplace</name></expr></argument>,
                                        <argument><expr><name>C_COLLATION_OID</name></expr></argument>,
                                        <argument><expr><name>t_sql</name></expr></argument>,
                                        <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"^\\\\echo.*$"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"ng"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If it's not relocatable, substitute the target schema name for
         * occurrences of @extschema@.
         *
         * For a relocatable extension, we needn't do this.  There cannot be
         * any need for @extschema@, else it wouldn't be relocatable.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qSchemaName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>t_sql</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>,
                                        <argument><expr><name>t_sql</name></expr></argument>,
                                        <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"@extschema@"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>qSchemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If module_pathname was set in the control file, substitute its
         * value for occurrences of MODULE_PATHNAME.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>module_pathname</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>t_sql</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>,
                                        <argument><expr><name>t_sql</name></expr></argument>,
                                        <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"MODULE_PATHNAME"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>module_pathname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* And now back to C string */</comment>
        <expr_stmt><expr><name>c_sql</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>t_sql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>support_gis_extension</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>execute_support_gis_sql_string</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>c_sql</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>execute_sql_string</name><argument_list>(<argument><expr><name>c_sql</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><name>creating_extension</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentExtensionObject</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>creating_extension</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentExtensionObject</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Restore the GUC variables we set above.
     */</comment>
    <expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find or create an ExtensionVersionInfo for the specified version name
 *
 * Currently, we just use a List of the ExtensionVersionInfo's.  Searching
 * for them therefore uses about O(N^2) time when there are N versions of
 * the extension.  We could change the data structure to a hash table if
 * this ever becomes a bottleneck.
 */</comment>
<function><type><specifier>static</specifier> <name>ExtensionVersionInfo</name> <modifier>*</modifier></type>
<name>get_ext_ver_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>versionname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>evi_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>*evi_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>evi</name> <operator>=</operator> <operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>evi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>versionname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>evi</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>evi</name> <operator>=</operator> <operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionVersionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>versionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>reachable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>installable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* initialize for later application of Dijkstra's algorithm */</comment>
    <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>distance_known</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>evi_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>evi_list</name></expr></argument>, <argument><expr><name>evi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>evi</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Locate the nearest unprocessed ExtensionVersionInfo
 *
 * This part of the algorithm is also about O(N^2).  A priority queue would
 * make it much faster, but for now there's no need.
 */</comment>
<function><type><specifier>static</specifier> <name>ExtensionVersionInfo</name> <modifier>*</modifier></type>
<name>get_nearest_unprocessed_vertex</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>evi_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>evi_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi2</name> <init>= <expr><operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* only vertices whose distance is still uncertain are candidates */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>evi2</name><operator>-&gt;</operator><name>distance_known</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* remember the closest such vertex */</comment>
        <if_stmt><if>if <condition>(<expr><name>evi</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>evi</name><operator>-&gt;</operator><name>distance</name></name> <operator>&gt;</operator> <name><name>evi2</name><operator>-&gt;</operator><name>distance</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>evi</name> <operator>=</operator> <name>evi2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>evi</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain information about the set of update scripts available for the
 * specified extension.  The result is a List of ExtensionVersionInfo
 * structs, each with a subsidiary list of the ExtensionVersionInfos for
 * the versions that can be reached in one step from that version.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_ext_ver_list</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>evi_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>extnamelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>get_extension_script_directory</name><argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>vername</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>vername2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi2</name></decl>;</decl_stmt>

        <comment type="block">/* must be a .sql file ... */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_extension_script_filename</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* ... matching extension name followed by separator */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>extnamelen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <name><name>de</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><name>extnamelen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>||</operator>
            <name><name>de</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><name>extnamelen</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* extract version name(s) from 'extname--something.sql' filename */</comment>
        <expr_stmt><expr><name>vername</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>extnamelen</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><call><name>strrchr</name><argument_list>(<argument><expr><name>vername</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>vername2</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>vername</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>vername2</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* It's an install, not update, script; record its version name */</comment>
            <expr_stmt><expr><name>evi</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>vername</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>installable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>vername2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>        <comment type="block">/* terminate first version */</comment>
        <expr_stmt><expr><name>vername2</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>            <comment type="block">/* and point to second */</comment>

        <comment type="block">/* if there's a third --, it's bogus, ignore it */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>vername2</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Create ExtensionVersionInfos and link them together */</comment>
        <expr_stmt><expr><name>evi</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>vername</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>evi2</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>vername2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>reachable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>evi</name><operator>-&gt;</operator><name>reachable</name></name></expr></argument>, <argument><expr><name>evi2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>evi_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given an initial and final version name, identify the sequence of update
 * scripts that have to be applied to perform that update.
 *
 * Result is a List of names of versions to transition through (the initial
 * version is *not* included).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>identify_update_path</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldVersion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>evi_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_target</name></decl>;</decl_stmt>

    <comment type="block">/* Extract the version update graph from the script directory */</comment>
    <expr_stmt><expr><name>evi_list</name> <operator>=</operator> <call><name>get_ext_ver_list</name><argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize start and end vertices */</comment>
    <expr_stmt><expr><name>evi_start</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>oldVersion</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>evi_target</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find shortest path */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>find_update_path</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>, <argument><expr><name>evi_start</name></expr></argument>, <argument><expr><name>evi_target</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" has no update path from version \"%s\" to version \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>oldVersion</name></expr></argument>, <argument><expr><name>newVersion</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply Dijkstra's algorithm to find the shortest path from evi_start to
 * evi_target.
 *
 * If reject_indirect is true, ignore paths that go through installable
 * versions.  This saves work when the caller will consider starting from
 * all installable versions anyway.
 *
 * If reinitialize is false, assume the ExtensionVersionInfo list has not
 * been used for this before, and the initialization done by get_ext_ver_info
 * is still good.  Otherwise, reinitialize all transient fields used here.
 *
 * Result is a List of names of versions to transition through (the initial
 * version is *not* included).  Returns NIL if no such path.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>find_update_path</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>evi_list</name></decl></parameter>,
                 <parameter><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_start</name></decl></parameter>,
                 <parameter><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_target</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>reject_indirect</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>reinitialize</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Caller error if start == target */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>evi_start</name> <operator>!=</operator> <name>evi_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Caller error if reject_indirect and target is installable */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>reject_indirect</name> <operator>&amp;&amp;</operator> <name><name>evi_target</name><operator>-&gt;</operator><name>installable</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>reinitialize</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>evi_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>evi</name> <operator>=</operator> <operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>distance_known</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>evi_start</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>evi</name> <operator>=</operator> <call><name>get_nearest_unprocessed_vertex</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>evi</name><operator>-&gt;</operator><name>distance</name></name> <operator>==</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* all remaining vertices are unreachable */</comment>
        <expr_stmt><expr><name><name>evi</name><operator>-&gt;</operator><name>distance_known</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>evi</name> <operator>==</operator> <name>evi_target</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* found shortest path to target */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>evi-&gt;reachable</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi2</name> <init>= <expr><operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>newdist</name></decl>;</decl_stmt>

            <comment type="block">/* if reject_indirect, treat installable versions as unreachable */</comment>
            <if_stmt><if>if <condition>(<expr><name>reject_indirect</name> <operator>&amp;&amp;</operator> <name><name>evi2</name><operator>-&gt;</operator><name>installable</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>newdist</name> <operator>=</operator> <name><name>evi</name><operator>-&gt;</operator><name>distance</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>newdist</name> <operator>&lt;</operator> <name><name>evi2</name><operator>-&gt;</operator><name>distance</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>evi2</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>newdist</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>evi2</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name>evi</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>newdist</name> <operator>==</operator> <name><name>evi2</name><operator>-&gt;</operator><name>distance</name></name> <operator>&amp;&amp;</operator>
                     <name><name>evi2</name><operator>-&gt;</operator><name>previous</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                     <call><name>strcmp</name><argument_list>(<argument><expr><name><name>evi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>evi2</name><operator>-&gt;</operator><name>previous</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Break ties in favor of the version name that comes first
                 * according to strcmp().  This behavior is undocumented and
                 * users shouldn't rely on it.  We do it just to ensure that
                 * if there is a tie, the update path that is chosen does not
                 * depend on random factors like the order in which directory
                 * entries get visited.
                 */</comment>
                <expr_stmt><expr><name><name>evi2</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name>evi</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></while>

    <comment type="block">/* Return NIL if target is not reachable from start */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>evi_target</name><operator>-&gt;</operator><name>distance_known</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Build and return list of version names representing the update path */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>evi</name> <operator>=</operator> <name>evi_target</name></expr>;</init> <condition><expr><name>evi</name> <operator>!=</operator> <name>evi_start</name></expr>;</condition> <incr><expr><name>evi</name> <operator>=</operator> <name><name>evi</name><operator>-&gt;</operator><name>previous</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>evi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a target version that is not directly installable, find the
 * best installation sequence starting from a directly-installable version.
 *
 * evi_list: previously-collected version update graph
 * evi_target: member of that list that we want to reach
 *
 * Returns the best starting-point version, or NULL if there is none.
 * On success, *best_path is set to the path from the start point.
 *
 * If there's more than one possible start point, prefer shorter update paths,
 * and break any ties arbitrarily on the basis of strcmp'ing the starting
 * versions' names.
 */</comment>
<function><type><specifier>static</specifier> <name>ExtensionVersionInfo</name> <modifier>*</modifier></type>
<name>find_install_path</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>evi_list</name></decl></parameter>, <parameter><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_target</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>best_path</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We don't expect to be called for an installable target, but if we are,
     * the answer is easy: just start from there, with an empty update path.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>evi_target</name><operator>-&gt;</operator><name>installable</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>evi_target</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Consider all installable versions as start points */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>evi_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi1</name> <init>= <expr><operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>evi1</name><operator>-&gt;</operator><name>installable</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Find shortest path from evi1 to evi_target; but no need to consider
         * paths going through other installable versions.
         */</comment>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>find_update_path</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>, <argument><expr><name>evi1</name></expr></argument>, <argument><expr><name>evi_target</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Remember best path */</comment>
        <if_stmt><if>if <condition>(<expr><name>evi_start</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <call><name>list_length</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>best_path</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>best_path</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
             <call><name>strcmp</name><argument_list>(<argument><expr><name><name>evi_start</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>evi1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>evi_start</name> <operator>=</operator> <name>evi1</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>best_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>evi_start</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CREATE EXTENSION worker
 *
 * When CASCADE is specified, CreateExtensionInternal() recurses if required
 * extensions need to be installed.  To sanely handle cyclic dependencies,
 * the "parents" list contains a list of names of extensions already being
 * installed, allowing us to error out if we recurse to one of those.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>CreateExtensionInternal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>versionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>oldVersionName</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>origSchemaName</name> <init>= <expr><name>schemaName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>schemaOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extowner</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>updateVersions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredExtensions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredSchemas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extensionOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Read the primary control file.  Note we assume that it does not contain
     * any non-ASCII data, so there is no need to worry about encoding at this
     * point.
     */</comment>
    <expr_stmt><expr><name>pcontrol</name> <operator>=</operator> <call><name>read_extension_control_file</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the version to install
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>versionName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pcontrol</name><operator>-&gt;</operator><name>default_version</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name><name>pcontrol</name><operator>-&gt;</operator><name>default_version</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version to install must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>check_valid_version_name</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Figure out which script(s) we need to run to install the desired
     * version of the extension.  If we do not have a script that directly
     * does what is needed, we try to find a sequence of update scripts that
     * will get us there.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldVersionName</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * "FROM old_version" was specified, indicating that we're trying to
         * update from some unpackaged version of the extension.  Locate a
         * series of update scripts that will do it.
         */</comment>
        <expr_stmt><expr><call><name>check_valid_version_name</name><argument_list>(<argument><expr><name>oldVersionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FROM version must be different from installation target version \"%s\""</literal></expr></argument>,
                            <argument><expr><name>versionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <call><name>identify_update_path</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>,
                                              <argument><expr><name>oldVersionName</name></expr></argument>,
                                              <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Simple case where there's just one update script to run. We
             * will not need any follow-on update steps.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Multi-step sequence.  We treat this as installing the version
             * that is the target of the first script, followed by successive
             * updates to the later versions.
             */</comment>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * No FROM, so we're installing from scratch.  If there is an install
         * script for the desired version, we only need to run that one.
         */</comment>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_extension_script_filename</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Easy, no extra scripts */</comment>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Look for best way to install this version */</comment>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>evi_list</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_start</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_target</name></decl>;</decl_stmt>

            <comment type="block">/* Extract the version update graph from the script directory */</comment>
            <expr_stmt><expr><name>evi_list</name> <operator>=</operator> <call><name>get_ext_ver_list</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Identify the target version */</comment>
            <expr_stmt><expr><name>evi_target</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Identify best path to reach target */</comment>
            <expr_stmt><expr><name>evi_start</name> <operator>=</operator> <call><name>find_install_path</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>, <argument><expr><name>evi_target</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Fail if no path ... */</comment>
            <if_stmt><if>if <condition>(<expr><name>evi_start</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" has no installation script nor update path for version \"%s\""</literal></expr></argument>,
                                <argument><expr><name><name>pcontrol</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Otherwise, install best starting point and then upgrade */</comment>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name><name>evi_start</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Fetch control parameters for installation target version
     */</comment>
    <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_aux_control_file</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the target schema to install the extension into
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>schemaName</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If the user is giving us the schema name, it must exist already. */</comment>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The extension is not relocatable and the author gave us a schema
         * for it.
         *
         * Unless CASCADE parameter was given, it's an error to give a schema
         * different from control-&gt;schema if control-&gt;schema is specified.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <operator>!</operator><name>cascade</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" must be installed in schema \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Always use the schema from control file for current extension. */</comment>
        <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr>;</expr_stmt>

        <comment type="block">/* Find or create the schema in case it does not exist. */</comment>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>csstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateSchemaStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <name>schemaName</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>authrole</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* will be created by current user */</comment>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>schemaElts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CreateSchemaCommand</name><argument_list>(<argument><expr><name>csstmt</name></expr></argument>, <argument><expr><literal type="string">"(generated CREATE SCHEMA command)"</literal></expr></argument>,
                                <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * CreateSchemaCommand includes CommandCounterIncrement, so new
             * schema is now visible.
             */</comment>
            <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Neither user nor author of the extension specified schema; use the
         * current default creation namespace, which is the first explicit
         * entry in the search_path.
         */</comment>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>search_path</name> <init>= <expr><call><name>fetch_search_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>search_path</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* nothing valid in search_path? */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* recently-deleted namespace? */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We don't check creation rights on the target namespace here.  If the
     * extension script actually creates any objects there, it will fail if
     * the user doesn't have such permissions.  But there are cases such as
     * procedural languages where it's convenient to set schema = pg_catalog
     * yet we don't want to restrict the command to users with ACL_CREATE for
     * pg_catalog.
     */</comment>

    <comment type="block">/*
     * Look up the prerequisite extensions, install them if necessary, and
     * build lists of their OIDs and the OIDs of their target schemas.
     */</comment>
    <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>control-&gt;requires</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curreq</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqschema</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>reqext</name> <operator>=</operator> <call><name>get_required_extension</name><argument_list>(<argument><expr><name>curreq</name></expr></argument>,
                                        <argument><expr><name>extensionName</name></expr></argument>,
                                        <argument><expr><name>origSchemaName</name></expr></argument>,
                                        <argument><expr><name>cascade</name></expr></argument>,
                                        <argument><expr><name>parents</name></expr></argument>,
                                        <argument><expr><name>is_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reqschema</name> <operator>=</operator> <call><name>get_extension_schema</name><argument_list>(<argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredExtensions</name></expr></argument>, <argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredSchemas</name></expr></argument>, <argument><expr><name>reqschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Insert new tuple into pg_extension, and create dependency entries.
     */</comment>
    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>InsertExtensionTuple</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>extowner</name></expr></argument>,
                                   <argument><expr><name>schemaOid</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name></expr></argument>,
                                   <argument><expr><name>versionName</name></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>requiredExtensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extensionOid</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Apply any control-file comment on extension
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CreateComments</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Execute the installation script file
     */</comment>
    <expr_stmt><expr><call><name>execute_extension_script</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>control</name></expr></argument>,
                             <argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>,
                             <argument><expr><name>requiredSchemas</name></expr></argument>,
                             <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>schemaOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If additional update scripts have to be executed, apply the updates as
     * though a series of ALTER EXTENSION UPDATE commands were given
     */</comment>
    <expr_stmt><expr><call><name>ApplyExtensionUpdates</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>pcontrol</name></expr></argument>,
                          <argument><expr><name>versionName</name></expr></argument>, <argument><expr><name>updateVersions</name></expr></argument>,
                          <argument><expr><name>origSchemaName</name></expr></argument>, <argument><expr><name>cascade</name></expr></argument>, <argument><expr><name>is_create</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the OID of an extension listed in "requires", possibly creating it.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_required_extension</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>reqExtensionName</name></decl></parameter>,
                       <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>,
                       <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>origSchemaName</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>reqExtensionOid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>reqExtensionOid</name> <operator>=</operator> <call><name>get_extension_oid</name><argument_list>(<argument><expr><name>reqExtensionName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reqExtensionOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cascade</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Must install it. */</comment>
            <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>cascade_parents</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <comment type="block">/* Check extension name validity before trying to cascade. */</comment>
            <expr_stmt><expr><call><name>check_valid_extension_name</name><argument_list>(<argument><expr><name>reqExtensionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Check for cyclic dependency between extensions. */</comment>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parents</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>pname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pname</name></expr></argument>, <argument><expr><name>reqExtensionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_RECURSION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cyclic dependency detected between extensions \"%s\" and \"%s\""</literal></expr></argument>,
                                    <argument><expr><name>reqExtensionName</name></expr></argument>, <argument><expr><name>extensionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"installing required extension \"%s\""</literal></expr></argument>,
                            <argument><expr><name>reqExtensionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Add current extension to list of parents to pass down. */</comment>
            <expr_stmt><expr><name>cascade_parents</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>parents</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extensionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Create the required extension.  We propagate the SCHEMA option
             * if any, and CASCADE, but no other options.
             */</comment>
            <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>CreateExtensionInternal</name><argument_list>(<argument><expr><name>reqExtensionName</name></expr></argument>,
                                           <argument><expr><name>origSchemaName</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>cascade</name></expr></argument>,
                                           <argument><expr><name>cascade_parents</name></expr></argument>,
                                           <argument><expr><name>is_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Get its newly-assigned OID. */</comment>
            <expr_stmt><expr><name>reqExtensionOid</name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"required extension \"%s\" is not installed"</literal></expr></argument>,
                            <argument><expr><name>reqExtensionName</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <ternary><condition><expr><name>is_create</name></expr> ?</condition><then>
                     <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use CREATE EXTENSION ... CASCADE to install required extensions too."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>reqExtensionOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CREATE EXTENSION
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateExtension</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_schema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_new_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_old_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_cascade</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>versionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oldVersionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>cascade</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Check extension name validity before any filesystem access */</comment>
    <expr_stmt><expr><call><name>check_valid_extension_name</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for duplicate extension name.  The unique index on
     * pg_extension.extname would catch this anyway, and serves as a backstop
     * in case of race conditions; but this is a friendlier error message, and
     * besides we need a check to support IF NOT EXISTS.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" already exists, skipping"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" already exists"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We use global variables to track the extension being created, so we can
     * create only one extension at the same time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>creating_extension</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nested CREATE EXTENSION is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Deconstruct the statement option list */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_schema</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_schema</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_new_version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_new_version</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_new_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"old_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_old_version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_old_version</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_old_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cascade"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_cascade</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_cascade</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cascade</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>d_cascade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Call CreateExtensionInternal to do the real work. */</comment>
    <return>return <expr><call><name>CreateExtensionInternal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>,
                                   <argument><expr><name>schemaName</name></expr></argument>,
                                   <argument><expr><name>versionName</name></expr></argument>,
                                   <argument><expr><name>oldVersionName</name></expr></argument>,
                                   <argument><expr><name>cascade</name></expr></argument>,
                                   <argument><expr><name>NIL</name></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InsertExtensionTuple
 *
 * Insert the new pg_extension row, and create extension's dependency entries.
 * Return the OID assigned to the new row.
 *
 * This is exported for the benefit of pg_upgrade, which has to create a
 * pg_extension entry (and the extension-level dependencies) without
 * actually running the extension's script.
 *
 * extConfig and extCondition should be arrays or PointerGetDatum(NULL).
 * We declare them as plain Datum to avoid needing array.h in extension.h.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>InsertExtensionTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>extOwner</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>schemaOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>relocatable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extVersion</name></decl></parameter>,
                     <parameter><decl><type><name>Datum</name></type> <name>extConfig</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>extCondition</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>requiredExtensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extensionOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>nsp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Build and insert the pg_extension tuple
     */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
        <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>extName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extnamespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extrelocatable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>relocatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extversion</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>extVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>extConfig</name> <operator>==</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_extension_extconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>extConfig</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>extCondition</name> <operator>==</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_extension_extcondition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extcondition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>extCondition</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extensionOid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Record dependencies on owner, schema, and prerequisite extensions
     */</comment>
    <expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>extOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ExtensionRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>extensionOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>nsp</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>NamespaceRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsp</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>schemaOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsp</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsp</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>requiredExtensions</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqext</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>otherext</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>otherext</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ExtensionRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>otherext</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>reqext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>otherext</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherext</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="block">/* Post creation hook for new extension */</comment>
    <expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of extension deletion.
 *
 * All we need do here is remove the pg_extension tuple itself.  Everything
 * else is taken care of by the dependency infrastructure.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveExtensionById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Disallow deletion of any extension that's currently open for insertion;
     * else subsequent executions of recordDependencyOnCurrentExtension()
     * could create dangling pg_depend records that refer to a no-longer-valid
     * pg_extension OID.  This is needed not so much because we think people
     * might write "DROP EXTENSION foo" in foo's own script files, as because
     * errors in dependency management in extension script files could give
     * rise to cases where an extension is dropped as a result of recursing
     * from some contained object.  Because of that, we must test for the case
     * here, not at some higher level of the DROP EXTENSION command.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>extId</name> <operator>==</operator> <name>CurrentExtensionObject</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop extension \"%s\" because it is being modified"</literal></expr></argument>,
                        <argument><expr><call><name>get_extension_name</name><argument_list>(<argument><expr><name>extId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We assume that there can be at most one matching tuple */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function lists the available extensions (one row per primary control
 * file in the control directory).  We parse each control file and report the
 * interesting fields.
 *
 * The system view pg_available_extensions provides a user interface to this
 * SRF, adding information about whether the extensions are installed in the
 * current DB.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_available_extensions</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
                        <literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build a tuple descriptor for our result type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build tuplestore to hold the result rows */</comment>
    <expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>get_extension_control_directory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the control directory doesn't exist, we want to silently return an
     * empty set.  Any other error will be reported by ReadDir.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* do nothing */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>extname</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_extension_control_filename</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* extract extension name from 'name.control' filename */</comment>
            <expr_stmt><expr><name>extname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><call><name>strrchr</name><argument_list>(<argument><expr><name>extname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

            <comment type="block">/* ignore it if it's an auxiliary control file */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>extname</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_control_file</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* name */</comment>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
                                            <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* default_version */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>default_version</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>default_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <comment type="block">/* comment */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* clean up and return the tuplestore */</comment>
    <expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function lists the available extension versions (one row per
 * extension installation script).  For each version, we parse the related
 * control file(s) and report the interesting fields.
 *
 * The system view pg_available_extension_versions provides a user interface
 * to this SRF, adding information about which versions are installed in the
 * current DB.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_available_extension_versions</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

    <comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
                        <literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build a tuple descriptor for our result type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build tuplestore to hold the result rows */</comment>
    <expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>get_extension_control_directory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the control directory doesn't exist, we want to silently return an
     * empty set.  Any other error will be reported by ReadDir.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* do nothing */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>extname</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_extension_control_filename</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* extract extension name from 'name.control' filename */</comment>
            <expr_stmt><expr><name>extname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><call><name>strrchr</name><argument_list>(<argument><expr><name>extname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

            <comment type="block">/* ignore it if it's an auxiliary control file */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>extname</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* read the control file */</comment>
            <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_control_file</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* scan extension's script directory for install scripts */</comment>
            <expr_stmt><expr><call><name>get_available_versions_for_extension</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* clean up and return the tuplestore */</comment>
    <expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inner loop for pg_available_extension_versions:
 *        read versions of one extension, add rows to tupstore
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_available_versions_for_extension</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl></parameter>,
                                     <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl></parameter>,
                                     <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>evi_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Extract the version update graph from the script directory */</comment>
    <expr_stmt><expr><name>evi_list</name> <operator>=</operator> <call><name>get_ext_ver_list</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* For each installable version ... */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>evi_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi</name> <init>= <expr><operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>evi</name><operator>-&gt;</operator><name>installable</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Fetch parameters for specific version (pcontrol is not changed)
         */</comment>
        <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_aux_control_file</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name><name>evi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* name */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
                                        <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* version */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>evi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* superuser */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>superuser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* relocatable */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* schema */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
                                            <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <comment type="block">/* requires */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>requires</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>convert_requires_to_datum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>requires</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <comment type="block">/* comment */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Find all non-directly-installable versions that would be installed
         * starting from this version, and report them, inheriting the
         * parameters that aren't changed in updates from this version.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>evi_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi2</name> <init>= <expr><operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>evi2</name><operator>-&gt;</operator><name>installable</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>find_install_path</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>, <argument><expr><name>evi2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>best_path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>evi</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Fetch parameters for this version (pcontrol is not changed)
                 */</comment>
                <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_aux_control_file</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name><name>evi2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* name stays the same */</comment>
                <comment type="block">/* version */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>evi2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* superuser */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>superuser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* relocatable */</comment>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* schema stays the same */</comment>
                <comment type="block">/* requires */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>requires</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>convert_requires_to_datum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>requires</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <comment type="block">/* comment stays the same */</comment>

                <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a list of extension names to a name[] Datum
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>convert_requires_to_datum</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>requires</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>datums</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ndatums</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ndatums</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>requires</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>datums</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ndatums</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>requires</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curreq</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>datums</name><index>[<expr><name>ndatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
            <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>curreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>datums</name></expr></argument>, <argument><expr><name>ndatums</name></expr></argument>,
                        <argument><expr><name>NAMEOID</name></expr></argument>,
                        <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function reports the version update paths that exist for the
 * specified extension.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_extension_update_paths</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>        <name>extname</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>evi_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

    <comment type="block">/* Check extension name validity before any filesystem access */</comment>
    <expr_stmt><expr><call><name>check_valid_extension_name</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>extname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
                        <literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build a tuple descriptor for our result type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build tuplestore to hold the result rows */</comment>
    <expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read the extension's control file */</comment>
    <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_control_file</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>extname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Extract the version update graph from the script directory */</comment>
    <expr_stmt><expr><name>evi_list</name> <operator>=</operator> <call><name>get_ext_ver_list</name><argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Iterate over all pairs of versions */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>evi_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi1</name> <init>= <expr><operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>evi_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi2</name> <init>= <expr><operator>(</operator><name>ExtensionVersionInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>evi1</name> <operator>==</operator> <name>evi2</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Find shortest path from evi1 to evi2 */</comment>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>find_update_path</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>, <argument><expr><name>evi1</name></expr></argument>, <argument><expr><name>evi2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Emit result row */</comment>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* source */</comment>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>evi1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* target */</comment>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>evi2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* path */</comment>
            <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>StringInfoData</name></type> <name>pathbuf</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcv</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* The path doesn't include start vertex, but show it */</comment>
                <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>, <argument><expr><name><name>evi1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>lcv</argument>, <argument>path</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>versionName</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathbuf</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>pathbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pathbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <comment type="block">/* clean up and return the tuplestore */</comment>
    <expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_extension_config_dump
 *
 * Record information about a configuration table that belongs to an
 * extension being created, but whose contents should be dumped in whole
 * or in part during pg_dump.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_extension_config_dump</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tableoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>wherecond</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tablename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>extRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>extScan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>extTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>arrayDatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>elementDatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>arrayLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>arrayIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We only allow this to be called from an extension's SQL script. We
     * shouldn't need any permissions check beyond that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>creating_extension</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_extension_config_dump() can only be called "</literal>
                        <literal type="string">"from an SQL script executed by CREATE EXTENSION"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the table exists and is a member of the extension being
     * created.  This ensures that we don't need to register an additional
     * dependency to protect the extconfig entry.
     */</comment>
    <expr_stmt><expr><name>tablename</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tablename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"OID %u does not refer to a table"</literal></expr></argument>, <argument><expr><name>tableoid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getExtensionOfObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>tableoid</name></expr></argument>)</argument_list></call> <operator>!=</operator>
        <name>CurrentExtensionObject</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is not a member of the extension being created"</literal></expr></argument>,
                        <argument><expr><name>tablename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Add the table OID and WHERE condition to the extension's extconfig and
     * extcondition arrays.
     *
     * If the table is already in extconfig, treat this as an update of the
     * WHERE condition.
     */</comment>

    <comment type="block">/* Find the pg_extension tuple */</comment>
    <expr_stmt><expr><name>extRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>CurrentExtensionObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for extension %u"</literal></expr></argument>,
             <argument><expr><name>CurrentExtensionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build or modify the extconfig value */</comment>
    <expr_stmt><expr><name>elementDatum</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tableoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>arrayDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><name>Anum_pg_extension_extconfig</name></expr></argument>,
                              <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Previously empty extconfig, so build 1-element array */</comment>
        <expr_stmt><expr><name>arrayLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>arrayIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elementDatum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                            <argument><expr><name>OIDOID</name></expr></argument>,
                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Modify or extend existing extconfig array */</comment>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>arrayData</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arrayDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>arrayLength</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <name>arrayLength</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extconfig is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>arrayData</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>arrayIndex</name> <operator>=</operator> <name>arrayLength</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* set up to add after end */</comment>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>arrayData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>tableoid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>arrayIndex</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* replace this element instead */</comment>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrayIndex</name></expr></argument>,
                      <argument><expr><name>elementDatum</name></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>,
                      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlena array */</comment> ,
                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument> <comment type="block">/* OID's typlen */</comment> ,
                      <argument><expr><name>true</name></expr></argument> <comment type="block">/* OID's typbyval */</comment> ,
                      <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* OID's typalign */</comment> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_extension_extconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_extension_extconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Build or modify the extcondition value */</comment>
    <expr_stmt><expr><name>elementDatum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>wherecond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>arrayDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><name>Anum_pg_extension_extcondition</name></expr></argument>,
                              <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>arrayLength</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extconfig and extcondition arrays do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elementDatum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                            <argument><expr><name>TEXTOID</name></expr></argument>,
                            <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arrayDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extcondition is not a 1-D text array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>arrayLength</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extconfig and extcondition arrays do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Add or replace at same index as in extconfig */</comment>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrayIndex</name></expr></argument>,
                      <argument><expr><name>elementDatum</name></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>,
                      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlena array */</comment> ,
                      <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
                      <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
                      <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_extension_extcondition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_extension_extcondition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * extension_config_remove
 *
 * Remove the specified table OID from extension's extconfig, if present.
 * This is not currently exposed as a function, but it could be;
 * for now, we just invoke it from ALTER EXTENSION DROP.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extension_config_remove</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tableoid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>extRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>extScan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>extTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>arrayDatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>arrayLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>arrayIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

    <comment type="block">/* Find the pg_extension tuple */</comment>
    <expr_stmt><expr><name>extRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extensionoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for extension %u"</literal></expr></argument>,
             <argument><expr><name>extensionoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Search extconfig for the tableoid */</comment>
    <expr_stmt><expr><name>arrayDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><name>Anum_pg_extension_extconfig</name></expr></argument>,
                              <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* nothing to do */</comment>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>arrayLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>arrayIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>arrayData</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arrayDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>arrayLength</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <name>arrayLength</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extconfig is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>arrayData</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>arrayIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* flag for no deletion needed */</comment>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>arrayData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>tableoid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>arrayIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> <comment type="block">/* index to remove */</comment>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If tableoid is not in extconfig, nothing to do */</comment>
    <if_stmt><if>if <condition>(<expr><name>arrayIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Modify or delete the extconfig value */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>arrayLength</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* removing only element, just set array to null */</comment>
        <expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_extension_extconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* squeeze out the target element */</comment>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>dvalues</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We already checked there are no nulls, so ignore dnulls */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>arrayIndex</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLength</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dvalues</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>arrayLength</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                            <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_extension_extconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_extension_extconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Modify or delete the extcondition value */</comment>
    <expr_stmt><expr><name>arrayDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><name>Anum_pg_extension_extcondition</name></expr></argument>,
                              <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extconfig and extcondition arrays do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arrayDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extcondition is not a 1-D text array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>arrayLength</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extconfig and extcondition arrays do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>arrayLength</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* removing only element, just set array to null */</comment>
        <expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_extension_extcondition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* squeeze out the target element */</comment>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>dvalues</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We already checked there are no nulls, so ignore dnulls */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>arrayIndex</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLength</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dvalues</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>arrayLength</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                            <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_extension_extcondition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_extension_extcondition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER EXTENSION SET SCHEMA
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterExtensionNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newschema</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oldschema</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extensionOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>nspOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>oldNspOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>extRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>extScan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>extTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_extension</name></type> <name>extForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>depTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>extAddr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>extensionOid</name> <operator>=</operator> <call><name>get_extension_oid</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nspOid</name> <operator>=</operator> <call><name>LookupCreationNamespace</name><argument_list>(<argument><expr><name>newschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Permission check: must own extension.  Note that we don't bother to
     * check ownership of the individual member objects ...
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_extension_ownercheck</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_EXTENSION</name></expr></argument>,
                       <argument><expr><name>extensionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Permission check: must have creation rights in target namespace */</comment>
    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_NAMESPACE</name></expr></argument>, <argument><expr><name>newschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the schema is currently a member of the extension, disallow moving
     * the extension into the schema.  That would create a dependency loop.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>getExtensionOfObject</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>extensionOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move extension \"%s\" into schema \"%s\" "</literal>
                        <literal type="string">"because the extension contains the schema"</literal></expr></argument>,
                        <argument><expr><name>extensionName</name></expr></argument>, <argument><expr><name>newschema</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Locate the pg_extension tuple */</comment>
    <expr_stmt><expr><name>extRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for extension %u"</literal></expr></argument>,
             <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Copy tuple so we can modify it below */</comment>
    <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_extension</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the extension is already in the target schema, just silently do
     * nothing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>extForm</name><operator>-&gt;</operator><name>extnamespace</name></name> <operator>==</operator> <name>nspOid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check extension is supposed to be relocatable */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extForm</name><operator>-&gt;</operator><name>extrelocatable</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" does not support SET SCHEMA"</literal></expr></argument>,
                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>extForm</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>objsMoved</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan pg_depend to find objects that depend directly on the extension,
     * and alter each one's schema.
     */</comment>
    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>depScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>dep</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>dep_oldNspOid</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Ignore non-membership dependencies.  (Currently, the only other
         * case we could see here is a normal dependency from another
         * extension.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_EXTENSION</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>dep</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dep</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dep</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>dep</name><operator>.</operator><name>objectSubId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extension should not have a sub-object dependency"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Relocate the object */</comment>
        <expr_stmt><expr><name>dep_oldNspOid</name> <operator>=</operator> <call><name>AlterObjectNamespace_oid</name><argument_list>(<argument><expr><name><name>dep</name><operator>.</operator><name>classId</name></name></expr></argument>,
                                                 <argument><expr><name><name>dep</name><operator>.</operator><name>objectId</name></name></expr></argument>,
                                                 <argument><expr><name>nspOid</name></expr></argument>,
                                                 <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Remember previous namespace of first object that has one
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>oldNspOid</name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>dep_oldNspOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <name>dep_oldNspOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If not all the objects had the same old namespace (ignoring any
         * that are not in namespaces), complain.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>dep_oldNspOid</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>dep_oldNspOid</name> <operator>!=</operator> <name>oldNspOid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" does not support SET SCHEMA"</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>extForm</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s is not in the extension's schema \"%s\""</literal></expr></argument>,
                               <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dep</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>oldNspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* report old schema, if caller wants it */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldschema</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>oldschema</name> <operator>=</operator> <name>oldNspOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now adjust pg_extension.extnamespace */</comment>
    <expr_stmt><expr><name><name>extForm</name><operator>-&gt;</operator><name>extnamespace</name></name> <operator>=</operator> <name>nspOid</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* update dependencies to point to the new schema */</comment>
    <expr_stmt><expr><call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>,
                        <argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>extAddr</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>extAddr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER EXTENSION UPDATE
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecAlterExtensionStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_new_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>versionName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oldVersionName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extensionOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>extRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>extScan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>extTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>updateVersions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We use global variables to track the extension being created, so we can
     * create/update only one extension at the same time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>creating_extension</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nested ALTER EXTENSION is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Look up the extension --- it must already exist in pg_extension
     */</comment>
    <expr_stmt><expr><name>extRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_extension_extname</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
                <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>ExtensionNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>extensionOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the existing version we are updating from
     */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><name>Anum_pg_extension_extversion</name></expr></argument>,
                         <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extversion is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Permission check: must own extension */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_extension_ownercheck</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_EXTENSION</name></expr></argument>,
                       <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Read the primary control file.  Note we assume that it does not contain
     * any non-ASCII data, so there is no need to worry about encoding at this
     * point.
     */</comment>
    <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_control_file</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read the statement option list
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_new_version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_new_version</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Determine the version to update to
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>d_new_version</name> <operator>&amp;&amp;</operator> <name><name>d_new_version</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>versionName</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>d_new_version</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>default_version</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>default_version</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version to install must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>check_valid_version_name</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we're already at that version, just say so
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version \"%s\" of extension \"%s\" is already installed"</literal></expr></argument>,
                        <argument><expr><name>versionName</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Identify the series of update script files we need to execute
     */</comment>
    <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <call><name>identify_update_path</name><argument_list>(<argument><expr><name>control</name></expr></argument>,
                                          <argument><expr><name>oldVersionName</name></expr></argument>,
                                          <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update the pg_extension row and execute the update scripts, one at a
     * time
     */</comment>
    <expr_stmt><expr><call><name>ApplyExtensionUpdates</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>control</name></expr></argument>,
                          <argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>updateVersions</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply a series of update scripts as though individual ALTER EXTENSION
 * UPDATE commands had been given, including altering the pg_extension row
 * and dependencies each time.
 *
 * This might be more work than necessary, but it ensures that old update
 * scripts don't break if newer versions have different control parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyExtensionUpdates</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionOid</name></decl></parameter>,
                      <parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initialVersion</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>updateVersions</name></decl></parameter>,
                      <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>origSchemaName</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>support_gis_extension</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldVersionName</name> <init>= <expr><name>initialVersion</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcv</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lcv</argument>, <argument>updateVersions</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>versionName</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>schemaName</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>schemaOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredExtensions</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredSchemas</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>extRel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>extScan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>extTup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_extension</name></type> <name>extForm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl</name><index>[<expr><name>Natts_pg_extension</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Fetch parameters for specific version (pcontrol is not changed)
         */</comment>
        <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_aux_control_file</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Find the pg_extension tuple */</comment>
        <expr_stmt><expr><name>extRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>extScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for extension %u"</literal></expr></argument>,
                 <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>extForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_extension</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Determine the target schema (set by original install)
         */</comment>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <name><name>extForm</name><operator>-&gt;</operator><name>extnamespace</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Modify extrelocatable and extversion in the pg_extension tuple
         */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extrelocatable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
            <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repl</name><index>[<expr><name>Anum_pg_extension_extrelocatable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_extension_extversion</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
            <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repl</name><index>[<expr><name>Anum_pg_extension_extversion</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>extTup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>extTup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>extTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>extScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>extRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Look up the prerequisite extensions for this version, install them
         * if necessary, and build lists of their OIDs and the OIDs of their
         * target schemas.
         */</comment>
        <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>control-&gt;requires</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curreq</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>reqext</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>reqschema</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>reqext</name> <operator>=</operator> <call><name>get_required_extension</name><argument_list>(<argument><expr><name>curreq</name></expr></argument>,
                                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                            <argument><expr><name>origSchemaName</name></expr></argument>,
                                            <argument><expr><name>cascade</name></expr></argument>,
                                            <argument><expr><name>NIL</name></expr></argument>,
                                            <argument><expr><name>is_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>reqschema</name> <operator>=</operator> <call><name>get_extension_schema</name><argument_list>(<argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredExtensions</name></expr></argument>, <argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredSchemas</name></expr></argument>, <argument><expr><name>reqschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * Remove and recreate dependencies on prerequisite extensions
         */</comment>
        <expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>,
                                        <argument><expr><name>ExtensionRelationId</name></expr></argument>,
                                        <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ExtensionRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>extensionOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>requiredExtensions</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>reqext</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>otherext</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>otherext</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ExtensionRelationId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>otherext</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>reqext</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>otherext</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherext</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Finally, execute the update script file
         */</comment>
        <expr_stmt><expr><call><name>execute_extension_script</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>control</name></expr></argument>,
                                 <argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>,
                                 <argument><expr><name>requiredSchemas</name></expr></argument>,
                                 <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>schemaOid</name></expr></argument>, <argument><expr><name>support_gis_extension</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Update prior-version name and loop around.  Since
         * execute_sql_string did a final CommandCounterIncrement, we can
         * update the pg_extension row again.
         */</comment>
        <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <name>versionName</name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER EXTENSION ADD/DROP
 *
 * Return value is the address of the altered extension.
 *
 * objAddr is an output argument which, if not NULL, is set to the address of
 * the added/dropped object.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecAlterExtensionContentsStmt</name><parameter_list>(<parameter><decl><type><name>AlterExtensionContentsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
                               <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objAddr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>extension</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>oldExtension</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>extension</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ExtensionRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extension</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>get_extension_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extension</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Permission check: must own extension */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_extension_ownercheck</name><argument_list>(<argument><expr><name><name>extension</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_EXTENSION</name></expr></argument>,
                       <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Translate the parser representation that identifies the object into an
     * ObjectAddress.  get_object_address() will throw an error if the object
     * does not exist, and will also acquire a lock on the object to guard
     * against concurrent DROP and ALTER EXTENSION ADD/DROP operations.
     */</comment>
    <expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>objAddr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>objAddr</name> <operator>=</operator> <name>object</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Permission check: must own target object, too */</comment>
    <expr_stmt><expr><call><name>check_object_ownership</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name>object</name></expr></argument>,
                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check existing extension membership.
     */</comment>
    <expr_stmt><expr><name>oldExtension</name> <operator>=</operator> <call><name>getExtensionOfObject</name><argument_list>(<argument><expr><name><name>object</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>action</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * ADD, so complain if object is already attached to some extension.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldExtension</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is already a member of extension \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>get_extension_name</name><argument_list>(<argument><expr><name>oldExtension</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Prevent a schema from being added to an extension if the schema
         * contains the extension.  That would create a dependency loop.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name>NamespaceRelationId</name> <operator>&amp;&amp;</operator>
            <name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>==</operator> <call><name>get_extension_schema</name><argument_list>(<argument><expr><name><name>extension</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add schema \"%s\" to extension \"%s\" "</literal>
                            <literal type="string">"because the schema contains the extension"</literal></expr></argument>,
                            <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>object</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * OK, add the dependency.
         */</comment>
        <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extension</name></expr></argument>, <argument><expr><name>DEPENDENCY_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Also record the initial ACL on the object, if any.
         *
         * Note that this will handle the object's ACLs, as well as any ACLs
         * on object subIds.  (In other words, when the object is a table,
         * this will record the table's ACL and the ACLs for the columns on
         * the table, if any).
         */</comment>
        <expr_stmt><expr><call><name>recordExtObjInitPriv</name><argument_list>(<argument><expr><name><name>object</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * DROP, so complain if it's not a member.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>oldExtension</name> <operator>!=</operator> <name><name>extension</name><operator>.</operator><name>objectId</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a member of extension \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * OK, drop the dependency.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name><name>object</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>.</operator><name>objectId</name></name></expr></argument>,
                                            <argument><expr><name>ExtensionRelationId</name></expr></argument>,
                                            <argument><expr><name>DEPENDENCY_EXTENSION</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected number of extension dependency records"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If it's a relation, it might have an entry in the extension's
         * extconfig array, which we must remove.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>extension_config_remove</name><argument_list>(<argument><expr><name><name>extension</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Remove all the initial ACLs, if any.
         *
         * Note that this will remove the object's ACLs, as well as any ACLs
         * on object subIds.  (In other words, when the object is a table,
         * this will remove the table's ACL and the ACLs for the columns on
         * the table, if any).
         */</comment>
        <expr_stmt><expr><call><name>removeExtObjInitPriv</name><argument_list>(<argument><expr><name><name>object</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name><name>extension</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If get_object_address() opened the relation for us, we close it to keep
     * the reference count correct - but we retain any locks acquired by
     * get_object_address() until commit time, to guard against concurrent
     * activity.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>relation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>extension</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read the whole of file into memory.
 *
 * The file contents are returned as a single palloc'd chunk. For convenience
 * of the callers, an extra \0 byte is added to the end.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_whole_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>bytes_to_read</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fst</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <operator>(</operator><name>MaxAllocSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"file \"%s\" is too large"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bytes_to_read</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>fst</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for reading: %m"</literal></expr></argument>,
                        <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>bytes_to_read</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bytes_to_read</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><operator>*</operator><name>length</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * PREPARE EXTENSION
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>PrepareExtension</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_schema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_new_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_old_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_cascade</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>versionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oldVersionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>cascade</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Check extension name validity before any filesystem access */</comment>
    <expr_stmt><expr><call><name>check_valid_extension_name</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for duplicate extension name.  The unique index on
     * pg_extension.extname would catch this anyway, and serves as a backstop
     * in case of race conditions; but this is a friendlier error message, and
     * besides we need a check to support IF NOT EXISTS.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" already exists, skipping"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" already exists"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We use global variables to track the extension being created, so we can
     * create only one extension at the same time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>creating_extension</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nested CREATE EXTENSION is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Deconstruct the statement option list */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_schema</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_schema</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_new_version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_new_version</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_new_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"old_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_old_version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_old_version</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_old_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cascade"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_cascade</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_cascade</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cascade</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>d_cascade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Call PrepareExtensionInternal to do the real work. */</comment>
    <return>return <expr><call><name>PrepareExtensionInternal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>,
                                   <argument><expr><name>schemaName</name></expr></argument>,
                                   <argument><expr><name>versionName</name></expr></argument>,
                                   <argument><expr><name>oldVersionName</name></expr></argument>,
                                   <argument><expr><name>cascade</name></expr></argument>,
                                   <argument><expr><name>NIL</name></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>PrepareExtensionInternal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>versionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>oldVersionName</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>origSchemaName</name> <init>= <expr><name>schemaName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>schemaOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extowner</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>updateVersions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredExtensions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredSchemas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extensionOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Read the primary control file.  Note we assume that it does not contain
     * any non-ASCII data, so there is no need to worry about encoding at this
     * point.
     */</comment>
    <expr_stmt><expr><name>pcontrol</name> <operator>=</operator> <call><name>read_extension_control_file</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the version to install
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>versionName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pcontrol</name><operator>-&gt;</operator><name>default_version</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name><name>pcontrol</name><operator>-&gt;</operator><name>default_version</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version to install must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>check_valid_version_name</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Figure out which script(s) we need to run to install the desired
     * version of the extension.  If we do not have a script that directly
     * does what is needed, we try to find a sequence of update scripts that
     * will get us there.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldVersionName</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * "FROM old_version" was specified, indicating that we're trying to
         * update from some unpackaged version of the extension.  Locate a
         * series of update scripts that will do it.
         */</comment>
        <expr_stmt><expr><call><name>check_valid_version_name</name><argument_list>(<argument><expr><name>oldVersionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FROM version must be different from installation target version \"%s\""</literal></expr></argument>,
                            <argument><expr><name>versionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <call><name>identify_update_path</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>,
                                              <argument><expr><name>oldVersionName</name></expr></argument>,
                                              <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Simple case where there's just one update script to run. We
             * will not need any follow-on update steps.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Multi-step sequence.  We treat this as installing the version
             * that is the target of the first script, followed by successive
             * updates to the later versions.
             */</comment>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * No FROM, so we're installing from scratch.  If there is an install
         * script for the desired version, we only need to run that one.
         */</comment>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_extension_script_filename</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Easy, no extra scripts */</comment>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Look for best way to install this version */</comment>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>evi_list</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_start</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_target</name></decl>;</decl_stmt>

            <comment type="block">/* Extract the version update graph from the script directory */</comment>
            <expr_stmt><expr><name>evi_list</name> <operator>=</operator> <call><name>get_ext_ver_list</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Identify the target version */</comment>
            <expr_stmt><expr><name>evi_target</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Identify best path to reach target */</comment>
            <expr_stmt><expr><name>evi_start</name> <operator>=</operator> <call><name>find_install_path</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>, <argument><expr><name>evi_target</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Fail if no path ... */</comment>
            <if_stmt><if>if <condition>(<expr><name>evi_start</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" has no installation script nor update path for version \"%s\""</literal></expr></argument>,
                                <argument><expr><name><name>pcontrol</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Otherwise, install best starting point and then upgrade */</comment>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name><name>evi_start</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Fetch control parameters for installation target version
     */</comment>
    <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_aux_control_file</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the target schema to install the extension into
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>schemaName</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If the user is giving us the schema name, it must exist already. */</comment>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The extension is not relocatable and the author gave us a schema
         * for it.
         *
         * Unless CASCADE parameter was given, it's an error to give a schema
         * different from control-&gt;schema if control-&gt;schema is specified.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <operator>!</operator><name>cascade</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" must be installed in schema \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Always use the schema from control file for current extension. */</comment>
        <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr>;</expr_stmt>

        <comment type="block">/* Find or create the schema in case it does not exist. */</comment>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>csstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateSchemaStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <name>schemaName</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>authrole</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* will be created by current user */</comment>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>schemaElts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CreateSchemaCommand</name><argument_list>(<argument><expr><name>csstmt</name></expr></argument>, <argument><expr><literal type="string">"(generated CREATE SCHEMA command)"</literal></expr></argument>,
                                <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * CreateSchemaCommand includes CommandCounterIncrement, so new
             * schema is now visible.
             */</comment>
            <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Neither user nor author of the extension specified schema; use the
         * current default creation namespace, which is the first explicit
         * entry in the search_path.
         */</comment>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>search_path</name> <init>= <expr><call><name>fetch_search_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>search_path</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* nothing valid in search_path? */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* recently-deleted namespace? */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We don't check creation rights on the target namespace here.  If the
     * extension script actually creates any objects there, it will fail if
     * the user doesn't have such permissions.  But there are cases such as
     * procedural languages where it's convenient to set schema = pg_catalog
     * yet we don't want to restrict the command to users with ACL_CREATE for
     * pg_catalog.
     */</comment>

    <comment type="block">/*
     * Look up the prerequisite extensions, install them if necessary, and
     * build lists of their OIDs and the OIDs of their target schemas.
     */</comment>
    <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>control-&gt;requires</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curreq</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqschema</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>reqext</name> <operator>=</operator> <call><name>get_required_extension</name><argument_list>(<argument><expr><name>curreq</name></expr></argument>,
                                        <argument><expr><name>extensionName</name></expr></argument>,
                                        <argument><expr><name>origSchemaName</name></expr></argument>,
                                        <argument><expr><name>cascade</name></expr></argument>,
                                        <argument><expr><name>parents</name></expr></argument>,
                                        <argument><expr><name>is_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reqschema</name> <operator>=</operator> <call><name>get_extension_schema</name><argument_list>(<argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredExtensions</name></expr></argument>, <argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredSchemas</name></expr></argument>, <argument><expr><name>reqschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Insert new tuple into pg_extension, and create dependency entries.
     */</comment>
    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>InsertExtensionTuple</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>extowner</name></expr></argument>,
                                   <argument><expr><name>schemaOid</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>relocatable</name></name></expr></argument>,
                                   <argument><expr><name>versionName</name></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>requiredExtensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extensionOid</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Apply any control-file comment on extension
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CreateComments</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>creating_extension</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentExtensionObject</name> <operator>=</operator> <name>extensionOid</name></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecuteExtension</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_schema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_new_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_old_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>d_cascade</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>versionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oldVersionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>cascade</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    
    <comment type="block">/*
     * We use global variables to track the extension being created, so we can
     * create only one extension at the same time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>creating_extension</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected EXECUTE CREATE EXTENSION"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Deconstruct the statement option list */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_schema</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_schema</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_new_version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_new_version</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_new_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"old_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_old_version</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_old_version</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>d_old_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cascade"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d_cascade</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>d_cascade</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cascade</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>d_cascade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Call ExecuteExtensionInternal to do the real work. */</comment>
    <expr_stmt><expr><call><name>ExecuteExtensionInternal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>,
                                   <argument><expr><name>schemaName</name></expr></argument>,
                                   <argument><expr><name>versionName</name></expr></argument>,
                                   <argument><expr><name>oldVersionName</name></expr></argument>,
                                   <argument><expr><name>cascade</name></expr></argument>,
                                   <argument><expr><name>NIL</name></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteExtensionInternal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>versionName</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>oldVersionName</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>cascade</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>is_create</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>origSchemaName</name> <init>= <expr><name>schemaName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>schemaOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>pcontrol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>updateVersions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredExtensions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>requiredSchemas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>extensionOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Read the primary control file.  Note we assume that it does not contain
     * any non-ASCII data, so there is no need to worry about encoding at this
     * point.
     */</comment>
    <expr_stmt><expr><name>pcontrol</name> <operator>=</operator> <call><name>read_extension_control_file</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the version to install
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>versionName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pcontrol</name><operator>-&gt;</operator><name>default_version</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name><name>pcontrol</name><operator>-&gt;</operator><name>default_version</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version to install must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>check_valid_version_name</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Figure out which script(s) we need to run to install the desired
     * version of the extension.  If we do not have a script that directly
     * does what is needed, we try to find a sequence of update scripts that
     * will get us there.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>oldVersionName</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * "FROM old_version" was specified, indicating that we're trying to
         * update from some unpackaged version of the extension.  Locate a
         * series of update scripts that will do it.
         */</comment>
        <expr_stmt><expr><call><name>check_valid_version_name</name><argument_list>(<argument><expr><name>oldVersionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FROM version must be different from installation target version \"%s\""</literal></expr></argument>,
                            <argument><expr><name>versionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <call><name>identify_update_path</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>,
                                              <argument><expr><name>oldVersionName</name></expr></argument>,
                                              <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Simple case where there's just one update script to run. We
             * will not need any follow-on update steps.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Multi-step sequence.  We treat this as installing the version
             * that is the target of the first script, followed by successive
             * updates to the later versions.
             */</comment>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * No FROM, so we're installing from scratch.  If there is an install
         * script for the desired version, we only need to run that one.
         */</comment>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oldVersionName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>get_extension_script_filename</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Easy, no extra scripts */</comment>
            <expr_stmt><expr><name>updateVersions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Look for best way to install this version */</comment>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>evi_list</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_start</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtensionVersionInfo</name> <modifier>*</modifier></type><name>evi_target</name></decl>;</decl_stmt>

            <comment type="block">/* Extract the version update graph from the script directory */</comment>
            <expr_stmt><expr><name>evi_list</name> <operator>=</operator> <call><name>get_ext_ver_list</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Identify the target version */</comment>
            <expr_stmt><expr><name>evi_target</name> <operator>=</operator> <call><name>get_ext_ver_info</name><argument_list>(<argument><expr><name>versionName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evi_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Identify best path to reach target */</comment>
            <expr_stmt><expr><name>evi_start</name> <operator>=</operator> <call><name>find_install_path</name><argument_list>(<argument><expr><name>evi_list</name></expr></argument>, <argument><expr><name>evi_target</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>updateVersions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Fail if no path ... */</comment>
            <if_stmt><if>if <condition>(<expr><name>evi_start</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" has no installation script nor update path for version \"%s\""</literal></expr></argument>,
                                <argument><expr><name><name>pcontrol</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Otherwise, install best starting point and then upgrade */</comment>
            <expr_stmt><expr><name>versionName</name> <operator>=</operator> <name><name>evi_start</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Fetch control parameters for installation target version
     */</comment>
    <expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>read_extension_aux_control_file</name><argument_list>(<argument><expr><name>pcontrol</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the target schema to install the extension into
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>schemaName</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If the user is giving us the schema name, it must exist already. */</comment>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The extension is not relocatable and the author gave us a schema
         * for it.
         *
         * Unless CASCADE parameter was given, it's an error to give a schema
         * different from control-&gt;schema if control-&gt;schema is specified.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <operator>!</operator><name>cascade</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" must be installed in schema \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                            <argument><expr><name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Always use the schema from control file for current extension. */</comment>
        <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>schema</name></name></expr>;</expr_stmt>

        <comment type="block">/* Find or create the schema in case it does not exist. */</comment>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>csstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateSchemaStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <name>schemaName</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>authrole</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* will be created by current user */</comment>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>schemaElts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>csstmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CreateSchemaCommand</name><argument_list>(<argument><expr><name>csstmt</name></expr></argument>, <argument><expr><literal type="string">"(generated CREATE SCHEMA command)"</literal></expr></argument>,
                                <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * CreateSchemaCommand includes CommandCounterIncrement, so new
             * schema is now visible.
             */</comment>
            <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Neither user nor author of the extension specified schema; use the
         * current default creation namespace, which is the first explicit
         * entry in the search_path.
         */</comment>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>search_path</name> <init>= <expr><call><name>fetch_search_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>search_path</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* nothing valid in search_path? */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>schemaOid</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* recently-deleted namespace? */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We don't check creation rights on the target namespace here.  If the
     * extension script actually creates any objects there, it will fail if
     * the user doesn't have such permissions.  But there are cases such as
     * procedural languages where it's convenient to set schema = pg_catalog
     * yet we don't want to restrict the command to users with ACL_CREATE for
     * pg_catalog.
     */</comment>

    <comment type="block">/*
     * Look up the prerequisite extensions, install them if necessary, and
     * build lists of their OIDs and the OIDs of their target schemas.
     */</comment>
    <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>control-&gt;requires</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>curreq</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>reqschema</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>reqext</name> <operator>=</operator> <call><name>get_required_extension</name><argument_list>(<argument><expr><name>curreq</name></expr></argument>,
                                        <argument><expr><name>extensionName</name></expr></argument>,
                                        <argument><expr><name>origSchemaName</name></expr></argument>,
                                        <argument><expr><name>cascade</name></expr></argument>,
                                        <argument><expr><name>parents</name></expr></argument>,
                                        <argument><expr><name>is_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reqschema</name> <operator>=</operator> <call><name>get_extension_schema</name><argument_list>(<argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>requiredExtensions</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredExtensions</name></expr></argument>, <argument><expr><name>reqext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>requiredSchemas</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>requiredSchemas</name></expr></argument>, <argument><expr><name>reqschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    
    <expr_stmt><expr><name>extensionOid</name> <operator>=</operator> <name>CurrentExtensionObject</name></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Execute the installation script file
     */</comment>
    <expr_stmt><expr><call><name>execute_extension_script</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>control</name></expr></argument>,
                             <argument><expr><name>oldVersionName</name></expr></argument>, <argument><expr><name>versionName</name></expr></argument>,
                             <argument><expr><name>requiredSchemas</name></expr></argument>,
                             <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>schemaOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If additional update scripts have to be executed, apply the updates as
     * though a series of ALTER EXTENSION UPDATE commands were given
     */</comment>
    <expr_stmt><expr><call><name>ApplyExtensionUpdates</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><name>pcontrol</name></expr></argument>,
                          <argument><expr><name>versionName</name></expr></argument>, <argument><expr><name>updateVersions</name></expr></argument>,
                          <argument><expr><name>origSchemaName</name></expr></argument>, <argument><expr><name>cascade</name></expr></argument>, <argument><expr><name>is_create</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>execute_support_gis_sql_string</name><parameter_list>(<parameter><decl><type><name>ExtensionControlFile</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>utility_sql</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>cnt</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>create_replica_table</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Parse the SQL string into a list of raw parse trees.
     */</comment>
    <expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* All output from SELECTs goes to the bit bucket */</comment>
    <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do parse analysis, rule rewrite, planning, and execution for each raw
     * parsetree.  We must fully execute each query before beginning parse
     * analysis on the next one, since there may be interdependencies.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stmt_list</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

        <comment type="block">/* Be sure parser can see any DDL done so far */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
                                           <argument><expr><name>sql</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>stmt_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * we guess sql except utility executing on local cn is enough,
                 * sql would cover these, such as 'normal select'/insert/update/delete/'select function()'
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>qdesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
                                        <argument><expr><name>sql</name></expr></argument>,
                                        <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"skip sql on remote cn and dn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction control statements are not allowed within an extension script"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>create_replica_table</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <comment type="block">/* only push down create table stmt when create extension postgis */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CreateStmt</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>create_stmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name><operator>*</operator><operator>)</operator><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>create_stmt</name><operator>-&gt;</operator><name>distributeby</name></name> <operator>&amp;&amp;</operator> <name><name>create_stmt</name><operator>-&gt;</operator><name>distributeby</name><operator>-&gt;</operator><name>disttype</name></name> <operator>==</operator> <name>DISTTYPE_REPLICATION</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>create_replica_table</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * tables in extension should be replication, so needs to send 'create' cmd to remote nodes,
                 * and other utilities execute on local node
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>create_replica_table</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition> 
                <block>{<block_content>
                    <expr_stmt><expr><name>utility_sql</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt_len</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>utility_sql</name></expr></argument>, <argument><expr><name>sql</name> <operator>+</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>utility_sql</name><index>[<expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[%d]stmt_location:%d, stmt_len:%d ,utility_sql:%s"</literal></expr></argument>, 
                        <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>, <argument><expr><name>utility_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
                                   <argument><expr><name>utility_sql</name></expr></argument>,
                                   <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>dest</name></expr></argument>,
                                   <argument><expr><name>false</name></expr></argument>,<comment type="block">/*sentToRemote*/</comment>
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>utility_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>utility_sql</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>create_replica_table</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"skip create replica table in datanode or remote coord"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
                                   <argument><expr><name>sql</name></expr></argument>,
                                   <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>dest</name></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>,<comment type="block">/*sentToRemote*/</comment>
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>    
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <comment type="block">/* Be sure to advance the command counter after the last script command */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetExitCreateExtension</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>creating_extension</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentExtensionObject</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
