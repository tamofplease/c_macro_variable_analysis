<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/vacuum.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * vacuum.c
 *      The postgres vacuum cleaner.
 *
 * This file now includes only control and dispatch code for VACUUM and
 * ANALYZE commands.  Regular VACUUM is implemented in vacuumlazy.c,
 * ANALYZE in analyze.c, and VACUUM FULL is a variant of CLUSTER, handled
 * in cluster.c.
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/vacuum.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_ORCL_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * GUC parameters
 */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>vacuum_freeze_min_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>vacuum_freeze_table_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>vacuum_multixact_freeze_min_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>vacuum_multixact_freeze_table_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>vacuum_defer_freeze_min_age</name></decl>;</decl_stmt>

<comment type="block">/* A few variables that don't seem worth passing around as parameters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>vac_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BufferAccessStrategy</name></type> <name>vac_strategy</name></decl>;</decl_stmt>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_rel_oids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>vacrel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vac_truncate_clog</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>frozenXID</name></decl></parameter>,
                  <parameter><decl><type><name>MultiXactId</name></type> <name>minMulti</name></decl></parameter>,
                  <parameter><decl><type><name>TransactionId</name></type> <name>lastSaneFrozenXid</name></decl></parameter>,
                  <parameter><decl><type><name>MultiXactId</name></type> <name>lastSaneMinMulti</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
           <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Primary entry point for manual VACUUM and ANALYZE commands
 *
 * This is mainly a preparation wrapper for the real operations that will
 * happen in vacuum().
 */</comment>
<function><type><name>void</name></type>
<name>ExecVacuum</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacstmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VacuumParams</name></type> <name>params</name></decl>;</decl_stmt>

    <comment type="block">/* sanity checks on options */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>(</operator><name>VACOPT_VACUUM</name> <operator>|</operator> <name>VACOPT_ANALYZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>||</operator>
           <operator>!</operator><operator>(</operator><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>(</operator><name>VACOPT_FULL</name> <operator>|</operator> <name>VACOPT_FREEZE</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name><operator>)</operator> <operator>||</operator> <name><name>vacstmt</name><operator>-&gt;</operator><name>va_cols</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_SKIPTOAST</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * All freeze ages are zero if the FREEZE option is given; otherwise pass
     * them as -1 which means to use the default values.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FREEZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_min_age</name></name> <operator>=</operator> <name>vacuum_defer_freeze_min_age</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_table_age</name></name> <operator>=</operator> <name>vacuum_defer_freeze_min_age</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_min_age</name></name> <operator>=</operator> <name>vacuum_defer_freeze_min_age</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_table_age</name></name> <operator>=</operator> <name>vacuum_defer_freeze_min_age</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_min_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>freeze_table_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_min_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>params</name><operator>.</operator><name>multixact_freeze_table_age</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* user-invoked vacuum is never "for wraparound" */</comment>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>is_wraparound</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* user-invoked vacuum never uses this parameter */</comment>
    <expr_stmt><expr><name><name>params</name><operator>.</operator><name>log_min_duration</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Now go through the common routine */</comment>
    <expr_stmt><expr><call><name>vacuum</name><argument_list>(<argument><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>,
           <argument><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>va_cols</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Primary entry point for VACUUM and ANALYZE commands.
 *
 * options is a bitmask of VacuumOption flags, indicating what to do.
 *
 * relid, if not InvalidOid, indicate the relation to process; otherwise,
 * the RangeVar is used.  (The latter must always be passed, because it's
 * used for error messages.)
 *
 * params contains a set of parameters that can be used to customize the
 * behavior.
 *
 * va_cols is a list of columns to analyze, or NIL to process them all.
 *
 * bstrategy is normally given as NULL, but in autovacuum it can be passed
 * in to use the same buffer strategy object across multiple vacuum() calls.
 *
 * isTopLevel should be passed down from ProcessUtility.
 *
 * It is the caller's responsibility that all parameters are allocated in a
 * memory context that will not disappear at transaction commit.
 */</comment>
<function><type><name>void</name></type>
<name>vacuum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmttype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>in_outer_xact</name></decl>,
                <decl><type ref="prev"/><name>use_own_xacts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>relations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>in_vacuum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>stmttype</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"VACUUM"</literal></expr> </then><else>: <expr><literal type="string">"ANALYZE"</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * We cannot run VACUUM inside a user transaction block; if we were inside
     * a transaction, then our commit- and start-transaction-command calls
     * would not have the intended effect!    There are numerous other subtle
     * dependencies on this, too.
     *
     * ANALYZE (without VACUUM) can run either way.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PreventTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>stmttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>in_outer_xact</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>in_outer_xact</name> <operator>=</operator> <call><name>IsInTransactionChain</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Due to static variables vac_context, anl_context and vac_strategy,
     * vacuum() is not reentrant.  This matters when VACUUM FULL or ANALYZE
     * calls a hostile index expression that itself calls ANALYZE.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>in_vacuum</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be executed from VACUUM or ANALYZE"</literal></expr></argument>,
                        <argument><expr><name>stmttype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Sanity check DISABLE_PAGE_SKIPPING option.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_DISABLE_PAGE_SKIPPING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VACUUM option DISABLE_PAGE_SKIPPING cannot be used with FULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Send info about dead objects to the statistics collector, unless we are
     * in autovacuum --- autovacuum.c does this for itself.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgstat_vacuum_stat</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create special memory context for cross-transaction storage.
     *
     * Since it is a child of PortalContext, it will go away eventually even
     * if we suffer an error; there's no need for special abort cleanup logic.
     */</comment>
    <expr_stmt><expr><name>vac_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>,
                                        <argument><expr><literal type="string">"Vacuum"</literal></expr></argument>,
                                        <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If caller didn't give us a buffer strategy object, make one in the
     * cross-transaction memory context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>bstrategy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>bstrategy</name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <name>bstrategy</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Build list of relations to process, unless caller gave us one. (If we
     * build one, we put it in vac_context for safekeeping.)
     */</comment>
    <expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>get_rel_oids</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Decide whether we need to start/commit our own transactions.
     *
     * For VACUUM (with or without ANALYZE): always do so, so that we can
     * release locks as soon as possible.  (We could possibly use the outer
     * transaction for a one-table VACUUM, but handling TOAST tables would be
     * problematic.)
     *
     * For ANALYZE (no VACUUM): if inside a transaction block, we cannot
     * start/commit our own transactions.  Also, there's no need to do so if
     * only processing one relation.  For multiple relations when not within a
     * transaction block, and also in an autovacuum worker, use own
     * transactions so we can release locks sooner.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>in_outer_xact</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>use_own_xacts</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * vacuum_rel expects to be entered with no transaction active; it will
     * start and commit its own transaction.  But we are called by an SQL
     * command, and so we are executing inside a transaction already. We
     * commit the transaction started in PostgresMain() here, and start
     * another one before exiting to match the commit waiting for us back in
     * PostgresMain().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>in_outer_xact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ActiveSnapshot is not set by autovacuum */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* matches the StartTransaction in PostgresMain() */</comment>
        <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Turn vacuum cost accounting on or off */</comment>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>in_vacuum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>VacuumCostActive</name> <operator>=</operator> <operator>(</operator><name>VacuumCostDelay</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>VacuumCostBalance</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>VacuumPageHit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>VacuumPageMiss</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>VacuumPageDirty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Loop to process each selected relation.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>relations</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If using separate xacts, start one for analyze. Otherwise,
                 * we can use the outer transaction.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* functions in indexes may want a snapshot set */</comment>
                    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>analyze_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
                            <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><name>in_vacuum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>VacuumCostActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>in_vacuum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>VacuumCostActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Finish up processing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_own_xacts</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* here, we are not in a transaction */</comment>

        <comment type="block">/*
         * This matches the CommitTransaction waiting for us in
         * PostgresMain().
         */</comment>
        <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Update pg_database.datfrozenxid, and truncate pg_xact if possible.
         * (autovacuum.c does this for itself.)
         */</comment>
        <expr_stmt><expr><call><name>vac_update_datfrozenxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Clean up working storage --- note we must do this after
     * StartTransactionCommand, else we might be trying to delete the active
     * context!
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>vac_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a list of Oids for each relation to be processed
 *
 * The list is built in vac_context so that it will survive across our
 * per-relation transactions.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_rel_oids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>vacrel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>oid_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* OID supplied by VACUUM's caller? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oid_list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oid_list</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>vacrel</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Process a specific relation */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>include_parts</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Since we don't take a lock here, the relation might be gone, or the
         * RangeVar might no longer refer to the OID we look up here.  In the
         * former case, VACUUM will do nothing; in the latter case, it will
         * process the OID we looked up here, rather than the new one. Neither
         * is ideal, but there's little practical alternative, since we're
         * going to commit this transaction and begin a new one between now
         * and then.
         */</comment>
        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>vacrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * To check whether the relation is a partitioned table, fetch its
         * syscache entry.
         */</comment>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>include_parts</name> <operator>=</operator> <operator>(</operator><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Make relation list entries for this guy and its partitions, if any.
         * Note that the list returned by find_all_inheritors() include the
         * passed-in OID at its head.  Also note that we did not request a
         * lock to be taken to match what would be done otherwise.
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>include_parts</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>oid_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>oid_list</name></expr></argument>,
                                   <argument><expr><call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>oid_list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oid_list</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Process all plain relations and materialized views listed in
         * pg_class
         */</comment>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>pgclass</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * We include partitioned tables here; depending on which
             * operation is to be performed, caller will decide whether to
             * process or ignore them.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
                <name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
                <name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
			
			<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relpartkind</name></name> <operator>==</operator> <name>RELPARTKIND_CHILD</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Make a relation list entry for this guy */</comment>
            <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>oid_list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oid_list</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>oid_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * vacuum_set_xid_limits() -- compute oldest-Xmin and freeze cutoff points
 *
 * The output parameters are:
 * - oldestXmin is the cutoff value used to distinguish whether tuples are
 *     DEAD or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
 * - freezeLimit is the Xid below which all Xids are replaced by
 *     FrozenTransactionId during vacuum.
 * - xidFullScanLimit (computed from table_freeze_age parameter)
 *     represents a minimum Xid value; a table whose relfrozenxid is older than
 *     this will have a full-table vacuum applied to it, to freeze tuples across
 *     the whole table.  Vacuuming a table younger than this value can use a
 *     partial scan.
 * - multiXactCutoff is the value below which all MultiXactIds are removed from
 *     Xmax.
 * - mxactFullScanLimit is a value against which a table's relminmxid value is
 *     compared to produce a full-table vacuum, as with xidFullScanLimit.
 *
 * xidFullScanLimit and mxactFullScanLimit can be passed as NULL if caller is
 * not interested.
 */</comment>
<function><type><name>void</name></type>
<name>vacuum_set_xid_limits</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>freeze_min_age</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>freeze_table_age</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>multixact_freeze_min_age</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>multixact_freeze_table_age</name></decl></parameter>,
                      <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>oldestXmin</name></decl></parameter>,
                      <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>freezeLimit</name></decl></parameter>,
                      <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xidFullScanLimit</name></decl></parameter>,
                      <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>multiXactCutoff</name></decl></parameter>,
                      <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>mxactFullScanLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>freezemin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>mxid_freezemin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>effective_multixact_freeze_max_age</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>safeLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MultiXactId</name></type> <name>mxactLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MultiXactId</name></type> <name>safeMxactLimit</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We can always ignore processes running lazy vacuum.  This is because we
     * use these values only for deciding which tuples we must keep in the
     * tables.  Since lazy vacuum doesn't write its XID anywhere, it's safe to
     * ignore it.  In theory it could be problematic to ignore lazy vacuums in
     * a full vacuum, but keep in mind that only one vacuum process can be
     * working on a particular table at any time, and that each vacuum is
     * always an independent transaction.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>oldestXmin</name> <operator>=</operator>
        <call><name>TransactionIdLimitedForOldSnapshots</name><argument_list>(<argument><expr><call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><operator>*</operator><name>oldestXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the minimum freeze age to use: as specified by the caller, or
     * vacuum_freeze_min_age, but in any case not more than half
     * autovacuum_freeze_max_age, so that autovacuums to prevent XID
     * wraparound won't occur too frequently.
     */</comment>
    <expr_stmt><expr><name>freezemin</name> <operator>=</operator> <name>freeze_min_age</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>freezemin</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>freezemin</name> <operator>=</operator> <name>vacuum_freeze_min_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>freezemin</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>freezemin</name></expr></argument>, <argument><expr><name>autovacuum_freeze_max_age</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freezemin</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute the cutoff XID, being careful not to generate a "permanent" XID
     */</comment>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>*</operator><name>oldestXmin</name> <operator>-</operator> <name>freezemin</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If oldestXmin is very far back (in practice, more than
     * autovacuum_freeze_max_age / 2 XIDs old), complain and force a minimum
     * freeze age of zero.
     */</comment>
    <expr_stmt><expr><name>safeLimit</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>autovacuum_freeze_max_age</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>safeLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>safeLimit</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>safeLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oldest xmin is far in the past"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Close open transactions soon to avoid wraparound problems."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>*</operator><name>oldestXmin</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>freezeLimit</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute the multixact age for which freezing is urgent.  This is
     * normally autovacuum_multixact_freeze_max_age, but may be less if we are
     * short of multixact member space.
     */</comment>
    <expr_stmt><expr><name>effective_multixact_freeze_max_age</name> <operator>=</operator> <call><name>MultiXactMemberFreezeThreshold</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the minimum multixact freeze age to use: as specified by
     * caller, or vacuum_multixact_freeze_min_age, but in any case not more
     * than half effective_multixact_freeze_max_age, so that autovacuums to
     * prevent MultiXact wraparound won't occur too frequently.
     */</comment>
    <expr_stmt><expr><name>mxid_freezemin</name> <operator>=</operator> <name>multixact_freeze_min_age</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mxid_freezemin</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>mxid_freezemin</name> <operator>=</operator> <name>vacuum_multixact_freeze_min_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>mxid_freezemin</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>mxid_freezemin</name></expr></argument>,
                         <argument><expr><name>effective_multixact_freeze_max_age</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mxid_freezemin</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* compute the cutoff multi, being careful to generate a valid value */</comment>
    <expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>mxid_freezemin</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mxactLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>safeMxactLimit</name> <operator>=</operator>
        <call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>effective_multixact_freeze_max_age</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>safeMxactLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>safeMxactLimit</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>mxactLimit</name></expr></argument>, <argument><expr><name>safeMxactLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oldest multixact is far in the past"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Close open transactions with multixacts soon to avoid wraparound problems."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>safeMxactLimit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>multiXactCutoff</name> <operator>=</operator> <name>mxactLimit</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>xidFullScanLimit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>freezetable</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mxactFullScanLimit</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Determine the table freeze age to use: as specified by the caller,
         * or vacuum_freeze_table_age, but in any case not more than
         * autovacuum_freeze_max_age * 0.95, so that if you have e.g nightly
         * VACUUM schedule, the nightly VACUUM gets a chance to freeze tuples
         * before anti-wraparound autovacuum is launched.
         */</comment>
        <expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>freeze_table_age</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>freezetable</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>vacuum_freeze_table_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>freezetable</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>freezetable</name></expr></argument>, <argument><expr><name>autovacuum_freeze_max_age</name> <operator>*</operator> <literal type="number">0.95</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freezetable</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Compute XID limit causing a full-table vacuum, being careful not to
         * generate a "permanent" XID.
         */</comment>
        <expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>freezetable</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>xidFullScanLimit</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Similar to the above, determine the table freeze age to use for
         * multixacts: as specified by the caller, or
         * vacuum_multixact_freeze_table_age, but in any case not more than
         * autovacuum_multixact_freeze_table_age * 0.95, so that if you have
         * e.g. nightly VACUUM schedule, the nightly VACUUM gets a chance to
         * freeze multixacts before anti-wraparound autovacuum is launched.
         */</comment>
        <expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>multixact_freeze_table_age</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>freezetable</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>freezetable</name> <operator>=</operator> <name>vacuum_multixact_freeze_table_age</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>freezetable</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>freezetable</name></expr></argument>,
                          <argument><expr><name>effective_multixact_freeze_max_age</name> <operator>*</operator> <literal type="number">0.95</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freezetable</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Compute MultiXact limit causing a full-table vacuum, being careful
         * to generate a valid MultiXact value.
         */</comment>
        <expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call> <operator>-</operator> <name>freezetable</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>mxactLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>mxactLimit</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>mxactFullScanLimit</name> <operator>=</operator> <name>mxactLimit</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mxactFullScanLimit</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * vac_estimate_reltuples() -- estimate the new value for pg_class.reltuples
 *
 *        If we scanned the whole relation then we should just use the count of
 *        live tuples seen; but if we did not, we should not trust the count
 *        unreservedly, especially not in VACUUM, which may have scanned a quite
 *        nonrandom subset of the table.  When we have only partial information,
 *        we take the old value of pg_class.reltuples as a measurement of the
 *        tuple density in the unscanned pages.
 *
 *        This routine is shared by VACUUM and ANALYZE.
 */</comment>
<function><type><name>double</name></type>
<name>vac_estimate_reltuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_analyze</name></decl></parameter>,
                       <parameter><decl><type><name>BlockNumber</name></type> <name>total_pages</name></decl></parameter>,
                       <parameter><decl><type><name>BlockNumber</name></type> <name>scanned_pages</name></decl></parameter>,
                       <parameter><decl><type><name>double</name></type> <name>scanned_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_rel_pages</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>old_rel_tuples</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>old_density</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>new_density</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>multiplier</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>updated_density</name></decl>;</decl_stmt>

    <comment type="block">/* If we did scan the whole table, just use the count as-is */</comment>
    <if_stmt><if>if <condition>(<expr><name>scanned_pages</name> <operator>&gt;=</operator> <name>total_pages</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>scanned_tuples</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If scanned_pages is zero but total_pages isn't, keep the existing value
     * of reltuples.  (Note: callers should avoid updating the pg_class
     * statistics in this situation, since no new information has been
     * provided.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>scanned_pages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>old_rel_tuples</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If old value of relpages is zero, old density is indeterminate; we
     * can't do much except scale up scanned_tuples to match total_pages.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>old_rel_pages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>scanned_tuples</name> <operator>/</operator> <name>scanned_pages</name><operator>)</operator> <operator>*</operator> <name>total_pages</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Okay, we've covered the corner cases.  The normal calculation is to
     * convert the old measurement to a density (tuples per page), then update
     * the density using an exponential-moving-average approach, and finally
     * compute reltuples as updated_density * total_pages.
     *
     * For ANALYZE, the moving average multiplier is just the fraction of the
     * table's pages we scanned.  This is equivalent to assuming that the
     * tuple density in the unscanned pages didn't change.  Of course, it
     * probably did, if the new density measurement is different. But over
     * repeated cycles, the value of reltuples will converge towards the
     * correct value, if repeated measurements show the same new density.
     *
     * For VACUUM, the situation is a bit different: we have looked at a
     * nonrandom sample of pages, but we know for certain that the pages we
     * didn't look at are precisely the ones that haven't changed lately.
     * Thus, there is a reasonable argument for doing exactly the same thing
     * as for the ANALYZE case, that is use the old density measurement as the
     * value for the unscanned pages.
     *
     * This logic could probably use further refinement.
     */</comment>
    <expr_stmt><expr><name>old_density</name> <operator>=</operator> <name>old_rel_tuples</name> <operator>/</operator> <name>old_rel_pages</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_density</name> <operator>=</operator> <name>scanned_tuples</name> <operator>/</operator> <name>scanned_pages</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>multiplier</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>scanned_pages</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>total_pages</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>updated_density</name> <operator>=</operator> <name>old_density</name> <operator>+</operator> <operator>(</operator><name>new_density</name> <operator>-</operator> <name>old_density</name><operator>)</operator> <operator>*</operator> <name>multiplier</name></expr>;</expr_stmt>
    <return>return <expr><call><name>floor</name><argument_list>(<argument><expr><name>updated_density</name> <operator>*</operator> <name>total_pages</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *    vac_update_relstats() -- update statistics for one relation
 *
 *        Update the whole-relation statistics that are kept in its pg_class
 *        row.  There are additional stats that will be updated if we are
 *        doing ANALYZE, but we always update these stats.  This routine works
 *        for both index and heap relation entries in pg_class.
 *
 *        We violate transaction semantics here by overwriting the rel's
 *        existing pg_class tuple with the new values.  This is reasonably
 *        safe as long as we're sure that the new values are correct whether or
 *        not this transaction commits.  The reason for doing this is that if
 *        we updated these tuples in the usual way, vacuuming pg_class itself
 *        wouldn't work very well --- by the time we got done with a vacuum
 *        cycle, most of the tuples in pg_class would've been obsoleted.  Of
 *        course, this only works for fixed-size not-null columns, but these are.
 *
 *        Another reason for doing it this way is that when we are in a lazy
 *        VACUUM and have PROC_IN_VACUUM set, we mustn't do any regular updates.
 *        Somebody vacuuming pg_class might think they could delete a tuple
 *        marked with xmin = our xid.
 *
 *        In addition to fundamentally nontransactional statistics such as
 *        relpages and relallvisible, we try to maintain certain lazily-updated
 *        DDL flags such as relhasindex, by clearing them if no longer correct.
 *        It's safe to do this in VACUUM, which can't run in parallel with
 *        CREATE INDEX/RULE/TRIGGER and can't be part of a transaction block.
 *        However, it's *not* safe to do it in an ANALYZE that's within an
 *        outer transaction, because for example the current transaction might
 *        have dropped the last index; then we'd think relhasindex should be
 *        cleared, but if the transaction later rolls back this would be wrong.
 *        So we refrain from updating the DDL flags if we're inside an outer
 *        transaction.  This is OK since postponing the flag maintenance is
 *        always allowable.
 *
 *        This routine is shared by VACUUM and ANALYZE.
 */</comment>
<function><type><name>void</name></type>
<name>vac_update_relstats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
                    <parameter><decl><type><name>BlockNumber</name></type> <name>num_pages</name></decl></parameter>,
                    <parameter><decl><type><name>double</name></type> <name>num_tuples</name></decl></parameter>,
                    <parameter><decl><type><name>BlockNumber</name></type> <name>num_all_visible_pages</name></decl></parameter>,
                    <parameter><decl><type><name>bool</name></type> <name>hasindex</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>frozenxid</name></decl></parameter>,
                    <parameter><decl><type><name>MultiXactId</name></type> <name>minmulti</name></decl></parameter>,
                    <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>ctup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pgcform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>dirty</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rd</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch a copy of the tuple to scribble on */</comment>
    <expr_stmt><expr><name>ctup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_class entry for relid %u vanished during vacuuming"</literal></expr></argument>,
             <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Apply statistical updates, if any, to copied tuple */</comment>

    <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_pages</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_pages</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>!=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>num_tuples</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>num_tuples</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_all_visible_pages</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>num_all_visible_pages</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Apply DDL updates, but not inside an outer transaction (see above) */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_outer_xact</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we didn't find any indexes, reset relhasindex.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasindex</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we have discovered that there are no indexes, then there's no
         * primary key either.  This could be done more thoroughly...
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhaspkey</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasindex</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhaspkey</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* We also clear relhasrules and relhastriggers if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasrules</name></name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhasrules</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Update relfrozenxid, unless caller passed InvalidTransactionId
     * indicating it has no new data.
     *
     * Ordinarily, we don't let relfrozenxid go backwards: if things are
     * working correctly, the only way the new frozenxid could be older would
     * be if a previous VACUUM was done with a tighter freeze_min_age, in
     * which case we don't want to forget the work it already did.  However,
     * if the stored relfrozenxid is "in the future", then it must be corrupt
     * and it seems best to overwrite it with the cutoff we used this time.
     * This should match vac_update_datfrozenxid() concerning what we consider
     * to be "in the future".
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>frozenxid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>!=</operator> <name>frozenxid</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>, <argument><expr><name>frozenxid</name></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>frozenxid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Similarly for relminmxid */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>minmulti</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>!=</operator> <name>minmulti</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>, <argument><expr><name>minmulti</name></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pgcform</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>minmulti</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If anything changed, write out the tuple. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>rd</name></expr></argument>, <argument><expr><name>ctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rd</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    vac_update_datfrozenxid() -- update pg_database.datfrozenxid for our DB
 *
 *        Update pg_database's datfrozenxid entry for our database to be the
 *        minimum of the pg_class.relfrozenxid values.
 *
 *        Similarly, update our datminmxid to be the minimum of the
 *        pg_class.relminmxid values.
 *
 *        If we are able to advance either pg_database value, also try to
 *        truncate pg_xact and pg_multixact.
 *
 *        We violate transaction semantics here by overwriting the database's
 *        existing pg_database tuple with the new values.  This is reasonably
 *        safe since the new values are correct whether or not this transaction
 *        commits.  As with vac_update_relstats, this avoids leaving dead tuples
 *        behind after a VACUUM.
 */</comment>
<function><type><name>void</name></type>
<name>vac_update_datfrozenxid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_database</name></type> <name>dbform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>classTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>newFrozenXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MultiXactId</name></type> <name>newMinMulti</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>lastSaneFrozenXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MultiXactId</name></type> <name>lastSaneMinMulti</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bogus</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Initialize the "min" calculation with GetOldestXmin, which is a
     * reasonable approximation to the minimum relfrozenxid for not-yet-
     * committed pg_class entries for new tables; see AddNewRelationTuple().
     * So we cannot produce a wrong minimum by starting with this.
     */</comment>
    <expr_stmt><expr><name>newFrozenXid</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Similarly, initialize the MultiXact "min" with the value that would be
     * used on pg_class for new tables.  See AddNewRelationTuple().
     */</comment>
    <expr_stmt><expr><name>newMinMulti</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Identify the latest relfrozenxid and relminmxid values that we could
     * validly see during the scan.  These are conservative values, but it's
     * not really worth trying to be more exact.
     */</comment>
    <expr_stmt><expr><name>lastSaneFrozenXid</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lastSaneMinMulti</name> <operator>=</operator> <call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We must seqscan pg_class to find the minimum Xid, because there is no
     * index that can help us here.
     */</comment>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>classTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Only consider relations able to hold unfrozen XIDs (anything else
         * should have InvalidTransactionId in relfrozenxid anyway.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
            <name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
            <name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If things are working properly, no relation should have a
         * relfrozenxid or relminmxid that is "in the future".  However, such
         * cases have been known to arise due to bugs in pg_upgrade.  If we
         * see any entries that are "in the future", chicken out and don't do
         * anything.  This ensures we won't truncate clog before those
         * relations have been scanned and cleaned up.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneMinMulti</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>bogus</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>, <argument><expr><name>newFrozenXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newFrozenXid</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>, <argument><expr><name>newMinMulti</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>newMinMulti</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* we're done with pg_class */</comment>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* chicken out if bogus data found */</comment>
    <if_stmt><if>if <condition>(<expr><name>bogus</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>newFrozenXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>newMinMulti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now fetch the pg_database tuple we need to update. */</comment>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch a copy of the tuple to scribble on */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for database %u"</literal></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>dbform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * As in vac_update_relstats(), we ordinarily don't want to let
     * datfrozenxid go backward; but if it's "in the future" then it must be
     * corrupt and it seems best to overwrite it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name> <operator>!=</operator> <name>newFrozenXid</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr></argument>, <argument><expr><name>newFrozenXid</name></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>

    <block>{<block_content>
        <expr_stmt><expr><name><name>dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name> <operator>=</operator> <name>newFrozenXid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>newFrozenXid</name> <operator>=</operator> <name><name>dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Ditto for datminmxid */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dbform</name><operator>-&gt;</operator><name>datminmxid</name></name> <operator>!=</operator> <name>newMinMulti</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr></argument>, <argument><expr><name>newMinMulti</name></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneMinMulti</name></expr></argument>, <argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>dbform</name><operator>-&gt;</operator><name>datminmxid</name></name> <operator>=</operator> <name>newMinMulti</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>newMinMulti</name> <operator>=</operator> <name><name>dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we were able to advance datfrozenxid or datminmxid, see if we can
     * truncate pg_xact and/or pg_multixact.  Also do it if the shared
     * XID-wrap-limit info is stale, since this action will update that too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dirty</name> <operator>||</operator> <call><name>ForceTransactionIdLimitUpdate</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>vac_truncate_clog</name><argument_list>(<argument><expr><name>newFrozenXid</name></expr></argument>, <argument><expr><name>newMinMulti</name></expr></argument>,
                          <argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name>lastSaneMinMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    vac_truncate_clog() -- attempt to truncate the commit log
 *
 *        Scan pg_database to determine the system-wide oldest datfrozenxid,
 *        and use it to truncate the transaction commit log (pg_xact).
 *        Also update the XID wrap limit info maintained by varsup.c.
 *        Likewise for datminmxid.
 *
 *        The passed frozenXID and minMulti are the updated values for my own
 *        pg_database entry. They're used to initialize the "min" calculations.
 *        The caller also passes the "last sane" XID and MXID, since it has
 *        those at hand already.
 *
 *        This routine is only invoked when we've managed to change our
 *        DB's datfrozenxid/datminmxid values, or we found that the shared
 *        XID-wrap-limit info is stale.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vac_truncate_clog</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>frozenXID</name></decl></parameter>,
                  <parameter><decl><type><name>MultiXactId</name></type> <name>minMulti</name></decl></parameter>,
                  <parameter><decl><type><name>TransactionId</name></type> <name>lastSaneFrozenXid</name></decl></parameter>,
                  <parameter><decl><type><name>MultiXactId</name></type> <name>lastSaneMinMulti</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXID</name> <init>= <expr><call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>oldestxid_datoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>minmulti_datoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bogus</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>frozenAlreadyWrapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* init oldest datoids to sync with my frozenXID/minMulti values */</comment>
    <expr_stmt><expr><name>oldestxid_datoid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>minmulti_datoid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan pg_database to compute the minimum datfrozenxid/datminmxid
     *
     * Since vac_update_datfrozenxid updates datfrozenxid/datminmxid in-place,
     * the values could change while we look at them.  Fetch each one just
     * once to ensure sane behavior of the comparison logic.  (Here, as in
     * many other places, we assume that fetching or updating an XID in shared
     * storage is atomic.)
     *
     * Note: we need not worry about a race condition with new entries being
     * inserted by CREATE DATABASE.  Any such entry will have a copy of some
     * existing DB's datfrozenxid, and that source DB cannot be ours because
     * of the interlock against copying a DB containing an active backend.
     * Hence the new entry will not reduce the minimum.  Also, if two VACUUMs
     * concurrently modify the datfrozenxid's of different databases, the
     * worst possible outcome is that pg_xact is not truncated as aggressively
     * as it could be.
     */</comment>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>FormData_pg_database</name> <modifier>*</modifier></type><name>dbform</name> <init>= <expr><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>datfrozenxid</name> <init>= <expr><name><name>dbform</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>datminmxid</name> <init>= <expr><name><name>dbform</name><operator>-&gt;</operator><name>datminmxid</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>datfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>datminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If things are working properly, no database should have a
         * datfrozenxid or datminmxid that is "in the future".  However, such
         * cases have been known to arise due to bugs in pg_upgrade.  If we
         * see any entries that are "in the future", chicken out and don't do
         * anything.  This ensures we won't truncate clog before those
         * databases have been scanned and cleaned up.  (We will issue the
         * "already wrapped" warning if appropriate, though.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneFrozenXid</name></expr></argument>, <argument><expr><name>datfrozenxid</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>lastSaneMinMulti</name></expr></argument>, <argument><expr><name>datminmxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>bogus</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>nextXID</name></expr></argument>, <argument><expr><name>datfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>frozenAlreadyWrapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>datfrozenxid</name></expr></argument>, <argument><expr><name>frozenXID</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>frozenXID</name> <operator>=</operator> <name>datfrozenxid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>oldestxid_datoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>datminmxid</name></expr></argument>, <argument><expr><name>minMulti</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>minMulti</name> <operator>=</operator> <name>datminmxid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>minmulti_datoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do not truncate CLOG if we seem to have suffered wraparound already;
     * the computed minimum XID might be bogus.  This case should now be
     * impossible due to the defenses in GetNewTransactionId, but we keep the
     * test anyway.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>frozenAlreadyWrapped</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"some databases have not been vacuumed in over 2 billion transactions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"You might have already suffered transaction-wraparound data loss."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Don't return if PGXC: We want to update the transaction limits anyways */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* chicken out if data is bogus in any other way */</comment>
    <if_stmt><if>if <condition>(<expr><name>bogus</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Advance the oldest value for commit timestamps before truncating, so
     * that if a user requests a timestamp for a transaction we're truncating
     * away right after this point, they get NULL instead of an ugly "file not
     * found" error from slru.c.  This doesn't matter for xact/multixact
     * because they are not subject to arbitrary lookups from users.
     */</comment>
    <expr_stmt><expr><call><name>AdvanceOldestCommitTsXid</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Truncate CLOG, multixact and CommitTs to the oldest computed value.
     */</comment>
    <expr_stmt><expr><call><name>TruncateCLOG</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>, <argument><expr><name>oldestxid_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TruncateCommitTs</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TruncateMultiXact</name><argument_list>(<argument><expr><name>minMulti</name></expr></argument>, <argument><expr><name>minmulti_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update the wrap limit for GetNewTransactionId and creation of new
     * MultiXactIds.  Note: these functions will also signal the postmaster
     * for an(other) autovac cycle if needed.   XXX should we avoid possibly
     * signalling twice?
     */</comment>
    <expr_stmt><expr><call><name>SetTransactionIdLimit</name><argument_list>(<argument><expr><name>frozenXID</name></expr></argument>, <argument><expr><name>oldestxid_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetMultiXactIdLimit</name><argument_list>(<argument><expr><name>minMulti</name></expr></argument>, <argument><expr><name>minmulti_datoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    vacuum_rel() -- vacuum one heap relation
 *
 *        Doing one heap at a time incurs extra overhead, since we need to
 *        check that the heap exists again just before we vacuum it.  The
 *        reason that we do this is so that vacuuming can be spread across
 *        many small transactions.  Otherwise, two-phase locking would require
 *        us to lock the entire database during one pass of the vacuum cleaner.
 *
 *        At entry and exit, we are not inside a transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lmode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>onerel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockRelId</name></type>    <name>onerelid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>toast_relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>save_userid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_sec_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_nestlevel</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>part_vacuum_result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>childs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>new_childs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* functions in indexes may want a snapshot set */</comment>
        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>childs</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_childs</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>childs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>childs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>childs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>childs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>onerelid</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>onerelid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><name>new_childs</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>new_childs</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>part_vacuum_result</name> <operator>=</operator> <call><name>vacuum_rel</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>onerelid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_childs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>part_vacuum_result</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>        
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/* Begin a transaction for vacuuming this relation */</comment>
    <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* In Postgres-XC, take a snapshot after setting the vacuum flags */</comment>
    <comment type="block">/*
     * Functions in indexes may want a snapshot set.  Also, setting a snapshot
     * ensures that RecentGlobalXmin is kept truly recent.
     */</comment>
    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In lazy vacuum, we can set the PROC_IN_VACUUM flag, which lets
         * other concurrent VACUUMs know that they can ignore this one while
         * determining their OldestXmin.  (The reason we don't set it during a
         * full VACUUM is exactly that we may have to run user-defined
         * functions for functional indexes, and we want to make sure that if
         * they use the snapshot set above, any tuples it requires can't get
         * removed from other tables.  An index function that depends on the
         * contents of other tables is arguably broken, but we won't break it
         * here by violating transaction semantics.)
         *
         * We also set the VACUUM_FOR_WRAPAROUND flag, which is passed down by
         * autovacuum; it's used to avoid canceling a vacuum that was invoked
         * in an emergency.
         *
         * Note: these flags remain set until CommitTransaction or
         * AbortTransaction.  We don't want to clear them until we reset
         * MyPgXact-&gt;xid/xmin, else OldestXmin might appear to go backwards,
         * which is probably Not Good.
         */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>|=</operator> <name>PROC_IN_VACUUM</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>is_wraparound</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>|=</operator> <name>PROC_VACUUM_FOR_WRAPAROUND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/*
     * Check for user-requested abort.  Note we want this to be inside a
     * transaction, so xact.c doesn't issue useless WARNING.
     */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the type of lock we want --- hard exclusive lock for a FULL
     * vacuum, but just ShareUpdateExclusiveLock for concurrent vacuum. Either
     * way, we can be sure that no other backend is vacuuming the same table.
     */</comment>
    <expr_stmt><expr><name>lmode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AccessExclusiveLock</name></expr> </then><else>: <expr><name>ShareUpdateExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the relation and get the appropriate lock on it.
     *
     * There's a race condition here: the rel may have gone away since the
     * last time we saw it.  If so, we don't need to vacuum it.
     *
     * If we've been asked not to wait for the relation lock, acquire it first
     * in non-blocking mode, before calling try_relation_open().
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_NOWAIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping vacuum of \"%s\" --- lock not available"</literal></expr></argument>,
                            <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>onerel</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check permissions.
     *
     * We allow the user to vacuum a table if he is superuser, the table
     * owner, or the database owner (but in the latter case, only if it's not
     * a shared relation).  pg_class_ownercheck includes the superuser case.
     *
     * Note we choose to treat permissions failure as a WARNING and keep
     * trying to vacuum the rest of the DB --- is this appropriate?
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
          <operator>(</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser can vacuum it"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_ORCL_</name></cpp:ifdef>
        <if type="elseif">else if <condition>(<expr><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser or database owner can vacuum it"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only table or database owner can vacuum it"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that it's a vacuumable relation; we used to do this in
	 * get_rel_oids() but seems safer to check after we've locked the
	 * relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot vacuum non-tables or special system tables"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Silently ignore tables that are temp tables of other backends ---
	 * trying to vacuum these will lead to great unhappiness, since their
	 * contents are probably not up-to-date on disk.  (We don't throw a
	 * warning here; it would just lead to chatter during a database-wide
	 * VACUUM.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get a session-level lock too. This will protect our access to the
	 * relation across multiple transactions, so that we can vacuum the
	 * relation's TOAST table (if any) secure in the knowledge that no one is
	 * deleting the parent relation.
	 *
	 * NOTE: this cannot block, even if someone else is waiting for access,
	 * because the lock manager knows that both lock requests are from the
	 * same process.
	 */</comment>
	<expr_stmt><expr><name>onerelid</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>onerelid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember the relation's TOAST relation for later, if the caller asked
	 * us to process it.  In VACUUM FULL, though, the toast table is
	 * automatically rebuilt by cluster_rel so we shouldn't recurse to it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_SKIPTOAST</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Switch to the table owner's userid, so that any index functions are run
	 * as that user.  Also lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command. (This is
	 * unnecessary, but harmless, for lazy VACUUM.)
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ignore partitioned tables as there is no work to be done.  Since we
	 * release the lock here, it's possible that any partitions added from
	 * this point on will not get processed, but that seems harmless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore userid and security context */</comment>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the relation has a secondary toast rel, vacuum that too while we
		 * still hold the session lock on the master table.  Note however that
		 * "analyze" will not get done on the toast table.  This is good, because
		 * the toaster always uses hardcoded index access and statistics are
		 * totally unimportant for toast relations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>toast_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now release the session-level lock on the master table.
		 */</comment>
		<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>onerelid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* It's OK for other commands to look at this table */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * If we are on coordinator and target relation is distributed, read
     * the statistics from the data node instead of vacuuming local relation.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>vacuum_rel_coordinator</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Do the actual work --- either FULL or "lazy" vacuum
     */</comment>
    if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_FULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* close relation before vacuuming, but hold lock until commit */</comment>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* VACUUM FULL is now a variant of CLUSTER; see cluster.c */</comment>
        <expr_stmt><expr><call><name>cluster_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>lazy_vacuum_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
    <expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore userid and security context */</comment>
    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* all done with this class, but hold lock until commit */</comment>
    <if_stmt><if>if <condition>(<expr><name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Complete the transaction and free all temporary memory used.
     */</comment>
    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the relation has a secondary toast rel, vacuum that too while we
     * still hold the session lock on the master table.  Note however that
     * "analyze" will not get done on the toast table.  This is good, because
     * the toaster always uses hardcoded index access and statistics are
     * totally unimportant for toast relations.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>toast_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>vacuum_rel</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now release the session-level lock on the master table.
     */</comment>
    <expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>onerelid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Report that we really did it. */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Open all the vacuumable indexes of the given relation, obtaining the
 * specified kind of lock on each.  Return an array of Relation pointers for
 * the indexes into *Irel, and the number of indexes into *nindexes.
 *
 * We consider an index vacuumable if it is marked insertable (IndexIsReady).
 * If it isn't, probably a CREATE INDEX CONCURRENTLY command failed early in
 * execution, and what we have is too corrupt to be processable.  We will
 * vacuum even if the index isn't indisvalid; this is important because in a
 * unique index, uniqueness checks will be performed anyway and had better not
 * hit dangling index pointers.
 */</comment>
<function><type><name>void</name></type>
<name>vac_open_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
                 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nindexes</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier><modifier>*</modifier></type><name>Irel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lockmode</name> <operator>!=</operator> <name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* allocate enough memory for all indexes */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>Irel</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>Irel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* collect just the ready indexes */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>indrel</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>indrel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IndexIsReady</name><argument_list>(<argument><expr><name><name>indrel</name><operator>-&gt;</operator><name>rd_index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>Irel</name><operator>)</operator><index>[<expr><name>i</name><operator>++</operator></expr>]</index> <operator>=</operator> <name>indrel</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><operator>*</operator><name>nindexes</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release the resources acquired by vac_open_indexes.  Optionally release
 * the locks (say NoLock to keep 'em).
 */</comment>
<function><type><name>void</name></type>
<name>vac_close_indexes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>Irel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>nindexes</name><operator>--</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>ind</name> <init>= <expr><name><name>Irel</name><index>[<expr><name>nindexes</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * vacuum_delay_point --- check for interrupts and cost-based delay.
 *
 * This should be called in each major loop of VACUUM processing,
 * typically once per page processed.
 */</comment>
<function><type><name>void</name></type>
<name>vacuum_delay_point</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Always check for interrupts */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Nap if appropriate */</comment>
    <if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>InterruptPending</name> <operator>&amp;&amp;</operator>
        <name>VacuumCostBalance</name> <operator>&gt;=</operator> <name>VacuumCostLimit</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>msec</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>msec</name> <operator>=</operator> <name>VacuumCostDelay</name> <operator>*</operator> <name>VacuumCostBalance</name> <operator>/</operator> <name>VacuumCostLimit</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>msec</name> <operator>&gt;</operator> <name>VacuumCostDelay</name> <operator>*</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>msec</name> <operator>=</operator> <name>VacuumCostDelay</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>msec</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>VacuumCostBalance</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* update balance values for workers */</comment>
        <expr_stmt><expr><call><name>AutoVacuumUpdateDelay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Might have gotten an interrupt while sleeping */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * For the data node query make up TargetEntry representing specified column
 * of pg_class catalog table
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>make_relation_tle</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>column</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>att_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
                  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
                  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
                  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
                  <argument><expr><name>InvalidOid</name></expr></argument>,
                  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>tle</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get relation statistics from remote data nodes
 * Returns number of nodes that returned correct statistics.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_remote_relstat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replicated</name></decl></parameter>,
                   <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>allvisiblepages</name></decl></parameter>,
                   <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>frozenXid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>        <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>validpages</name></decl>,
                <decl><type ref="prev"/><name>validtuples</name></decl>,
                <decl><type ref="prev"/><name>validfrozenxids</name></decl>,
                <decl><type ref="prev"/><name>validallvisiblepages</name></decl>;</decl_stmt>

    <comment type="block">/* Make up query string */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT c.relpages, "</literal>
                                    <literal type="string">"c.reltuples, "</literal>
                                    <literal type="string">"c.relallvisible, "</literal>
                                    <literal type="string">"c.relfrozenxid "</literal>
                             <literal type="string">"FROM pg_class c JOIN pg_namespace n "</literal>
                             <literal type="string">"ON c.relnamespace = n.oid "</literal>
                             <literal type="string">"WHERE n.nspname = '%s' "</literal>
                             <literal type="string">"AND c.relname = '%s'"</literal></expr></argument>,
                     <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build up RemoteQuery */</comment>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>query</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>

    <comment type="block">/* Add targetlist entries */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_class"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"relpages"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_class"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"reltuples"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_class"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"relallvisible"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_class"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"relfrozenxid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Execute query on the data nodes */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get ready to combine results */</comment>
    <expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>allvisiblepages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>frozenXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>validpages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>validallvisiblepages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>validtuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>validfrozenxids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>     <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>    <name>isnull</name></decl>;</decl_stmt>
        <comment type="block">/* Process statistics from the data node */</comment>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* relpages */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>validpages</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>pages</name> <operator>+=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* reltuples */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>validtuples</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>+=</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* relallvisible */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>validallvisiblepages</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>allvisiblepages</name> <operator>+=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* relfrozenxid */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * relfrozenxid on coordinator should be the lowest one from the
             * datanodes.
             */</comment>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>DatumGetTransactionId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>validfrozenxids</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>frozenXid</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><operator>*</operator><name>frozenXid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>frozenXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* fetch next */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>replicated</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Normally numbers should be the same on the nodes, but relations
         * are autovacuum'ed independedly, so they may differ.
         * Average is good enough approximation in this case.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>validpages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>pages</name> <operator>/=</operator> <name>validpages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>validtuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>/=</operator> <name>validtuples</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>validallvisiblepages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>allvisiblepages</name> <operator>/=</operator> <name>validallvisiblepages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>validfrozenxids</name> <operator>&lt;</operator> <name>validpages</name> <operator>||</operator> <name>validfrozenxids</name> <operator>&lt;</operator> <name>validtuples</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If some node returned invalid value for frozenxid we can not set
         * it on coordinator. There are other cases when returned value of
         * frozenXid should be ignored, these cases are checked by caller.
         * Basically, to be sure, there should be one value from each node,
         * where the table is partitioned.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>frozenXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <return>return <expr><call><name>Max</name><argument_list>(<argument><expr><name>validpages</name></expr></argument>, <argument><expr><name>validtuples</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>validfrozenxids</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Coordinator does not contain any data, so we never need to vacuum relations.
 * This function only updates optimizer statistics based on info from the
 * data nodes.
 */</comment>
<function><type><name>void</name></type>
<name>vacuum_rel_coordinator</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_outer</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
    <comment type="block">/* fields to combine relation statistics */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>num_pages</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>num_allvisible_pages</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float4</name></type>        <name>num_tuples</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>min_frozenxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>replicated</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>rel_nodes</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>freezeLimit</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiXactCutoff</name> <init>= <expr><name>InvalidMultiXactId</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Get the relation identifier */</comment>
    <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Getting relation statistics for %s.%s"</literal></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>params</name> <operator>&amp;&amp;</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>vacuum_set_xid_limits</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
							  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_min_age</name></name></expr></argument>,
							  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_table_age</name></name></expr></argument>,
							  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_min_age</name></name></expr></argument>,
							  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_table_age</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>oldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freezeLimit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>multiXactCutoff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>replicated</name> <operator>=</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><call><name>RelationGetLocatorType</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Get stats from the remote nodes. Function returns the number of nodes
     * returning correct stats.
     */</comment>
    <expr_stmt><expr><name>rel_nodes</name> <operator>=</operator> <call><name>get_remote_relstat</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>replicated</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>num_pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_allvisible_pages</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>num_tuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>min_frozenxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rel_nodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>nindexes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>Irel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>         <name>nodes</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>RelationGetLocInfo</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rl_nodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>vac_open_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nindexes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hasindex</name> <operator>=</operator> <operator>(</operator><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>

            <comment type="block">/* Fetch index stats */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int32</name></type>    <name>idx_pages</name></decl>, <decl><type ref="prev"/><name>idx_allvisible_pages</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>float4</name></type>    <name>idx_tuples</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TransactionId</name></type> <name>idx_frozenxid</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>idx_nodes</name></decl>;</decl_stmt>

                <comment type="block">/* Get the index identifier */</comment>
                <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Index is replicated if parent relation is replicated */</comment>
                <expr_stmt><expr><name>idx_nodes</name> <operator>=</operator> <call><name>get_remote_relstat</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>replicated</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>idx_pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx_allvisible_pages</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>idx_tuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx_frozenxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>idx_nodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Do not update the frozenxid if information was not from
                     * all the expected nodes.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>idx_nodes</name> <operator>&lt;</operator> <name>nodes</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>idx_frozenxid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* save changes */</comment>
                    <comment type="block">/* !!TODO Get multi-xid from remote nodes */</comment>
                    <expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>idx_pages</name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>idx_tuples</name></expr></argument>,
                                        <argument><expr><literal type="number">0</literal></expr></argument>,
                                        <argument><expr><name>false</name></expr></argument>,
                                        <argument><expr><name>idx_frozenxid</name></expr></argument>,
                                        <argument><expr><name>InvalidMultiXactId</name></expr></argument>,
                                        <argument><expr><name>is_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Done with indexes */</comment>
        <expr_stmt><expr><call><name>vac_close_indexes</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Do not update the frozenxid if information was not from all
         * the expected nodes.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>rel_nodes</name> <operator>&lt;</operator> <name>nodes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>min_frozenxid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>freezeLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
	        <expr_stmt><expr><name>min_frozenxid</name> <operator>=</operator> <name>freezeLimit</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* save changes */</comment>
        <expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
                            <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>num_pages</name></expr></argument>,
                            <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>num_tuples</name></expr></argument>,
                            <argument><expr><name>num_allvisible_pages</name></expr></argument>,
                            <argument><expr><name>hasindex</name></expr></argument>,
                            <argument><expr><name>min_frozenxid</name></expr></argument>,
                            <argument><expr><name>InvalidMultiXactId</name></expr></argument>,
                            <argument><expr><name>is_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>ExecVacuumShard</name><parameter_list>(<parameter><decl><type><name>VacuumShardStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relations</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>vac_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>,
                                        <argument><expr><literal type="string">"Vacuum"</literal></expr></argument>,
                                        <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>get_rel_oids</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>relations</argument>)</argument_list></macro>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>Oid</name></type>         <name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">//Relation    rel = heap_open(relid, ShareLock);</comment>
        <decl_stmt><decl><type><name>ListCell</name>     <modifier>*</modifier></type><name>lc_shard</name></decl>;</decl_stmt>

        <comment type="block">/* for every shard */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc_shard</argument>, <argument>stmt-&gt;shards</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>s_tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type> <name>con</name> <init>= <expr><operator>(</operator><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_shard</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>ShardID</name></type> <name>sid</name> <init>= <expr><call><name>intVal</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>s_tuples</name> <operator>=</operator> <call><name>TruncateShard</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>pause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Vacuum One Shard Success. rel=%d, sid=%d, tuples=%d"</literal></expr></argument>,
                        <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>s_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tuples</name> <operator>+=</operator> <name>s_tuples</name></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="line">//heap_close(rel, ShareLock);</comment>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Vacuum Shard Success. rel=%d, tuples=%d"</literal></expr></argument>,
                        <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>vac_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>vac_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
