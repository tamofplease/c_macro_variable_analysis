<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/sequence.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * sequence.c
 *      PostgreSQL sequences support code.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/sequence.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<comment type="block">/* PGXC_COORD */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<comment type="block">/*
 * We don't want to log each fetching of a value from a sequence,
 * so we pre-log a few fetches in advance. In the event of
 * crash we can lose (skip over) as many values as we pre-logged.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEQ_LOG_VALS</name></cpp:macro>    <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/*
 * The "special area" of a sequence's buffer page looks like this.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEQ_MAGIC</name></cpp:macro>      <cpp:value>0x1717</cpp:value></cpp:define>

<comment type="block">/* Configuration options */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>

<decl_stmt><decl><type><name>int</name></type>            <name>SequenceRangeVal</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>sequence_magic</name>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type>        <name>magic</name></decl>;</decl_stmt>
}</block></struct></type> <name>sequence_magic</name>;</typedef>

<comment type="block">/*
 * We store a SeqTable item for every sequence we have touched in the current
 * session.  This is needed to hold onto nextval/currval state.  (We can't
 * rely on the relcache, since it's only, well, a cache, and may decide to
 * discard entries.)
 */</comment>
<typedef>typedef <type><struct>struct <name>SeqTableData</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>            <comment type="block">/* pg_class OID of this sequence (hash key) */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>filenode</name></decl>;</decl_stmt>        <comment type="block">/* last seen relfilenode of this sequence */</comment>
    <decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>lxid</name></decl>;</decl_stmt>    <comment type="block">/* xact in which we last did a seq op */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>last_valid</name></decl>;</decl_stmt>        <comment type="block">/* do we have a valid "last" value? */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>last</name></decl>;</decl_stmt>            <comment type="block">/* value last returned by nextval */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>cached</name></decl>;</decl_stmt>            <comment type="block">/* last value already cached for nextval */</comment>
    <comment type="block">/* if last != cached, we have not used up all the cached values */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>increment</name></decl>;</decl_stmt>        <comment type="block">/* copy of sequence's increment field */</comment>
    <comment type="block">/* note that increment is zero until we first do nextval_internal() */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_call_time</name></decl>;</decl_stmt> <comment type="block">/* the time when the last call as made */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>range_multiplier</name></decl>;</decl_stmt> <comment type="block">/* multiply this value with 2 next time */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>SeqTableData</name>;</typedef>

<typedef>typedef <type><name>SeqTableData</name> <modifier>*</modifier></type><name>SeqTable</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>seqhashtab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* hash table for SeqTable items */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * Arguments for callback of sequence drop on GTM
 */</comment>
<typedef>typedef <type><struct>struct <name>drop_sequence_callback_arg</name>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_SequenceDropType</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_SequenceKeyType</name></type> <name>key</name></decl>;</decl_stmt>
}</block></struct></type> <name>drop_sequence_callback_arg</name>;</typedef>

<comment type="block">/*
 * Arguments for callback of sequence rename on GTM
 */</comment>
<typedef>typedef <type><struct>struct <name>rename_sequence_callback_arg</name>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newseqname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldseqname</name></decl>;</decl_stmt>
}</block></struct></type> <name>rename_sequence_callback_arg</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * last_used_seq is updated by nextval() to point to the last used
 * sequence.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SeqTableData</name> <modifier>*</modifier></type><name>last_used_seq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_seq_with_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relation</name></type> <name>lock_and_open_sequence</name><parameter_list>(<parameter><decl><type><name>SeqTable</name></type> <name>seq</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_seq_hashtable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_sequence</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>SeqTable</name> <modifier>*</modifier></type><name>p_elm</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>p_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Form_pg_sequence_data</name></type> <name>read_seq_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
               <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>seqdatatuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_params</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_identity</name></decl></parameter>,
            <parameter><decl><type><name>bool</name></type> <name>isInit</name></decl></parameter>,
            <parameter><decl><type><name>Form_pg_sequence</name></type> <name>seqform</name></decl></parameter>,
            <parameter><decl><type><name>Form_pg_sequence_data</name></type> <name>seqdataform</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_seq_rewrite</name></decl></parameter>,
            <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>owned_by</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_restart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_setval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>next</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iscalled</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_owned_by</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>seqrel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>owned_by</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_identity</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type>  <name>g_GTM_skip_catalog</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>is_txn_has_parallel_ddl</name></decl>;</decl_stmt>

<comment type="block">/*
 * Check sequence exists or not
 */</comment>
<function><type><name>bool</name></type> <name>PrecheckDefineSequence</name><parameter_list>(<parameter><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>seq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>seqoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>nspid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>need_send</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skip_gtm_catalog can not be true on datanode."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_GTM_skip_catalog</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Unlogged sequences are not implemented -- not clear if useful. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unlogged sequences are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If if_not_exists was given and a relation with the same name already
		 * exists, bail out. (Note: we needn't check this when not if_not_exists,
		 * because DefineRelation will complain anyway.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>seqoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>seqoid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists, skipping"</literal></expr></argument>,
								<argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>need_send</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>UnlockDatabaseObject</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>need_send</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DefineSequence
 *                Creates a new sequence relation
 */</comment>
<decl_stmt><decl><type><name>ObjectAddress</name></type>
<name>DefineSequence</name><argument_list>(<argument><expr><name>ParseState</name> <operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>CreateSeqStmt</name> <operator>*</operator><name>seq</name></expr></argument>, <argument><expr><name>bool</name> <name>exists_ok</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>ObjectAddress</name>
<name>DefineSequence</name><argument_list>(<argument><expr><name>ParseState</name> <operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>CreateSeqStmt</name> <operator>*</operator><name>seq</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
    <decl_stmt><decl><type><name>FormData_pg_sequence</name></type> <name>seqform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FormData_pg_sequence_data</name></type> <name>seqdataform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_seq_rewrite</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>owned_by</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>seqoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>value</name><index>[<expr><name>SEQ_COL_LASTCOL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>null</name><index>[<expr><name>SEQ_COL_LASTCOL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>pgs_values</name><index>[<expr><name>Natts_pg_sequence</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>pgs_nulls</name><index>[<expr><name>Natts_pg_sequence</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef> <comment type="block">/* PGXC_COORD */</comment>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>start_value</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>min_value</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>max_value</name> <init>= <expr><name>InvalidSequenceValue</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>increment</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>cycle</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_restart</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>seqname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skip_gtm_catalog can not be true on datanode."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_GTM_skip_catalog</name></expr>)</condition>
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Unlogged sequences are not implemented -- not clear if useful. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unlogged sequences are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If if_not_exists was given and a relation with the same name already
         * exists, bail out. (Note: we needn't check this when not if_not_exists,
         * because DefineRelation will complain anyway.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>seqoid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists_ok</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists"</literal></expr></argument>,
								<argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists, skipping"</literal></expr></argument>,
                                <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check and set all option values */</comment>
        <expr_stmt><expr><call><name>init_params</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>for_identity</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>seqform</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqdataform</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>need_seq_rewrite</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>owned_by</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>is_restart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Create relation (and fill value[] and null[] for the tuple)
         */</comment>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>SEQ_COL_FIRSTCOL</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>SEQ_COL_LASTCOL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_parent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>null</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><name>i</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>SEQ_COL_LASTVAL</name></expr>:</case>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <literal type="string">"last_value"</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>value</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>seqdataform</name><operator>.</operator><name>last_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>SEQ_COL_LOG</name></expr>:</case>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <literal type="string">"log_cnt"</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>value</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>SEQ_COL_CALLED</name></expr>:</case>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <literal type="string">"is_called"</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>value</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>, <argument><expr><name>coldef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>seq</name><operator>-&gt;</operator><name>sequence</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name><name>seq</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>ownerId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>seqoid</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seqoid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>seqoid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* now initialize the sequence's data */</comment>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fill_seq_with_data</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* process OWNED BY if given */</comment>
        <if_stmt><if>if <condition>(<expr><name>owned_by</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>process_owned_by</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>owned_by</name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>for_identity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>seqname</name> <operator>=</operator> <call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>increment</name> <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqincrement</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>min_value</name> <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqmin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_value</name> <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqmax</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start_value</name> <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqstart</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cycle</name> <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqcycle</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* fill in pg_sequence */</comment>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SequenceRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pgs_nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgs_nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>seqoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqtypid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>seqform</name><operator>.</operator><name>seqtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqstart</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>seqform</name><operator>.</operator><name>seqstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqincrement</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>seqform</name><operator>.</operator><name>seqincrement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqmax</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>seqform</name><operator>.</operator><name>seqmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqmin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>seqform</name><operator>.</operator><name>seqmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqcache</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>seqform</name><operator>.</operator><name>seqcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgs_values</name><index>[<expr><name>Anum_pg_sequence_seqcycle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>seqform</name><operator>.</operator><name>seqcycle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>pgs_values</name></expr></argument>, <argument><expr><name>pgs_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        
        <comment type="block">/* Check and set all option values */</comment>
        <expr_stmt><expr><call><name>init_params</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>for_identity</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>seqform</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqdataform</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>need_seq_rewrite</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>owned_by</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>is_restart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>increment</name>   <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqincrement</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>min_value</name>   <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqmin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_value</name>   <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqmax</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start_value</name> <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqstart</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cycle</name>       <operator>=</operator> <name><name>seqform</name><operator>.</operator><name>seqcycle</name></name></expr>;</expr_stmt>

        <comment type="block">/* build the sequenct name. */</comment>
        <expr_stmt><expr><name>seqname</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>catalogname</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%s.%s"</literal></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else 
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>seq</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>  <comment type="block">/* PGXC_COORD */</comment>
    <comment type="block">/*
     * Remote Coordinator is in charge of creating sequence in GTM.
     * If sequence is temporary, it is not necessary to create it on GTM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We also need to create it on the GTM */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CreateSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>,
                              <argument><expr><name>increment</name></expr></argument>,
                              <argument><expr><name>min_value</name></expr></argument>,
                              <argument><expr><name>max_value</name></expr></argument>,
                              <argument><expr><name>start_value</name></expr></argument>, <argument><expr><name>cycle</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not create sequence %s"</literal></expr></argument>, <argument><expr><name>seqname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RegisterSeqCreate</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>GTM_SEQ_FULL_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>address</name><operator>.</operator><name>classId</name></name>     <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>address</name><operator>.</operator><name>objectId</name></name>    <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>address</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NO CATALOG TOUCHED."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Reset a sequence to its initial value.
 *
 * The change is made transactionally, so that on failure of the current
 * transaction, the sequence will be restored to its previous state.
 * We do that by creating a whole new relfilenode for the sequence; so this
 * works much like the rewriting forms of ALTER TABLE.
 *
 * Caller is assumed to have acquired AccessExclusiveLock on the sequence,
 * which must not be released until end of transaction.  Caller is also
 * responsible for permissions checking.
 */</comment>
<function><type><name>void</name></type>
<name>ResetSequence</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>seq_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>seq_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SeqTable</name></type>    <name>elm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence_data</name></type> <name>seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>seqdatatuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>pgstuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>pgsform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>startv</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Read the old sequence.  This does a bit more work than really
     * necessary, but it's simple, and we do want to double-check that it's
     * indeed a sequence.
     */</comment>
    <expr_stmt><expr><call><name>init_sequence</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seq_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>read_seq_tuple</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pgstuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>, <argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgsform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>startv</name> <operator>=</operator> <name><name>pgsform</name><operator>-&gt;</operator><name>seqstart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Copy the existing sequence tuple.
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now we're done with the old page */</comment>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Modify the copied tuple to execute the restart (compare the RESTART
     * action in AlterSequence)
     */</comment>
    <expr_stmt><expr><name>seq</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence_data</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <name>startv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>is_called</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a new storage file for the sequence.  We want to keep the
     * sequence's relfrozenxid at 0, since it won't contain any unfrozen XIDs.
     * Same with relminmxid, since a sequence will never contain multixacts.
     */</comment>
    <expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>, <argument><expr><name><name>seq_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
                              <argument><expr><name>InvalidTransactionId</name></expr></argument>, <argument><expr><name>InvalidMultiXactId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Insert the modified tuple into the new storage file.
     */</comment>
    <expr_stmt><expr><call><name>fill_seq_with_data</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear local cache so that we don't think we have cached numbers */</comment>
    <comment type="block">/* Note that we do not change the currval() state */</comment>
    <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a sequence's relation with the specified tuple as content
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_seq_with_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sequence_magic</name> <modifier>*</modifier></type><name>sm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

    <comment type="block">/* Initialize first page of relation with special magic number */</comment>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now insert sequence tuple */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sequence_magic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sm</name> <operator>=</operator> <operator>(</operator><name>sequence_magic</name> <operator>*</operator><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sm</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SEQ_MAGIC</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Since VACUUM does not process sequences, we have to force the tuple to
     * have xmin = FrozenTransactionId now.  Otherwise it would become
     * invisible to SELECTs after 2G transactions.  It is okay to do this
     * because if the current transaction aborts, no other xact will ever
     * examine the sequence tuple anyway.
     */</comment>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>FrozenTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetXminFrozen</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check the comment above nextval_internal()'s equivalent call. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>GetTopTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>,
                         <argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>!=</operator> <name>FirstOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add sequence tuple to page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* XLOG stuff */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_seq_rec</name></type>    <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_seq_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SEQ_ID</name></expr></argument>, <argument><expr><name>XLOG_SEQ_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterSequence
 *
 * Modify the definition of a sequence relation
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterSequence</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SeqTable</name></type>    <name>elm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>seqrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>datatuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>seqform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence_data</name></type> <name>newdataform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_seq_rewrite</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>owned_by</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>start_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>last_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>min_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>max_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTM_Sequence</name></type>    <name>increment</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>cycle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>is_restart</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>seqtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newdatatuple</name></decl>;</decl_stmt>

    <comment type="block">/* Open and lock sequence, and check for ownership along the way. */</comment>
    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sequence</name></name></expr></argument>,
                                     <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>,
                                     <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>,
                                     <argument><expr><name>RangeVarCallbackOwnsRelation</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    

    <expr_stmt><expr><call><name>init_sequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skip_gtm_catalog can not be true on datanode."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_GTM_skip_catalog</name></expr>)</condition>
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SequenceRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>seqtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>,
                                       <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>seqtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>,
                 <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>seqform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>seqtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* lock page's buffer and read tuple into new sequence structure */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>read_seq_tuple</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* copy the existing sequence data tuple, so it can be modified locally */</comment>
        <expr_stmt><expr><name>newdatatuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>datatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newdataform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence_data</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check and set new values */</comment>
        <expr_stmt><expr><call><name>init_params</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>for_identity</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                    <argument><expr><name>seqform</name></expr></argument>, <argument><expr><name>newdataform</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>need_seq_rewrite</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>owned_by</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>is_restart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear local cache so that we don't think we have cached numbers */</comment>
        <comment type="block">/* Note that we do not change the currval() state */</comment>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

        <comment type="block">/* Now okay to update the on-disk tuple */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <expr_stmt><expr><name>increment</name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqincrement</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>min_value</name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_value</name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start_value</name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_value</name> <operator>=</operator> <name><name>newdataform</name><operator>-&gt;</operator><name>last_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cycle</name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqcycle</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* If needed, rewrite the sequence relation itself */</comment>
        <if_stmt><if>if <condition>(<expr><name>need_seq_rewrite</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* check the comment above nextval_internal()'s equivalent call. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>GetTopTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Create a new storage file for the sequence, making the state
             * changes transactional.  We want to keep the sequence's relfrozenxid
             * at 0, since it won't contain any unfrozen XIDs.  Same with
             * relminmxid, since a sequence will never contain multixacts.
             */</comment>
            <expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name><name>seqrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
                                      <argument><expr><name>InvalidTransactionId</name></expr></argument>, <argument><expr><name>InvalidMultiXactId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Insert the modified tuple into the new storage file.
             */</comment>
            <expr_stmt><expr><call><name>fill_seq_with_data</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>newdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* process OWNED BY if given */</comment>
        <if_stmt><if>if <condition>(<expr><name>owned_by</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>process_owned_by</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>owned_by</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>for_identity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* update the pg_sequence tuple (we could skip this in some cases...) */</comment>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seqtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>seqtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* just get the values we needed. */</comment>
        <decl_stmt><decl><type><name>FormData_pg_sequence</name></type> <name>seqdata</name></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>FormData_pg_sequence_data</name></type> <name>seqnewform</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SequenceRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>seqtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>,
                                       <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>seqtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>,
                 <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>seqform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>seqtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>seqdata</name></expr></argument>, <argument><expr><name>seqform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>seqdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* lock page's buffer and read tuple into new sequence structure */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>read_seq_tuple</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* copy the existing sequence data tuple, so it can be modified locally */</comment>
        <expr_stmt><expr><name>newdatatuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>datatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newdataform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence_data</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>seqnewform</name></expr></argument>, <argument><expr><name>newdataform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>seqnewform</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check and set new values */</comment>
        <expr_stmt><expr><call><name>init_params</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>for_identity</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>seqdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqnewform</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>need_seq_rewrite</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>owned_by</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>is_restart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear local cache so that we don't think we have cached numbers */</comment>
        <comment type="block">/* Note that we do not change the currval() state */</comment>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

        <comment type="block">/* Now okay to update the on-disk tuple */</comment>

        <expr_stmt><expr><name>increment</name> <operator>=</operator> <name><name>seqdata</name><operator>.</operator><name>seqincrement</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>min_value</name> <operator>=</operator> <name><name>seqdata</name><operator>.</operator><name>seqmin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_value</name> <operator>=</operator> <name><name>seqdata</name><operator>.</operator><name>seqmax</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start_value</name> <operator>=</operator> <name><name>seqdata</name><operator>.</operator><name>seqstart</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_value</name> <operator>=</operator> <name><name>seqnewform</name><operator>.</operator><name>last_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cycle</name> <operator>=</operator> <name><name>seqdata</name><operator>.</operator><name>seqcycle</name></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * Remote Coordinator is in charge of create sequence in GTM
     * If sequence is temporary, no need to go through GTM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>seqrel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>!=</operator> <name>MyBackendId</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We also need to create it on the GTM */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>AlterSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>,
                             <argument><expr><name>increment</name></expr></argument>,
                             <argument><expr><name>min_value</name></expr></argument>,
                             <argument><expr><name>max_value</name></expr></argument>,
                             <argument><expr><name>start_value</name></expr></argument>,
                             <argument><expr><name>last_value</name></expr></argument>,
                             <argument><expr><name>cycle</name></expr></argument>,
                             <argument><expr><name>is_restart</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not alter sequence"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_GTM_skip_catalog</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NO CATALOG TOUCHED."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DeleteSequenceTuple</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>SequenceRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Note: nextval with a text argument is no longer exported as a pg_proc
 * entry, but we keep it around to ease porting of C code that may have
 * called the function directly.
 */</comment>
<function><type><name>Datum</name></type>
<name>nextval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name>       <modifier>*</modifier></type><name>seqin</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>sequence</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sequence</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>seqin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * XXX: This is not safe in the presence of concurrent DDL, but acquiring
     * a lock here is more expensive than letting nextval_internal do it,
     * since the latter maintains a cache that keeps us from hitting the lock
     * manager more than once per transaction.  It's not clear whether the
     * performance penalty is material in practice, but for now, we do it this
     * way.
     */</comment>
    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>nextval_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>nextval_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>nextval_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>nextval_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check_permissions</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SeqTable</name></type>    <name>elm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>seqrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>pgstuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>pgsform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>seqdatatuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence_data</name></type> <name>seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>incby</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>cache</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* open and lock sequence */</comment>
    <expr_stmt><expr><call><name>init_sequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>check_permissions</name> <operator>&amp;&amp;</operator>
        <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><name>ACL_USAGE</name> <operator>|</operator> <name>ACL_UPDATE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for sequence %s"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* read-only transactions may only modify temp sequences */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seqrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><literal type="string">"nextval()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Forbid this during parallel operation because, to make it work, the
     * cooperating backends would need to share the backend-local cached
     * sequence information.  Currently, we don't support that.
     */</comment>
    <expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><literal type="string">"nextval()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>elm</name><operator>-&gt;</operator><name>last</name></name> <operator>!=</operator> <name><name>elm</name><operator>-&gt;</operator><name>cached</name></name></expr>)</condition>    <comment type="block">/* some numbers were cached */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>last_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>increment</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last</name></name> <operator>+=</operator> <name><name>elm</name><operator>-&gt;</operator><name>increment</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_used_seq</name> <operator>=</operator> <name>elm</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[nextval_internal] skip connect gtm. procid:%d get nextval:%lld, increment:%lld, cached:%lld"</literal></expr></argument>,  
                    <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <name>int</name><operator>)</operator><name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <name>int</name><operator>)</operator><name><name>elm</name><operator>-&gt;</operator><name>increment</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <name>int</name><operator>)</operator><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pgstuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgsform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>incby</name> <operator>=</operator> <name><name>pgsform</name><operator>-&gt;</operator><name>seqincrement</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cache</name> <operator>=</operator> <name><name>pgsform</name><operator>-&gt;</operator><name>seqcache</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* lock page' buffer and read tuple */</comment>
    <expr_stmt><expr><name>seq</name> <operator>=</operator> <call><name>read_seq_tuple</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>int64</name></type> <name>range</name> <init>= <expr><name>cache</name></expr></init></decl>;</decl_stmt> <comment type="block">/* how many values to ask from GTM? */</comment>
        <decl_stmt><decl><type><name>int64</name></type> <name>rangemax</name></decl>;</decl_stmt> <comment type="block">/* the max value returned from the GTM for our request */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Above, we still use the page as a locking mechanism to handle
         * concurrency
         *
         * If the user has set a CACHE parameter, we use that. Else we pass in
         * the SequenceRangeVal value
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>range</name> <operator>==</operator> <name>DEFAULT_CACHEVAL</name> <operator>&amp;&amp;</operator> <name>SequenceRangeVal</name> <operator>&gt;</operator> <name>range</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TimestampTz</name></type> <name>curtime</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>last_call_time</name></name></expr></argument>,
                                                    <argument><expr><name>curtime</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * The previous GetNextValGTM call was made just a while back.
                 * Request double the range of what was requested in the
                 * earlier call. Honor the SequenceRangeVal boundary
                 * value to limit very large range requests!
                 */</comment>
                <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name> <operator>&lt;</operator> <name>SequenceRangeVal</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>range</name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name> <operator>=</operator> <name>range</name> <operator>=</operator> <name>SequenceRangeVal</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"increase sequence range %ld"</literal></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>last_call_time</name></name></expr></argument>,
                                                <argument><expr><name>curtime</name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* The previous GetNextValGTM call was pretty old */</comment>
                <expr_stmt><expr><name>range</name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name> <operator>=</operator> <name>DEFAULT_CACHEVAL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"reset sequence range %ld"</literal></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>last_call_time</name></name></expr></argument>,
                                                <argument><expr><name>curtime</name></expr></argument>, <argument><expr><literal type="number">3000</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * The previous GetNextValGTM call was made quite some time
                 * ago. Try to reduce the range request to reduce the gap
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name> <operator>!=</operator> <name>DEFAULT_CACHEVAL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>range</name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name> <operator>=</operator>
                                <call><name>rint</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"decrease sequence range %ld"</literal></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Current range_multiplier alllows to cache sequence values
                 * for 1-3 seconds of work. Keep that rate.
                 */</comment>
                <expr_stmt><expr><name>range</name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last_call_time</name></name> <operator>=</operator> <name>curtime</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
        <comment type="block">/* Always set range to 1 when regress */</comment>
        <expr_stmt><expr><name>range</name>  <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>GetNextValGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangemax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[nextval_internal] connect gtm. seqname:%s procid:%d get nextval:%lld, range:%lld, rangemax:%lld"</literal></expr></argument>,  
                    <argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <name>int</name><operator>)</operator><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <name>int</name><operator>)</operator><name>range</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <name>int</name><operator>)</operator><name>rangemax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Update the on-disk data */</comment>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt> <comment type="block">/* last fetched number */</comment>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>is_called</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* save info in local cache */</comment>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>            <comment type="block">/* last returned number */</comment>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <name>rangemax</name></expr>;</expr_stmt>        <comment type="block">/* last fetched range max limit */</comment>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>last_used_seq</name> <operator>=</operator> <name>elm</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>increment</name></name> <operator>=</operator> <name>incby</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* ready to change the on-disk (or really, in-buffer) tuple */</comment>
    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*
     * We must mark the buffer dirty before doing XLogInsert(); see notes in
     * SyncOneBuffer().  However, we don't apply the desired changes just yet.
     * This looks like a violation of the buffer update protocol, but it is in
     * fact safe because we hold exclusive lock on the buffer.    Any other
     * process, including a checkpoint, that tries to examine the buffer
     * contents will block until we release the lock, and then will see the
     * final state that we install below.
     */</comment>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>currval_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqTable</name></type>	<name>elm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>seqrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* open and lock sequence */</comment>
	<expr_stmt><expr><call><name>init_sequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						  <argument><expr><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for sequence %s"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>elm</name><operator>-&gt;</operator><name>last_valid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <block>{<block_content>
        <comment type="block">/*
          * Always contact GTM for currval
          */</comment>
        <block>{<block_content>
            <expr_stmt><expr><name>seqname</name> <operator>=</operator> <call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>GetCurrentValGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[currval_oid]seqname:%s procid:%d result:%lld"</literal></expr></argument>, <argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <name>int</name><operator>)</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lastval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>seqrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>last_used_seq</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lastval is not yet defined in this session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Someone may have dropped the sequence since the last nextval() */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>last_used_seq</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lastval is not yet defined in this session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>seqrel</name> <operator>=</operator> <call><name>lock_and_open_sequence</name><argument_list>(<argument><expr><name>last_used_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* nextval() must have already been called for this sequence */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>last_used_seq</name><operator>-&gt;</operator><name>last_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>last_used_seq</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for sequence %s"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>last_used_seq</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main internal procedure that handles 2 &amp; 3 arg forms of SETVAL.
 *
 * Note that the 3 arg version (which sets the is_called flag) is
 * only for use in pg_dump, and setting the is_called flag may not
 * work if multiple users are attached to the database and referencing
 * the sequence (unlikely if pg_dump is restoring it).
 *
 * It is necessary to have the 3 arg version so that pg_dump can
 * restore the state of a sequence exactly during data-only restores -
 * it is the only way to clear the is_called flag in an existing
 * sequence.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_setval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>next</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iscalled</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SeqTable</name></type>    <name>elm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>seqrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>seqdatatuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence_data</name></type> <name>seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>pgstuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>pgsform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>maxv</name></decl>,
                <decl><type ref="prev"/><name>minv</name></decl>;</decl_stmt>

    <comment type="block">/* open and lock sequence */</comment>
    <expr_stmt><expr><call><name>init_sequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>elm</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_UPDATE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for sequence %s"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pgstuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgsform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>maxv</name> <operator>=</operator> <name><name>pgsform</name><operator>-&gt;</operator><name>seqmax</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>minv</name> <operator>=</operator> <name><name>pgsform</name><operator>-&gt;</operator><name>seqmin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* read-only transactions may only modify temp sequences */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seqrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><literal type="string">"setval()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Forbid this during parallel operation because, to make it work, the
     * cooperating backends would need to share the backend-local cached
     * sequence information.  Currently, we don't support that.
     */</comment>
    <expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><literal type="string">"setval()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* lock page' buffer and read tuple */</comment>
    <expr_stmt><expr><name>seq</name> <operator>=</operator> <call><name>read_seq_tuple</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>next</name> <operator>&lt;</operator> <name>minv</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>next</name> <operator>&gt;</operator> <name>maxv</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufv</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>bufm</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>bufx</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufv</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>minv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>maxv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"setval: value %s is out of bounds for sequence \"%s\" (%s..%s)"</literal></expr></argument>,
                        <argument><expr><name>bufv</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>bufm</name></expr></argument>, <argument><expr><name>bufx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>SetValGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>iscalled</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not obtain sequence value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Update the on-disk data */</comment>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <comment type="block">/* last fetched number */</comment>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>is_called</name></name> <operator>=</operator> <name>iscalled</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>iscalled</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>iscalled</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>        <comment type="block">/* last returned number */</comment>
            <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <comment type="block">/* In any case, forget any future cached numbers */</comment>
    <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

    <comment type="block">/* check the comment above nextval_internal()'s equivalent call. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>GetTopTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* ready to change the on-disk (or really, in-buffer) tuple */</comment>
    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>        <comment type="block">/* last fetched number */</comment>
    <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>is_called</name></name> <operator>=</operator> <name>iscalled</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XLOG stuff */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_seq_rec</name></type>    <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>seqrel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_seq_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>seqdatatuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>seqdatatuple</name><operator>.</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SEQ_ID</name></expr></argument>, <argument><expr><name>XLOG_SEQ_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implement the 2 arg setval procedure.
 * See do_setval for discussion.
 */</comment>
<function><type><name>Datum</name></type>
<name>setval_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>next</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>do_setval</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implement the 3 arg setval procedure.
 * See do_setval for discussion.
 */</comment>
<function><type><name>Datum</name></type>
<name>setval3_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>next</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>iscalled</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>do_setval</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>iscalled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Open the sequence and acquire lock if needed
 *
 * If we haven't touched the sequence already in this transaction,
 * we need to acquire a lock.  We arrange for the lock to
 * be owned by the top transaction, so that we don't need to do it
 * more than once per xact.
 */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>lock_and_open_sequence</name><parameter_list>(<parameter><decl><type><name>SeqTable</name></type> <name>seq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>thislxid</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Get the lock if not already held in this xact */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>seq</name><operator>-&gt;</operator><name>lxid</name></name> <operator>!=</operator> <name>thislxid</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ResourceOwner</name></type> <name>currentOwner</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>currentOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>seq</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <comment type="block">/* Ensure CurrentResourceOwner is restored on error */</comment>
            <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>currentOwner</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>currentOwner</name></expr>;</expr_stmt>

        <comment type="block">/* Flag that we have a lock in the current xact */</comment>
        <expr_stmt><expr><name><name>seq</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>thislxid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We now know we have the lock, and can safely open the rel */</comment>
    <return>return <expr><call><name>relation_open</name><argument_list>(<argument><expr><name><name>seq</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates the hash table for storing sequence data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_seq_hashtable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SeqTableData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><name>seqhashtab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Sequence values"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                             <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a relation OID, open and lock the sequence.  p_elm and p_rel are
 * output parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_sequence</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>SeqTable</name> <modifier>*</modifier></type><name>p_elm</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>p_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SeqTable</name></type>    <name>elm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>seqrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <comment type="block">/* Find or create a hash table entry for this sequence */</comment>
    <if_stmt><if>if <condition>(<expr><name>seqhashtab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>create_seq_hashtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>elm</name> <operator>=</operator> <operator>(</operator><name>SeqTable</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>seqhashtab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the new hash table entry if it did not exist already.
     *
     * NOTE: seqtable entries are stored for the life of a backend (unless
     * explicitly discarded with DISCARD). If the sequence itself is deleted
     * then the entry becomes wasted memory, but it's small enough that this
     * should not matter.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* relid already filled in */</comment>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>filenode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last_call_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>range_multiplier</name></name> <operator>=</operator> <name>DEFAULT_CACHEVAL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Open the sequence relation.
     */</comment>
    <expr_stmt><expr><name>seqrel</name> <operator>=</operator> <call><name>lock_and_open_sequence</name><argument_list>(<argument><expr><name>elm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>seqrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the sequence has been transactionally replaced since we last saw it,
     * discard any cached-but-unissued values.  We do not touch the currval()
     * state, however.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>seqrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>!=</operator> <name><name>elm</name><operator>-&gt;</operator><name>filenode</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>filenode</name></name> <operator>=</operator> <name><name>seqrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>elm</name><operator>-&gt;</operator><name>cached</name></name> <operator>=</operator> <name><name>elm</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return results */</comment>
    <expr_stmt><expr><operator>*</operator><name>p_elm</name> <operator>=</operator> <name>elm</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p_rel</name> <operator>=</operator> <name>seqrel</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Given an opened sequence relation, lock the page buffer and find the tuple
 *
 * *buf receives the reference to the pinned-and-ex-locked buffer
 * *seqdatatuple receives the reference to the sequence tuple proper
 *        (this arg should point to a local variable of type HeapTupleData)
 *
 * Function's return value points to the data payload of the tuple
 */</comment>
<function><type><specifier>static</specifier> <name>Form_pg_sequence_data</name></type>
<name>read_seq_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>seqdatatuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemId</name></type>        <name>lp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sequence_magic</name> <modifier>*</modifier></type><name>sm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence_data</name></type> <name>seq</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sm</name> <operator>=</operator> <operator>(</operator><name>sequence_magic</name> <operator>*</operator><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sm</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>SEQ_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad magic number in sequence \"%s\": %08X"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sm</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note we currently only bother to set these two fields of *seqdatatuple */</comment>
    <expr_stmt><expr><name><name>seqdatatuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqdatatuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Previous releases of Postgres neglected to prevent SELECT FOR UPDATE on
     * a sequence, which would leave a non-frozen XID in the sequence tuple's
     * xmax, which eventually leads to clog access failures or worse. If we
     * see this has happened, clean up after it.  We treat this like a hint
     * bit update, ie, don't bother to WAL-log it, since we can certainly do
     * this again if the update gets lost.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>seqdatatuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>seqdatatuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>seqdatatuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqdatatuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_COMMITTED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqdatatuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>seq</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence_data</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>seqdatatuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>seq</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * init_params: process the options list of CREATE or ALTER SEQUENCE, and
 * store the values into appropriate fields of seqform, for changes that go
 * into the pg_sequence catalog, and fields of seqdataform for changes to the
 * sequence relation itself.  Set *need_seq_rewrite to true if we changed any
 * parameters that require rewriting the sequence's relation (interesting for
 * ALTER SEQUENCE).  Also set *owned_by to any OWNED BY option, or to NIL if
 * there is none.
 *
 * If isInit is true, fill any unspecified options with default values;
 * otherwise, do not change existing options that aren't explicitly overridden.
 *
 * Note: we force a sequence rewrite whenever we change parameters that affect
 * generation of future sequence values, even if the seqdataform per se is not
 * changed.  This allows ALTER SEQUENCE to behave transactionally.  Currently,
 * the only option that doesn't cause that is OWNED BY.  It's *necessary* for
 * ALTER SEQUENCE OWNED BY to not rewrite the sequence, because that would
 * break pg_upgrade by causing unwanted changes in the sequence's relfilenode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_params</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_identity</name></decl></parameter>,
            <parameter><decl><type><name>bool</name></type> <name>isInit</name></decl></parameter>,
            <parameter><decl><type><name>Form_pg_sequence</name></type> <name>seqform</name></decl></parameter>,
            <parameter><decl><type><name>Form_pg_sequence_data</name></type> <name>seqdataform</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_seq_rewrite</name></decl></parameter>,
            <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>owned_by</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_restart</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>as_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>start_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>restart_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>increment_by</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>max_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>min_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>cache_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>is_cycled</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>reset_max_value</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>reset_min_value</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><operator>*</operator><name>is_restart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>owned_by</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"as"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>as_type</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>as_type</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"increment"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>increment_by</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>increment_by</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"start"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>start_value</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>start_value</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"restart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>restart_value</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>restart_value</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>max_value</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>max_value</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"minvalue"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>min_value</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>min_value</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cache"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cache_value</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>cache_value</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cycle"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>is_cycled</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>is_cycled</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>need_seq_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"owned_by"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>owned_by</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>owned_by</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sequence_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * The parser allows this, but it is only for identity columns, in
             * which case it is filtered out in parse_utilcmd.c.  We only get
             * here if someone puts it into a CREATE SEQUENCE.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid sequence option SEQUENCE NAME"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
                 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * We must reset log_cnt when isInit or when changing any parameters that
     * would affect future nextval allocations.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isInit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* AS type */</comment>
    <if_stmt><if>if <condition>(<expr><name>as_type</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>newtypid</name> <init>= <expr><call><name>typenameTypeId</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>defGetTypeName</name><argument_list>(<argument><expr><name>as_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>newtypid</name> <operator>!=</operator> <name>INT2OID</name> <operator>&amp;&amp;</operator>
            <name>newtypid</name> <operator>!=</operator> <name>INT4OID</name> <operator>&amp;&amp;</operator>
            <name>newtypid</name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <ternary><condition><expr><name>for_identity</name></expr>
                     ?</condition><then> <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"identity column type must be smallint, integer, or bigint"</literal></expr></argument>)</argument_list></call></expr>
                     </then><else>: <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sequence type must be smallint, integer, or bigint"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isInit</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * When changing type and the old sequence min/max values were the
             * min/max of the old type, adjust sequence min/max values to
             * min/max of new type.  (Otherwise, the user chose explicit
             * min/max values, which we'll leave alone.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT2OID</name> <operator>&amp;&amp;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>==</operator> <name>PG_INT16_MAX</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT4OID</name> <operator>&amp;&amp;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>==</operator> <name>PG_INT32_MAX</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT8OID</name> <operator>&amp;&amp;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>==</operator> <name>PG_INT64_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>reset_max_value</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT2OID</name> <operator>&amp;&amp;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>==</operator> <name>PG_INT16_MIN</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT4OID</name> <operator>&amp;&amp;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>==</operator> <name>PG_INT32_MIN</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT8OID</name> <operator>&amp;&amp;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>==</operator> <name>PG_INT64_MIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>reset_min_value</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>=</operator> <name>newtypid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* INCREMENT BY */</comment>
    <if_stmt><if>if <condition>(<expr><name>increment_by</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqincrement</name></name> <operator>=</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>increment_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqincrement</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INCREMENT must not be zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqincrement</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* CYCLE */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_cycled</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqcycle</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>is_cycled</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BoolIsValid</name><argument_list>(<argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqcycle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqcycle</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* MAXVALUE (null arg means NO MAXVALUE) */</comment>
    <if_stmt><if>if <condition>(<expr><name>max_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>max_value</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>=</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>max_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name> <operator>||</operator> <name>max_value</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>reset_max_value</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqincrement</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>reset_max_value</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* ascending seq */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>=</operator> <name>PG_INT16_MAX</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>=</operator> <name>PG_INT64_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* descending seq */</comment>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT2OID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>&lt;</operator> <name>PG_INT16_MIN</name> <operator>||</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>&gt;</operator> <name>PG_INT16_MAX</name><operator>)</operator><operator>)</operator>
        <operator>||</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT4OID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>&lt;</operator> <name>PG_INT32_MIN</name> <operator>||</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>&gt;</operator> <name>PG_INT32_MAX</name><operator>)</operator><operator>)</operator>
        <operator>||</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT8OID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>&lt;</operator> <name>PG_INT64_MIN</name> <operator>||</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name> <operator>&gt;</operator> <name>PG_INT64_MAX</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufx</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MAXVALUE (%s) is out of range for sequence data type %s"</literal></expr></argument>,
                        <argument><expr><name>bufx</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* MINVALUE (null arg means NO MINVALUE) */</comment>
    <if_stmt><if>if <condition>(<expr><name>min_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>min_value</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>=</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>min_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name> <operator>||</operator> <name>min_value</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>reset_min_value</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqincrement</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>reset_min_value</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* descending seq */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>=</operator> <name>PG_INT16_MIN</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>=</operator> <name>PG_INT32_MIN</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>=</operator> <name>PG_INT64_MIN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* ascending seq */</comment>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT2OID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>&lt;</operator> <name>PG_INT16_MIN</name> <operator>||</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>&gt;</operator> <name>PG_INT16_MAX</name><operator>)</operator><operator>)</operator>
        <operator>||</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT4OID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>&lt;</operator> <name>PG_INT32_MIN</name> <operator>||</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>&gt;</operator> <name>PG_INT32_MAX</name><operator>)</operator><operator>)</operator>
        <operator>||</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name> <operator>==</operator> <name>INT8OID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>&lt;</operator> <name>PG_INT64_MIN</name> <operator>||</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>&gt;</operator> <name>PG_INT64_MAX</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufm</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MINVALUE (%s) is out of range for sequence data type %s"</literal></expr></argument>,
                        <argument><expr><name>bufm</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqtypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* crosscheck min/max */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name> <operator>&gt;=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufm</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>bufx</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MINVALUE (%s) must be less than MAXVALUE (%s)"</literal></expr></argument>,
                        <argument><expr><name>bufm</name></expr></argument>, <argument><expr><name>bufx</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* START WITH */</comment>
    <if_stmt><if>if <condition>(<expr><name>start_value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name> <operator>=</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>start_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqincrement</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* ascending seq */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* descending seq */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* crosscheck START */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name> <operator>&lt;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufs</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>bufm</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"START value (%s) cannot be less than MINVALUE (%s)"</literal></expr></argument>,
                        <argument><expr><name>bufs</name></expr></argument>, <argument><expr><name>bufm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name> <operator>&gt;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufs</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>bufm</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"START value (%s) cannot be greater than MAXVALUE (%s)"</literal></expr></argument>,
                        <argument><expr><name>bufs</name></expr></argument>, <argument><expr><name>bufm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* RESTART [WITH] */</comment>
    <if_stmt><if>if <condition>(<expr><name>restart_value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>restart_value</name><operator>-&gt;</operator><name>arg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>restart_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <expr_stmt><expr><operator>*</operator><name>is_restart</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>is_called</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>last_value</name></name> <operator>=</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqstart</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>is_called</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* crosscheck RESTART (or current value, if changing MIN/MAX) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>seqdataform</name><operator>-&gt;</operator><name>last_value</name></name> <operator>&lt;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufs</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>bufm</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>last_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RESTART value (%s) cannot be less than MINVALUE (%s)"</literal></expr></argument>,
                        <argument><expr><name>bufs</name></expr></argument>, <argument><expr><name>bufm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>seqdataform</name><operator>-&gt;</operator><name>last_value</name></name> <operator>&gt;</operator> <name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>bufs</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>,
                    <decl><type ref="prev"/><name><name>bufm</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>last_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RESTART value (%s) cannot be greater than MAXVALUE (%s)"</literal></expr></argument>,
                        <argument><expr><name>bufs</name></expr></argument>, <argument><expr><name>bufm</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* CACHE */</comment>
    <if_stmt><if>if <condition>(<expr><name>cache_value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqcache</name></name> <operator>=</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>cache_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>seqform</name><operator>-&gt;</operator><name>seqcache</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CACHE (%s) must be greater than zero"</literal></expr></argument>,
                            <argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>seqdataform</name><operator>-&gt;</operator><name>log_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isInit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>seqform</name><operator>-&gt;</operator><name>seqcache</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * GetGlobalSeqName
 *
 * Returns a global sequence name adapted to GTM
 * Name format is dbname.schemaname.seqname
 * so as to identify in a unique way in the whole cluster each sequence
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetGlobalSeqName</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>seqrel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_seqname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_schemaname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dbname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>namespace</name><index>[<expr><name>NAMEDATALEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>charlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_temp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
	<comment type="block">/*
	 * In case of distributed session use MyFirstBackendId for temp objects.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyCoordId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	        <expr_stmt><expr><name>is_temp</name> <operator>=</operator> <operator>(</operator><name><name>seqrel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>==</operator> <name>MyFirstBackendId</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>is_temp</name> <operator>=</operator> <operator>(</operator><name><name>seqrel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>==</operator> <name>MyBackendId</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Get all the necessary relation names */</comment>
    <expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name><name>seqrel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>new_seqname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>relname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_seqname</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_temp</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For a permanent sequence, use schema qualified name. That can
         * uniquely identify the sequences.
         */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>new_schemaname</name></expr> ?</condition><then> <expr><name>new_schemaname</name></expr> </then><else>: <expr><name>schema</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * For temporary sequences, we use originating coordinator name and
         * originating coordinator PID to qualify the sequence name. If we are
         * running on the local coordinator, we can readily fetch that
         * information from PGXCNodeName and MyProcPid, but when running on
         * remote datanode, we must consult MyCoordName and MyProcPid to get
         * the correct information.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>MyCoordName</name></expr></argument>, <argument><expr><name>MyCoordPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Calculate the global name size including the dots and \0 */</comment>
    <expr_stmt><expr><name>charlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>seqname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>charlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Form a unique sequence name with schema and database name for GTM */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>,
             <argument><expr><name>charlen</name></expr></argument>,
             <argument><expr><literal type="string">"%s.%s.%s"</literal></expr></argument>,
             <argument><expr><name>dbname</name></expr></argument>,
             <argument><expr><name>namespace</name></expr></argument>,
             <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dbname</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>seqname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsTempSequence
 *
 * Determine if given sequence is temporary or not.
 */</comment>
<function><type><name>bool</name></type>
<name>IsTempSequence</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type> <name>seqrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SeqTable</name></type>    <name>elm</name></decl>;</decl_stmt>

    <comment type="block">/* open and AccessShareLock sequence */</comment>
    <expr_stmt><expr><call><name>init_sequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyCoordId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name><name>seqrel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>==</operator> <name>MyFirstBackendId</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name><name>seqrel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>==</operator> <name>MyBackendId</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Process an OWNED BY option for CREATE/ALTER SEQUENCE
 *
 * Ownership permissions on the sequence are already checked,
 * but if we are establishing a new owned-by dependency, we must
 * enforce that the referenced table has the same owner and namespace
 * as the sequence.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_owned_by</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>seqrel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>owned_by</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_identity</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DependencyType</name></type> <name>deptype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nnames</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>tablerel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>deptype</name> <operator>=</operator> <ternary><condition><expr><name>for_identity</name></expr> ?</condition><then> <expr><name>DEPENDENCY_INTERNAL</name></expr> </then><else>: <expr><name>DEPENDENCY_AUTO</name></expr></else></ternary></expr>;</expr_stmt>

    <expr_stmt><expr><name>nnames</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>owned_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nnames</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Must be OWNED BY NONE */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>owned_by</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid OWNED BY option"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify OWNED BY table.column or OWNED BY NONE."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>tablerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attrname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

        <comment type="block">/* Separate relname and attr name */</comment>
        <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>owned_by</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nnames</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attrname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_tail</name><argument_list>(<argument><expr><name>owned_by</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Open and lock rel to ensure it won't go away meanwhile */</comment>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tablerel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Must be a regular or foreign table */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tablerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
              <name><name>tablerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
              <name><name>tablerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
              <name><name>tablerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referenced relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>tablerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* We insist on same owner and schema */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>seqrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name><name>tablerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sequence must have same owner as table it is linked to"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>tablerel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sequence must be in same schema as table it is linked to"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Now, fetch the attribute number from the system cache */</comment>
        <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>tablerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name>attrname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>tablerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Catch user explicitly running OWNED BY on identity sequence.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>deptype</name> <operator>==</operator> <name>DEPENDENCY_AUTO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>tableId</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>colId</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>sequenceIsOwned</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change ownership of identity sequence"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s\" is linked to table \"%s\"."</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * OK, we are ready to update pg_depend.  First remove any existing
     * dependencies for the sequence, then optionally add a new one.
     */</comment>
    <expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>tablerel</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>refobject</name></decl>,
                    <decl><type ref="prev"/><name>depobject</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>refobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>refobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>tablerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>refobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>depobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>depobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>depobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>depobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refobject</name></expr></argument>, <argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Done, but hold lock until commit */</comment>
    <if_stmt><if>if <condition>(<expr><name>tablerel</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>tablerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return sequence parameters in a list of the form created by the parser.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>sequence_options</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>pgstuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>pgsform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>pgstuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgsform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"cache"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqcache</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"cycle"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqcycle</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"increment"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqincrement</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqmax</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"minvalue"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqmin</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"start"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqstart</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return sequence parameters (formerly for use by information schema)
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_sequence_parameters</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>pgstuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>pgsform</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for sequence %s"</literal></expr></argument>,
                        <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"start_value"</literal></expr></argument>,
                       <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"minimum_value"</literal></expr></argument>,
                       <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"maximum_value"</literal></expr></argument>,
                       <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"increment"</literal></expr></argument>,
                       <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"cycle_option"</literal></expr></argument>,
                       <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"cache_size"</literal></expr></argument>,
                       <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"data_type"</literal></expr></argument>,
                       <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pgstuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pgsform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqincrement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqcycle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>pgsform</name><operator>-&gt;</operator><name>seqtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pgstuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the last value from the sequence
 *
 * Note: This has a completely different meaning than lastval().
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_sequence_last_value</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SeqTable</name></type>    <name>elm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>seqrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>seqtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_sequence_data</name></type> <name>seq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_called</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* open and lock sequence */</comment>
    <expr_stmt><expr><call><name>init_sequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for sequence %s"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>seq</name> <operator>=</operator> <call><name>read_seq_tuple</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>is_called</name> <operator>=</operator> <name><name>seq</name><operator>-&gt;</operator><name>is_called</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>seq</name><operator>-&gt;</operator><name>last_value</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_called</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>seq_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>localpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>itemsz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_seq_rec</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_seq_rec</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sequence_magic</name> <modifier>*</modifier></type><name>sm</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_SEQ_LOG</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"seq_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We always reinit the page.  However, since this WAL record type is also
     * used for updating sequences, it's possible that a hot-standby backend
     * is examining the page concurrently; so we mustn't transiently trash the
     * buffer.  The solution is to build the correct new page contents in
     * local workspace and then memcpy into the buffer.  Then only bytes that
     * are supposed to change will change, even transiently. We must palloc
     * the local page for alignment reasons.
     */</comment>
    <expr_stmt><expr><name>localpage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>localpage</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sequence_magic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sm</name> <operator>=</operator> <operator>(</operator><name>sequence_magic</name> <operator>*</operator><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>localpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sm</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SEQ_MAGIC</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlrec</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_seq_rec</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_seq_rec</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>localpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>item</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>,
                    <argument><expr><name>FirstOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"seq_redo: failed to add item to page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>localpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>localpage</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>localpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Flush cached sequence information.
 */</comment>
<function><type><name>void</name></type>
<name>ResetSequenceCaches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>seqhashtab</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>seqhashtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>seqhashtab</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>last_used_seq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* connect GTM to clean up all current session related sequence */</comment>
    <expr_stmt><expr><call><name>CleanGTMSeq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Mask a Sequence page before performing consistency checks on it.
 */</comment>
<function><type><name>void</name></type>
<name>seq_mask</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>mask_page_lsn</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mask_unused_space</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type> <name>RenameDatabaseSequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>oldname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>newname</name></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <if_stmt><if>if <condition>(<expr><call><name>RenameDBSequenceGTM</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not rename database sequence"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
