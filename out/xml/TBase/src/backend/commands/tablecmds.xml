<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/tablecmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tablecmds.c
 *      Commands for creating and altering table structures and settings
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/tablecmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/redistrib.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/extentmapping.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/relcryptstorage.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/groupmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ON COMMIT action list
 */</comment>
<typedef>typedef <type><struct>struct <name>OnCommitItem</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>            <comment type="block">/* relid of relation */</comment>
    <decl_stmt><decl><type><name>OnCommitAction</name></type> <name>oncommit</name></decl>;</decl_stmt>    <comment type="block">/* what to do at end of xact */</comment>

    <comment type="block">/*
     * If this entry was created during the current transaction,
     * creating_subid is the ID of the creating subxact; if created in a prior
     * transaction, creating_subid is zero.  If deleted during the current
     * transaction, deleting_subid is the ID of the deleting subxact; if no
     * deletion request is pending, deleting_subid is zero.
     */</comment>
    <decl_stmt><decl><type><name>SubTransactionId</name></type> <name>creating_subid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SubTransactionId</name></type> <name>deleting_subid</name></decl>;</decl_stmt>
}</block></struct></type> <name>OnCommitItem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>on_commits</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type>    <name>is_txn_has_parallel_ddl</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * State information for ALTER TABLE
 *
 * The pending-work queue for an ALTER TABLE is a List of AlteredTableInfo
 * structs, one for each table modified by the operation (the named table
 * plus any child tables that are affected).  We save lists of subcommands
 * to apply to this table (possibly modified by parse transformation steps);
 * these lists will be executed in Phase 2.  If a Phase 3 step is needed,
 * necessary information is stored in the constraints and newvals lists.
 *
 * Phase 2 is divided into multiple passes; subcommands are executed in
 * a pass determined by subcommand type.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_UNSET</name></cpp:macro>            <cpp:value>-1</cpp:value></cpp:define>    <comment type="block">/* UNSET will cause ERROR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_DROP</name></cpp:macro>            <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* DROP (all flavors) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ALTER_TYPE</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* ALTER COLUMN TYPE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_OLD_INDEX</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* re-add existing indexes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_OLD_CONSTR</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>    <comment type="block">/* re-add existing constraints */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_COL_ATTRS</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>    <comment type="block">/* set other column attributes */</comment>
<comment type="block">/* We could support a RENAME COLUMN pass here, but not currently used */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ADD_COL</name></cpp:macro>            <cpp:value>5</cpp:value></cpp:define>    <comment type="block">/* ADD COLUMN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ADD_INDEX</name></cpp:macro>        <cpp:value>6</cpp:value></cpp:define>    <comment type="block">/* ADD indexes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ADD_CONSTR</name></cpp:macro>        <cpp:value>7</cpp:value></cpp:define>    <comment type="block">/* ADD constraints, defaults */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_MISC</name></cpp:macro>            <cpp:value>8</cpp:value></cpp:define>    <comment type="block">/* other stuff */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_DISTRIB</name></cpp:macro>            <cpp:value>9</cpp:value></cpp:define>    <comment type="block">/* Redistribution pass */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_PARTITION</name></cpp:macro>         <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_NUM_PASSES</name></cpp:macro>            <cpp:value>11</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_NUM_PASSES</name></cpp:macro>            <cpp:value>10</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_NUM_PASSES</name></cpp:macro>            <cpp:value>9</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>AlteredTableInfo</name>
<block>{
    <comment type="block">/* Information saved before any work commences: */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>            <comment type="block">/* Relation to work on */</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>        <comment type="block">/* Its relkind */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>oldDesc</name></decl>;</decl_stmt>        <comment type="block">/* Pre-modification tuple descriptor */</comment>
    <comment type="block">/* Information saved by Phase 1 for Phase 2: */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name><name>subcmds</name><index>[<expr><name>AT_NUM_PASSES</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Lists of AlterTableCmd */</comment>
    <comment type="block">/* Information saved by Phases 1/2 for Phase 3: */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>constraints</name></decl>;</decl_stmt>    <comment type="block">/* List of NewConstraint */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newvals</name></decl>;</decl_stmt>        <comment type="block">/* List of NewColumnValue */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>new_notnull</name></decl>;</decl_stmt>    <comment type="block">/* T if we added new NOT NULL constraints */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>rewrite</name></decl>;</decl_stmt>        <comment type="block">/* Reason for forced rewrite, if any */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>newTableSpace</name></decl>;</decl_stmt>    <comment type="block">/* new tablespace; 0 means no change */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>chgPersistence</name></decl>;</decl_stmt> <comment type="block">/* T if SET LOGGED/UNLOGGED is used */</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>newrelpersistence</name></decl>;</decl_stmt>    <comment type="block">/* if above is true */</comment>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>partition_constraint</name></decl>;</decl_stmt>    <comment type="block">/* for attach partition validation */</comment>
	<comment type="block">/* true, if validating default due to some other attach/detach */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>validate_default</name></decl>;</decl_stmt>
    <comment type="block">/* Objects to rebuild after completing ALTER TYPE operations */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>changedConstraintOids</name></decl>;</decl_stmt>    <comment type="block">/* OIDs of constraints to rebuild */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>changedConstraintDefs</name></decl>;</decl_stmt>    <comment type="block">/* string definitions of same */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>changedIndexOids</name></decl>;</decl_stmt>    <comment type="block">/* OIDs of indexes to rebuild */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>changedIndexDefs</name></decl>;</decl_stmt>    <comment type="block">/* string definitions of same */</comment>
}</block></struct></type> <name>AlteredTableInfo</name>;</typedef>

<comment type="block">/* Struct describing one new constraint to check in Phase 3 scan */</comment>
<comment type="block">/* Note: new NOT NULL constraints are handled elsewhere */</comment>
<typedef>typedef <type><struct>struct <name>NewConstraint</name>
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>            <comment type="block">/* Constraint name, or NULL if none */</comment>
    <decl_stmt><decl><type><name>ConstrType</name></type>    <name>contype</name></decl>;</decl_stmt>        <comment type="block">/* CHECK or FOREIGN */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>refrelid</name></decl>;</decl_stmt>        <comment type="block">/* PK rel, if FOREIGN */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>refindid</name></decl>;</decl_stmt>        <comment type="block">/* OID of PK's index, if FOREIGN */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>conid</name></decl>;</decl_stmt>            <comment type="block">/* OID of pg_constraint entry, if FOREIGN */</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>            <comment type="block">/* Check expr or CONSTR_FOREIGN Constraint */</comment>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>qualstate</name></decl>;</decl_stmt>        <comment type="block">/* Execution state for CHECK expr */</comment>
}</block></struct></type> <name>NewConstraint</name>;</typedef>

<comment type="block">/*
 * Struct describing one new column value that needs to be computed during
 * Phase 3 copy (this could be either a new column with a non-null default, or
 * a column that we're changing the type of).  Columns without such an entry
 * are just copied from the old table during ATRewriteTable.  Note that the
 * expr is an expression over *old* table values.
 */</comment>
<typedef>typedef <type><struct>struct <name>NewColumnValue</name>
<block>{
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>            <comment type="block">/* which column */</comment>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>            <comment type="block">/* expression to compute */</comment>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>        <comment type="block">/* execution state */</comment>
}</block></struct></type> <name>NewColumnValue</name>;</typedef>

<comment type="block">/*
 * Error-reporting support for RemoveRelations
 */</comment>
<struct>struct <name>dropmsgstrings</name>
<block>{
    <decl_stmt><decl><type><name>char</name></type>        <name>kind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nonexistent_code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nonexistent_msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>skipping_msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nota_msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>drophint_msg</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name></type> <name><name>dropmsgstringarray</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><name>RELKIND_RELATION</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TABLE to remove a table."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><name>RELKIND_SEQUENCE</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP SEQUENCE to remove a sequence."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><name>RELKIND_VIEW</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP VIEW to remove a view."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><name>RELKIND_MATVIEW</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a materialized view"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP MATERIALIZED VIEW to remove a materialized view."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><name>RELKIND_INDEX</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP INDEX to remove an index."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><name>RELKIND_COMPOSITE_TYPE</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a type"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TYPE to remove a type."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><name>RELKIND_FOREIGN_TABLE</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP FOREIGN TABLE to remove a foreign table."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><name>RELKIND_PARTITIONED_TABLE</name></expr>,
        <expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>,
    <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TABLE to remove a table."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_PARTITIONED_INDEX</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP INDEX to remove an index."</literal></argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr><literal type="char">'\0'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<struct>struct <name>DropRelationCallbackState</name>
<block>{
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>heapOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>partParentOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>concurrent</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Alter table target-type flags for ATSimplePermissions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>ATT_TABLE</name></cpp:macro>                <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>ATT_VIEW</name></cpp:macro>                <cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>ATT_MATVIEW</name></cpp:macro>                <cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>ATT_INDEX</name></cpp:macro>                <cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>ATT_COMPOSITE_TYPE</name></cpp:macro>        <cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>        <cpp:macro><name>ATT_FOREIGN_TABLE</name></cpp:macro>        <cpp:value>0x0020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_PARTITIONED_INDEX</name></cpp:macro>	<cpp:value>0x0040</cpp:value></cpp:define>

<comment type="block">/*
 * Partition tables are expected to be dropped when the parent partitioned
 * table gets dropped. Hence for partitioning we use AUTO dependency.
 * Otherwise, for regular inheritance use NORMAL dependency.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>child_dependency_type</name><parameter_list>(<parameter><type><name>child_is_partition</name></type></parameter>)</parameter_list></cpp:macro>    \
    <cpp:value>((child_is_partition) ? DEPENDENCY_AUTO : DEPENDENCY_NORMAL)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>truncate_check_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>MergeAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_partition</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supconstr</name></decl></parameter>,
                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>supOidCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MergeCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MergeAttributesIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MergeConstraintsIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MergeDistributionIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreCatalogInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreCatalogInheritance1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>,
                         <parameter><decl><type><name>int16</name></type> <name>seqNumber</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>inhRelation</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreIntervalPartitionDependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATAddPartitions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExchangeIndexName</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExchangeIndexName</name> <modifier>*</modifier></type> <name>exchange</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATModifyPartitionStartValue</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ModifyPartStartValue</name> <modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>findAttrByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterIndexNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterSeqNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>,
                   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecValidateConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>transformColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colList</name></decl></parameter>,
                        <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>transformFkeyGetPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indexOid</name></decl></parameter>,
                           <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
                           <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>transformFkeyCheckAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
                        <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkFkeyPermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CoercionPathType</name></type> <name>findFkeyCast</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>,
             <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateCheckConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>constrtup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>,
                             <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
                             <parameter><decl><type><name>Oid</name></type> <name>pkindOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>createForeignKeyTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>,
                         <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATController</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
             <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
          <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteCatalogs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
          <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteTables</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteTable</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type><name>ATGetQueueEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATSimplePermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATWrongRelkindError</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATSimpleRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATCheckPartitionsNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATTypedTableRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
                      <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>find_typed_table_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>,
                              <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>is_view</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
                <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>colDef</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isOid</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_for_column_name_collision</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_column_datatype_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_column_collation_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddOids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
              <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecColumnDefault</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newDefault</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReset</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
									  <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIndex</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
               <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_rebuild</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
                    <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                    <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>newConstraint</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
                    <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIndexConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATAddCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
                     <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                     <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
                     <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATAddForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                          <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
                     <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAlterColumnType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
                      <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                      <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ATColumnChangeRequiresRewrite</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterColumnType</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterColumnGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPostAlterTypeCleanup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
                       <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPostAlterTypeParse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelId</name></decl></parameter>,
                     <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>rewrite</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RebuildConstraintComment</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pass</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TryReuseIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TryReuseForeignKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>change_owner_fix_column_acls</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
                             <parameter><decl><type><name>Oid</name></type> <name>oldOwnerId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>change_owner_recurse_to_sequences</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
                                  <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecClusterOn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexName</name></decl></parameter>,
                <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ATPrepChangePersistence</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toLogged</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetTableSpace</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetTableSpaceNoStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defList</name></decl></parameter>,
                    <parameter><decl><type><name>AlterTableType</name></type> <name>operation</name></decl></parameter>,
                    <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableDisableTrigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>,
                           <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableDisableRule</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
                        <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drop_parent_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
                       <parameter><decl><type><name>DependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtExecDistributeBy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>DistributeBy</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtExecSubCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PGXCSubCluster</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtExecAddNode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtExecDeleteNode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATCheckCmd</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RedistribState</name> <modifier>*</modifier></type><name>BuildRedistribCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subCmds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name> <modifier>*</modifier></type><name>delete_node_list</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>old_oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>old_num</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>del_oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>del_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>new_num</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDisableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecForceNoForceRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_rls</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_relation_data</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>dst</name></decl></parameter>,
                   <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>storage_name</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForDropRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>,
                                <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForAlterRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
                                 <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type><name>transformPartitionSpec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>partspec</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ComputePartitionAttrs</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partParams</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partattrs</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAttachPartition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AttachPartitionEnsureIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>attachrel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>QueuePartitionConstraintValidation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>,
                            <parameter><decl><type><name>bool</name></type> <name>validate_default</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDetachPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAttachPartitionIdx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validatePartitionedIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partedIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partedTbl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>refuseDupeIndexAttach</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partIdx</name></decl></parameter>,
                     <parameter><decl><type><name>Relation</name></type> <name>partitionTbl</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtExecRebuildExtent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mls_allow_add_cls_col</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mls_allow_detach_parition</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mls_policy_check</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------
 *        DefineRelation
 *                Creates a new relation.
 *
 * stmt carries parsetree information from an ordinary CREATE TABLE statement.
 * The other arguments are used to extend the behavior for other cases:
 * relkind: relkind to assign to the new relation
 * ownerId: if not InvalidOid, use this as the new relation's owner.
 * typaddress: if not null, it's set to the pg_type entry's address.
 *
 * Note that permissions checks are done against current user regardless of
 * ownerId.  A nonzero ownerId is used when someone is creating a relation
 * "on behalf of" someone else, so we still want to see that the current user
 * has permissions to do it.
 *
 * If successful, returns the address of the new relation.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineRelation</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>,
               <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>typaddress</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>relname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>namespaceId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relationId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tablespaceId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>descriptor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>inheritOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>old_constraints</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>localHasOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>parentOidCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rawDefaults</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>cookedDefaults</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>reloptions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>listptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partitioned</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>ofTypeId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>parentLockmode</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_extent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Truncate relname to appropriate length (probably a waste of time, as
     * parser should have done this already).
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* interval partition's child has its own name */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_child</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partname</name> <init>= <expr><call><name>GetPartitionName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_parentId</name></name></expr></argument>, 
                                   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_child_idx</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>partname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Check consistency of arguments
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>!=</operator> <name>ONCOMMIT_NOOP</name>
        <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON COMMIT can only be used on temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected relkind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>PARTITION_INTERVAL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>partitioned</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>partitioned</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Look up the namespace in which we are supposed to create the relation,
     * check we have permission to create there, lock it against concurrent
     * drop, and mark stmt-&gt;relation as RELPERSISTENCE_TEMP if a temporary
     * namespace is selected.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_child</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* interval partition child's namespace is same as parent. */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_parentId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
    <block>{<block_content>
        <expr_stmt><expr><name>namespaceId</name> <operator>=</operator>
                <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator>
		<call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Security check: disallow creating temp tables from security-restricted
	 * code.  This is needed because calling code might not expect untrusted
	 * tables to appear in pg_temp at the front of its search path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name>
		<operator>&amp;&amp;</operator> <call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary table within security-restricted operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine the lockmode to use when scanning parents.  A self-exclusive
	 * lock is needed here.
	 *
	 * For regular inheritance, if two backends attempt to add children to the
	 * same parent simultaneously, and that parent has no pre-existing
	 * children, then both will attempt to update the parent's relhassubclass
	 * field, leading to a "tuple concurrently updated" error.  Also, this
	 * interlocks against a concurrent ANALYZE on the parent table, which
	 * might otherwise be attempting to clear the parent's relhassubclass
	 * field, if its previous children were recently dropped.
	 *
	 * If the child table is a partition, then we instead grab an exclusive
	 * lock on the parent because its partition descriptor will be changed by
	 * addition of the new partition.
	 */</comment>
	<expr_stmt><expr><name>parentLockmode</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>AccessExclusiveLock</name></expr> </then><else>:
					  <expr><name>ShareUpdateExclusiveLock</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Determine the list of OIDs of the parents. */</comment>
	<expr_stmt><expr><name>inheritOids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>stmt-&gt;inhRelations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parentOid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>parentLockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reject duplications in the list of parents.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" would be inherited from more than once"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>inheritOids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Select tablespace to use: an explicitly indicated one, or (in the case
	 * of a partitioned table) the parent's, if it has one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>partitioned</name> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify default tablespace for partitioned relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For partitions, when no other tablespace is specified, we default
		 * the tablespace to the parent partitioned table's.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_rel_tablespace</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* still nothing? use the default */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>GetDefaultTablespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
											<argument><expr><name>partitioned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check permissions except when using database's default */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_TABLESPACE</name></expr></argument>,
						   <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* In all cases disallow placing user relations in pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>tablespaceId</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Identify user ID that will own the table */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parse and validate reloptions, if any.
	 */</comment>
	<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>view_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>ofTypeId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ofTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Look up inheritance ancestors and generate relation schema, including
	 * inherited attributes.  (Note that stmt-&gt;tableElts is destructively
	 * modified by MergeAttributes.)
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator>
		<call><name>MergeAttributes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>, <argument><expr><name>inheritOids</name></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>old_constraints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentOidCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a tuple descriptor from the relation schema.  Note that this
	 * deals with column names, types, and NOT NULL constraints, but not
	 * default values or CHECK constraints; we handle those below.
	 */</comment>
	<expr_stmt><expr><name>descriptor</name> <operator>=</operator> <call><name>BuildDescForRelation</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Notice that we allow OIDs here only for plain tables and partitioned
	 * tables, even though some other relkinds can support them.  This is
	 * necessary because the default_with_oids GUC must apply only to plain
	 * tables and not any other relkind; doing otherwise would break existing
	 * pg_dump files.  We could allow explicit "WITH OIDS" while not allowing
	 * default_with_oids to affect other relkinds, but it would complicate
	 * interpretOidsOption().
	 */</comment>
	<expr_stmt><expr><name>localHasOids</name> <operator>=</operator> <call><name>interpretOidsOption</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
										<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>tdhasoid</name></name> <operator>=</operator> <operator>(</operator><name>localHasOids</name> <operator>||</operator> <name>parentOidCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>has_extent</name> <operator>=</operator> <call><name>interpretExtentOption</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
                                        <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* table in cold group must be extent shard table */</comment>
    if (IS_PGXC_DATANODE &amp;&amp; stmt-&gt;distributeby &amp;&amp; 
        stmt-&gt;distributeby-&gt;disttype == DISTTYPE_SHARD)
    {
        <comment type="block">/* distributed by two columns and in hot cold groups */</comment>
        if (list_length(stmt-&gt;distributeby-&gt;colname) == 2 &amp;&amp;
            stmt-&gt;subcluster &amp;&amp; stmt-&gt;subcluster-&gt;clustertype == SUBCLUSTER_GROUP &amp;&amp;
            list_length(stmt-&gt;subcluster-&gt;members) == 2)
        {
            PGXCSubCluster *subcluster = stmt-&gt;subcluster;
            
            const char *coldGroupName = strVal(lsecond(subcluster-&gt;members));

            char *myGroupName = GetMyGroupName();

            if (myGroupName)
            {
                if (strcmp(myGroupName, coldGroupName) == 0)
                {
                    has_extent = true;
                }
            }
        }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If a partitioned table doesn't have the system OID column, then none of
     * its partitions should have it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>&amp;&amp;</operator> <name>parentOidCount</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>localHasOids</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create table with OIDs as partition of table without OIDs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Find columns with default values and prepare for insertion of the
     * defaults.  Pre-cooked (that is, inherited) defaults go into a list of
     * CookedConstraint structs that we'll pass to heap_create_with_catalog,
     * while raw defaults go into a list of RawColumnDefault structs that will
     * be processed by AddRelationNewConstraints.  (We can't deal with raw
     * expressions until we can do transformExpr.)
     *
     * We can set the atthasdef flags now in the tuple descriptor; this just
     * saves StoreAttrDefault from having to do an immediate update of the
     * pg_attribute rows.
     */</comment>
    <expr_stmt><expr><name>rawDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cookedDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>stmt-&gt;tableElts</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>colDef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rawDefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rawDefaults</name></expr></argument>, <argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atthasdef</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    <comment type="block">/* until created */</comment>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>    <comment type="block">/* not used for defaults */</comment>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* ditto */</comment>
            <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cookedDefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cookedDefaults</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atthasdef</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attidentity</name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <comment type="block">/*
     * check if this relation has extent
     * Only table which is created by user with shard distribution can be has extent.
     * It's toast table also has extent if it exist.
     */</comment>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator>        
        <operator>(</operator><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>distributeby</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>distributeby</name><operator>-&gt;</operator><name>disttype</name></name> <operator>!=</operator> <name>DISTTYPE_SHARD</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>has_extent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Create the relation.  Inherited defaults and constraints are passed in
     * for immediate handling --- since they don't need parsing, they can be
     * stored immediately.
     */</comment>
    <expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>heap_create_with_catalog</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
                                          <argument><expr><name>namespaceId</name></expr></argument>,
                                          <argument><expr><name>tablespaceId</name></expr></argument>,
                                          <argument><expr><name>InvalidOid</name></expr></argument>,
                                          <argument><expr><name>InvalidOid</name></expr></argument>,
                                          <argument><expr><name>ofTypeId</name></expr></argument>,
                                          <argument><expr><name>ownerId</name></expr></argument>,
                                          <argument><expr><name>descriptor</name></expr></argument>,
                                          <argument><expr><call><name>list_concat</name><argument_list>(<argument><expr><name>cookedDefaults</name></expr></argument>,
                                                      <argument><expr><name>old_constraints</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>relkind</name></expr></argument>,
                                          <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><name>localHasOids</name></expr></argument>,
                                          <argument><expr><name>parentOidCount</name></expr></argument>,
                                          <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name></expr></argument>,
                                          <argument><expr><name>reloptions</name></expr></argument>,
                                          <argument><expr><name>true</name></expr></argument>,
                                          <argument><expr><name>allowSystemTableMods</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                                          <argument><expr><name>has_extent</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                          <argument><expr><name>typaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Store inheritance information for new rel. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_child</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            
        <expr_stmt><expr><call><name>StoreIntervalPartitionDependency</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_parentId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>RELPARTKIND_CHILD</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>interval_parentId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><name>PARTITION_INTERVAL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            
        <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>RELPARTKIND_PARENT</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                
            <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>RELPARTKIND_NONE</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>StoreCatalogInheritance</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * We must bump the command counter to make the newly-created relation
     * tuple visible for opening.
     */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Add to pgxc_class.
     * we need to do this after CommandCounterIncrement
     * Distribution info is to be added under the following conditions:
     * 1. The create table command is being run on a coordinator
     * 2. The create table command is being run in restore mode and
     *    the statement contains distribute by clause.
     *    While adding a new datanode to the cluster an existing dump
     *    that was taken from a datanode is used, and
     *    While adding a new coordinator to the cluster an exiting dump
     *    that was taken from a coordinator is used.
     *    The dump taken from a datanode does NOT contain any DISTRIBUTE BY
     *    clause. This fact is used here to make sure that when the
     *    DISTRIBUTE BY clause is missing in the statemnet the system
     *    should not try to find out the node list itself.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>distributeby</name></name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>isRestoreMode</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>distributeby</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>            
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>distributeby</name></name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>isRestoreMode</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>distributeby</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AddRelationDistribution</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributeby</name></name></expr></argument>,
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subcluster</name></name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                                <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Make sure locator info gets rebuilt */</comment>
        <expr_stmt><expr><call><name>RelationCacheInvalidateEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Open the new relation and acquire exclusive lock on it.  This isn't
     * really necessary for locking out other backends (since they can't see
     * the new rel anyway until we commit), but it keeps the lock manager from
     * complaining about deadlock risks.
     */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are inheriting from more than one parent, ensure that the
     * distribution strategy of the child table and each of the parent table
     * satisfies various limitations imposed by XL. Any violation will be
     * reported as ERROR by MergeDistributionIntoExisting.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>inheritOids</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>parentOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>parent_rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>MergeDistributionIntoExisting</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* Process and store partition bound, if any. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></init></decl>,
					<decl><type ref="prev"/><name>defaultPartOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>,
					<decl><type ref="prev"/><name>defaultRel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Already have strong enough lock on the parent */</comment>
        <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We are going to try to validate the partition bound specification
         * against the partition key of parentRel, so it better have one.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not partitioned"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The partition constraint of the default partition depends on the
		 * partition bounds of every other partition. It is possible that
		 * another backend might be about to execute a query on the default
		 * partition table, and that the query relies on previously cached
		 * default partition constraints. We must therefore take a table lock
		 * strong enough to prevent all queries on the default partition from
		 * proceeding until we commit and send out a shared-cache-inval notice
		 * that will make them update their index lists.
		 *
		 * Order of locking: The relation being added won't be visible to
		 * other backends until it is committed, hence here in
		 * DefineRelation() the order of locking the default partition and the
		 * relation being added does not matter. But at all other places we
		 * need to lock the default relation before we lock the relation being
		 * added or removed i.e. we should take the lock in same order at all
		 * the places such that lock parent, lock default partition and then
		 * lock the partition so as to avoid a deadlock.
		 */</comment>
		<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
			<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defaultRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Tranform the bound values */</comment>
        <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>bound</name> <operator>=</operator> <call><name>transformPartitionBound</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check first that the new partition's bound is valid and does not
		 * overlap with any of existing partitions of the parent.
         */</comment>
        <expr_stmt><expr><call><name>check_new_partition_bound</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the default partition exists, its partition constraints will
		 * change after the addition of this new partition such that it won't
		 * allow any row that qualifies for this new partition. So, check that
		 * the existing data in the default partition satisfies the constraint
		 * as it will exist after adding this partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_default_allows_bound</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>defaultRel</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Keep the lock until commit. */</comment>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>defaultRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/* Update the pg_class entry. */</comment>
        <expr_stmt><expr><call><name>StorePartitionBound</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the default partition oid */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bound</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>update_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * The code that follows may also update the pg_class tuple to update
         * relnumchecks, so bump up the command counter to avoid the "already
         * updated by self" error.
         */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* set interval partition's child as partition table in pg_class tuple */</comment>
    if (stmt-&gt;interval_child)
    {
        Relation    parent;

        parent = heap_open(stmt-&gt;interval_parentId, AccessShareLock);

        if (parent-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)
            ereport(ERROR,
                    (errcode(ERRCODE_INVALID_OBJECT_DEFINITION),
                     errmsg("\"%s\" is not interval partition parent.",
                            RelationGetRelationName(parent))));

        <comment type="block">/* Update the pg_class entry. */</comment>
        StorePartitionBound(rel, parent, NULL);

        heap_close(parent, AccessShareLock);

        <comment type="block">/*
         * The code that follows may also update the pg_class tuple to update
         * relnumchecks, so bump up the command counter to avoid the "already
         * updated by self" error.
         */</comment>
        CommandCounterIncrement();
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Process the partitioning specification (if any) and store the partition
     * key information into the catalog.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitioned</name></expr>)</condition>
    <block>{<block_content>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>strategy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>partnatts</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name><name>partattrs</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name><name>partopclass</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name><name>partcollation</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>partexprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>partnatts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Protect fixed-size arrays here and in executor */</comment>
        <if_stmt><if>if <condition>(<expr><name>partnatts</name> <operator>&gt;</operator> <name>PARTITION_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot partition using more than %d columns"</literal></expr></argument>,
                            <argument><expr><name>PARTITION_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We need to transform the raw parsetrees corresponding to partition
         * expressions into executable expression trees.  Like column defaults
         * and CHECK constraints, we could not have done the transformation
         * earlier.
         */</comment>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>=</operator> <call><name>transformPartitionSpec</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/*
          * For interval partition, and store all information
          * into catalog pg_partition_interval.
                 */</comment>
        <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_INTERVAL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//StoreIntervalPartition(rel, strategy);</comment>

            <expr_stmt><expr><call><name>AddRelationPartitionInfo</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>ComputePartitionAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>,
                              <argument><expr><name>partattrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partexprs</name></expr></argument>, <argument><expr><name>partopclass</name></expr></argument>,
							  <argument><expr><name>partcollation</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>StorePartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partattrs</name></expr></argument>, <argument><expr><name>partexprs</name></expr></argument>,
                          <argument><expr><name>partopclass</name></expr></argument>, <argument><expr><name>partcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make it all visible */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
	* If we're creating a partition, create now all the indexes defined in
	* the parent.  We can't do it earlier, because DefineIndex wants to know
	* the partition key which we just stored.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
	   <decl_stmt><decl><type><name>Oid</name></type>         <name>parentId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	   <decl_stmt><decl><type><name>Relation</name></type>    <name>parent</name></decl>;</decl_stmt>
	   <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>idxlist</name></decl>;</decl_stmt>
	   <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	   <comment type="block">/* Already have strong enough lock on the parent */</comment>
	   <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <expr_stmt><expr><name>idxlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	   <comment type="block">/*
	    * For each index in the parent table, create one in the partition
	    */</comment>
	   <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxlist</argument>)</argument_list></macro>
	   <block>{<block_content>
	       <decl_stmt><decl><type><name>Relation</name></type>    <name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	       <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
	       <decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

	       <expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
	                                           <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
	                                           <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	       <expr_stmt><expr><name>idxstmt</name> <operator>=</operator>
	           <call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idxRel</name></expr></argument>,
										<argument><expr><name>attmap</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	       <expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
	                   <argument><expr><name>idxstmt</name></expr></argument>,
	                   <argument><expr><name>InvalidOid</name></expr></argument>,
	                   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>constraintOid</name></expr></argument>,
	                   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	       <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   </block_content>}</block>

	   <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>idxlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
     * Now add any newly specified column default values and CHECK constraints
     * to the new relation.  These are passed to us in the form of raw
     * parsetrees; we need to transform them to executable expression trees
     * before they can be added. The most convenient way to do that is to
     * apply the parser's transformExpr routine, but transformExpr doesn't
     * work unless we have a pre-existing relation. So, the transformation has
     * to be postponed to this final step of CREATE TABLE.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>rawDefaults</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rawDefaults</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
                                  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clean up.  We keep lock on new relation (although it shouldn't be
     * visible to anyone else anyway, until commit).
     */</comment>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the right error or warning message for a "DROP" command issued on a
 * non-existent relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropErrorMsgNonExistent</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>rightkind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>rentry</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist, skipping"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>rentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>rentry</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>rightkind</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nonexistent_code</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nonexistent_msg</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>skipping_msg</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* Should be impossible */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the right error message for a "DROP" command issued on a
 * relation of the wrong type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropErrorMsgWrongType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>wrongkind</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>rightkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>rentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>wentry</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>rentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>rentry</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>rightkind</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>wentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>wentry</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>wrongkind</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
    <comment type="block">/* wrongkind could be something we don't have in our table... */</comment>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nota_msg</name></name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
             <ternary><condition><expr><operator>(</operator><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>wentry</name><operator>-&gt;</operator><name>drophint_msg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>

<comment type="block">/*
 * remove relname in query string (replace with ' ')
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveRelnameInQueryString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpStr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start_ptr</name> <init>= <expr><name>queryString</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end_ptr</name> <init>= <expr><name>queryString</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>full_name</name><index>[<expr><name>MAXFULLNAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* get remove obj full name */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>full_name</name></expr></argument>, <argument><expr><name>MAXFULLNAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>catalogname</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>catalogname</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                                                            <argument><expr><ternary><condition><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>catalogname</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                                                            <argument><expr><ternary><condition><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                                                             <argument><expr><ternary><condition><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                                                             <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* is not independent string, skip */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">','</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>!=</operator> <literal type="char">';'</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\"'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>==</operator> <literal type="char">'\"'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
                        <operator>(</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;</operator> <name>start_ptr</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* replace obj name with ' ' */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* find the previous ',' */</comment>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>tmp</name> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tmp</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&gt;=</operator> <name>start_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* find the following ',' */</comment>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>tmp</name> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>tmp</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&lt;=</operator> <name>end_ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>char</name></type> <name>GetRemoveObjectRelkind</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>removeType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>relkind</name></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>removeType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_MATVIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized drop object type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>removeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>relkind</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PreCheckforRemoveRelation
 * Check before implementing DROP TABLE, DROP INDEX, DROP SEQUENCE,
 * DROP VIEW, DROP FOREIGN TABLE, DROP MATERIALIZED VIEW, return the
 * object of existing relations.
 */</comment>
<function><type><name>ObjectAddresses</name><modifier>*</modifier></type> <name>PreCheckforRemoveRelation</name><parameter_list>(<parameter><decl><type><name>DropStmt</name><modifier>*</modifier></type> <name>drop</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>queryString</name></decl></parameter>,
											<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>needDrop</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>heap_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>querystring_omit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name><modifier>*</modifier></type> <name>objects</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* DROP CONCURRENTLY uses a weaker lock, and has some restrictions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support dropping multiple objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support CASCADE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First we identify all the relations, then we delete them in a single
	 * performMultipleDeletions() call.  This is to avoid unwanted DROP
	 * RESTRICT errors if one of the relations depends on another.
	 */</comment>

	<comment type="block">/* Determine required relkind */</comment>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>GetRemoveObjectRelkind</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>needDrop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>drop-&gt;objects</argument>)</argument_list></macro> 
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * These next few steps are a great deal like relation_openrv, but we
		 * don't bother building a relcache entry since we don't need it.
		 *
		 * Check for shared-cache-inval messages before trying to access the
		 * relation.  This is needed to cover the case where the name
		 * identifies a rel that has been dropped and recreated since the
		 * start of our transaction: if we don't flush the old syscache entry,
		 * then we'll latch onto that entry and suffer an error later.
		 */</comment>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Look up the appropriate relation using namespace search. */</comment>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>partParentOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>concurrent</name></name> <operator>=</operator> <name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>RangeVarCallbackForDropRelation</name></expr></argument>,
											<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Not there? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DropErrorMsgNonExistent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name><name>drop</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>querystring_omit</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>OmitqueryStringSpace</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>querystring_omit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RemoveRelnameInQueryString</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK, we're ready to delete this one */</comment>
        <expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>needDrop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition> 
		<block>{<block_content>
			<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>heapLockMode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>heapLockMode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heapLockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>heap_list</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><operator>*</operator><name>heap_list</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
	<return>return <expr><name>objects</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * RemoveRelations
 *        Implements DROP TABLE, DROP INDEX, DROP SEQUENCE, DROP VIEW,
 *        DROP MATERIALIZED VIEW, DROP FOREIGN TABLE
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type>
<name>RemoveRelations</name><argument_list>(<argument><expr><name>DropStmt</name> <operator>*</operator><name>drop</name></expr></argument>, <argument><expr><name>char</name><operator>*</operator> <name>queryString</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>void</name>
<name>RemoveRelations</name><argument_list>(<argument><expr><name>DropStmt</name> <operator>*</operator><name>drop</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>querystring_omit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>drop_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* DROP CONCURRENTLY uses a weaker lock, and has some restrictions */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support dropping multiple objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support CASCADE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * First we identify all the relations, then we delete them in a single
     * performMultipleDeletions() call.  This is to avoid unwanted DROP
     * RESTRICT errors if one of the relations depends on another.
     */</comment>

    <comment type="block">/* Determine required relkind */</comment>
    <switch>switch <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_SEQUENCE</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_VIEW</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_MATVIEW</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized drop object type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Lock and validate each relation; build a list of object addresses */</comment>
    <expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>drop-&gt;objects</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>Relation</name></type> <name>child_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * These next few steps are a great deal like relation_openrv, but we
         * don't bother building a relcache entry since we don't need it.
         *
         * Check for shared-cache-inval messages before trying to access the
         * relation.  This is needed to cover the case where the name
         * identifies a rel that has been dropped and recreated since the
         * start of our transaction: if we don't flush the old syscache entry,
         * then we'll latch onto that entry and suffer an error later.
         */</comment>
        <expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Look up the appropriate relation using namespace search. */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>partParentOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>concurrent</name></name> <operator>=</operator> <name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><name>RangeVarCallbackForDropRelation</name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Not there? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>missing_ok</name> <init>= <expr><name><name>drop</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>is_txn_has_parallel_ddl</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>missing_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>DropErrorMsgNonExistent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>querystring_omit</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>OmitqueryStringSpace</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>querystring_omit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RemoveRelnameInQueryString</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* could not drop child interval partition or its index */</comment>
        <if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name>relkind</name></expr>)</condition><comment type="line">// ||</comment>
            <comment type="line">//RELKIND_INDEX == relkind)</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>report_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"drop table relOid: %u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name>relkind</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">//child_rel = index_open(relOid, NoLock);</comment>
            </block_content>}</block></else></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>report_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name>relkind</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">//index_close(child_rel, NoLock);</comment>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>report_error</name></expr>)</condition>
            <block>{<block_content>
				<comment type="line">//elog(ERROR, "Drop child interval partition or its index is not permitted");</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* OK, we're ready to delete this one */</comment>
        <expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>drop_cnt</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>

    <expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <return>return <expr><name>drop_cnt</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Before acquiring a table lock, check whether we have sufficient rights.
 * In the case of DROP INDEX, also try to lock the table before the index.
 * Also, if the table to be dropped is a partition, we try to lock the parent
 * first.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForDropRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>,
                                <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>expected_relkind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_partition</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>heap_lockmode</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>DropRelationCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>heap_lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then>
        <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * If we previously locked some other index's heap, and the name we're
     * looking up no longer refers to that relation, release the now-useless
     * lock.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/*
		 * Unlock index before unlock table, or may cause deadlock
		 * when drop index and create same index executed concurrently.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_txn_has_parallel_ddl</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldRelOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>oldRelOid</name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Unlock index(name:oid):(%s:%u) before unlock table"</literal></expr></argument>,
					<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>oldRelOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Similarly, if we previously locked some other partition's heap, and the
     * name we're looking up no longer refers to that relation, release the
     * now-useless lock.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Didn't find a relation, so no need for locking or permission checks. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>is_txn_has_parallel_ddl</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Can't get valid tuple, relation %s had been invalid"</literal>
				<literal type="string">"by other process in parallel ddl mode"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return;</return>                    <comment type="block">/* concurrently dropped, so nothing to do */</comment>
	</block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>is_partition</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relispartition</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Both RELKIND_RELATION and RELKIND_PARTITIONED_TABLE are OBJECT_TABLE,
     * but RemoveRelations() can only pass one relkind for a given relation.
     * It chooses RELKIND_RELATION for both regular and partitioned tables.
     * That means we must be careful before giving the wrong type error when
	 * the relation is RELKIND_PARTITIONED_TABLE.  An equivalent problem
	 * exists with indexes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>expected_relkind</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DropErrorMsgWrongType</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Allow DROP to either table owner or schema owner */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>pg_namespace_ownercheck</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                       <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * In DROP INDEX, attempt to acquire lock on the parent table before
     * locking the index.  index_drop() will need this anyway, and since
     * regular queries lock tables before their indexes, we risk deadlock if
     * we do it the other way around.  No error if we don't find a pg_index
     * entry, though --- the relation may have been dropped.
     */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>relOid</name> <operator>!=</operator> <name>oldRelOid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_txn_has_parallel_ddl</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Can't get valid tableoid, index %s had been invalid"</literal>
					<literal type="string">"by other process in parallel ddl mode"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Similarly, if the relation is a partition, we must acquire lock on its
     * parent before locking the partition.  That's because queries lock the
     * parent before its partitions, so we risk deadlock it we do it the other
     * way around.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator> <name>relOid</name> <operator>!=</operator> <name>oldRelOid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecuteTruncate
 *        Executes a TRUNCATE command.
 *
 * This is a multi-relation truncate.  We first open and grab exclusive
 * lock on all relations involved, checking permissions and otherwise
 * verifying that the relation is OK for truncation.  In CASCADE mode,
 * relations having FK references to the targeted relations are automatically
 * added to the group; in RESTRICT mode, we check that all FK references are
 * internal to the group that's being truncated.  Finally all the relations
 * are truncated and reindexed.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteTruncate</name><parameter_list>(<parameter><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>seq_relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>restart_seqs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC does not support RESTART IDENTITY yet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not supported currently"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Open, exclusive-lock, and check all the explicitly-specified relations
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;relations</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>recurse</name> <init>= <expr><name><name>rv</name><operator>-&gt;</operator><name>inh</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>myrelid</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* for interval partition, locate which partition need to be truncated */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>rv</name><operator>-&gt;</operator><name>intervalparent</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rv</name><operator>-&gt;</operator><name>partitionvalue</name><operator>-&gt;</operator><name>isdefault</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AttrNumber</name></type>  <name>partkey</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Const</name>        <modifier>*</modifier></type><name>partvalue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>         <name>partidx</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>partname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>        <modifier>*</modifier></type><name>partvalue_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ParseState</name>     <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
            <expr_stmt><expr><name>partvalue_node</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>rv</name><operator>-&gt;</operator><name>partitionvalue</name><operator>-&gt;</operator><name>router_src</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_INSERT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>partvalue_node</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>partvalue_node</name></expr></argument>,<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>partvalue_node</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>partvalue_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><name>partvalue_node</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>partvalue_node</name></expr></argument>,<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"the value for locating a partition MUST be constants"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
    
            <expr_stmt><expr><name>partvalue</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>partvalue_node</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>partkey</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %s is not a interval partitioned table"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attrs</name><index>[<expr><name>partkey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name><name>partvalue</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"data type of value for locating a partition does not match partition key of relation."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>partidx</name> <operator>=</operator> <call><name>RelationGetPartitionIdxByValue</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>partvalue</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>partidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the value for locating a partition is out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <block>{<block_content>
                <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if <condition>(<expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Day</name> <operator>&amp;&amp;</operator>
                    <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>start_time</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>fsec_t</name></type> <name>start_sec</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>current_time</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>fsec_t</name></type> <name>current_sec</name></decl>;</decl_stmt>

                    <comment type="block">/* timestamp convert to posix struct */</comment>
                    <if_stmt><if>if<condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_sec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    
                    <if_stmt><if>if<condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name><name>partvalue</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_sec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>current_time</name><operator>.</operator><name>tm_year</name></name> <operator>==</operator> <name><name>start_time</name><operator>.</operator><name>tm_year</name></name> <operator>&amp;&amp;</operator> <name><name>current_time</name><operator>.</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">12</literal> <operator>&amp;&amp;</operator> <name><name>current_time</name><operator>.</operator><name>tm_mday</name></name> <operator>==</operator> <literal type="number">31</literal><operator>)</operator> <operator>||</operator>
                        <operator>(</operator><name><name>current_time</name><operator>.</operator><name>tm_year</name></name> <operator>==</operator> <name><name>start_time</name><operator>.</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>current_time</name><operator>.</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>current_time</name><operator>.</operator><name>tm_mday</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not truncate this partition, use delete instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <expr_stmt><expr><name>partname</name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partidx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>partname</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rv</name><operator>-&gt;</operator><name>intervalparent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rv</name><operator>-&gt;</operator><name>partitionvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* could not truncate interval partitioned parent table directly */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rv</name><operator>-&gt;</operator><name>intervalparent</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trancate a partitioned table is forbidden, trancate a partition is allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>myrelid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* don't throw error for "TRUNCATE foo, foo" */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/* find_all_inheritors already got lock */</comment>
                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate only a partitioned table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword, or use truncate only on the partitions directly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * In CASCADE mode, suck in all referencing relations as well.  This
     * requires multiple iterations to find indirectly-dependent relations. At
     * each phase, we need to exclusive-lock new rels before looking for their
     * dependencies, else we might miss something.  Also, we check each rel as
     * soon as we open it, to avoid a faux pas such as holding lock for a long
     * time on a rel we have no permissions for.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newrelids</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>newrelids</name> <operator>=</operator> <call><name>heap_truncate_find_FKs</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>newrelids</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>            <comment type="block">/* nothing else to add */</comment>

            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>newrelids</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"truncate cascades to table \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check foreign key references.  In CASCADE mode, this should be
     * unnecessary since we just pulled in all the references; but as a
     * cross-check, do it anyway if in an Assert-enabled build.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
    <expr_stmt><expr><call><name>heap_truncate_check_FKs</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_RESTRICT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_truncate_check_FKs</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we are asked to restart sequences, find all the sequences, lock them
     * (we need AccessExclusiveLock for ResetSequence), and check permissions.
     * We want to do this early since it's pointless to do all the truncation
     * work only to fail on sequence permissions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>restart_seqs</name></name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>seqlist</name> <init>= <expr><call><name>getOwnedSequences</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>seqcell</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>seqcell</argument>, <argument>seqlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>seq_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>seqcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Relation</name></type>    <name>seq_rel</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>seq_rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* This check must match AlterSequence! */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                                   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>seq_relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>seq_relids</name></expr></argument>, <argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Prepare to catch AFTER triggers. */</comment>
    <expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * To fire triggers, we'll need an EState as well as a ResultRelInfo for
     * each relation.  We don't need to call ExecOpenIndices, though.
     */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
                          <argument><expr><name>rel</name></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>,    <comment type="block">/* dummy rangetable index */</comment>
                          <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Process all BEFORE STATEMENT TRUNCATE triggers before we begin
     * truncating (this is because one of them might throw an error). Also, if
     * we were to allow them to prevent statement execution, that would need
     * to be handled here.
     */</comment>
    <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecBSTruncateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * OK, truncate each table.
     */</comment>
    <expr_stmt><expr><name>mySubid</name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip partitioned tables as there is nothing to do */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Normally, we need a transaction-safe truncation here.  However, if
         * the table was either created in the current (sub)transaction or has
         * a new relfilenode in the current (sub)transaction, then we can just
         * truncate it in-place, because a rollback would cause the whole
         * table or the current physical file to be thrown away anyway.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>==</operator> <name>mySubid</name> <operator>||</operator>
            <name><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Immediate, non-rollbackable truncation is OK */</comment>
            <expr_stmt><expr><call><name>heap_truncate_one_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>heap_relid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>toast_relid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>MultiXactId</name></type> <name>minmulti</name></decl>;</decl_stmt>

            <comment type="block">/*
             * This effectively deletes all rows in the table, and may be done
             * in a serializable transaction.  In that case we must record a
             * rw-conflict in to this transaction from each transaction
             * holding a predicate lock on the table.
             */</comment>
            <expr_stmt><expr><call><name>CheckTableForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>minmulti</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Need the full transaction-safe pushups.
             *
             * Create a new empty storage file for the relation, and assign it
             * as the relfilenode value. The old storage file is scheduled for
             * deletion at commit.
             */</comment>
            <expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
                                      <argument><expr><name>RecentXmin</name></expr></argument>, <argument><expr><name>minmulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>heap_create_init_fork</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>heap_relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * The same for the toast table, if any.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
                                          <argument><expr><name>RecentXmin</name></expr></argument>, <argument><expr><name>minmulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>heap_create_init_fork</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Reconstruct the indexes to match, and we're done.
             */</comment>
            <expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>heap_relid</name></expr></argument>, <argument><expr><name>REINDEX_REL_PROCESS_TOAST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>pgstat_count_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Restart owned sequences if we were asked to.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>seq_relids</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>seq_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ResetSequence</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Process all AFTER STATEMENT TRUNCATE triggers.
     */</comment>
    <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecASTruncateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Handle queued AFTER triggers */</comment>
    <expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We can clean up the EState now */</comment>
    <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And close the rels (can't do this while EState still holds refs) */</comment>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Check that a given rel is safe to truncate.  Subroutine for ExecuteTruncate
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>truncate_check_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Only allow truncate on regular tables and partitioned tables (although,
     * the latter are only being included here for the following checks; no
     * physical truncation will occur in their case.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Permissions checks */</comment>
    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
                                  <argument><expr><name>ACL_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                       <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Don't allow truncate on temp tables of other backends ... their local
     * buffer manager is not going to cope.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Also check for active uses of the relation in the current transaction,
     * including open scans and pending AFTER trigger events.
     */</comment>
    <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * storage_name
 *      returns the name corresponding to a typstorage/attstorage enum value
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>storage_name</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'p'</literal></expr>:</case>
            <return>return <expr><literal type="string">"PLAIN"</literal></expr>;</return>
        <case>case <expr><literal type="char">'m'</literal></expr>:</case>
            <return>return <expr><literal type="string">"MAIN"</literal></expr>;</return>
        <case>case <expr><literal type="char">'x'</literal></expr>:</case>
            <return>return <expr><literal type="string">"EXTENDED"</literal></expr>;</return>
        <case>case <expr><literal type="char">'e'</literal></expr>:</case>
            <return>return <expr><literal type="string">"EXTERNAL"</literal></expr>;</return>
        <default>default:</default>
            <return>return <expr><literal type="string">"???"</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*----------
 * MergeAttributes
 *        Returns new schema given initial schema and superclasses.
 *
 * Input arguments:
 * 'schema' is the column/attribute definition for the table. (It's a list
 *        of ColumnDef's.) It is destructively changed.
 * 'supers' is a list of OIDs of parent relations, already locked by caller.
 * 'relpersistence' is a persistence type of the table.
 * 'is_partition' tells if the table is a partition
 *
 * Output arguments:
 * 'supconstr' receives a list of constraints belonging to the parents,
 *        updated as necessary to be valid for the child.
 * 'supOidCount' is set to the number of parents that have OID columns.
 *
 * Return value:
 * Completed schema list.
 *
 * Notes:
 *      The order in which the attributes are inherited is very important.
 *      Intuitively, the inherited attributes should come first. If a table
 *      inherits from multiple parents, the order of those attributes are
 *      according to the order of the parents specified in CREATE TABLE.
 *
 *      Here's an example:
 *
 *        create table person (name text, age int4, location point);
 *        create table emp (salary int4, manager text) inherits(person);
 *        create table student (gpa float8) inherits (person);
 *        create table stud_emp (percent int4) inherits (emp, student);
 *
 *      The order of the attributes of stud_emp is:
 *
 *                            person {1:name, 2:age, 3:location}
 *                            /     \
 *               {6:gpa}    student   emp {4:salary, 5:manager}
 *                            \     /
 *                           stud_emp {7:percent}
 *
 *       If the same attribute name appears multiple times, then it appears
 *       in the result table in the proper location for its first appearance.
 *
 *       Constraints (including NOT NULL constraints) for the child table
 *       are the union of all relevant constraints, from both the child schema
 *       and parent tables.
 *
 *       The default value for a child column is defined as:
 *        (1) If the child schema specifies a default, that value is used.
 *        (2) If neither the child nor any parent specifies a default, then
 *            the column will not have a default.
 *        (3) If conflicting defaults are inherited from different parents
 *            (and not overridden by the child), an error is raised.
 *        (4) Otherwise the inherited default is used.
 *        Rule (3) is new in Postgres 7.1; in earlier releases you got a
 *        rather arbitrary choice of which parent default to use.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>MergeAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_partition</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supconstr</name></decl></parameter>,
                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>supOidCount</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>inhSchema</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>constraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>parentsWithOids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_bogus_defaults</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>child_attno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>Node</name></type> <name>bogus_marker</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* marks conflicting defaults */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>saved_schema</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>       <name>need_dropped_column</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator> <name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>need_dropped_column</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Check for and reject tables with too many columns. We perform this
     * check relatively early for two reasons: (a) we don't run the risk of
     * overflowing an AttrNumber in subsequent code (b) an O(n^2) algorithm is
     * okay if we're processing &lt;= 1600 columns, but could take minutes to
     * execute if the user attempts to create a table with hundreds of
     * thousands of columns.
     *
     * Note that we also need to check that we do not exceed this figure after
     * including columns from inherited relations.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
                        <argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * In case of a partition, there are no new column definitions, only dummy
     * ColumnDefs created for column constraints.  We merge them with the
     * constraints inherited from the parent.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_partition</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>saved_schema</name> <operator>=</operator> <name>schema</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>schema</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check for duplicate names in the explicit list of attributes.
     *
     * Although we might consider merging such entries in the same way that we
     * handle name conflicts for inherited attributes, it seems to make more
     * sense to assume such conflicts are errors.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rest</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>entry</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

            <comment type="block">/*
             * Typed table column option that does not belong to a column from
             * the type.  This works because the columns from the type come
             * first in the list.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <while>while <condition>(<expr><name>rest</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>restdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* need to save it in case we
                                             * delete it */</comment>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_type</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * merge the column options into the column from the type
                     */</comment>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>constraints</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
                                    <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>rest</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rest</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block>

    <comment type="block">/*
     * Scan the parents left-to-right, and merge their attributes to form a
     * list of inherited attributes (inhSchema).  Also check to see if we need
     * to inherit an OID column.
     */</comment>
    <expr_stmt><expr><name>child_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>supers</argument>)</argument_list></macro>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>         <name>parent</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>newattno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>parent_attno</name></decl>;</decl_stmt>

		<comment type="block">/* caller already got lock */</comment>
        <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We do not allow partitioned tables and partitions to participate in
         * regular inheritance.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partitioned table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partition \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
            <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
            <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
							 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Permanent rels cannot inherit from temporary ones */</comment>
        <if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
            <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name>is_partition</name></expr>
                            ?</condition><then> <expr><literal type="string">"cannot inherit from temporary relation \"%s\""</literal></expr>
                            </then><else>: <expr><literal type="string">"cannot create a permanent relation as partition of temporary relation \"%s\""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* If existing rel is temp, it must belong to this session */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name>is_partition</name></expr>
                            ?</condition><then> <expr><literal type="string">"cannot inherit from temporary relation of another session"</literal></expr>
                            </then><else>: <expr><literal type="string">"cannot create as partition of temporary relation of another session"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We should have an UNDER permission flag for this, but for now,
         * demand that creator of a child table own the parent.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>parentsWithOids</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>constr</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * newattno[] will contain the child-table attribute numbers for the
         * attributes of this parent table.  (They are not the same for
         * parents after the first one, nor if we have dropped columns.)
         */</comment>
        <expr_stmt><expr><name>newattno</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
             <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>exist_attno</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Ignore dropped columns in the parent.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>need_dropped_column</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
                    
                    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>supers</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"partition child has more than one parent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
                                                        <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_parent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                    <expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>attribute</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_dropped</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inhSchema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* leave newattno entry as zero */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*
             * Does it conflict with some previously inherited column?
             */</comment>
            <expr_stmt><expr><name>exist_attno</name> <operator>=</operator> <call><name>findAttrByName</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name>inhSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>defTypeId</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>        <name>deftypmod</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>defCollId</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Yes, try to merge the two column definitions. They must
                 * have the same type, typmod, and collation.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging multiple inherited definitions of column \"%s\""</literal></expr></argument>,
                                <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>def</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>exist_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>defTypeId</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
                    <name>deftypmod</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a type conflict"</literal></expr></argument>,
                                    <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                                       <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>defTypeId</name></expr></argument>,
                                                                <argument><expr><name>deftypmod</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
                                                                <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>defCollId</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>defTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>defCollId</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a collation conflict"</literal></expr></argument>,
                                    <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
                                       <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>defCollId</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Copy storage parameter */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a storage parameter conflict"</literal></expr></argument>,
                                    <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                                       <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name><operator>++</operator></expr>;</expr_stmt>
                <comment type="block">/* Merge of NOT NULL constraints = OR 'em together */</comment>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
                <comment type="block">/* Default and other constraints are handled below */</comment>
                <expr_stmt><expr><name><name>newattno</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>exist_attno</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * No, create a new inherited column
                 */</comment>
                <expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
                                                    <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_parent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>inhSchema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newattno</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>child_attno</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Copy default if any
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>this_default</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

                <comment type="block">/* Find default in constraint structure */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>attrdef</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>==</operator> <name>parent_attno</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>this_default</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>this_default</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If default expr could contain any vars, we'd need to fix
                 * 'em, but it can't; so default is ready to apply to child.
                 *
                 * If we already had a default from some prior parent, check
                 * to see if they are the same.  If so, no problem; if not,
                 * mark the column as having a bogus default. Below, we will
                 * complain if the bogus default isn't overridden by the child
                 * schema.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>this_default</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></argument>, <argument><expr><name>this_default</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <operator>&amp;</operator><name>bogus_marker</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>have_bogus_defaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Now copy the CHECK constraints of this parent, adjusting attnos
         * using the completed newattno[] map.  Identically named constraints
         * are merged if possible, else we throw error.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>found_whole_row</name></decl>;</decl_stmt>

                <comment type="block">/* ignore if the constraint is non-inheritable */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/* Adjust Vars to match new table's column numbering */</comment>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                           <argument><expr><name>newattno</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
                                           <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * For the moment we have to reject whole-row variables. We
                 * could convert them, if we knew the new table's rowtype OID,
                 * but that hasn't been assigned yet.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Constraint \"%s\" contains a whole-row reference to table \"%s\"."</literal></expr></argument>,
                                       <argument><expr><name>name</name></expr></argument>,
                                       <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* check for duplicate */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MergeCheckConstraint</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* nope, this is a new one */</comment>
                    <decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_CHECK</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    <comment type="block">/* until created */</comment>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not used for constraints */</comment>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>constraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Close the parent rel, but keep our lock on it until xact commit.
         * That will prevent someone else from deleting or ALTERing the parent
         * before the child is committed.
         */</comment>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If we had no inherited attributes, the result schema is just the
     * explicitly declared columns.  Otherwise, we need to merge the declared
     * columns into the inherited schema list.  Although, we never have any
     * explicitly declared columns if the table is a partition.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>inhSchema</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>schema_attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>newdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><name><name>newdef</name><operator>-&gt;</operator><name>colname</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>exist_attno</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>schema_attno</name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/*
             * Does it conflict with some previously inherited column?
             */</comment>
            <expr_stmt><expr><name>exist_attno</name> <operator>=</operator> <call><name>findAttrByName</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name>inhSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>defTypeId</name></decl>,
                            <decl><type ref="prev"/><name>newTypeId</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>        <name>deftypmod</name></decl>,
                            <decl><type ref="prev"/><name>newtypmod</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>defcollid</name></decl>,
                            <decl><type ref="prev"/><name>newcollid</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Partitions have only one parent and have no column
                 * definitions of their own, so conflict should never occur.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Yes, try to merge the two column definitions. They must
                 * have the same type, typmod, and collation.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>==</operator> <name>schema_attno</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging column \"%s\" with inherited definition"</literal></expr></argument>,
                                    <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving and merging column \"%s\" with inherited definition"</literal></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User-specified column moved to the position of the inherited column."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name>def</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>exist_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>newdef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>defTypeId</name> <operator>!=</operator> <name>newTypeId</name> <operator>||</operator> <name>deftypmod</name> <operator>!=</operator> <name>newtypmod</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a type conflict"</literal></expr></argument>,
                                    <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                                       <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>defTypeId</name></expr></argument>,
                                                                <argument><expr><name>deftypmod</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>newTypeId</name></expr></argument>,
                                                                <argument><expr><name>newtypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>defcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>defTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>newcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>, <argument><expr><name>newTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>defcollid</name> <operator>!=</operator> <name>newcollid</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a collation conflict"</literal></expr></argument>,
                                    <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
                                       <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>defcollid</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>newcollid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Identity is never inherited.  The new column can have an
                 * identity definition, so we always just take that one.
                 */</comment>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>

                <comment type="block">/* Copy storage parameter */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a storage parameter conflict"</literal></expr></argument>,
                                    <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
                                       <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Mark the column as locally defined */</comment>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <comment type="block">/* Merge of NOT NULL constraints = OR 'em together */</comment>
                <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
                <comment type="block">/* If new def has a default, override previous default */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>newdef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * No, attach new column to result schema
                 */</comment>
                <expr_stmt><expr><name>inhSchema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>schema</name> <operator>=</operator> <name>inhSchema</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Check that we haven't exceeded the legal # of columns after merging
         * in inherited columns.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
                            <argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now that we have the column definition list for a partition, we can
     * check whether the columns referenced in the column constraint specs
     * actually exist.  Also, we merge the constraints into the corresponding
     * column definitions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>saved_schema</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>saved_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rest</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>entry</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Partition column option that does not belong to a column from
             * the parent.  This works because the columns from the parent
             * come first in the list (see above).
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
                                <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <while>while <condition>(<expr><name>rest</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>restdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* need to save it in case we
                                                 * delete it */</comment>

                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * merge the column options into the column from the
                     * parent
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_parent</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>constraints</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_parent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
                                        <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>rest</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rest</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we found any conflicting parent default values, check to make sure
     * they were overridden by the child.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>have_bogus_defaults</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <operator>&amp;</operator><name>bogus_marker</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" inherits conflicting default values"</literal></expr></argument>,
                                <argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To resolve the conflict, specify a default explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>supconstr</name> <operator>=</operator> <name>constraints</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>supOidCount</name> <operator>=</operator> <name>parentsWithOids</name></expr>;</expr_stmt>
    <return>return <expr><name>schema</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MergeCheckConstraint
 *        Try to merge an inherited CHECK constraint with previous ones
 *
 * If we inherit identically-named constraints from multiple parents, we must
 * merge them, or throw an error if they don't have identical definitions.
 *
 * constraints is a list of CookedConstraint structs for previous constraints.
 *
 * Returns TRUE if merged (constraint is a duplicate), or FALSE if it's
 * got a so-far-unique name, or throws error if conflict.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MergeCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraints</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>ccon</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Non-matching names never conflict */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* OK to merge */</comment>
            <expr_stmt><expr><name><name>ccon</name><operator>-&gt;</operator><name>inhcount</name></name><operator>++</operator></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint name \"%s\" appears multiple times but with different expressions"</literal></expr></argument>,
                        <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StoreCatalogInheritance
 *        Updates the system catalogs with proper inheritance information.
 *
 * supers is a list of the OIDs of the new relation's direct ancestors.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreCatalogInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>seqNumber</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/*
     * sanity checks
     */</comment>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>supers</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Store INHERITS information in pg_inherits using direct ancestors only.
     * Also enter dependencies on the direct ancestors, and make sure they are
     * marked with relhassubclass = true.
     *
     * (Once upon a time, both direct and indirect ancestors were found here
     * and then entered into pg_ipl.  Since that catalog doesn't exist
     * anymore, there's no need to look for indirect ancestors.)
     */</comment>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>seqNumber</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>supers</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>parentOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>StoreCatalogInheritance1</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>seqNumber</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
                                 <argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>seqNumber</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make catalog entries showing relationId as being an inheritance child
 * of parentOid.  inhRelation is the already-opened pg_inherits catalog.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreCatalogInheritance1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>,
                         <parameter><decl><type><name>int16</name></type> <name>seqNumber</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>inhRelation</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>childobject</name></decl>,
                <decl><type ref="prev"/><name>parentobject</name></decl>;</decl_stmt>

	<comment type="block">/* store the pg_inherits row */</comment>
    <expr_stmt><expr><call><name>StoreSingleInheritance</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>seqNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Store a dependency too
     */</comment>
    <expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>parentOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>childobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentobject</name></expr></argument>,
                       <argument><expr><call><name>child_dependency_type</name><argument_list>(<argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Post creation hook of this inheritance. Since object_access_hook
     * doesn't take multiple object identifiers, we relay oid of parent
     * relation using auxiliary_id argument.
     */</comment>
    <expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>,
                                 <argument><expr><name>relationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark the parent as having subclasses.
     */</comment>
    <expr_stmt><expr><call><name>SetRelationHasSubclass</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>StoreIntervalPartitionInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>partkind</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isindex</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_triggers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>classRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>,
                <decl><type ref="prev"/><name>parent_tupe</name></decl>,
                <decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>new_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>new_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>,
                <decl><type ref="prev"/><name><name>new_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>pg_class_desc</name></decl>;</decl_stmt>

    <comment type="block">/* Update pg_class tuple */</comment>
    <expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isindex</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
             <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <comment type="block">/* Fill in relpartbound value */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relpartkind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>partkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relpartkind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relpartkind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relparent</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relparent</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relparent</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isindex</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type> <name>reloptions_datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type> <name>replica_datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type> <name>trigger_datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>  <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pg_class_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>parent_tupe</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>parent_tupe</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
                 <argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>reloptions_datum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>parent_tupe</name></expr></argument>,
                            <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
                            <argument><expr><name>pg_class_desc</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>reloptions_datum</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>replica_datum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>parent_tupe</name></expr></argument>,
                            <argument><expr><name>Anum_pg_class_relreplident</name></expr></argument>,
                            <argument><expr><name>pg_class_desc</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relreplident</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>replica_datum</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relreplident</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relreplident</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>trigger_datum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>parent_tupe</name></expr></argument>,
                            <argument><expr><name>Anum_pg_class_relhastriggers</name></expr></argument>,
                            <argument><expr><name>pg_class_desc</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relhastriggers</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>trigger_datum</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relhastriggers</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relhastriggers</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>parent_tupe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>has_triggers</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relhastriggers</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>new_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isindex</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>parent_tupe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpartkind</name></name> <operator>=</operator> <name>partkind</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relparent</name></name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isindex</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>has_triggers</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>tgrel</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>=</operator> <name>has_triggers</name></expr>;</expr_stmt>

            <comment type="block">/* update trigger */</comment>
            <expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
                <argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Datum</name></type>        <name><name>new_tg_val</name><index>[<expr><name>Natts_pg_trigger</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name><name>new_tg_null</name><index>[<expr><name>Natts_pg_trigger</name></expr>]</index></name></decl>,
                            <decl><type ref="prev"/><name><name>new_tg_repl</name><index>[<expr><name>Natts_pg_trigger</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>         <name>trigoid</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
                              <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
                
                <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tg_tuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>trigoid</name> <operator>=</operator> <call><name>GetNewOid</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_tg_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_tg_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_tg_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_tg_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_tg_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_tg_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>new_tg_val</name><index>[<expr><name>Anum_pg_trigger_tgrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>new_tg_null</name><index>[<expr><name>Anum_pg_trigger_tgrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>new_tg_repl</name><index>[<expr><name>Anum_pg_trigger_tgrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tg_tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>new_tg_val</name></expr></argument>, <argument><expr><name>new_tg_null</name></expr></argument>, <argument><expr><name>new_tg_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tg_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TriggerRelationId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>trigoid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isindex</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * store dependency between interval partition parent and child
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreIntervalPartitionDependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>childobject</name></decl>,
                <decl><type ref="prev"/><name>parentobject</name></decl>;</decl_stmt>
    <comment type="block">/*
     * Store a dependency too
     */</comment>
    <expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>parentOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>childobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Look for an existing schema entry with the given name.
 *
 * Returns the index (starting with 1) if attribute already exists in schema,
 * 0 if it doesn't.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findAttrByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>s</argument>, <argument>schema</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetRelationHasSubclass
 *        Set the value of the relation's relhassubclass field in pg_class.
 *
 * NOTE: caller must be holding an appropriate lock on the relation.
 * ShareUpdateExclusiveLock is sufficient.
 *
 * NOTE: an important side-effect of this operation is that an SI invalidation
 * message is sent out to all backends --- including me --- causing plans
 * referencing the relation to be rebuilt with the new list of children.
 * This must happen even if we find that no change is needed in the pg_class
 * row.
 */</comment>
<function><type><name>void</name></type>
<name>SetRelationHasSubclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>relhassubclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relationRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classtuple</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Fetch a modifiable copy of the tuple, modify it, update pg_class.
     */</comment>
    <expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>classtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>!=</operator> <name>relhassubclass</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>classtuple</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>=</operator> <name>relhassubclass</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* no need to change tuple, but force relcache rebuild anyway */</comment>
        <expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        renameatt_check            - basic sanity checks before attribute rename
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>renameatt_check</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name> <init>= <expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename column of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Renaming the columns of sequences or toast tables doesn't actually
     * break anything from the system's point of view, since internal
     * references are by attnum.  But it doesn't seem right to allow users to
     * change names that are hardcoded into the system, hence the following
     * restriction.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, composite type, index, or foreign table"</literal></expr></argument>,
                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/*
     * permissions checking.  only the owner of a class can change its schema.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><operator>!</operator><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                       <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        renameatt_internal        - workhorse for renameatt
 *
 * Return value is the attribute number in the 'myrelid' relation.
 */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name></type>
<name>renameatt_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldattname</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newattname</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
                   <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>expected_parents</name></decl></parameter>,
                   <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                   ,<parameter><decl><type><name>bool</name></type> <name>need_check_mls_permission</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>targetrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>atttup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Grab an exclusive lock on the target table, which we will NOT release
     * until end of transaction.
     */</comment>
    <expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * if the 'recurse' flag is set then we are supposed to rename this
     * attribute in all classes that inherit from 'relname' (as well as in
     * 'relname').
     *
     * any permissions or problems with duplicate attributes will cause the
     * whole transaction to abort, which is what we want -- all or nothing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>child_oids</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>child_numparents</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

        <comment type="block">/*
         * we need the number of parents for each child so that the recursive
         * calls to renameatt() can determine whether there are any parents
         * outside the inheritance hierarchy being processed.
         */</comment>
        <expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>child_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * find_all_inheritors does the recursive search of the inheritance
         * hierarchy, so all we have to do is process all of the relids in the
         * list that it returns.
         */</comment>
        <macro><name>forboth</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>, <argument>li</argument>, <argument>child_numparents</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>numparents</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>myrelid</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <comment type="block">/* note we need not recurse again */</comment>
            <expr_stmt><expr><call><name>renameatt_internal</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>numparents</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            ,<argument><expr><name>false</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If we are told not to recurse, there had better not be any child
         * tables; else the rename would put them out of step.
         *
         * expected_parents will only be 0 if we are not already recursing.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>expected_parents</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" must be renamed in child tables too"</literal></expr></argument>,
                            <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* rename attributes in typed tables of composite type */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>child_oids</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_typed_table_dependencies</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
                                                   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>)</argument_list></macro>
            <expr_stmt><expr><call><name>renameatt_internal</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>behavior</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                              ,<argument><expr><name>false</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>atttup</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>need_check_mls_permission</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_column_permission</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not rename column:%s, cause column has mls poilcy bound"</literal></expr></argument>, 
                        <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * if the attribute is inherited, forbid the renaming.  if this is a
     * top-level call to renameatt(), then expected_parents will be 0, so the
     * effect of this code will be to prohibit the renaming if the attribute
     * is inherited at all.  if this is a recursive call to renameatt(),
     * expected_parents will be the number of parents the current relation has
     * within the inheritance hierarchy being processed, so we'll prohibit the
     * renaming only if there are additional parents from elsewhere.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <name>expected_parents</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename inherited column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* new name should not already exist */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>check_for_column_name_collision</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* apply the update */</comment>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attform</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* close rel but keep lock */</comment>

    <return>return <expr><name>attnum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform permissions and integrity checks before acquiring a relation lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForRenameAttribute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
                                   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>form</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* concurrently dropped */</comment>
    <expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *        renameatt        - changes the name of an attribute in a relation
 *
 * The returned ObjectAddress is that of the renamed column.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>renameatt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* lock level taken here should match renameatt_internal */</comment>
    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                                     <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                     <argument><expr><name>RangeVarCallbackForRenameAttribute</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator>
        <call><name>renameatt_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,    <comment type="block">/* old att name */</comment>
                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,    <comment type="block">/* new att name */</comment>
                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <comment type="block">/* recursive? */</comment>
                           <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* recursing? */</comment>
                           <argument><expr><literal type="number">0</literal></expr></argument>,    <comment type="block">/* expected inhcount */</comment>
                           <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                            ,<argument><expr><name>true</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_COLUMN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>children</name> <init>= <expr><call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>attnum</name> <operator>=</operator>
                    <call><name>renameatt_internal</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>,
                               <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,    <comment type="block">/* old att name */</comment>
                               <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,    <comment type="block">/* new att name */</comment>
                               <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <comment type="block">/* recursive? */</comment>
                               <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* recursing? */</comment>
                               <argument><expr><literal type="number">0</literal></expr></argument>,    <comment type="block">/* expected inhcount */</comment>
                               <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                               ,<argument><expr><name>true</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                               )</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"rename child table's column is not permitted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * same logic as renameatt_internal
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>rename_constraint_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name></type> <name>mytypid</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldconname</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newconname</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>expected_parents</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>targetrelation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>constraintOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><operator>!</operator><name>myrelid</name> <operator>||</operator> <operator>!</operator><name>mytypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>mytypid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_domain_constraint_oid</name><argument_list>(<argument><expr><name>mytypid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * don't tell it whether we're recursing; we allow changing typed
         * tables here
         */</comment>
        <expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
             <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>myrelid</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>child_oids</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>child_numparents</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>child_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>forboth</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>, <argument>li</argument>, <argument>child_numparents</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>numparents</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>myrelid</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>rename_constraint_internal</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>expected_parents</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited constraint \"%s\" must be renamed in child tables too"</literal></expr></argument>,
                                <argument><expr><name>oldconname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&gt;</operator> <name>expected_parents</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename inherited constraint \"%s\""</literal></expr></argument>,
                            <argument><expr><name>oldconname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name>
        <operator>&amp;&amp;</operator> <operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_PRIMARY</name>
            <operator>||</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_UNIQUE</name>
            <operator>||</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_EXCLUSION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* rename the index; this renames the constraint as well */</comment>
        <expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RenameConstraintById</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>targetrelation</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* close rel but keep lock */</comment>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ObjectAddress</name></type>
<name>RenameConstraint</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_DOMCONSTRAINT</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* lock level taken here should match rename_constraint_internal */</comment>
        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                                         <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>RangeVarCallbackForRenameAttribute</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* rename constraint of interval partition is not permitted */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"rename constraint of interval partition is not permitted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <return>return
        <expr><call><name>rename_constraint_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
                                   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,
                                   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,
                                   <argument><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>&amp;&amp;</operator>
                                    <name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name><operator>)</operator></expr></argument>,    <comment type="block">/* recursive? */</comment>
                                   <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* recursing? */</comment>
                                   <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* expected inhcount */</comment> )</argument_list></call></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE/INDEX/SEQUENCE/VIEW/MATERIALIZED VIEW/FOREIGN TABLE
 * RENAME
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>RenameRelation</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Grab an exclusive lock on the target table, index, sequence, view,
     * materialized view, or foreign table, which we will NOT release until
     * end of transaction.
     *
     * Lock level used here should match RenameRelationInternal, to avoid lock
     * escalation.
     */</comment>
    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                                     <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                     <argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* rename is forbidden on interval partition */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator>
        <name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
            <operator>||</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not rename interval partition or its index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>schema_bound</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <name>found</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>schema_bound</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not rename table:%s, cause mls poilcy is bound"</literal></expr></argument>, 
                    <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* rename all childs */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nparts</name> <init>= <expr><call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type> <name>child_relid</name> <init>= <expr><call><name>RelationGetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>child_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partname</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name></type> <name><name>relname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>partname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>partname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>,
                                 <argument><expr><literal type="string">"%s_part_%d"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>child_relid</name></expr></argument>, <argument><expr><name>partname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>partname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
				<comment type="block">/*
                else
                {
                    elog(ERROR, "RenameRelation: could not get %d child's oid of interval partition %s",
                                 i, RelationGetRelationName(rel));
                }
				*/</comment>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Do the work */</comment>
    <expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *        RenameRelationInternal - change the name of a relation
 *
 *        XXX - When renaming sequences, we don't bother to modify the
 *              sequence name that is stored within the sequence itself
 *              (this would cause problems with MVCC). In the future,
 *              the sequence name should probably be removed from the
 *              sequence, AFAIK there's no need for it to be there.
 */</comment>
<function><type><name>void</name></type>
<name>RenameRelationInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newrelname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>targetrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relrelation</name></decl>;</decl_stmt>    <comment type="block">/* for RELATION relation */</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>reltup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>namespaceId</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Grab an exclusive lock on the target table, index, sequence, view,
     * materialized view, or foreign table, which we will NOT release until
     * end of transaction.
     */</comment>
    <expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find relation's pg_class tuple, and make sure newrelname isn't in use.
     */</comment>
    <expr_stmt><expr><name>relrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>newrelname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists"</literal></expr></argument>,
                        <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Update pg_class tuple with new relname.  (Scribbling on reltup is OK
     * because it's a copy...)
     */</comment>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>relform</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Also rename the associated type, if any.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RenameTypeInternal</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
                           <argument><expr><name>newrelname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Also rename the associated constraint, if any.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RenameConstraintById</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Operation with GTM can only be done with a Remote Coordinator */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name> <operator>==</operator> <name>OBJECT_SEQUENCE</name> <operator>||</operator>
         <name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newseqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We also need to rename it on the GTM */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RenameSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>newseqname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not rename sequence"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
         <expr_stmt><expr><call><name>RegisterRenameSequence</name><argument_list>(<argument><expr><name>newseqname</name></expr></argument>, <argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newseqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Close rel, but keep exclusive lock!
     */</comment>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>RenameCryptRelation</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Disallow ALTER TABLE (and similar commands) when the current backend has
 * any open reference to the target table besides the one just acquired by
 * the calling command; this implies there's an open cursor or active plan.
 * We need this check because our lock doesn't protect us against stomping
 * on our own foot, only other people's feet!
 *
 * For ALTER TABLE, the only case known to cause serious trouble is ALTER
 * COLUMN TYPE, and some changes are obviously pretty benign, so this could
 * possibly be relaxed to only error out for certain types of alterations.
 * But the use-case for allowing any of these things is not obvious, so we
 * won't work hard at it for now.
 *
 * We also reject these commands if there are any pending AFTER trigger events
 * for the rel.  This is certainly necessary for the rewriting variants of
 * ALTER TABLE, because they don't preserve tuple TIDs and so the pending
 * events would try to fetch the wrong tuples.  It might be overly cautious
 * in other cases, but again it seems better to err on the side of paranoia.
 *
 * REINDEX calls this with "rel" referencing the index to be rebuilt; here
 * we are worried about active indexscans on the index.  The trigger-event
 * check can be skipped, since we are doing no damage to the parent table.
 *
 * The statement name (eg, "ALTER TABLE") is passed for use in error messages.
 */</comment>
<function><type><name>void</name></type>
<name>CheckTableNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>expected_refcnt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>expected_refcnt</name> <operator>=</operator> <ternary><condition><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>!=</operator> <name>expected_refcnt</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: first %s is a SQL command, eg ALTER TABLE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s \"%s\" because it is being used by active queries in this session"</literal></expr></argument>,
                        <argument><expr><name>stmt</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
        <call><name>AfterTriggerPendingOnRel</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: first %s is a SQL command, eg ALTER TABLE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s \"%s\" because it has pending trigger events"</literal></expr></argument>,
                        <argument><expr><name>stmt</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableLookupRelation
 *        Look up, and lock, the OID for the relation named by an alter table
 *        statement.
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterTableLookupRelation</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                    <argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTable
 *        Execute ALTER TABLE, which can be a list of subcommands
 *
 * ALTER TABLE is performed in three phases:
 *        1. Examine subcommands and perform pre-transformation checking.
 *        2. Update system catalogs.
 *        3. Scan table(s) to check new constraints, and optionally recopy
 *           the data into new table(s).
 * Phase 3 is not performed unless one or more of the subcommands requires
 * it.  The intention of this design is to allow multiple independent
 * updates of the table schema to be performed with only one pass over the
 * data.
 *
 * ATPrepCmd performs phase 1.  A "work queue" entry is created for
 * each table to be affected (there may be multiple affected tables if the
 * commands traverse a table inheritance hierarchy).  Also we do preliminary
 * validation of the subcommands, including parse transformation of those
 * expressions that need to be evaluated with respect to the old table
 * schema.
 *
 * ATRewriteCatalogs performs phase 2 for each affected table.  (Note that
 * phases 2 and 3 normally do no explicit recursion, since phase 1 already
 * did it --- although some subcommands have to recurse in phase 2 instead.)
 * Certain subcommands need to be performed before others to avoid
 * unnecessary conflicts; for example, DROP COLUMN should come before
 * ADD COLUMN.  Therefore phase 1 divides the subcommands into multiple
 * lists, one for each logical "pass" of phase 2.
 *
 * ATRewriteTables performs phase 3 for those tables that need it.
 *
 * Thanks to the magic of MVCC, an error anywhere along the way rolls back
 * the whole operation; we don't have to do anything special to clean up.
 *
 * The caller must lock the relation, with an appropriate lock level
 * for the subcommands requested, using AlterTableGetLockLevel(stmt-&gt;cmds)
 * or higher. We pass the lock level down
 * so that we can apply it recursively to inherited tables. Note that the
 * lock level we want as we recurse might well be higher than required for
 * that specific subcommand. So we pass down the overall lock requirement,
 * rather than reassess it at lower levels.
 *
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * In Postgres-XC, an extension is added to ALTER TABLE for modification
 * of the data distribution. Depending on the old and new distribution type
 * of the relation redistributed, a list of redistribution subcommands is built.
 * Data redistribution cannot be done in parallel of operations that need
 * the table to be rewritten like column addition/deletion.
 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type>
<name>AlterTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>

    <comment type="block">/* Caller is required to provide an adequate lock. */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ATController</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableInternal
 *
 * ALTER TABLE with target specified by OID
 *
 * We do not reject if the relation is already open, because it's quite
 * likely that one or more layers of caller have it open.  That means it
 * is unsafe to use this entry point for alterations that could break
 * existing query plans.  On the assumption it's not used for such, we
 * don't have to reject pending AFTER triggers, either.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTableInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ATController</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableGetLockLevel
 *
 * Sets the overall lock level required for the supplied list of subcommands.
 * Policy for doing this set according to needs of AlterTable(), see
 * comments there for overall explanation.
 *
 * Function is called before and after parsing, so it must give same
 * answer each time it is called. Some subcommands are transformed
 * into other subcommand types, so the transform must never be made to a
 * lower lock level than previously assigned. All transforms are noted below.
 *
 * Since this is called before we lock the table we cannot use table metadata
 * to influence the type of lock we acquire.
 *
 * There should be no lockmodes hardcoded into the subcommand functions. All
 * lockmode decisions for ALTER TABLE are made here only. The one exception is
 * ALTER TABLE RENAME which is treated as a different statement type T_RenameStmt
 * and does not travel through this section of code and cannot be combined with
 * any of the subcommands given here.
 *
 * Note that Hot Standby only knows about AccessExclusiveLocks on the master
 * so any changes that might affect SELECTs running on standbys need to use
 * AccessExclusiveLocks even if you think a lesser lock would do, unless you
 * have a solution for that also.
 *
 * Also note that pg_dump uses only an AccessShareLock, meaning that anything
 * that takes a lock less than AccessExclusiveLock can change object definitions
 * while pg_dump is running. Be careful to check that the appropriate data is
 * derived by pg_dump using an MVCC snapshot, rather than syscache lookups,
 * otherwise we might end up with an inconsistent dump that can't restore.
 */</comment>
<function><type><name>LOCKMODE</name></type>
<name>AlterTableGetLockLevel</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * This only works if we read catalog tables using MVCC snapshots.
     */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name> <init>= <expr><name>ShareUpdateExclusiveLock</name></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>cmds</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>cmd_lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt> <comment type="block">/* default for compiler */</comment>

        <switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/*
                 * These subcommands rewrite the heap, so require full locks.
                 */</comment>
            <case>case <expr><name>AT_AddColumn</name></expr>:</case>    <comment type="block">/* may rewrite heap, in some cases and visible
                                 * to SELECT */</comment>
            <case>case <expr><name>AT_SetTableSpace</name></expr>:</case>    <comment type="block">/* must rewrite heap */</comment>
            <case>case <expr><name>AT_AlterColumnType</name></expr>:</case>    <comment type="block">/* must rewrite heap */</comment>
            <case>case <expr><name>AT_AddOids</name></expr>:</case>    <comment type="block">/* must rewrite heap */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * These subcommands may require addition of toast tables. If
                 * we add a toast table to a table currently being scanned, we
                 * might miss data added to the new toast table by concurrent
                 * insert transactions.
                 */</comment>
            <case>case <expr><name>AT_SetStorage</name></expr>:</case> <comment type="block">/* may add toast tables, see
                                 * ATRewriteCatalogs() */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Removing constraints can affect SELECTs that have been
                 * optimised assuming the constraint holds true.
                 */</comment>
            <case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* as DROP INDEX */</comment>
            <case>case <expr><name>AT_DropNotNull</name></expr>:</case>    <comment type="block">/* may change some SQL plans */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Subcommands that may be visible to concurrent SELECTs
                 */</comment>
            <case>case <expr><name>AT_DropColumn</name></expr>:</case> <comment type="block">/* change visible to SELECT */</comment>
            <case>case <expr><name>AT_AddColumnToView</name></expr>:</case>    <comment type="block">/* CREATE VIEW */</comment>
            <case>case <expr><name>AT_DropOids</name></expr>:</case>    <comment type="block">/* calls AT_DropColumn */</comment>
            <case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>    <comment type="block">/* may change SELECT rules */</comment>
            <case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>    <comment type="block">/* may change SELECT rules */</comment>
            <case>case <expr><name>AT_EnableRule</name></expr>:</case> <comment type="block">/* may change SELECT rules */</comment>
            <case>case <expr><name>AT_DisableRule</name></expr>:</case>    <comment type="block">/* may change SELECT rules */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Changing owner may remove implicit SELECT privileges
                 */</comment>
            <case>case <expr><name>AT_ChangeOwner</name></expr>:</case>    <comment type="block">/* change visible to SELECT */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Changing foreign table options may affect optimization.
                 */</comment>
            <case>case <expr><name>AT_GenericOptions</name></expr>:</case>
            <case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
            <case>case <expr><name>AT_DistributeBy</name></expr>:</case>        <comment type="block">/* Changes table distribution type */</comment>
            <case>case <expr><name>AT_SubCluster</name></expr>:</case>            <comment type="block">/* Changes node list of distribution */</comment>
            <case>case <expr><name>AT_AddNodeList</name></expr>:</case>        <comment type="block">/* Adds nodes in distribution */</comment>
            <case>case <expr><name>AT_DeleteNodeList</name></expr>:</case>        <comment type="block">/* Deletes nodes in distribution */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <case>case <expr><name>AT_RebuildExtent</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * These subcommands affect write operations only.
                 */</comment>
            <case>case <expr><name>AT_EnableTrig</name></expr>:</case>
            <case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
            <case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
            <case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
            <case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
            <case>case <expr><name>AT_DisableTrig</name></expr>:</case>
            <case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
            <case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareRowExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * These subcommands affect write operations only. XXX
                 * Theoretically, these could be ShareRowExclusiveLock.
                 */</comment>
            <case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
            <case>case <expr><name>AT_AlterConstraint</name></expr>:</case>
            <case>case <expr><name>AT_AddIndex</name></expr>:</case>    <comment type="block">/* from ADD CONSTRAINT */</comment>
            <case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case>
            <case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
            <case>case <expr><name>AT_SetNotNull</name></expr>:</case>
            <case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
            <case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
            <case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
            <case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
            <case>case <expr><name>AT_AddIdentity</name></expr>:</case>
            <case>case <expr><name>AT_DropIdentity</name></expr>:</case>
            <case>case <expr><name>AT_SetIdentity</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>AT_AddConstraint</name></expr>:</case>
            <case>case <expr><name>AT_ProcessedConstraint</name></expr>:</case>    <comment type="block">/* becomes AT_AddConstraint */</comment>
            <case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>    <comment type="block">/* becomes AT_AddConstraint */</comment>
            <case>case <expr><name>AT_ReAddConstraint</name></expr>:</case>    <comment type="block">/* becomes AT_AddConstraint */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

                    <switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
                        <case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
                        <case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>

                            <comment type="block">/*
                             * Cases essentially the same as CREATE INDEX. We
                             * could reduce the lock strength to ShareLock if
                             * we can work out how to allow concurrent catalog
                             * updates. XXX Might be set down to
                             * ShareRowExclusiveLock but requires further
                             * analysis.
                             */</comment>
                            <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>

                            <comment type="block">/*
                             * We add triggers to both tables when we add a
                             * Foreign Key, so the lock level must be at least
                             * as strong as CREATE TRIGGER.
                             */</comment>
                            <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareRowExclusiveLock</name></expr>;</expr_stmt>
                            <break>break;</break>

                        <default>default:</default>
                            <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                    </block_content>}</block></switch>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * These subcommands affect inheritance behaviour. Queries
                 * started before us will continue to see the old inheritance
                 * behaviour, while queries started after we commit will see
                 * new behaviour. No need to prevent reads or writes to the
                 * subtable while we hook it up though. Changing the TupDesc
                 * may be a problem, so keep highest lock.
                 */</comment>
            <case>case <expr><name>AT_AddInherit</name></expr>:</case>
            <case>case <expr><name>AT_DropInherit</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * These subcommands affect implicit row type conversion. They
                 * have affects similar to CREATE/DROP CAST on queries. don't
                 * provide for invalidating parse trees as a result of such
                 * changes, so we keep these at AccessExclusiveLock.
                 */</comment>
            <case>case <expr><name>AT_AddOf</name></expr>:</case>
            <case>case <expr><name>AT_DropOf</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Only used by CREATE OR REPLACE VIEW which must conflict
                 * with an SELECTs currently using the view.
                 */</comment>
            <case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * These subcommands affect general strategies for performance
                 * and maintenance, though don't change the semantic results
                 * from normal data reads and writes. Delaying an ALTER TABLE
                 * behind currently active writes only delays the point where
                 * the new strategy begins to take effect, so there is no
                 * benefit in waiting. In this case the minimum restriction
                 * applies: we don't currently allow concurrent catalog
                 * updates.
                 */</comment>
            <case>case <expr><name>AT_SetStatistics</name></expr>:</case>    <comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
            <case>case <expr><name>AT_ClusterOn</name></expr>:</case>    <comment type="block">/* Uses MVCC in getIndexes() */</comment>
            <case>case <expr><name>AT_DropCluster</name></expr>:</case>    <comment type="block">/* Uses MVCC in getIndexes() */</comment>
            <case>case <expr><name>AT_SetOptions</name></expr>:</case> <comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
            <case>case <expr><name>AT_ResetOptions</name></expr>:</case>    <comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>AT_SetLogged</name></expr>:</case>
            <case>case <expr><name>AT_SetUnLogged</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* Uses MVCC in getConstraints() */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * Rel options are more complex than first appears. Options
                 * are set here for tables, views and indexes; for historical
                 * reasons these can all be used with ALTER TABLE, so we can't
                 * decide between them using the basic grammar.
                 */</comment>
            <case>case <expr><name>AT_SetRelOptions</name></expr>:</case>    <comment type="block">/* Uses MVCC in getIndexes() and
                                     * getTables() */</comment>
            <case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>    <comment type="block">/* Uses MVCC in getIndexes() and
                                         * getTables() */</comment>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <call><name>AlterTableGetRelOptionsLockLevel</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>AT_AttachPartition</name></expr>:</case>
            <case>case <expr><name>AT_DetachPartition</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <case>case <expr><name>AT_AddPartitions</name></expr>:</case>
            <case>case <expr><name>AT_DropPartitions</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>AT_ExchangeIndexName</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>AT_ModifyStartValue</name></expr>:</case>
                <expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <default>default:</default>            <comment type="block">/* oops */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/*
         * Take the greatest lockmode from any subcommand
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>cmd_lockmode</name> <operator>&gt;</operator> <name>lockmode</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>cmd_lockmode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>lockmode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ATController provides top level control over the phases.
 *
 * parsetree is passed in to allow it to be passed to event triggers
 * when requested.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATController</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
             <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>wqueue</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RedistribState</name>   <modifier>*</modifier></type><name>redistribState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Phase 1: preliminary examination of commands, create work queue */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>cmds</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Check restrictions of ALTER TABLE in cluster */</comment>
        <expr_stmt><expr><call><name>ATCheckCmd</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Only check that on local Coordinator */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Redistribution is only applied to the parent table and not subsequent
         * children. It is also not applied in recursion. This needs to be done
         * once all the commands have been treated.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>wqueue</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
                <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_DISTRIB</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Check if there are any commands incompatible
                 * with redistribution. For the time being no other commands
                 * are authorized.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_ADD_COL</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_DROP</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_ALTER_TYPE</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_COL_ATTRS</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_ADD_COL</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_ADD_INDEX</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_ADD_CONSTR</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_MISC</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Incompatible operation with data redistribution"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


                    <comment type="block">/* Scan redistribution commands and improve operation */</comment>
                    <expr_stmt><expr><name>redistribState</name> <operator>=</operator> <call><name>BuildRedistribCommands</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_DISTRIB</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Close the relation, but keep lock until commit */</comment>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Perform pre-catalog-update redistribution operations */</comment>
    <expr_stmt><expr><call><name>PGXCRedistribTable</name><argument_list>(<argument><expr><name>redistribState</name></expr></argument>, <argument><expr><name>CATALOG_UPDATE_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Phase 2: update system catalogs */</comment>
    <expr_stmt><expr><call><name>ATRewriteCatalogs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Invalidate cache for redistributed relation */</comment>
    <if_stmt><if>if <condition>(<expr><name>redistribState</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type> <name>rel2</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name><name>redistribState</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Invalidate all entries related to this relation */</comment>
        <expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make sure locator info is rebuilt */</comment>
        <expr_stmt><expr><call><name>RelationCacheInvalidateEntry</name><argument_list>(<argument><expr><name><name>redistribState</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Perform post-catalog-update redistribution operations */</comment>
    <expr_stmt><expr><call><name>PGXCRedistribTable</name><argument_list>(<argument><expr><name>redistribState</name></expr></argument>, <argument><expr><name>CATALOG_UPDATE_AFTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeRedistribState</name><argument_list>(<argument><expr><name>redistribState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Phase 3: scan/rewrite tables as needed */</comment>
    <expr_stmt><expr><call><name>ATRewriteTables</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATPrepCmd
 *
 * Traffic cop for ALTER TABLE Phase 1 operations, including simple
 * recursion and permission checks.
 *
 * Caller must have acquired appropriate lock type on relation already.
 * This lock should be held until commit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
          <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pass</name> <init>= <expr><name>AT_PASS_UNSET</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Find or create work queue entry for this table */</comment>
    <expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Copy the original subcommand for each table.  This avoids conflicts
     * when different child tables need to make different parse
     * transformations (for example, the same column may have different column
     * numbers in different children).
     */</comment>
    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>AT_AddColumn</name></expr>:</case>
                <case>case <expr><name>AT_AddIndex</name></expr>:</case>
                <case>case <expr><name>AT_AddPartitions</name></expr>:</case>            
                <case>case <expr><name>AT_ModifyStartValue</name></expr>:</case>
                <case>case <expr><name>AT_SetNotNull</name></expr>:</case>
                <case>case <expr><name>AT_DropNotNull</name></expr>:</case>
                <case>case <expr><name>AT_DropColumn</name></expr>:</case>
                <case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
                <case>case <expr><name>AT_DropConstraint</name></expr>:</case>
                <case>case <expr><name>AT_AddConstraint</name></expr>:</case>
                <case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
                <case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
                <case>case <expr><name>AT_ChangeOwner</name></expr>:</case>
                <case>case <expr><name>AT_ExchangeIndexName</name></expr>:</case>
                <case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
                <case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"this operation is forbidden in interval partitioned table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>AT_ExchangeIndexName</name></expr>:</case>
                    <break>break;</break>
                <case>case <expr><name>AT_SetNotNull</name></expr>:</case>
                <case>case <expr><name>AT_DropNotNull</name></expr>:</case>
                <case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
                <case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
                <case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
                <case>case <expr><name>AT_SetRelOptions</name></expr>:</case>
                <case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"this operation is forbidden in interval child table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></else></if_stmt>
                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"this operation is forbidden in interval child table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Do permissions checking, recursion to child tables if needed, and any
     * additional phase-1 processing needed.
     */</comment>
    <switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>AT_AddColumn</name></expr>:</case>        <comment type="block">/* ADD COLUMN */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                                <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>,
                            <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Recursion occurs during execution phase */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddColumnToView</name></expr>:</case>    <comment type="block">/* add column via CREATE OR REPLACE VIEW */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>,
                            <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Recursion occurs during execution phase */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ColumnDefault</name></expr>:</case>    <comment type="block">/* ALTER COLUMN DEFAULT */</comment>

            <comment type="block">/*
             * We allow defaults on views so that INSERT into a view can have
             * default-ish behavior.  This works because the rewriter
             * substitutes default values into INSERTs before it expands
             * rules.
             */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <ternary><condition><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr> ?</condition><then> <expr><name>AT_PASS_ADD_CONSTR</name></expr> </then><else>: <expr><name>AT_PASS_DROP</name></expr></else></ternary></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddIdentity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetIdentity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_COL_ATTRS</name></expr>;</expr_stmt>
            <break>break;</break>
		<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
        <case>case <expr><name>AT_DropNotNull</name></expr>:</case>    <comment type="block">/* ALTER COLUMN DROP NOT NULL */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATPrepDropNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetNotNull</name></expr>:</case>        <comment type="block">/* ALTER COLUMN SET NOT NULL */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATPrepSetNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetStatistics</name></expr>:</case>    <comment type="block">/* ALTER COLUMN SET STATISTICS */</comment>
            <expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Performs own permission checks */</comment>
            <expr_stmt><expr><call><name>ATPrepSetStatistics</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetOptions</name></expr>:</case>        <comment type="block">/* ALTER COLUMN SET ( options ) */</comment>
        <case>case <expr><name>AT_ResetOptions</name></expr>:</case>    <comment type="block">/* ALTER COLUMN RESET ( options ) */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetStorage</name></expr>:</case>        <comment type="block">/* ALTER COLUMN SET STORAGE */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropColumn</name></expr>:</case>        <comment type="block">/* DROP COLUMN */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                                <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATPrepDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Recursion occurs during execution phase */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddIndex</name></expr>:</case>        <comment type="block">/* ADD INDEX */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_INDEX</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddConstraint</name></expr>:</case>    <comment type="block">/* ADD CONSTRAINT */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Recursion occurs during execution phase */</comment>
            <comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
            <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case> <comment type="block">/* ADD CONSTRAINT USING INDEX */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* DROP CONSTRAINT */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATCheckPartitionsNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Other recursion occurs during execution phase */</comment>
            <comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
            <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AlterColumnType</name></expr>:</case>    <comment type="block">/* ALTER COLUMN TYPE */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                                <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Performs own recursion */</comment>
            <expr_stmt><expr><call><name>ATPrepAlterColumnType</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ALTER_TYPE</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ChangeOwner</name></expr>:</case>    <comment type="block">/* ALTER OWNER */</comment>
            <comment type="block">/* This command never recurses */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ClusterOn</name></expr>:</case>        <comment type="block">/* CLUSTER ON */</comment>
        <case>case <expr><name>AT_DropCluster</name></expr>:</case>    <comment type="block">/* SET WITHOUT CLUSTER */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* These commands never recurse */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetLogged</name></expr>:</case>        <comment type="block">/* SET LOGGED */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <call><name>ATPrepChangePersistence</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* force rewrite if necessary; see comment in ATRewriteTables */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_PERSISTENCE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetUnLogged</name></expr>:</case>    <comment type="block">/* SET UNLOGGED */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <call><name>ATPrepChangePersistence</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* force rewrite if necessary; see comment in ATRewriteTables */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_PERSISTENCE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddOids</name></expr>:</case>        <comment type="block">/* SET WITH OIDS */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>||</operator> <name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ATPrepAddOids</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Recursion occurs during execution phase */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropOids</name></expr>:</case>        <comment type="block">/* SET WITHOUT OIDS */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Performs own recursion */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>dropCmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>dropCmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropColumn</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dropCmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dropCmd</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>dropCmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetTableSpace</name></expr>:</case>    <comment type="block">/* SET TABLESPACE */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator>
								<name>ATT_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <expr_stmt><expr><call><name>ATPrepSetTableSpace</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>    <comment type="block">/* doesn't actually matter */</comment>
            <break>break;</break>
        <case>case <expr><name>AT_SetRelOptions</name></expr>:</case>    <comment type="block">/* SET (...) */</comment>
        <case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>    <comment type="block">/* RESET (...) */</comment>
        <case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>    <comment type="block">/* reset them all, then set just these */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddInherit</name></expr>:</case>        <comment type="block">/* INHERIT */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <expr_stmt><expr><call><name>ATPrepAddInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropInherit</name></expr>:</case>    <comment type="block">/* NO INHERIT */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AlterConstraint</name></expr>:</case>    <comment type="block">/* ALTER CONSTRAINT */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* VALIDATE CONSTRAINT */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Recursion occurs during execution phase */</comment>
            <comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
            <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ValidateConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>    <comment type="block">/* REPLICA IDENTITY ... */</comment>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <comment type="block">/* This command never recurses */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <break>break;</break>
        <case>case <expr><name>AT_EnableTrig</name></expr>:</case>        <comment type="block">/* ENABLE TRIGGER variants */</comment>
        <case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
        <case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
        <case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
        <case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
        <case>case <expr><name>AT_DisableTrig</name></expr>:</case>    <comment type="block">/* DISABLE TRIGGER variants */</comment>
        <case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
        <case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableRule</name></expr>:</case>        <comment type="block">/* ENABLE/DISABLE RULE variants */</comment>
        <case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>
        <case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>
        <case>case <expr><name>AT_DisableRule</name></expr>:</case>
        <case>case <expr><name>AT_AddOf</name></expr>:</case>            <comment type="block">/* OF */</comment>
        <case>case <expr><name>AT_DropOf</name></expr>:</case>            <comment type="block">/* NOT OF */</comment>
        <case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
        <case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
        <case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
        <case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* These commands never recurse */</comment>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_GenericOptions</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>AT_DistributeBy</name></expr>:</case>
        <case>case <expr><name>AT_SubCluster</name></expr>:</case>
        <case>case <expr><name>AT_AddNodeList</name></expr>:</case>
        <case>case <expr><name>AT_DeleteNodeList</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"this operation is not permitted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DISTRIB</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>AT_RebuildExtent</name></expr>:</case>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"this operation can only be executed on datanode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DetachPartition</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* No command-specific prep needed */</comment>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>AT_AddPartitions</name></expr>:</case>
        <case>case <expr><name>AT_DropPartitions</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_PARTITION</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ExchangeIndexName</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_OLD_INDEX</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ModifyStartValue</name></expr>:</case>
            <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_PARTITION</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>                <comment type="block">/* oops */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_UNSET</name></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pass</name> <operator>&gt;</operator> <name>AT_PASS_UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add the subcommand to the appropriate list for phase 2 */</comment>
    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteCatalogs
 *
 * Traffic cop for ALTER TABLE Phase 2 operations.  Subcommands are
 * dispatched in a "safe" execution order (designed to avoid unnecessary
 * conflicts).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteCatalogs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>pass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We process all the tables "in parallel", one pass at a time.  This is
     * needed because we may have to propagate work from one table to another
     * (specifically, ALTER TYPE on a foreign key's PK has to dispatch the
     * re-adding of the foreign key constraint to the other table).  Work can
     * only be propagated into later passes, however.
     */</comment>
    <for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;</operator> <name>AT_NUM_PASSES</name></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Go through each table that needs to be processed */</comment>
        <macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subcmds</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>subcmds</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Appropriate lock was obtained by phase 1, needn't get it again
             */</comment>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>subcmds</argument>)</argument_list></macro>
                <expr_stmt><expr><call><name>ATExecCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * After the ALTER TYPE pass, do cleanup work (this is not done in
             * ATExecAlterColumnType since it should be done only once if
             * multiple columns of a table are altered).
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <name>AT_PASS_ALTER_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ATPostAlterTypeCleanup</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></for>

    <comment type="block">/* Check to see if a toast table must be added. */</comment>
    <macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the table is source table of ATTACH PARTITION command, we did
         * not modify anything about it that will change its toasting
         * requirement, so no need to check.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
              <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
             <name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
            <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>AlterTableCreateToastTable</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ATExecCmd: dispatch a subcommand to appropriate execution routine
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
          <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>AT_AddColumn</name></expr>:</case>        <comment type="block">/* ADD COLUMN */</comment>
        <case>case <expr><name>AT_AddColumnToView</name></expr>:</case>    <comment type="block">/* add column via CREATE OR REPLACE VIEW */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                      <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ColumnDefault</name></expr>:</case>    <comment type="block">/* ALTER COLUMN DEFAULT */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecColumnDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddIdentity</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetIdentity</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropIdentity</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropNotNull</name></expr>:</case>    <comment type="block">/* ALTER COLUMN DROP NOT NULL */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetNotNull</name></expr>:</case>        <comment type="block">/* ALTER COLUMN SET NOT NULL */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetNotNull</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetStatistics</name></expr>:</case>    <comment type="block">/* ALTER COLUMN SET STATISTICS */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetStatistics</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetOptions</name></expr>:</case>        <comment type="block">/* ALTER COLUMN SET ( options ) */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ResetOptions</name></expr>:</case>    <comment type="block">/* ALTER COLUMN RESET ( options ) */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetStorage</name></expr>:</case>        <comment type="block">/* ALTER COLUMN SET STORAGE */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropColumn</name></expr>:</case>        <comment type="block">/* DROP COLUMN */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                       <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>    <comment type="block">/* DROP COLUMN with recursion */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                       <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddIndex</name></expr>:</case>        <comment type="block">/* ADD INDEX */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndex</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                     <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ReAddIndex</name></expr>:</case>        <comment type="block">/* ADD INDEX */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndex</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                     <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddConstraint</name></expr>:</case>    <comment type="block">/* ADD CONSTRAINT */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator>
                <call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>    <comment type="block">/* ADD CONSTRAINT with recursion */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator>
                <call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                    <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ReAddConstraint</name></expr>:</case>    <comment type="block">/* Re-add pre-existing check constraint */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator>
                <call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                    <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ReAddComment</name></expr>:</case>    <comment type="block">/* Re-add existing comment */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CommentObject</name><argument_list>(<argument><expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case> <comment type="block">/* ADD CONSTRAINT USING INDEX */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndexConstraint</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                               <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AlterConstraint</name></expr>:</case>    <comment type="block">/* ALTER CONSTRAINT */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAlterConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* VALIDATE CONSTRAINT */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ValidateConstraintRecurse</name></expr>:</case>    <comment type="block">/* VALIDATE CONSTRAINT with
                                             * recursion */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* DROP CONSTRAINT */</comment>
            <expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
                                 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropConstraintRecurse</name></expr>:</case>    <comment type="block">/* DROP CONSTRAINT with recursion */</comment>
            <expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
                                 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AlterColumnType</name></expr>:</case>    <comment type="block">/* ALTER COLUMN TYPE */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAlterColumnType</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>    <comment type="block">/* ALTER COLUMN OPTIONS */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator>
                <call><name>ATExecAlterColumnGenericOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ChangeOwner</name></expr>:</case>    <comment type="block">/* ALTER OWNER */</comment>
            <expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>newowner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ClusterOn</name></expr>:</case>        <comment type="block">/* CLUSTER ON */</comment>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecClusterOn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropCluster</name></expr>:</case>    <comment type="block">/* SET WITHOUT CLUSTER */</comment>
            <expr_stmt><expr><call><name>ATExecDropCluster</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SetLogged</name></expr>:</case>        <comment type="block">/* SET LOGGED */</comment>
        <case>case <expr><name>AT_SetUnLogged</name></expr>:</case>    <comment type="block">/* SET UNLOGGED */</comment>
            <break>break;</break>
        <case>case <expr><name>AT_AddOids</name></expr>:</case>        <comment type="block">/* SET WITH OIDS */</comment>
            <comment type="block">/* Use the ADD COLUMN code, unless prep decided to do nothing */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>address</name> <operator>=</operator>
                    <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                    <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                    <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddOidsRecurse</name></expr>:</case> <comment type="block">/* SET WITH OIDS */</comment>
            <comment type="block">/* Use the ADD COLUMN code, unless prep decided to do nothing */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>address</name> <operator>=</operator>
                    <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                    <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                    <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropOids</name></expr>:</case>        <comment type="block">/* SET WITHOUT OIDS */</comment>

            <comment type="block">/*
             * Nothing to do here; we'll have generated a DropColumn
             * subcommand to do the real work
             */</comment>
            <break>break;</break>
        <case>case <expr><name>AT_SetTableSpace</name></expr>:</case>    <comment type="block">/* SET TABLESPACE */</comment>
            <comment type="block">/*
			 * Only do this for partitioned tables and indexes, for which this
			 * is just a catalog change.  Other relation types which have
			 * storage are handled by Phase 3.
             */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
				<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecSetTableSpaceNoStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <break>break;</break>
        <case>case <expr><name>AT_SetRelOptions</name></expr>:</case>    <comment type="block">/* SET (...) */</comment>
        <case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>    <comment type="block">/* RESET (...) */</comment>
        <case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>    <comment type="block">/* replace entire option list */</comment>
            <expr_stmt><expr><call><name>ATExecSetRelOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableTrig</name></expr>:</case>        <comment type="block">/* ENABLE TRIGGER name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                       <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>    <comment type="block">/* ENABLE ALWAYS TRIGGER name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                       <argument><expr><name>TRIGGER_FIRES_ALWAYS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>    <comment type="block">/* ENABLE REPLICA TRIGGER name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                       <argument><expr><name>TRIGGER_FIRES_ON_REPLICA</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DisableTrig</name></expr>:</case>    <comment type="block">/* DISABLE TRIGGER name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                       <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>    <comment type="block">/* ENABLE TRIGGER ALL */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DisableTrigAll</name></expr>:</case> <comment type="block">/* DISABLE TRIGGER ALL */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableTrigUser</name></expr>:</case> <comment type="block">/* ENABLE TRIGGER USER */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>    <comment type="block">/* DISABLE TRIGGER USER */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>AT_EnableRule</name></expr>:</case>        <comment type="block">/* ENABLE RULE name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                    <argument><expr><name>RULE_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>    <comment type="block">/* ENABLE ALWAYS RULE name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                    <argument><expr><name>RULE_FIRES_ALWAYS</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>    <comment type="block">/* ENABLE REPLICA RULE name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                    <argument><expr><name>RULE_FIRES_ON_REPLICA</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DisableRule</name></expr>:</case>    <comment type="block">/* DISABLE RULE name */</comment>
            <expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                    <argument><expr><name>RULE_DISABLED</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>AT_AddInherit</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropInherit</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddOf</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddOf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropOf</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExecDropOf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExecReplicaIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ReplicaIdentityStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExecEnableRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExecDisableRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExecForceNoForceRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExecForceNoForceRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_GenericOptions</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExecGenericOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DistributeBy</name></expr>:</case>
            <expr_stmt><expr><call><name>AtExecDistributeBy</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>DistributeBy</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_SubCluster</name></expr>:</case>
            <expr_stmt><expr><call><name>AtExecSubCluster</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>PGXCSubCluster</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_AddNodeList</name></expr>:</case>
            <expr_stmt><expr><call><name>AtExecAddNode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DeleteNodeList</name></expr>:</case>
            <expr_stmt><expr><call><name>AtExecDeleteNode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>AT_RebuildExtent</name></expr>:</case>
            <expr_stmt><expr><call><name>AtExecRebuildExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ATExecAttachPartition</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ATExecAttachPartitionIdx</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                         <argument><expr><operator>(</operator><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DetachPartition</name></expr>:</case>
			<comment type="block">/* ATPrepCmd ensures it must be a table */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ATExecDetachPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>AT_AddPartitions</name></expr>:</case>
            <expr_stmt><expr><call><name>ATAddPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>AddDropPartitions</name> <operator>*</operator><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_DropPartitions</name></expr>:</case>
            <break>break;</break>
        <case>case <expr><name>AT_ExchangeIndexName</name></expr>:</case>
            <expr_stmt><expr><call><name>ATExchangeIndexName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>ExchangeIndexName</name> <operator>*</operator><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AT_ModifyStartValue</name></expr>:</case>
            <expr_stmt><expr><call><name>ATModifyPartitionStartValue</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>ModifyPartStartValue</name> <operator>*</operator><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <default>default:</default>                <comment type="block">/* oops */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Report the subcommand to interested event triggers.
     */</comment>
    <expr_stmt><expr><call><name>EventTriggerCollectAlterTableSubcmd</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmd</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Bump the command counter to ensure the next subcommand in the sequence
     * can see the changes so far
     */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATAddPartitions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>existnparts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"add partitions to a non-interval-partitioned table is forbidden"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>existnparts</name> <operator>=</operator>  <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>nparts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of partitions to add cannot be negative or zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>nparts</name> <operator>+</operator> <name>existnparts</name> <operator>&gt;</operator> <name>MAX_NUM_INTERVAL_PARTITIONS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"one table only have %d partitions at most"</literal></expr></argument>, <argument><expr><name>MAX_NUM_INTERVAL_PARTITIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* alter pgxc_partition_parent.nparts */</comment>
    <expr_stmt><expr><call><name>AddPartitions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExchangeIndexName</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExchangeIndexName</name> <modifier>*</modifier></type> <name>exchange</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>  <name>nParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>partIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>oldrelfilenode</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>newrelfilenode</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>  <name>oldIndid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>  <name>newIndid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>relrel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>reltup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type>    <name>relform</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


    <expr_stmt><expr><name>oldIndid</name> <operator>=</operator> <name><name>exchange</name><operator>-&gt;</operator><name>oldIndexId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newIndid</name> <operator>=</operator> <name><name>exchange</name><operator>-&gt;</operator><name>newIndexId</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nParts</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>relrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>oldrelfilenode</name> <operator>=</operator> <call><name>get_rel_filenode</name><argument_list>(<argument><expr><name>oldIndid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newrelfilenode</name> <operator>=</operator> <call><name>get_rel_filenode</name><argument_list>(<argument><expr><name>newIndid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldrelfilenode</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get relfilenode of index %s"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>oldIndid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newrelfilenode</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get relfilenode of index %s"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>newIndid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* update old index */</comment>
        <expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldIndid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition>        <comment type="block">/* shouldn't happen */</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>oldIndid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>

        <comment type="block">/* do update */</comment>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* update new index */</comment>
        <expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newIndid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition>        <comment type="block">/* shouldn't happen */</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>newIndid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        
        <expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>oldrelfilenode</name></expr>;</expr_stmt>

        <comment type="block">/* do update */</comment>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>partIndex</name> <operator>&lt;</operator> <name>nParts</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>oldIndid</name> <operator>=</operator> <call><name>RelationGetPartitionIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>exchange</name><operator>-&gt;</operator><name>oldIndexId</name></name></expr></argument>, <argument><expr><name>partIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>newIndid</name> <operator>=</operator> <call><name>RelationGetPartitionIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>exchange</name><operator>-&gt;</operator><name>newIndexId</name></name></expr></argument>, <argument><expr><name>partIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>partIndex</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATModifyPartitionStartValue</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ModifyPartStartValue</name> <modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>startvalue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>   <name>startdatatype</name>  <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>start_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type>  <name>rd_partitions_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"change start value only permitted on interval partition."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>startvalue</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>startvalue</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_INSERT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>startvalue</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>startvalue</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interval partition's start value MUST be constants."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>startdatatype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator><name>startvalue</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>IntervalType_Int2</name></expr>:</case>
        <case>case <expr><name>IntervalType_Int4</name></expr>:</case>
        <case>case <expr><name>IntervalType_Int8</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type> <name>threshold</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>   <name>nPartitions</name> <init>= <expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partnparts</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>   <name>step</name> <init>= <expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if<condition>(<expr><name>startdatatype</name> <operator>!=</operator> <name>INT4OID</name> <operator>&amp;&amp;</operator> <name>startdatatype</name> <operator>!=</operator> <name>INT2OID</name> <operator>&amp;&amp;</operator> <name>startdatatype</name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"data type of start value MUST be integer."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Int2</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int16</name></type> <name>startValueInt</name> <init>= <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator><name>startvalue</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>threshold</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator><name>SHRT_MAX</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>start_value</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator><name>startValueInt</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Int4</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int32</name></type> <name>startValueInt</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator><name>startvalue</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>threshold</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator><name>INT_MAX</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>start_value</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator><name>startValueInt</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Int8</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name></type> <name>startValueInt</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator><name>startvalue</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>threshold</name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>start_value</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator><name>startValueInt</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>start_value</name> <operator>+</operator> <name>step</name> <operator>*</operator> <name>nPartitions</name> <operator>&gt;</operator> <name>threshold</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the range of interval partition exceed max value(%ld) of partition column."</literal></expr></argument>,
                                <argument><expr><name>threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>IntervalType_Day</name></expr>:</case>
        <case>case <expr><name>IntervalType_Month</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>text</name>    <modifier>*</modifier></type><name>trunc_unit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>    <name>constvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if<condition>(<expr><name>startdatatype</name> <operator>!=</operator> <name>TIMESTAMPOID</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"data type of start value MUST be timestamp."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Day</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>trunc_unit</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"day"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Month</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>trunc_unit</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"month"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <call><name>OidFunctionCall2</name><argument_list>(<argument><expr><name>F_TIMESTAMP_TRUNC</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>trunc_unit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator><name>startvalue</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>start_value</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>fsec_t</name></type> <name>fsec</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>user_time</name></decl>;</decl_stmt>

                    <if_stmt><if>if<condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>start_value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>   
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Day</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>user_time</name><operator>.</operator><name>tm_hour</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_min</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_sec</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cold-hot table partitioned by day should begin with timestamp 'yy:mm:dd 00:00:00'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator> <name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>user_time</name><operator>.</operator><name>tm_mday</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_hour</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_min</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_sec</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cold-hot table partitioned by month should begin with timestamp 'yy:mm:01 00:00:00'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator> <name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>user_time</name><operator>.</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_mday</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_hour</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_min</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>user_time</name><operator>.</operator><name>tm_sec</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cold-hot table partitioned by year should begin with timestamp 'yy:01:01 00:00:00'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"unexpected interval partition data type:%d"</literal></expr></argument>, <argument><expr><name><name>rd_partitions_info</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ModifyPartitionStartValue</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>start_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ATRewriteTables: ALTER TABLE phase 3
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteTables</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

    <comment type="block">/* Go through each table that needs to be checked or rewritten */</comment>
    <macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Forbid table rewrite operations with online data redistribution */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&amp;&amp;</operator>
            <call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_DISTRIB</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Incompatible operation with data redistribution"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
         * Foreign tables have no storage, nor do partitioned tables and
         * indexes.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
				<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
                <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If we change column data types or add/remove OIDs, the operation
         * has to be propagated to tables that use this table's rowtype as a
         * column type.  tab-&gt;newvals will also be non-NULL in the case where
         * we're adding a column with a default.  We choose to forbid that
         * case as well, since composite types might eventually support
         * defaults.
         *
         * (Eventually we'll probably need to check for composite type
         * dependencies even when we're just scanning the table without a
         * rewrite, but at the moment a composite type does not enforce any
         * constraints, so it's not necessary/appropriate to enforce them just
         * during ALTER.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * We only need to rewrite the table if at least one column needs to
         * be recomputed, we are adding/removing the OID column, or we are
         * changing its persistence.
         *
         * There are two reasons for requiring a rewrite when changing
         * persistence: on one hand, we need to ensure that the buffers
         * belonging to each of the two relations are marked with or without
         * BM_PERMANENT properly.  On the other hand, since rewriting creates
         * and assigns a new relfilenode, we automatically create or drop an
         * init fork for the relation as appropriate.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Build a temporary relation and copy data */</comment>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>OldHeap</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>OIDNewHeap</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>NewTableSpace</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>        <name>persistence</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * We don't support rewriting of system catalogs; there are too
             * many corner cases and too little benefit.  In particular this
             * is certainly not going to work for mapped catalogs.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite system relation \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>RelationIsUsedAsCatalogTable</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite table \"%s\" used as a catalog table"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Don't allow rewrite on temp tables of other backends ... their
             * local buffer manager is not going to cope.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Select destination tablespace (same as original unless user
             * requested a change)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>NewTableSpace</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>NewTableSpace</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * Select persistence of transient table (same as original unless
             * user requested a change)
             */</comment>
            <expr_stmt><expr><name>persistence</name> <operator>=</operator> <ternary><condition><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr> ?</condition><then>
                <expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name></expr> </then><else>: <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></else></ternary></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Fire off an Event Trigger now, before actually rewriting the
             * table.
             *
             * We don't support Event Trigger for nested commands anywhere,
             * here included, and parsetree is given NULL when coming from
             * AlterTableInternal.
             *
             * And fire it only once.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>parsetree</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>EventTriggerTableRewrite</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
                                         <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
                                         <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Create transient table that will receive the modified data.
             *
             * Ensure it is marked correctly as logged or unlogged.  We have
             * to do this here so that buffers for the new relfilenode will
             * have the right persistence set, and at the same time ensure
             * that the original filenode's buffers will get read in with the
             * correct setting (i.e. the original one).  Otherwise a rollback
             * after the rewrite would possibly result with buffers for the
             * original filenode having the wrong persistence setting.
             *
             * NB: This relies on swap_relation_files() also swapping the
             * persistence. That wouldn't work for pg_class, but that can't be
             * unlogged anyway.
             */</comment>
            <expr_stmt><expr><name>OIDNewHeap</name> <operator>=</operator> <call><name>make_new_heap</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NewTableSpace</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>,
                                       <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Copy the heap data into the new table with the desired
             * modifications, and test the current data within the table
             * against new constraints generated by ALTER TABLE commands.
             */</comment>
            <expr_stmt><expr><call><name>ATRewriteTable</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Swap the physical files of the old and new heaps, then rebuild
             * indexes and discard the old heap.  We can use RecentXmin for
             * the table's new relfrozenxid because we rewrote all the tuples
             * in ATRewriteTable, so no older Xid remains in the table.  Also,
             * we never try to swap toast tables by content, since we have no
             * interest in letting this code work on system catalogs.
             */</comment>
            <expr_stmt><expr><call><name>finish_heap_swap</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>,
                             <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                             <argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>RecentXmin</name></expr></argument>,
                             <argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>,
                             <argument><expr><name>persistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Test the current data within the table against new constraints
             * generated by ALTER TABLE commands, but don't rebuild data.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name> <operator>||</operator>
                <name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ATRewriteTable</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If we had SET TABLESPACE but no reason to reconstruct tuples,
             * just do a block-by-block copy.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * In PGXC, do not check the FK constraints on the Coordinator, and just return
     * That is because a SELECT is generated whose plan will try and use
     * the Datanodes. We (currently) do not want to do that on the Coordinator,
     * when the command is passed down to the Datanodes it will
     * peform the check locally.
     * This issue was introduced when we added multi-step handling,
     * it caused foreign key constraints to fail.
     * PGXCTODO - issue for pg_catalog or any other cases?
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Foreign key constraints are checked in a final pass, since (a) it's
     * generally best to examine each one separately, and (b) it's at least
     * theoretically possible that we have changed both relations of the
     * foreign key, and we'd better have finished both rewrites before we try
     * to read the tables.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcon</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lcon</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Relation</name></type>    <name>refrel</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Long since locked, no need for another */</comment>
                    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>refrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>refrelid</name></name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>validateForeignKeyConstraint</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>refrel</name></expr></argument>,
                                             <argument><expr><name><name>con</name><operator>-&gt;</operator><name>refindid</name></name></expr></argument>,
                                             <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * No need to mark the constraint row as validated, we did
                 * that when we inserted the row earlier.
                 */</comment>

                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>refrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteTable: scan or rewrite one table
 *
 * OIDNewHeap is InvalidOid if we don't need to rewrite
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteTable</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>oldrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>newrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>oldTupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>newTupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>needscan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>notnull_attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>mycid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hi_options</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>partqualstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>AttrNumber</name></type>     <name>diskey</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>     <name>secdiskey</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Open the relation(s).  We have surely already locked the existing
     * table.
     */</comment>
    <expr_stmt><expr><name>oldrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldTupDesc</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* includes all mods */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>newrel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Prepare a BulkInsertState and options for heap_insert. Because we're
     * building a new heap, we can skip WAL-logging and fsync it to disk at
     * the end instead (unless WAL-logging is required for archiving or
     * streaming replication). The FSM is empty too, so don't bother using it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mycid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>hi_options</name> <operator>=</operator> <name>HEAP_INSERT_SKIP_FSM</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hi_options</name> <operator>|=</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <expr_stmt><expr><name>diskey</name> <operator>=</operator> <call><name>get_newheap_diskey</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>secdiskey</name> <operator>=</operator> <call><name>get_newheap_secdiskey</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* keep compiler quiet about using these uninitialized */</comment>
        <expr_stmt><expr><name>mycid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bistate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hi_options</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Generate the constraint and default execution states
     */</comment>

    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build the needed expression execution states */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
                <expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
                <comment type="block">/* Nothing to do here */</comment>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block>

    <comment type="block">/* Build expression execution states for partition check quals */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>partqualstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* expr already planned */</comment>
        <expr_stmt><expr><name><name>ex</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>ex</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>notnull_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we are rebuilding the tuples OR if we added any new NOT NULL
         * constraints, check all not-null constraints.  This is a bit of
         * overkill but it minimizes risk of bugs, and heap_attisnull is a
         * pretty cheap test anyway.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attnotnull</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><name><name>newTupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>notnull_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>notnull_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>notnull_attrs</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>||</operator> <name>needscan</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>dropped_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rewriting table \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"verifying table \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * All predicate locks on the tuples or pages are about to be made
             * invalid, because we move tuples around.  Promote them to
             * relation locks.
             */</comment>
            <expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Make tuple slots for old and new tuples.  Note that even when the
         * tuples are the same, the tupDescs might not be (consider ADD COLUMN
         * without a default).
         */</comment>
        <expr_stmt><expr><name>oldslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>oldTupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Preallocate values/isnull arrays */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name><name>oldTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Any attributes that are dropped according to the new tuple
         * descriptor can be set to NULL. We precompute the list of dropped
         * attributes to avoid needing to do so in the per-tuple loop.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>dropped_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>dropped_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Scan through the rows, generating a new row if needed and then
         * checking all the constraints.
         */</comment>
        <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Switch to per-tuple memory context and reset it for each tuple
         * produced, so we don't leak memory.
         */</comment>
        <expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>tupOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* Extract data from old tuple */</comment>
                <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oldTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>oldTupDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tupOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Set dropped attributes to null in new tuple */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dropped_attrs</argument>)</argument_list></macro>
                    <expr_stmt><expr><name><name>isnull</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Process supplied expressions to replace selected columns.
                 * Expression inputs come from the old tuple.
                 */</comment>
                <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>oldslot</name></expr>;</expr_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>values</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>ex</name><operator>-&gt;</operator><name>exprstate</name></name></expr></argument>,
                                                          <argument><expr><name>econtext</name></expr></argument>,
                                                          <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/*
                 * Form the new tuple. Note that we don't explicitly pfree it,
                 * since the per-tuple memory context will be reset shortly.
                 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><name>newrel</name> <operator>&amp;&amp;</operator> <call><name>RelationIsSharded</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple_plain</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,<argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>diskey</name></expr></argument>, <argument><expr><name>secdiskey</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <comment type="block">/* Preserve OID, if any */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Constraints might reference the tableoid column, so
                 * initialize t_tableOid before evaluating them.
                 */</comment>
                <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Now check any constraints on the possibly-changed tuple */</comment>
            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>newslot</name></expr>;</expr_stmt>

            <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>notnull_attrs</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>attn</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>newTupDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                    
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" contains null values"</literal></expr></argument>,
                                    <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attn</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errtablecol</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>attn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>

            <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint \"%s\" is violated by some row"</literal></expr></argument>,
                                            <argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
                        <comment type="block">/* Nothing to do here */</comment>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></switch>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>partqualstate</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>partqualstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>validate_default</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition would be violated by some row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint is violated by some row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

            <comment type="block">/* Write the tuple out to the new relation */</comment>
            <if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we skipped writing WAL, then we need to sync the heap. */</comment>
        <if_stmt><if>if <condition>(<expr><name>hi_options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>heap_sync</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATGetQueueEntry: find or create an entry in the ALTER TABLE work queue
 */</comment>
<function><type><specifier>static</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type>
<name>ATGetQueueEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tab</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Not there, so add it.  Note that we make a copy of the relation's
     * existing descriptor before anything interesting can happen to it.
     */</comment>
    <expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AlteredTableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>    
    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>wqueue</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>tab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ATSimplePermissions
 *
 * - Ensure that it is a relation (or possibly a view)
 * - Ensure this user is the owner
 * - Ensure that it is not a system table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATSimplePermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>actual_target</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
        <case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_TABLE</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
            <expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_VIEW</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
            <expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_MATVIEW</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
            <expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_INDEX</name></expr>;</expr_stmt>
            <break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_PARTITIONED_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
        <case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
            <expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_COMPOSITE_TYPE</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_FOREIGN_TABLE</name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>actual_target</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Wrong target type? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>actual_target</name> <operator>&amp;</operator> <name>allowed_targets</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATWrongRelkindError</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>allowed_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <comment type="block">/* Permissions checks, skip if mls_admin, OBJECT_TABLE is already checked in mls_allow_add_cls_col */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><operator>!</operator><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                       <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATWrongRelkindError
 *
 * Throw an error when a relation has been determined to be of the wrong
 * type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATWrongRelkindError</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>allowed_targets</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>ATT_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, or index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, or index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, composite type, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, index, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_VIEW</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ATT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="block">/* shouldn't get here, add all necessary cases above */</comment>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is of the wrong type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATSimpleRecursion
 *
 * Simple table recursion sufficient for most ALTER TABLE operations.
 * All direct and indirect children are processed in an unspecified order.
 * Note that if a child inherits from the original table via multiple
 * inheritance paths, it will be visited just once.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATSimpleRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
	 * Propagate to children if desired.  Only plain tables, foreign tables
	 * and partitioned tables have children, so no need to search for other
	 * relkinds.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
         <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
         <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * find_all_inheritors does the recursive search of the inheritance
         * hierarchy, so all we have to do is process all of the relids in the
         * list that it returns.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <comment type="block">/* find_all_inheritors already got lock */</comment>
            <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_ReplicaIdentity</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>childcmd</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>rep</name> <init>= <expr><operator>(</operator><name>ReplicaIdentityStmt</name> <operator>*</operator><operator>)</operator><name><name>childcmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>rep</name> <operator>&amp;&amp;</operator> <name>REPLICA_IDENTITY_INDEX</name> <operator>==</operator> <name><name>rep</name><operator>-&gt;</operator><name>identity_type</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>childname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>partidx</name> <init>= <expr><call><name>RelationGetChildIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>partidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>childname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>,
									 <argument><expr><literal type="string">"%s_part_%d"</literal></expr></argument>, <argument><expr><name><name>rep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>rep</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>childname</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
    
                <expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childcmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain list of partitions of the given table, locking them all at the given
 * lockmode and ensuring that they all pass CheckTableNotInUse.
 *
 * This function is a no-op if the given relation is not a partitioned table;
 * in particular, nothing is done if it's a legacy inheritance parent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATCheckPartitionsNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inh</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>inh</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* first element is the parent rel; must ignore it */</comment>
		<macro><name>for_each_cell</name><argument_list>(<argument>cell</argument>, <argument>lnext(list_head(inh))</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

			<comment type="block">/* find_all_inheritors already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATTypedTableRecursion
 *
 * Propagate ALTER TYPE operations to the typed tables of that type.
 * Also check the RESTRICT/CASCADE behavior.  Given CASCADE, also permit
 * recursion to inheritance children of the typed tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATTypedTableRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
                      <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_typed_table_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
                                             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * find_composite_type_dependencies
 *
 * Check to see if the type "typeOid" is being used as a column in some table
 * (possibly nested several levels deep in composite types, arrays, etc!).
 * Eventually, we'd like to propagate the check or rewrite operation
 * into such tables, but for now, just error out if we find any.
 *
 * Caller should provide either the associated relation of a rowtype,
 * or a type name (not both) for use in the error message, if any.
 *
 * Note that "typeOid" is not necessarily a composite type; it could also be
 * another container type such as an array or range, or a domain over one of
 * these things.  The name of this function is therefore somewhat historical,
 * but it's not worth changing.
 *
 * We assume that functions and views depending on the type are not reasons
 * to reject the ALTER.  (How safe is this really?)
 */</comment>
<function><type><name>void</name></type>
<name>find_composite_type_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>origRelation</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origTypeName</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>depTup</name></decl>;</decl_stmt>

    <comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We scan pg_depend to find those things that depend on the given type.
     * (We assume we can ignore refobjsubid for a type.)
     */</comment>
    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>depScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

        <comment type="block">/* Check for directly dependent types */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>TypeRelationId</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * This must be an array, domain, or range containing the given
             * type, so recursively check for uses of this type.  Note that
             * any error message will mention the original type not the
             * container; this is intentional.
             */</comment>
            <expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
                                             <argument><expr><name>origRelation</name></expr></argument>, <argument><expr><name>origTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Else, ignore dependees that aren't user columns of relations */</comment>
        <comment type="block">/* (we assume system columns are never of interesting types) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
            <name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
            <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
            <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>origTypeName</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because column \"%s.%s\" uses it"</literal></expr></argument>,
                                <argument><expr><name>origTypeName</name></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>origRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because column \"%s.%s\" uses it"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>origRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter foreign table \"%s\" because column \"%s.%s\" uses its row type"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter table \"%s\" because column \"%s.%s\" uses its row type"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * A view or composite type itself isn't a problem, but we must
             * recursively check for indirect dependencies via its rowtype.
             */</comment>
            <expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
                                             <argument><expr><name>origRelation</name></expr></argument>, <argument><expr><name>origTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * find_typed_table_dependencies
 *
 * Check to see if a composite type is being used as the type of a
 * typed table.  Abort if any are found and behavior is RESTRICT.
 * Else return the list of tables.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>find_typed_table_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>classRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_class_reloftype</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_RESTRICT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because it is the type of a typed table"</literal></expr></argument>,
                            <argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER ... CASCADE to alter the typed tables too."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * check_of_type
 *
 * Check whether a type is suitable for CREATE TABLE OF/ALTER TABLE OF.  If it
 * isn't suitable, throw an error.  Currently, we require that the type
 * originated with CREATE TYPE AS.  We could support any row type, but doing so
 * would require handling a number of extra corner cases in the DDL commands.
 */</comment>
<function><type><name>void</name></type>
<name>check_of_type</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>typetuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typ</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typeOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>typeRelation</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>typeRelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>typeOk</name> <operator>=</operator> <operator>(</operator><name><name>typeRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Close the parent rel, but keep our AccessShareLock on it until xact
         * commit.  That will prevent someone else from deleting or ALTERing
         * the type before the typed table creation/conversion commits.
         */</comment>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>typeRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>typeOk</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not a composite type"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE ADD COLUMN
 *
 * Adds an additional attribute to a relation making the assumption that
 * CHECK, NOT NULL, and FOREIGN KEY constraints will be removed from the
 * AT_AddColumn AlterTableCmd by parse_utilcmd.c and added as independent
 * AlterTableCmd's.
 *
 * ADD COLUMN cannot use the normal ALTER TABLE recursion mechanism, because we
 * have to decide at runtime whether to recurse or not depending on whether we
 * actually add a column or merely merge with an existing column.  (We can't
 * check this in a static pre-pass because it won't handle multiple inheritance
 * situations correctly.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>is_view</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column to typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_view</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddColumnRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a column to a table; this handles the AT_AddOids cases as well.  The
 * return value is the address of the new column in the parent relation.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>colDef</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isOid</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>myrelid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pgclass</name></decl>,
                <decl><type ref="prev"/><name>attrdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>reltup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FormData_pg_attribute</name></type> <name>attribute</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>newattnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typeOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>collOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>tform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>defval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
    <if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column to a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attrdesc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Are we adding the column to a recursion child?  If so, check whether to
     * merge with an existing definition for the column.  If we do merge, we
     * must not recurse.  Children will already have the column, and recursing
     * into them would mess up attinhcount.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

        <comment type="block">/* Does child already have a column by this name? */</comment>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>ctypeId</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>ctypmod</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>ccollid</name></decl>;</decl_stmt>

            <comment type="block">/* Child column must match on type, typmod, and collation */</comment>
            <expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ctypeId</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
                <name>ctypmod</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ccollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>ctypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ccollid</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different collation for column \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
                                   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>ccollid</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* If it's OID, child column must actually be OID */</comment>
            <if_stmt><if>if <condition>(<expr><name>isOid</name> <operator>&amp;&amp;</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has a conflicting \"%s\" column"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Bump the existing child att's inhcount */</comment>
            <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Inform the user about the merge */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging definition of column \"%s\" for child \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>relkind</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Cannot add identity column if table has children, because identity does
     * not inherit.  (Adding column and identity separately will work.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name> <operator>&amp;&amp;</operator>
        <name>recurse</name> <operator>&amp;&amp;</operator>
        <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot recursively add identity column to table that has child tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* skip if the name already exists and if_not_exists is true */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_for_column_name_collision</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Determine the new attribute's number */</comment>
    <if_stmt><if>if <condition>(<expr><name>isOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newattnum</name> <operator>=</operator> <name>ObjectIdAttributeNumber</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>newattnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relnatts</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newattnum</name> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
                            <argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>collOid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make sure datatype is legal for a column */</comment>
    <expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>collOid</name></expr></argument>,
                       <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>mls_cls_column_add_check</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* construct new attribute's pg_attribute entry */</comment>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attrelid</name></name> <operator>=</operator> <name>myrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attribute</name><operator>.</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atttypid</name></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attstattarget</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newattnum</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attlen</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atttypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name>newattnum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attbyval</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attndims</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attstorage</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attalign</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attnotnull</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attidentity</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attisdropped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attislocal</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_local</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attinhcount</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attcollation</name></name> <operator>=</operator> <name>collOid</name></expr>;</expr_stmt>
    <comment type="block">/* attribute.attacl is handled by InsertPgAttributeTuple */</comment>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InsertPgAttributeTuple</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attribute</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update pg_class tuple as appropriate
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relhasoids</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relnatts</name> <operator>=</operator> <name>newattnum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Post creation hook for new attribute */</comment>
    <expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make the attribute's catalog entry visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Store the DEFAULT, if any, in the catalogs
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <comment type="block">/*
         * Attempt to skip a complete table rewrite by storing the specified
         * DEFAULT value outside of the heap.  This may be disabled inside
         * AddRelationNewConstraints if the optimization cannot be applied.
         */</comment>
        <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
        <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * This function is intended for CREATE TABLE, so it processes a
         * _list_ of defaults, but we just do one.
         */</comment>
        <expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make the additional catalog changes visible */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <comment type="block">/*
         * Did the request for a missing value work? If not we'll have to do
         * a rewrite
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Tell Phase 3 to fill in the default expression, if there is one.
     *
     * If there is no default, Phase 3 doesn't have to do anything, because
     * that effectively means that the default is NULL.  The heap tuple access
     * routines always check for attnum &gt; # of attributes in tuple, and return
     * NULL if so, so without any modification of the tuple data we will get
     * the effect of NULL values in the new column.
     *
     * An exception occurs when the new column is of a domain type: the domain
     * might have a NOT NULL constraint, or a check constraint that indirectly
     * rejects nulls.  If there are any domain constraints then we construct
     * an explicit NULL default value that will be passed through
     * CoerceToDomain processing.  (This is a tad inefficient, since it causes
     * rewriting the table which we really don't have to do, but the present
     * design of domain processing doesn't offer any simple way of checking
     * the constraints more directly.)
     *
     * Note: we use build_column_default, and not just the cooked default
     * returned by AddRelationNewConstraints, so that the right thing happens
     * when a datatype's default applies.
     *
     * We skip this step completely for views and foreign tables.  For a view,
     * we can only get here from CREATE OR REPLACE VIEW, which historically
     * doesn't set up defaults, not even for domain-typed columns.  And in any
     * case we mustn't invoke Phase 3 on a view or foreign table, since they
     * have no storage.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name>
        <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>defval</name> <operator>&amp;&amp;</operator> <call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>baseTypeId</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>        <name>baseTypeMod</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>baseTypeColl</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>baseTypeColl</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>, <argument><expr><name>baseTypeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>defval</name></expr></argument>,
                                                    <argument><expr><name>baseTypeId</name></expr></argument>,
                                                    <argument><expr><name>typeOid</name></expr></argument>,
                                                    <argument><expr><name>typmod</name></expr></argument>,
                                                    <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                                    <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                                    <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>defval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to coerce base type to domain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>defval</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>NewColumnValue</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewColumnValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>        
        <if_stmt><if>if <condition>(<expr><call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atthasmissing</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If the new column is NOT NULL, and there is no missing value,
             * tell Phase 3 it needs to test that. (Note we don't do this for
             * an OID column.  OID will be marked not null, but since it's
             * filled specially, there's no need to test anything.)
             */</comment>
            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name> <operator>|=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we are adding an OID column, we have to tell Phase 3 to rewrite the
     * table to fix that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Add needed dependency entries for the new column.
     */</comment>
    <expr_stmt><expr><call><name>add_column_datatype_dependency</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_column_collation_dependency</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Propagate to children as appropriate.  Unlike most other ALTER
     * routines, we have to do this one level of recursion at a time; we can't
     * use find_all_inheritors to do it in one pass.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we are told not to recurse, there had better not be any child
     * tables; else the addition would put them out of step.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>children</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column must be added to child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Children should see column as singly inherited */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>colDef</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>colDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>

        <comment type="block">/* find_inheritance_children already got lock */</comment>
        <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Find or create work queue entry for this table */</comment>
        <expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Recurse to child; return value is ignored */</comment>
        <expr_stmt><expr><call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childtab</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
                        <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>isOid</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                        <argument><expr><name>if_not_exists</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If a new or renamed column will collide with the name of an existing
 * column and if_not_exists is false then error out, else do nothing.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_for_column_name_collision</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>attTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>

    <comment type="block">/*
     * this test is deliberately not attisdropped-aware, since if one tries to
     * add a column matching a dropped column name, it's gonna fail anyway.
     */</comment>
    <expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We throw a different error message for conflicts with system column
     * names, since they are normally not shown and the user might otherwise
     * be confused about the reason for the conflict.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name \"%s\" conflicts with a system column name"</literal></expr></argument>,
                        <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>if_not_exists</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already exists, skipping"</literal></expr></argument>,
                            <argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already exists"</literal></expr></argument>,
                        <argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Install a column's dependency on its datatype.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_column_datatype_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
                <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Install a column's dependency on its collation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_column_collation_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
                <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

    <comment type="block">/* We know the default collation is pinned, so don't bother recording it */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>CollationRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>collid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET WITH OIDS
 *
 * Basically this is an ADD COLUMN for the special OID column.  We have
 * to cons up a ColumnDef node because the ADD COLUMN code needs one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddOids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* If we're recursing to a child table, the ColumnDef is already set up */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>cdef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cdef</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddOidsRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN DROP NOT NULL
 *
 * Return the address of the modified column.  If the column was already
 * nullable, InvalidObjectAddress is returned.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If the parent is a partitioned table, like check constraints, we do not
     * support removing the NOT NULL while partitions exist.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partdesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove constraint from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attr_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <comment type="block">/*
     * lookup the attribute
     */</comment>
    <expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>

    <comment type="block">/* Prevent them from altering a system attribute */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>get_attidentity</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is an identity column"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the attribute is not in a primary key
     *
     * Note: we'll throw error even if the pkey index is not valid.
     */</comment>

    <comment type="block">/* Loop over all indexes on the relation */</comment>
    <expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>indexTuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the index is not a primary key, skip the check */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Loop over each attribute in the primary key and see if it
             * matches the to-be-altered attribute
             */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is in a primary key"</literal></expr></argument>,
                                    <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If rel is partition, shouldn't drop NOT NULL if parent has the same */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>parentId</name> <init>= <expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>parent</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>parent_attnum</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>parent_attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>parent_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is marked NOT NULL in parent table"</literal></expr></argument>,
                            <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Okay, actually perform the catalog change ... if needed
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                            <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET NOT NULL
 *
 * Return the address of the modified column.  If the column was already NOT
 * NULL, InvalidObjectAddress is returned.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If the parent is a partitioned table, like check constraints, NOT NULL
     * constraints must be added to the child tables.  Complain if requested
     * otherwise and partitions exist.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>partdesc</name> <operator>&amp;&amp;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add constraint to only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attr_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <comment type="block">/*
     * lookup the attribute
     */</comment>
    <expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>

    <comment type="block">/* Prevent them from altering a system attribute */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Okay, actually perform the catalog change ... if needed
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Tell Phase 3 it needs to test the constraint */</comment>
        <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                            <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET/DROP DEFAULT
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecColumnDefault</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newDefault</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <comment type="block">/*
     * get the number of the attribute
     */</comment>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Prevent them from altering a system attribute */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>get_attidentity</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is an identity column"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <ternary><condition><expr><name>newDefault</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE ... ALTER COLUMN ... DROP IDENTITY instead."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Remove any old default for the column.  We use RESTRICT here for
     * safety, but at present we do not expect anything to depend on the
     * default.
     *
     * We treat removing the existing default as an internal operation when it
     * is preparatory to adding a new default, but as a user-initiated
     * operation when the user asked for a drop.
     */</comment>
    <expr_stmt><expr><call><name>RemoveAttrDefault</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                      <argument><expr><ternary><condition><expr><name>newDefault</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>newDefault</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* SET DEFAULT */</comment>
        <decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>newDefault</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * This function is intended for CREATE TABLE, so it processes a
         * _list_ of defaults, but we just do one.
         */</comment>
        <expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN ADD IDENTITY
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>cdef</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

    <comment type="block">/* Can't alter a system attribute */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Creating a column as identity implies NOT NULL, so adding the identity
     * to an existing column that is not NOT NULL would create a state that
     * cannot be reproduced without contortions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" must be declared NOT NULL before identity can be added"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is already an identity column"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already has a default value"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <name><name>cdef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET { GENERATED or sequence options }
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>generatedEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>castNode(List, def)</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"generated"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>generatedEl</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>generatedEl</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
                 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Even if there is nothing to change here, we run all the checks.  There
     * will be a subsequent ALTER SEQUENCE that relies on everything being
     * there.
     */</comment>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>generatedEl</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <call><name>defGetInt32</name><argument_list>(<argument><expr><name>generatedEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                            <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN DROP IDENTITY
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>seqid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>seqaddress</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column"</literal></expr></argument>,
                            <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column, skipping"</literal></expr></argument>,
                            <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* drop the internal sequence */</comment>
    <expr_stmt><expr><name>seqid</name> <operator>=</operator> <call><name>getOwnedSequence</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>seqid</name></expr></argument>,
                                    <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>seqid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqaddress</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET STATISTICS
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * We do our own permission checking because (a) we want to allow SET
     * STATISTICS on indexes (for expressional index columns), and (b) we want
     * to allow SET STATISTICS on system catalogs without requiring
     * allowSystemTableMods to be turned on.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, index, or foreign table"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We allow referencing columns by numbers only for indexes, since table
	 * column numbers could contain gaps if columns are later dropped.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
	    <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
	    <operator>!</operator><name>colName</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
	            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
	             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refer to non-index column by number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Permissions checks */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                       <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>newtarget</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newtarget</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Limit target to a sane range
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newtarget</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics target %d is too low"</literal></expr></argument>,
                        <argument><expr><name>newtarget</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>newtarget</name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>newtarget</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lowering statistics target to %d"</literal></expr></argument>,
                        <argument><expr><name>newtarget</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
	     <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>&amp;&amp;</operator>
	    <name><name>rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
	            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
	             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter statistics on non-expression column \"%s\" of index \"%s\""</literal></expr></argument>,
	                    <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
	             <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Alter statistics on table column instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>isReset</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>,
                <decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>,
                <decl><type ref="prev"/><name>newOptions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Generate new proposed attoptions (text array) */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attoptions</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
                                     <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>, <argument><expr><name>isReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Validate new options */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>attribute_reloptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build new tuple. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update system catalog. */</comment>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET STORAGE
 *
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>storagemode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>newstorage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>storagemode</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"external"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"extended"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid storage type \"%s\""</literal></expr></argument>,
                        <argument><expr><name>storagemode</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * safety check: do not allow toasted storage modes unless column datatype
     * is TOAST-aware.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newstorage</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <call><name>TypeIsToastable</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name>newstorage</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column data type %s can only have storage PLAIN"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE DROP COLUMN
 *
 * DROP COLUMN cannot use the normal ALTER TABLE recursion mechanism,
 * because we have to decide at runtime whether to recurse or not depending
 * on whether attinhcount goes to zero or not.  (We can't check this in a
 * static pre-pass because it won't handle multiple inheritance situations
 * correctly.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column from typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropColumnRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drops column 'colName' from relation 'rel' and returns the address of the
 * dropped column.  The column is also dropped (or marked as no longer
 * inherited from relation) from the relation's inheritance children, if any.
 *
 * In the recursive invocations for inheritance child relations, instead of
 * dropping the column directly (if to be dropped at all), its object address
 * is added to 'addrs', which must be non-NULL in such invocations.  All
 * columns are dropped at the same time after all the children have been
 * checked recursively.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
				 <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>targetatt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_expr</name></decl>;</decl_stmt>

    <comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
    <if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize addrs on the first invocation */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>recursing</name> <operator>||</operator> <name>addrs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>addrs</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * get the number of the attribute
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                            <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>targetatt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>targetatt</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

    <comment type="block">/* Can't drop a system attribute, except OID */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
	 * Don't drop inherited columns, unless recursing (presumably from a drop
	 * of the parent column)
	 */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>targetatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop inherited column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	* Don't drop columns used in the partition key, either.  (If we let this
	* go through, the key column's dependencies would cause a cascaded drop
	* of the whole table, which is surely not what the user expected.)
	*/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>is_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
		        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column \"%s\" because it is part of the partition key of relation \"%s\""</literal></expr></argument>,
		             <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Don't drop columns used in the interval partition key*/</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column named in interval partition key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Don't drop columns used in distributed key */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationGetDisKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column named in distributed key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_column_permission</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not drop column:%s, cause column has mls poilcy bound"</literal></expr></argument>, 
                    <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Propagate to children as appropriate.  Unlike most other ALTER
     * routines, we have to do this one level of recursion at a time; we can't
     * use find_all_inheritors to do it in one pass.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>children</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>attr_rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

        <comment type="block">/*
         * In case of a partitioned table, the column must be dropped from the
         * partitions as well.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name></decl>;</decl_stmt>

            <comment type="block">/* find_inheritance_children already got lock */</comment>
            <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute \"%s\" of relation %u"</literal></expr></argument>,
                     <argument><expr><name>colName</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>childatt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Time to delete this child column, too */</comment>
                <expr_stmt><expr><call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>,
                                 <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited attribute \"%s\""</literal></expr></argument>,
                     <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If the child column has other definition sources, just
                 * decrement its inheritance count; if not, recurse to delete
                 * it.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Time to delete this child column, too */</comment>
                    <expr_stmt><expr><call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>,
                                     <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Child column must survive my deletion */</comment>
                    <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Make update visible */</comment>
                    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * If we were told to drop ONLY in this table (no recursion),
                 * we need to mark the inheritors' attributes as locally
                 * defined rather than inherited.
                 */</comment>
                <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Make update visible */</comment>
                <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Add object to delete */</comment>
    <expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
	<block>{<block_content>
	   <comment type="block">/* Recursion has ended, drop everything that was collected */</comment>
	   <expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we dropped the OID column, must adjust pg_class.relhasoids and tell
     * Phase 3 to physically get rid of the column.  We formerly left the
     * column in place physically, but this caused subtle problems.  See
     * http://archives.postgresql.org/pgsql-hackers/2009-02/msg00363.php
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>class_rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>tuple_class</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>class_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
                                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
                 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>tuple_class</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Find or create work queue entry for this table */</comment>
        <expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Tell Phase 3 to physically remove the OID column */</comment>
        <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_OID</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>object</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD INDEX
 *
 * There is no such command in the grammar, but parse_utilcmd.c converts
 * UNIQUE and PRIMARY KEY constraints into AT_AddIndex subcommands.  This lets
 * us schedule creation of the index at the appropriate time during ALTER.
 *
 * Return value is the address of the new index.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIndex</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
               <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_rebuild</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>check_rights</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>skip_build</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>quiet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>save_oldnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The IndexStmt has already been through transformIndexStmt */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* suppress schema rights check when rebuilding existing index */</comment>
    <expr_stmt><expr><name>check_rights</name> <operator>=</operator> <operator>!</operator><name>is_rebuild</name></expr>;</expr_stmt>
	<comment type="block">/* if we're resuing an old node */</comment>
	<expr_stmt><expr><name>save_oldnode</name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* skip index build if phase 3 will do it or we're reusing an old one */</comment>
	<expr_stmt><expr><name>skip_build</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>save_oldnode</name></expr>;</expr_stmt>
    <comment type="block">/* suppress notices when rebuilding existing index */</comment>
    <expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>is_rebuild</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>stmt</name></expr></argument>,
                          <argument><expr><name>InvalidOid</name></expr></argument>,    <comment type="block">/* no predefined OID */</comment>
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent index */</comment>
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent constraint */</comment>
                          <argument><expr><name>true</name></expr></argument>, <comment type="block">/* is_alter_table */</comment>
                          <argument><expr><name>check_rights</name></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* check_not_in_use - we did it already */</comment>
                          <argument><expr><name>skip_build</name></expr></argument>,
                          <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* create index on interval partition child table */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>indexOid</name>   <init>= <expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>partidxstmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>nParts</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>RELPARTKIND_PARENT</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>addr</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>partOid</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>referenced</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>partidxstmt</name> <operator>=</operator> <operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>partidxstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>partidxstmt</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>save_oldnode</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>partidxstmt</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partsOldNode</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>partOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>partidxstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>partOid</name></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>DefineIndex</name><argument_list>(<argument><expr><name>partOid</name></expr></argument>,    <comment type="block">/* OID of heap relation */</comment>
                                   <argument><expr><name>partidxstmt</name></expr></argument>,
                                   <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent index */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent constraint */</comment>
                                   <argument><expr><name>true</name></expr></argument>,    <comment type="block">/* is_alter_table */</comment>
                                   <argument><expr><name>check_rights</name></expr></argument>,    <comment type="block">/* check_rights */</comment>
                                   <argument><expr><name>false</name></expr></argument>,    <comment type="block">/* check_not_in_use */</comment>
                                   <argument><expr><name>skip_build</name></expr></argument>,    <comment type="block">/* skip_build */</comment>
                                   <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quiet */</comment>
				<comment type="block">/*
                 * If TryReuseIndex() stashed a relfilenode for us, we used it for the new
                 * index instead of building from scratch.  The DROP of the old edition of
                 * this index will have scheduled the storage for deletion at commit, so
                 * cancel that pending deletion.
                 */</comment>
				<if_stmt><if>if <condition>(<expr><name>save_oldnode</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>irel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>RelationPreserveStorage</name><argument_list>(<argument><expr><name><name>irel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

                <comment type="block">/* Make dependency entries */</comment>
                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <comment type="block">/* Dependency on relation */</comment>
                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>RELPARTKIND_CHILD</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>RELATION_IS_REGULAR</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type> <name>indexOid</name>   <init>= <expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>StoreIntervalPartitionInfo</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>RELPARTKIND_NONE</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If TryReuseIndex() stashed a relfilenode for us, we used it for the new
     * index instead of building from scratch.  The DROP of the old edition of
     * this index will have scheduled the storage for deletion at commit, so
     * cancel that pending deletion.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name>save_oldnode</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>irel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>RelationPreserveStorage</name><argument_list>(<argument><expr><name><name>irel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD CONSTRAINT USING INDEX
 *
 * Returns the address of the new constraint.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIndexConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>index_oid</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>indexOid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indexName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>constraintName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>constraintType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits16</name></type>		<name>flags</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Doing this on partitioned tables is not a simple feature to implement,
	 * so let's punt for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>indexName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this should have been checked at parse time */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" is not unique"</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Determine name to assign to constraint.  We require a constraint to
     * have the same name as the underlying index; therefore, use the index's
     * existing name as the default constraint name, and if the user
     * explicitly gives some other name for the constraint, rename the index
     * to match.
     */</comment>
    <expr_stmt><expr><name>constraintName</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>constraintName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>constraintName</name> <operator>=</operator> <name>indexName</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index \"%s\" to \"%s\""</literal></expr></argument>,
                        <argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Extra checks needed if making primary key */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_check_primary_key</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Note we currently don't support EXCLUSION constraints here */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_PRIMARY</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_UNIQUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Create the catalog entries for the constraint */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>INDEX_CONSTR_CREATE_UPDATE_INDEX</name> <operator>|</operator>
		<name>INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS</name> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>initdeferred</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_INIT_DEFERRED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>deferrable</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_DEFERRABLE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_MARK_AS_PRIMARY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>index_constraint_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                                      <argument><expr><name>index_oid</name></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,
                                      <argument><expr><name>indexInfo</name></expr></argument>,
                                      <argument><expr><name>constraintName</name></expr></argument>,
                                      <argument><expr><name>constraintType</name></expr></argument>,
									  <argument><expr><name>flags</name></expr></argument>,
                                      <argument><expr><name>allowSystemTableMods</name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* is_internal */</comment>

    <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD CONSTRAINT
 *
 * Return value is the address of the new constraint; if no constraint was
 * added, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                    <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>newConstraint</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
                    <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Currently, we only expect to see CONSTR_CHECK and CONSTR_FOREIGN nodes
     * arriving here (see the preprocessing done in parse_utilcmd.c).  Use a
     * switch anyway to make it easier to add more code later.
     */</comment>
    <switch>switch <condition>(<expr><name><name>newConstraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
            <expr_stmt><expr><name>address</name> <operator>=</operator>
                <call><name>ATAddCheckConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                     <argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_readd</name></expr></argument>,
                                     <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ADD ForeignKeyConstraint on interval partition is forbidden"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
            <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator>  <name>LOCATOR_TYPE_REPLICATED</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ADD ForeignKeyConstraint on replication table is forbidden"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*
             * Note that we currently never recurse for FK constraints, so the
             * "recurse" flag is silently ignored.
             *
             * Assign or validate constraint name
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_RELATION</name></expr></argument>,
                                         <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
                                    <argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator>
                    <call><name>ChooseConstraintName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><literal type="string">"fkey"</literal></expr></argument>,
                                         <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATAddForeignKeyConstraint</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newConstraint</name></expr></argument>,
                                                <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>newConstraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a check constraint to a single table and its children.  Returns the
 * address of the constraint added to the parent relation, if one gets added,
 * or InvalidObjectAddress otherwise.
 *
 * Subroutine for ATExecAddConstraint.
 *
 * We must recurse to child tables during execution, rather than using
 * ALTER TABLE's normal prep-time recursion.  The reason is that all the
 * constraints *must* be given the same name, else they won't be seen as
 * related later.  If the user didn't explicitly specify a name, then
 * AddRelationNewConstraints would normally assign different names to the
 * child constraints.  To fix that, we must capture the name assigned at
 * the parent table and pass that down.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATAddCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                     <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newcons</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcon</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
    <if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Call AddRelationNewConstraints to do the work, making sure it works on
     * a copy of the Constraint so transformExpr can't modify the original. It
     * returns a list of cooked constraints.
     *
     * If the constraint ends up getting merged with a pre-existing one, it's
     * omitted from the returned list, which is what we want: we do not need
     * to do any validation work.  That can only happen at child tables,
     * though, since we disallow merging at the top level.
     */</comment>
    <expr_stmt><expr><name>newcons</name> <operator>=</operator> <call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
                                        <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>recursing</name> <operator>|</operator> <name>is_readd</name></expr></argument>,    <comment type="block">/* allow_merge */</comment>
                                        <argument><expr><operator>!</operator><name>recursing</name></expr></argument>, <comment type="block">/* is_local */</comment>
                                        <argument><expr><name>is_readd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* is_internal */</comment>

    <comment type="block">/* we don't expect more than one constraint here */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>newcons</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add each to-be-validated constraint to Phase 3's queue */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lcon</argument>, <argument>newcons</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>ccon</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ccon</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Save the actually assigned name if it was defaulted */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* At this point we must have a locked-down name to use */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Advance command counter in case same table is visited multiple times */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the constraint got merged with an existing constraint, we're done.
     * We mustn't recurse to child tables in this case, because they've
     * already got the constraint, and visiting them again would lead to an
     * incorrect value for coninhcount.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newcons</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>address</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* add constraint to interval partition child tables */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>

            <comment type="block">/* find_inheritance_children already got lock */</comment>
            <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Find or create work queue entry for this table */</comment>
            <expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Recurse to child */</comment>
            <expr_stmt><expr><call><name>ATAddCheckConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childtab</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
                                 <argument><expr><name>constr</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_readd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If adding a NO INHERIT constraint, no need to find our children.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>address</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Propagate to children as appropriate.  Unlike most other ALTER
     * routines, we have to do this one level of recursion at a time; we can't
     * use find_all_inheritors to do it in one pass.
     */</comment>
    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check if ONLY was specified with ALTER TABLE.  If so, allow the
     * constraint creation only if there are no children currently.  Error out
     * otherwise.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name> <operator>&amp;&amp;</operator> <name>children</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint must be added to child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>

        <comment type="block">/* find_inheritance_children already got lock */</comment>
        <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Find or create work queue entry for this table */</comment>
        <expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Recurse to child */</comment>
        <expr_stmt><expr><call><name>ATAddCheckConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childtab</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
                             <argument><expr><name>constr</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_readd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a foreign-key constraint to a single table; return the new constraint's
 * address.
 *
 * Subroutine for ATExecAddConstraint.  Must already hold exclusive
 * lock on the rel, and have done appropriate validity checks for it.
 * We do permissions checks here, however.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATAddForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                          <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pkrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name><name>pkattnum</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name><name>fkattnum</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>pktypoid</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>fktypoid</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>opclasses</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>pfeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>ppeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name><name>ffeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numfks</name></decl>,
                <decl><type ref="prev"/><name>numpks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>indexOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>constrOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>old_check_ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>old_pfeqop_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Grab ShareRowExclusiveLock on the pk table, so that someone doesn't
     * delete rows out from under us.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_pktable_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pkrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_pktable_oid</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>pkrel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Validity checks (permission checks wait till we have the column
     * numbers)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reference partitioned table \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referenced relation \"%s\" is not a table"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * References from permanent or unlogged tables to temp tables, and from
     * permanent tables to unlogged tables, are disallowed because the
     * referenced data can vanish out from under us.  References from temp
     * tables to any other table type are also disallowed, because other
     * backends might need to run the RI triggers on the perm table, but they
     * can't reliably see tuples in the local buffers of other backends.
     */</comment>
    <switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on permanent tables may reference only permanent tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name>
                <operator>&amp;&amp;</operator> <name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on unlogged tables may reference only permanent or unlogged tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on temporary tables may reference only temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pkrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>||</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on temporary tables must involve temporary tables of this session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>||</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deferrable constraint on shard table is not supported."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Look up the referencing attributes to make sure they exist, and record
     * their attnums and type OIDs.
     */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pkattnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fkattnum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fkattnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pktypoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pktypoid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fktypoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fktypoid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opclasses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pfeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pfeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ppeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ppeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ffeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>numfks</name> <operator>=</operator> <call><name>transformColumnNameList</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>,
                                     <argument><expr><name>fkattnum</name></expr></argument>, <argument><expr><name>fktypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the attribute list for the referenced table was omitted, lookup the
     * definition of the primary key and use it.  Otherwise, validate the
     * supplied attribute list.  In either case, discover the index OID and
     * index opclasses, and the attnums and type OIDs of the attributes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>numpks</name> <operator>=</operator> <call><name>transformFkeyGetPrimaryKey</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexOid</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>,
                                            <argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>pktypoid</name></expr></argument>,
                                            <argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>numpks</name> <operator>=</operator> <call><name>transformColumnNameList</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>,
                                         <argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>pktypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Look for an index matching the column list */</comment>
        <expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>transformFkeyCheckAttrs</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>numpks</name></expr></argument>, <argument><expr><name>pkattnum</name></expr></argument>,
                                           <argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Now we can check permissions.
     */</comment>
    <expr_stmt><expr><call><name>checkFkeyPermissions</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>numpks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Look up the equality operators to use in the constraint.
     *
     * Note that we have to be careful about the difference between the actual
     * PK column type and the opclass' declared input type, which might be
     * only binary-compatible with it.  The declared opcintype is the right
     * thing to probe pg_amop with.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numfks</name> <operator>!=</operator> <name>numpks</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of referencing and referenced columns for foreign key disagree"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * On the strength of a previous constraint, we might avoid scanning
     * tables to validate this one.  See below.
     */</comment>
    <expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>old_check_ok</name> <operator>||</operator> <name>numfks</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numpks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>pktype</name> <init>= <expr><name><name>pktypoid</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>fktype</name> <init>= <expr><name><name>fktypoid</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>fktyped</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>cla_ht</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>amid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opfamily</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opcintype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>pfeqop</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>ppeqop</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>ffeqop</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>eqstrategy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>pfeqop_right</name></decl>;</decl_stmt>

        <comment type="block">/* We need several fields out of the pg_opclass entry */</comment>
        <expr_stmt><expr><name>cla_ht</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>amid</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcmethod</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>opcintype</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check it's a btree; currently this can never fail since no other
         * index AMs support unique indexes.  If we ever did have other types
         * of unique indexes, we'd need a way to determine which operator
         * strategy number is equality.  (Is it reasonable to insist that
         * every such index AM use btree's number for equality?)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>amid</name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only b-tree indexes are supported for foreign keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>eqstrategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>

        <comment type="block">/*
         * There had better be a primary equality operator for the index.
         * We'll use it for PK = PK comparisons.
         */</comment>
        <expr_stmt><expr><name>ppeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>,
                                     <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ppeqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
                 <argument><expr><name>eqstrategy</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Are there equality operators that take exactly the FK type? Assume
         * we should look through any domain here.
         */</comment>
        <expr_stmt><expr><name>fktyped</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>fktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pfeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>,
                                     <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>fktyped</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ffeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>,
                                         <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* keep compiler quiet */</comment>
            <expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ffeqop</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ffeqop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Otherwise, look for an implicit cast from the FK type to the
             * opcintype, and if found, use the primary equality operator.
             * This is a bit tricky because opcintype might be a polymorphic
             * type such as ANYARRAY or ANYENUM; so what we have to test is
             * whether the two actual column types can be concurrently cast to
             * that type.  (Otherwise, we'd fail to reject combinations such
             * as int[] and point[].)
             */</comment>
            <decl_stmt><decl><type><name>Oid</name></type>            <name><name>input_typeids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name><name>target_typeids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>input_typeids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pktype</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>input_typeids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>fktype</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>target_typeids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>target_typeids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>input_typeids</name></expr></argument>, <argument><expr><name>target_typeids</name></expr></argument>,
                                <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>pfeqop</name> <operator>=</operator> <name>ffeqop</name> <operator>=</operator> <name>ppeqop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ffeqop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraint \"%s\" "</literal>
                            <literal type="string">"cannot be implemented"</literal></expr></argument>,
                            <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key columns \"%s\" and \"%s\" "</literal>
                               <literal type="string">"are of incompatible types: %s and %s."</literal></expr></argument>,
                               <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>fktype</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>pktype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>old_check_ok</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * When a pfeqop changes, revalidate the constraint.  We could
             * permit intra-opfamily changes, but that adds subtle complexity
             * without any concrete benefit for core types.  We need not
             * assess ppeqop or ffeqop, which RI_Initial_Check() does not use.
             */</comment>
            <expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name>pfeqop</name> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>old_pfeqop_item</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>old_pfeqop_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>old_pfeqop_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>old_check_ok</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>old_fktype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>new_fktype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>old_pathtype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>new_pathtype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>old_castfunc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>new_castfunc</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Identify coercion pathways from each of the old and new FK-side
             * column types to the right (foreign) operand type of the pfeqop.
             * We may assume that pg_constraint.conkey is not changing.
             */</comment>
            <expr_stmt><expr><name>old_fktype</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name><name>fkattnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_fktype</name> <operator>=</operator> <name>fktype</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>old_pathtype</name> <operator>=</operator> <call><name>findFkeyCast</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>, <argument><expr><name>old_fktype</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>old_castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_pathtype</name> <operator>=</operator> <call><name>findFkeyCast</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>, <argument><expr><name>new_fktype</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>new_castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Upon a change to the cast from the FK column to its pfeqop
             * operand, revalidate the constraint.  For this evaluation, a
             * binary coercion cast is equivalent to no cast at all.  While
             * type implementors should design implicit casts with an eye
             * toward consistency of operations like equality, we cannot
             * assume here that they have done so.
             *
             * A function with a polymorphic argument could change behavior
             * arbitrarily in response to get_fn_expr_argtype().  Therefore,
             * when the cast destination is polymorphic, we only avoid
             * revalidation if the input type has not changed at all.  Given
             * just the core data types and operator classes, this requirement
             * prevents no would-be optimizations.
             *
             * If the cast converts from a base type to a domain thereon, then
             * that domain type must be the opcintype of the unique index.
             * Necessarily, the primary key column must then be of the domain
             * type.  Since the constraint was previously valid, all values on
             * the foreign side necessarily exist on the primary side and in
             * turn conform to the domain.  Consequently, we need not treat
             * domains specially here.
             *
             * Since we require that all collations share the same notion of
             * equality (which they do, because texteq reduces to bitwise
             * equality), we don't compare collation here.
             *
             * We need not directly consider the PK type.  It's necessarily
             * binary coercible to the opcintype of the unique index column,
             * and ri_triggers.c will only deal with PK datums in terms of
             * that opcintype.  Changing the opcintype also changes pfeqop.
             */</comment>
            <expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name>new_pathtype</name> <operator>==</operator> <name>old_pathtype</name> <operator>&amp;&amp;</operator>
                            <name>new_castfunc</name> <operator>==</operator> <name>old_castfunc</name> <operator>&amp;&amp;</operator>
                            <operator>(</operator><operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>)</argument_list></call> <operator>||</operator>
                             <name>new_fktype</name> <operator>==</operator> <name>old_fktype</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>pfeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pfeqop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ppeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ppeqop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ffeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ffeqop</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Record the FK constraint in pg_constraint.
     */</comment>
    <expr_stmt><expr><name>constrOid</name> <operator>=</operator> <call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,
                                      <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>,
                                      <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr></argument>,
                                      <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr></argument>,
                                      <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initially_valid</name></name></expr></argument>,
                                      <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>fkattnum</name></expr></argument>,
                                      <argument><expr><name>numfks</name></expr></argument>,
                                      <argument><expr><name>InvalidOid</name></expr></argument>,    <comment type="block">/* not a domain constraint */</comment>
                                      <argument><expr><name>indexOid</name></expr></argument>,
                                      <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>pkattnum</name></expr></argument>,
                                      <argument><expr><name>pfeqoperators</name></expr></argument>,
                                      <argument><expr><name>ppeqoperators</name></expr></argument>,
                                      <argument><expr><name>ffeqoperators</name></expr></argument>,
                                      <argument><expr><name>numpks</name></expr></argument>,
                                      <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>,
                                      <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>,
                                      <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_matchtype</name></name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no exclusion constraint */</comment>
                                      <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no check constraint */</comment>
                                      <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><name>true</name></expr></argument>, <comment type="block">/* islocal */</comment>
                                      <argument><expr><literal type="number">0</literal></expr></argument>,    <comment type="block">/* inhcount */</comment>
                                      <argument><expr><name>true</name></expr></argument>, <comment type="block">/* isnoinherit */</comment>
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* is_internal */</comment>
    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the triggers that will enforce the constraint.
     */</comment>
    <expr_stmt><expr><call><name>createForeignKeyTriggers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>,
                             <argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Tell Phase 3 to check that the constraint is satisfied by existing
     * rows. We can skip this during table creation, when requested explicitly
     * by specifying NOT VALID in an ADD FOREIGN KEY command, and when we're
     * recreating a constraint following a SET DATA TYPE operation that did
     * not impugn its validity.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_check_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_FOREIGN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refindid</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <name>constrOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fkconstraint</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Close pk table, but keep lock until we've committed.
     */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER CONSTRAINT
 *
 * Update the attributes of a constraint.
 *
 * Currently only works for Foreign Key constraints.
 * Foreign keys do not inherit, so we purposely ignore the
 * recursion bit here, but we keep the API the same for when
 * other constraint types are supported.
 *
 * If the constraint is modified, returns its address; otherwise, return
 * InvalidObjectAddress.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>cmdcon</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>conrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>contuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>currcon</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmdcon</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find and check the target constraint
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
                <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>contuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>currcon</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>currcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>currcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" is not a foreign key constraint"</literal></expr></argument>,
                        <argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>currcon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>||</operator>
        <name><name>currcon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>copyTuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tgtuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>otherrelids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>tgkey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>tgrel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Now update the catalog, while we have the door open.
         */</comment>
        <expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>copy_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>,
                                  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now we need to update the multiple entries in pg_trigger that
         * implement the constraint.
         */</comment>
        <expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tgkey</name></expr></argument>,
                    <argument><expr><name>Anum_pg_trigger_tgconstraint</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerConstraintIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tgkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tgtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>tgform</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>copy_tg</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Remember OIDs of other relation(s) involved in FK constraint.
             * (Note: it's likely that we could skip forcing a relcache inval
             * for other rels that don't have a trigger whose properties
             * change, but let's be conservative.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tgform</name><operator>-&gt;</operator><name>tgrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>otherrelids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>otherrelids</name></expr></argument>,
                                                     <argument><expr><name><name>tgform</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Update deferrability of RI_FKey_noaction_del,
             * RI_FKey_noaction_upd, RI_FKey_check_ins and RI_FKey_check_upd
             * triggers, but not others; see createForeignKeyTriggers and
             * CreateFKCheckTrigger.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_NOACTION_DEL</name> <operator>&amp;&amp;</operator>
                <name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_NOACTION_UPD</name> <operator>&amp;&amp;</operator>
                <name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_CHECK_INS</name> <operator>&amp;&amp;</operator>
                <name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_CHECK_UPD</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>copy_tg</name> <operator>=</operator> <operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>copy_tg</name><operator>-&gt;</operator><name>tgdeferrable</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>copy_tg</name><operator>-&gt;</operator><name>tginitdeferred</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>,
                                      <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Invalidate relcache so that others see the new attributes.  We must
         * inval both the named rel and any others having relevant triggers.
         * (At present there should always be exactly one other rel, but
         * there's no need to hard-wire such an assumption here.)
         */</comment>
        <expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>otherrelids</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>,
                         <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE VALIDATE CONSTRAINT
 *
 * XXX The reason we handle recursion here rather than at Phase 1 is because
 * there's no good way to skip recursing when handling foreign keys: there is
 * no need to lock children in that case, yet we wouldn't be able to avoid
 * doing so at that level.
 *
 * Return value is the address of the validated constraint.  If the constraint
 * was already validated, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecValidateConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>conrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find and check the target constraint
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
                <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>constrName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
        <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" is not a foreign key or check constraint"</literal></expr></argument>,
                        <argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>copyTuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>refrel</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Triggers are already in place on both tables, so a concurrent
             * write that alters the result here is not possible. Normally we
             * can run a query here to do the validation, which would only
             * require AccessShareLock. In some cases, it is possible that we
             * might need to fire triggers to perform the check, so we take a
             * lock at RowShareLock level just in case.
             */</comment>
            <expr_stmt><expr><name>refrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>validateForeignKeyConstraint</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>refrel</name></expr></argument>,
                                         <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>,
                                         <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>refrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Foreign keys do not inherit, so we purposely ignore the
             * recursion bit here
             */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

            <comment type="block">/*
             * If we're recursing, the parent has already done this, so skip
             * it.  Also, if the constraint is a NO INHERIT constraint, we
             * shouldn't try to look for it in the children.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * For CHECK constraints, we must ensure that we only mark the
             * constraint as validated on the parent if it's already validated
             * on the children.
             *
             * We recurse before validating on the parent, to reduce risk of
             * deadlocks.
             */</comment>
            <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>childoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>childoid</name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If we are told not to recurse, there had better not be any
                 * child tables, because we can't mark the constraint on the
                 * parent valid unless it is valid for all child tables.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint must be validated on child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* find_all_inheritors already got lock */</comment>
                <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childoid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><call><name>validateCheckConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Invalidate relcache so that others see the new validated
             * constraint.
             */</comment>
            <expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Now update the catalog, while we have the door open.
         */</comment>
        <expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>copy_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>,
                                  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>,
                         <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* already validated */</comment>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformColumnNameList - transform list of column names
 *
 * Lookup each name and return its attnum and type OID
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>transformColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colList</name></decl></parameter>,
                        <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>colList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>atttuple</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" referenced in foreign key constraint does not exist"</literal></expr></argument>,
                            <argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;=</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have more than %d keys in a foreign key"</literal></expr></argument>,
                            <argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>attnums</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>atttypids</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>attnum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFkeyGetPrimaryKey -
 *
 *    Look up the names, attnums, and types of the primary key attributes
 *    for the pkrel.  Also return the index OID and index opclasses of the
 *    index supporting the primary key.
 *
 *    All parameters except pkrel are output parameters.  Also, the function
 *    return value is the number of attributes in the primary key.
 *
 *    Used when the column list in the REFERENCES specification is omitted.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>transformFkeyGetPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indexOid</name></decl></parameter>,
                           <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
                           <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>indexTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>indclassDatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get the list of index OIDs for the table from the relcache, and look up
     * each one in the pg_index syscache until we find one marked primary key
     * (hopefully there isn't more than one such).  Insist it's valid, too.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>indexOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>&amp;&amp;</operator> <call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Refuse to use a deferrable primary key.  This is per SQL spec,
             * and there would be a lot of interesting semantic problems if we
             * tried to allow it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexStruct</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use a deferrable primary key for referenced table \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>*</operator><name>indexOid</name> <operator>=</operator> <name>indexoid</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check that we found it
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no primary key for referenced table \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Must get indclass the hard way */</comment>
    <expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>,
                                    <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now build the list of PK attributes from the indkey definition (we
     * assume a primary key cannot have expressional elements)
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>attnamelist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>pkattno</name> <init>= <expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pkattno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>atttypids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>attnumTypeId</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>attnamelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>attnamelist</name></expr></argument>,
                               <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>attnumAttName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFkeyCheckAttrs -
 *
 *    Make sure that the attributes of a referenced table belong to a unique
 *    (or primary key) constraint.  Return the OID of the index supporting
 *    the constraint, as well as the opclasses associated with the index
 *    columns.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>transformFkeyCheckAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
                        <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list> <comment type="block">/* output parameter */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>indexoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found_deferrable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Reject duplicate appearances of columns in the referenced-columns list.
     * Such a case is forbidden by the SQL standard, and even if we thought it
     * useful to allow it, there would be ambiguity about how to match the
     * list to unique indexes (in particular, it'd be unclear which index
     * opclass goes with which FK column).
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>attnums</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key referenced-columns list must not contain duplicates"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/*
     * Get the list of index OIDs for the table from the relcache, and look up
     * each one in the pg_index syscache, and match unique indexes to the list
     * of attnums we are given.
     */</comment>
    <expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>indexTuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>indexoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Must have the right number of columns; must be unique and not a
         * partial index; forget it if there are any expressions, too. Invalid
         * indexes are out as well.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indnatts</name></name> <operator>==</operator> <name>numattrs</name> <operator>&amp;&amp;</operator>
            <name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator>
            <call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>heap_attisnull</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>heap_attisnull</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>indclassDatum</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>

            <comment type="block">/* Must get indclass the hard way */</comment>
            <expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>,
                                            <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The given attnum list may match the index columns in any order.
             * Check for a match, and extract the appropriate opclasses while
             * we're at it.
             *
             * We know that attnums[] is duplicate-free per the test at the
             * start of this function, and we checked above that the number of
             * index columns agrees, so if we find a match for each attnums[]
             * entry then we must have a one-to-one match in some order.
             */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * Refuse to use a deferrable unique/primary key.  This is per SQL
             * spec, and there would be a lot of interesting semantic problems
             * if we tried to allow it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexStruct</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Remember that we found an otherwise matching index, so that
                 * we can generate a more appropriate error message.
                 */</comment>
                <expr_stmt><expr><name>found_deferrable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>found_deferrable</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use a deferrable unique constraint for referenced table \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no unique constraint matching given keys for referenced table \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>indexoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findFkeyCast -
 *
 *    Wrapper around find_coercion_pathway() for ATAddForeignKeyConstraint().
 *    Caller has equal regard for binary coercibility and for an exact match.
*/</comment>
<function><type><specifier>static</specifier> <name>CoercionPathType</name></type>
<name>findFkeyCast</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>sourceTypeId</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>sourceTypeId</name></expr></argument>,
                                    <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>COERCION_PATH_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* A previously-relied-upon cast is now gone. */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find cast from %u to %u"</literal></expr></argument>,
                 <argument><expr><name>sourceTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Permissions checks on the referenced table for ADD FOREIGN KEY
 *
 * Note: we have already checked that the user owns the referencing table,
 * else we'd have failed much earlier; no additional checks are needed for it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkFkeyPermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>roleid</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Okay if we have relation-level REFERENCES permission */</comment>
    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
                                  <argument><expr><name>ACL_REFERENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>==</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Else we must have REFERENCES on each column */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                          <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ACL_REFERENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the existing rows in a table to verify they meet a proposed
 * CHECK constraint.
 *
 * The caller must have opened and locked the relation appropriately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateCheckConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>constrtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>conbin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>origexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>

    <comment type="block">/*
     * VALIDATE CONSTRAINT is a no-op for foreign tables and partitioned
     * tables.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>constrForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constrtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * XXX this tuple doesn't really come from a syscache, but this doesn't
     * matter to SysCacheGetAttr, because it only wants to be able to fetch
     * the tupdesc
     */</comment>
    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>constrtup</name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>,
             <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>constrtup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>conbin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>origexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>conbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>origexpr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Switch to per-tuple memory context and reset it for each tuple
     * produced, so we don't leak memory.
     */</comment>
    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint \"%s\" is violated by some row"</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the existing rows in a table to verify they meet a proposed FK
 * constraint.
 *
 * Caller must have opened and locked both relations appropriately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>,
                             <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                             <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
                             <parameter><decl><type><name>Oid</name></type> <name>pkindOid</name></decl></parameter>,
                             <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Trigger</name></type>        <name>trig</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"validating foreign key constraint \"%s\""</literal></expr></argument>, <argument><expr><name>conname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * No need to do the same thing on the other coordinator. Its enough to
     * check constraint on the datanodes and at all on just one coordinator
     * if we ever support coordinator only relations
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_REMOTE_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Build a trigger call structure; we'll need it either way.
     */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgname</name></name> <operator>=</operator> <name>conname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgenabled</name></name> <operator>=</operator> <name>TRIGGER_FIRES_ON_ORIGIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgisinternal</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrindid</name></name> <operator>=</operator> <name>pkindOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstraint</name></name> <operator>=</operator> <name>constraintOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgdeferrable</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tginitdeferred</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <comment type="block">/* we needn't fill in remaining fields */</comment>

    <comment type="block">/*
     * See if we can do it with a single LEFT JOIN query.  A FALSE result
     * indicates we must proceed with the fire-the-trigger method.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RI_Initial_Check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Scan through each tuple, calling RI_FKey_check_ins (insert trigger) as
     * if that tuple had just been inserted.  If any of those fail, it should
     * ereport(ERROR) and that's that.
     */</comment>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>fcinfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TriggerData</name></type> <name>trigdata</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Make a call to the trigger function
         *
         * No parameters are passed, but we do set a context
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We assume RI_FKey_check_ins won't look at flinfo...
         */</comment>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>|</operator> <name>TRIGGER_EVENT_ROW</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <operator>&amp;</operator><name>trig</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigtuplebuf</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_newtuplebuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>context</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>trigdata</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>RI_FKey_check_ins</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateFKCheckTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>on_insert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>fk_trigger</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Note: for a self-referential FK (referencing and referenced tables are
     * the same), it is important that the ON UPDATE action fires before the
     * CHECK action, since both triggers will fire on the same row during an
     * UPDATE event; otherwise the CHECK trigger will be checking a non-final
     * state of the row.  Triggers fire in name order, so we ensure this by
     * using names like "RI_ConstraintTrigger_a_NNNN" for the action triggers
     * and "RI_ConstraintTrigger_c_NNNN" for the check triggers.
     */</comment>
    <expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_c"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>

    <comment type="block">/* Either ON INSERT or ON UPDATE */</comment>
    <if_stmt><if>if <condition>(<expr><name>on_insert</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_check_ins"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_INSERT</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_check_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
                         <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make changes-so-far visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the triggers that implement an FK constraint.
 *
 * NB: if you change any trigger properties here, see also
 * ATExecAlterConstraint.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>createForeignKeyTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>myRelOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>fk_trigger</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>myRelOid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make changes-so-far visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON
     * DELETE action on the referenced table.
     */</comment>
    <expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_a"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_DELETE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_noaction_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_restrict_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_cascade_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setnull_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setdefault_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized FK action type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
                         <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make changes-so-far visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON
     * UPDATE action on the referenced table.
     */</comment>
    <expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_a"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_noaction_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_restrict_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_cascade_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setnull_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setdefault_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized FK action type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
                         <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make changes-so-far visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build and execute CREATE CONSTRAINT TRIGGER statements for the CHECK
     * action for both INSERTs and UPDATEs on the referencing table.
     */</comment>
    <expr_stmt><expr><call><name>CreateFKCheckTrigger</name><argument_list>(<argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
                         <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CreateFKCheckTrigger</name><argument_list>(<argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
                         <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE DROP CONSTRAINT
 *
 * Like DROP COLUMN, we can't use the normal ALTER TABLE recursion mechanism.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
                     <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>conrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_no_inherit_constraint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>check_constraint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
    <if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find and drop the target constraint
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
                <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>conobj</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>constrName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Don't drop inherited constraints */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop inherited constraint \"%s\" of relation \"%s\""</literal></expr></argument>,
                            <argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* only handle check, primary, unique constraint */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name> <operator>&amp;&amp;</operator>
                <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_PRIMARY</name> <operator>&amp;&amp;</operator>
                <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_UNIQUE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop constraint \"%s\" of interval partition \"%s\","</literal>
                                <literal type="string">"only drop check,primary key,unique is allowed on interval partition"</literal></expr></argument>,
                                <argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>check_constraint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>is_no_inherit_constraint</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * If it's a foreign-key constraint, we'd better lock the referenced
         * table and check that that's not in use, just as we've already done
         * for the constrained table (else we might, eg, be dropping a trigger
         * that has unfired events).  But we can/must skip that in the
         * self-referential case.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
            <name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>frel</name></decl>;</decl_stmt>

            <comment type="block">/* Must match lock taken by RemoveTriggerById: */</comment>
            <expr_stmt><expr><name>frel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Perform the actual constraint deletion
         */</comment>
        <expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ConstraintRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conobj</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* constraint found and dropped -- no need to keep looping */</comment>
        <break>break;</break>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                            <argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>check_constraint</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>children</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Propagate to children as appropriate.  Unlike most other ALTER
     * routines, we have to do this one level of recursion at a time; we can't
     * use find_all_inheritors to do it in one pass.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_no_inherit_constraint</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * For a partitioned table, if partitions exist and we are told not to
     * recurse, it's a user error.  It doesn't make sense to have a constraint
     * be defined only on the parent, especially if it's a partitioned table.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
        <name>children</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove constraint from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>copy_tuple</name></decl>;</decl_stmt>

        <comment type="block">/* find_inheritance_children already got lock */</comment>
        <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
                    <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                                  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* scan for matching tuple - there should only be one */</comment>
        <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Right now only CHECK constraints can be inherited */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>constrName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name>constrName</name></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>copy_tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Time to delete this child constraint, too */</comment>
            <expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>,
                                 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited constraint \"%s\""</literal></expr></argument>,
                 <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If the child constraint has other definition sources, just
             * decrement its inheritance count; if not, recurse to delete it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Time to delete this child constraint, too */</comment>
                <expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>,
                                     <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Child constraint must survive my deletion */</comment>
                <expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Make update visible */</comment>
                <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * If we were told to drop ONLY in this table (no recursion), we
             * need to mark the inheritors' constraints as locally defined
             * rather than inherited.
             */</comment>
            <expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Make update visible */</comment>
            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLUMN TYPE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAlterColumnType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
                      <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
                      <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>transform</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>targettype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>targettypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>targetcollid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_expr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter column type of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* lookup the attribute so we can check inheritance status */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

    <comment type="block">/* Can't alter a system attribute */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Don't alter inherited columns */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter inherited column \"%s\""</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Don't alter columns used in the partition key */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>is_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter column \"%s\" because it is part of the partition key of relation \"%s\""</literal></expr></argument>,
                       <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* could not alter partition column of interval partition */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of column named in interval partition key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
    <comment type="block">/* could not alter distribute column */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationGetDisKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of column named in distributed key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Look up the target type */</comment>
    <expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* And the collation */</comment>
    <expr_stmt><expr><name>targetcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make sure datatype is legal for a column */</comment>
    <expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name>colName</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targetcollid</name></expr></argument>,
                       <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
        <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Set up an expression to transform the old data value to the new
         * type. If a USING option was given, use the expression as
         * transformed by transformAlterTableStmt, else just take the old
         * value and try to coerce it.  We do this first so that type
         * incompatibility can be detected before we waste effort, and because
         * we need the expression to be parsed against the original table row
         * type.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>transform</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>transform</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
                                         <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
                                         <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
                                         <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>transform</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                          <argument><expr><name>transform</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
                                          <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                          <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                          <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>transform</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* error text depends on whether USING was specified or not */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"result of USING clause for column \"%s\""</literal>
                                <literal type="string">" cannot be cast automatically to type %s"</literal></expr></argument>,
                                <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to add an explicit cast."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" cannot be cast automatically to type %s"</literal></expr></argument>,
                                <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                <comment type="block">/* translator: USING is SQL, don't translate it */</comment>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to specify \"USING %s::%s\"."</literal></expr></argument>,
                                 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>,
                                                          <argument><expr><name>targettypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Fix collations after all else */</comment>
        <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Plan the expr now so we can accurately assess the need to rewrite. */</comment>
        <expr_stmt><expr><name>transform</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Add a work queue item to make ATRewriteTable update the column
         * contents.
         */</comment>
        <expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>NewColumnValue</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewColumnValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>transform</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ATColumnChangeRequiresRewrite</name><argument_list>(<argument><expr><name>transform</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_COLUMN_REWRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>transform</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
        <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For composite types, do this check now.  Tables will check it later
         * when the table is being rewritten.
         */</comment>
        <expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Recurse manually by queueing a new command for each child, if
     * necessary. We cannot apply ATSimpleRecursion here because we need to
     * remap attribute numbers in the USING expression, if any.
     *
     * If we are told not to recurse, there had better not be any child
     * tables; else the alter would put them out of step.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Recurse manually by queueing a new command for each interval partition child */</comment>
    <if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>||</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * find_all_inheritors does the recursive search of the inheritance
         * hierarchy, so all we have to do is process all of the relids in the
         * list that it returns.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* find_all_inheritors already got lock */</comment>
            <expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Remap the attribute numbers.  If no USING expression was
             * specified, there is no need for this step.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>found_whole_row</name></decl>;</decl_stmt>

                <comment type="block">/* create a copy to scribble on */</comment>
                <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>cooked_default</name> <operator>=</operator>
                    <call><name>map_variable_attnos</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></argument>,
                                        <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                        <argument><expr><name>attmap</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
                                        <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"USING expression contains a whole-row table reference."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator>
             <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of inherited column \"%s\" must be changed in child tables too"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When the data type of a column is changed, a rewrite might not be required
 * if the new type is sufficiently identical to the old one, and the USING
 * clause isn't trying to insert some other value.  It's safe to skip the
 * rewrite if the old type is binary coercible to the new type, or if the
 * new type is an unconstrained domain over the old type.  In the case of a
 * constrained domain, we could get by with scanning the table and checking
 * the constraint rather than actually rewriting it, but we don't currently
 * try to do that.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ATColumnChangeRequiresRewrite</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* only one varno, so no need to check that */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>varattno</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLUMN .. SET DATA TYPE
 *
 * Return the address of the modified column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterColumnType</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>heapTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typeTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_type</name></type> <name>tform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>targettype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>targettypmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>targetcollid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>defaultexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>depTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Look up the target column */</comment>
    <expr_stmt><expr><name>heapTup</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

    <comment type="block">/* Check for multiple ALTER TYPE on same column --- can't cope */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name> <operator>||</operator>
        <name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of column \"%s\" twice"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_column_permission</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not alter column:%s type, cause column has mls poilcy bound"</literal></expr></argument>, 
                    <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Look up the target type (should not fail, since prep found it) */</comment>
    <expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>targettype</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* And the collation */</comment>
    <expr_stmt><expr><name>targetcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there is a default expression for the column, get it and ensure we
     * can coerce it to the new datatype.  (We must do this before changing
     * the column type, because build_column_default itself will try to
     * coerce, and will not issue the error message we want if it fails.)
     *
     * We remove any implicit coercion steps at the top level of the old
     * default expression; this has been agreed to satisfy the principle of
     * least surprise.  (The conversion to the new column type should act like
     * it started from what the user sees as the stored expression, and the
     * implicit coercions aren't going to be shown.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* no UNKNOWN params */</comment>
                                            <argument><expr><name>defaultexpr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
                                            <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                            <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
                                            <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>defaultexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"default for column \"%s\" cannot be cast automatically to type %s"</literal></expr></argument>,
                            <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Find everything that depends on the column (constraints, indexes, etc),
     * and record enough information to let us recreate the objects.
     *
     * The actual recreation does not happen here, but only after we have
     * performed all the individual ALTER TYPE operations.  We have to save
     * the info before executing ALTER TYPE, though, else the deparser will
     * get confused.
     *
     * There could be multiple entries for the same object, so we must check
     * to ensure we process each one only once.  Note: we assume that an index
     * that implements a constraint will not show a direct dependency on the
     * column.
     */</comment>
    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>foundObject</name></decl>;</decl_stmt>

        <comment type="block">/* We don't expect any PIN dependencies on columns */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_PIN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot alter type of a pinned column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name></type>        <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
						<name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name></expr></argument>, <argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name></expr></argument>,
                                                                <argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexDefs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexDefs</name></name></expr></argument>,
                                                            <argument><expr><call><name>pg_get_indexdef_string</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * This must be a SERIAL column's sequence.  We need
                         * not do anything to it.
                         */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* Not expecting any other direct dependencies... */</comment>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected object depending on column: %s"</literal></expr></argument>,
                             <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <break>break;</break>
                </block_content>}</block>

            <case>case <expr><name>OCLASS_CONSTRAINT</name></expr>:</case>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name></expr></argument>,
                                     <argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>defstring</name> <init>= <expr><call><name>pg_get_constraintdef_command</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name> <operator>=</operator>
                            <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name></expr></argument>,
                                        <argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name> <operator>=</operator>
                            <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name></expr></argument>,
                                    <argument><expr><name>defstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><name>OCLASS_REWRITE</name></expr>:</case>
                <comment type="block">/* XXX someday see if we can cope with revising views */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used by a view or rule"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
                                   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>OCLASS_TRIGGER</name></expr>:</case>

                <comment type="block">/*
                 * A trigger can depend on a column because the column is
                 * specified as an update target, or because the column is
                 * used in the trigger's WHEN condition.  The first case would
                 * not require any extra work, but the second case would
                 * require updating the WHEN expression, which will take a
                 * significant amount of new code.  Since we can't easily tell
                 * which case applies, we punt for both.  FIXME someday.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used in a trigger definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
                                   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>OCLASS_POLICY</name></expr>:</case>

                <comment type="block">/*
                 * A policy can depend on a column because the column is
                 * specified in the policy's USING or WITH CHECK qual
                 * expressions.  It might be possible to rewrite and recheck
                 * the policy expression, but punt for now.  It's certainly
                 * easy enough to remove and recreate the policy; still, FIXME
                 * someday.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used in a policy definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
                                   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>OCLASS_DEFAULT</name></expr>:</case>

                <comment type="block">/*
                 * Ignore the column's default expression, since we will fix
                 * it below.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>OCLASS_STATISTIC_EXT</name></expr>:</case>

                <comment type="block">/*
                 * Give the extended-stats machinery a chance to fix anything
                 * that this column type change would break.
                 */</comment>
                <expr_stmt><expr><call><name>UpdateStatisticsForTypeChange</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>,
                                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
                                              <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>OCLASS_PROC</name></expr>:</case>
            <case>case <expr><name>OCLASS_TYPE</name></expr>:</case>
            <case>case <expr><name>OCLASS_CAST</name></expr>:</case>
            <case>case <expr><name>OCLASS_COLLATION</name></expr>:</case>
            <case>case <expr><name>OCLASS_CONVERSION</name></expr>:</case>
            <case>case <expr><name>OCLASS_LANGUAGE</name></expr>:</case>
            <case>case <expr><name>OCLASS_LARGEOBJECT</name></expr>:</case>
            <case>case <expr><name>OCLASS_OPERATOR</name></expr>:</case>
            <case>case <expr><name>OCLASS_OPCLASS</name></expr>:</case>
            <case>case <expr><name>OCLASS_OPFAMILY</name></expr>:</case>
            <case>case <expr><name>OCLASS_AM</name></expr>:</case>
            <case>case <expr><name>OCLASS_AMOP</name></expr>:</case>
            <case>case <expr><name>OCLASS_AMPROC</name></expr>:</case>
            <case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
            <case>case <expr><name>OCLASS_TSPARSER</name></expr>:</case>
            <case>case <expr><name>OCLASS_TSDICT</name></expr>:</case>
            <case>case <expr><name>OCLASS_TSTEMPLATE</name></expr>:</case>
            <case>case <expr><name>OCLASS_TSCONFIG</name></expr>:</case>
            <case>case <expr><name>OCLASS_ROLE</name></expr>:</case>
            <case>case <expr><name>OCLASS_DATABASE</name></expr>:</case>
            <case>case <expr><name>OCLASS_TBLSPACE</name></expr>:</case>
            <case>case <expr><name>OCLASS_FDW</name></expr>:</case>
            <case>case <expr><name>OCLASS_FOREIGN_SERVER</name></expr>:</case>
            <case>case <expr><name>OCLASS_USER_MAPPING</name></expr>:</case>
            <case>case <expr><name>OCLASS_DEFACL</name></expr>:</case>
            <case>case <expr><name>OCLASS_EXTENSION</name></expr>:</case>
            <case>case <expr><name>OCLASS_EVENT_TRIGGER</name></expr>:</case>
            <case>case <expr><name>OCLASS_PUBLICATION</name></expr>:</case>
            <case>case <expr><name>OCLASS_PUBLICATION_REL</name></expr>:</case>
            <case>case <expr><name>OCLASS_SUBSCRIPTION</name></expr>:</case>
            <case>case <expr><name>OCLASS_TRANSFORM</name></expr>:</case>
            <case>case <expr><name>OCLASS_PGXC_NODE</name></expr>:</case>
            <case>case <expr><name>OCLASS_PGXC_GROUP</name></expr>:</case>
            <case>case <expr><name>OCLASS_PGXC_CLASS</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <case>case <expr><name>OCLASS_PG_PARTITION_INTERVAL</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
            <case>case <expr><name>OCLASS_AUDIT_STMT</name></expr>:</case>
            <case>case <expr><name>OCLASS_AUDIT_USER</name></expr>:</case>
            <case>case <expr><name>OCLASS_AUDIT_OBJ</name></expr>:</case>
            <case>case <expr><name>OCLASS_AUDIT_OBJDEFAULT</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
            <case>case <expr><name>OCLASS_PUBLICATION_SHARD</name></expr>:</case>
            <case>case <expr><name>OCLASS_SUBSCRIPTION_SHARD</name></expr>:</case>
            <case>case <expr><name>OCLASS_SUBSCRIPTION_TABLE</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * We don't expect any of these sorts of objects to depend on
                 * a column.
                 */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected object depending on column: %s"</literal></expr></argument>,
                     <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/*
                 * There's intentionally no default: case here; we want the
                 * compiler to warn if a new OCLASS hasn't been handled above.
                 */</comment>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now scan for dependencies of this column on other things.  The only
     * thing we should find is the dependency on the column datatype, which we
     * want to remove, and possibly a collation dependency.
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected dependency type '%c'"</literal></expr></argument>,
                 <argument><expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>TypeRelationId</name> <operator>&amp;&amp;</operator>
              <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>!</operator><operator>(</operator><name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>CollationRelationId</name> <operator>&amp;&amp;</operator>
              <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected dependency for column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>depTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Here we go --- change the recorded column type and collation.  (Note
     * heapTup is a copy of the syscache entry, so okay to scribble on.)
     */</comment>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>targettype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name>targettypmod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name>targetcollid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attndims</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Install dependencies on new datatype and collation */</comment>
    <expr_stmt><expr><call><name>add_column_datatype_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_column_collation_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>targetcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Drop any pg_statistic entry for the column, since it's now wrong type
     */</comment>
    <expr_stmt><expr><call><name>RemoveStatistics</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Update the default, if present, by brute force --- remove and re-add
     * the default.  Probably unsafe to take shortcuts, since the new version
     * may well have additional dependencies.  (It's okay to do this now,
     * rather than after other ALTER TYPE commands, since the default won't
     * depend on other column types.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>defaultexpr</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Must make new row visible since it will be updated again */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We use RESTRICT here for safety, but at present we do not expect
         * anything to depend on the default.
         */</comment>
        <expr_stmt><expr><call><name>RemoveAttrDefault</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                          <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>StoreAttrDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>defaultexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Cleanup */</comment>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterColumnGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
                                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
                                <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>ftrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_foreign_table</name></type> <name>fttableform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>atttableform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* First, determine FDW validator associated to the foreign table. */</comment>
    <expr_stmt><expr><name>ftrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>fttableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>fttableform</name><operator>-&gt;</operator><name>ftserver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fdw</name> <operator>=</operator> <call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Prevent them from altering a system attribute */</comment>
    <expr_stmt><expr><name>atttableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>atttableform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/* Initialize buffers for new tuple values */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Extract the current options */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
                            <argument><expr><name>tuple</name></expr></argument>,
                            <argument><expr><name>Anum_pg_attribute_attfdwoptions</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Transform the options */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>transformGenericOptions</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>,
                                    <argument><expr><name>datum</name></expr></argument>,
                                    <argument><expr><name>options</name></expr></argument>,
                                    <argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Everything looks good - update the tuple */</comment>

    <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>atttableform</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                        <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup after we've finished all the ALTER TYPE operations for a
 * particular relation.  We have to drop and recreate all the indexes
 * and constraints that depend on the altered columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPostAlterTypeCleanup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>def_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>oid_item</name></decl>;</decl_stmt>

    <comment type="block">/*
	 * Collect all the constraints and indexes to drop so we can process them
	 * in a single call.  That way we don't have to worry about dependencies
	 * among them.
	 */</comment>
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
     * Re-parse the index and constraint definitions, and attach them to the
     * appropriate work queue entries.  We do this before dropping because in
     * the case of a FOREIGN KEY constraint, we might not yet have exclusive
     * lock on the table the constraint is attached to, and we need to get
     * that before dropping.  It's safe because the parser won't actually look
     * at the catalogs to detect the existing entry.
     *
     * We can't rely on the output of deparsing to tell us which relation to
     * operate on, because concurrent activity might have made the name
     * resolve differently.  Instead, we've got to use the OID of the
     * constraint or index we're processing to figure out which relation to
     * operate on.
     */</comment>
    <macro><name>forboth</name><argument_list>(<argument>oid_item</argument>, <argument>tab-&gt;changedConstraintOids</argument>,
            <argument>def_item</argument>, <argument>tab-&gt;changedConstraintDefs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>oldId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>confrelid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>conislocal</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>confrelid</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>conislocal</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the constraint is inherited (only), we don't want to inject a
         * new definition here; it'll get recreated when ATAddCheckConstraint
         * recurses from adding the parent table's constraint.  But we had to
         * carry the info this far so that we can drop the constraint below.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>conislocal</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ATPostAlterTypeParse</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>confrelid</name></expr></argument>,
                             <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>def_item</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <macro><name>forboth</name><argument_list>(<argument>oid_item</argument>, <argument>tab-&gt;changedIndexOids</argument>,
            <argument>def_item</argument>, <argument>tab-&gt;changedIndexDefs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>oldId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ATPostAlterTypeParse</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>def_item</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
	 * It should be okay to use DROP_RESTRICT here, since nothing else should
	 * be depending on these objects.
     */</comment>
	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The objects will get recreated during subsequent passes over the work
     * queue.
     */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPostAlterTypeParse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rewrite</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>list_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We expect that we will get only ALTER TABLE and CREATE INDEX
     * statements. Hence, there is no need to pass them through
     * parse_analyze() or the rewriter, but instead we need to pass them
     * through parse_utilcmd.c to make them ready for execution.
     */</comment>
    <expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>raw_parser</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name><name>rs</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
                                     <argument><expr><call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>,
                                                        <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
                                                        <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
                                         <argument><expr><call><name>transformAlterTableStmt</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>,
                                                                 <argument><expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
                                                                 <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Caller should already have acquired whatever lock we need. */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Attach each generated command to the proper place in the work queue.
     * Note this could result in creation of entirely new work-queue entries.
     *
     * Also note that we have to tweak the command subtypes, because it turns
     * out that re-creation of indexes and constraints has to act a bit
     * differently from initial creation.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>querytree_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stm</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rewrite</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>TryReuseIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <comment type="block">/* keep the index's comment */</comment>
            <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name> <operator>=</operator>
                <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddIndex</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>indstmt</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>indoid</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>indstmt</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>indoid</name> <operator>=</operator> <call><name>get_constraint_index</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rewrite</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>TryReuseIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indoid</name></expr></argument>, <argument><expr><name>indstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <comment type="block">/* keep any comment on the index */</comment>
                    <expr_stmt><expr><name><name>indstmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>,
                                                     <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>indstmt</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name> <operator>=</operator>
                        <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* recreate any comment on the constraint */</comment>
                    <expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
                                             <argument><expr><name>AT_PASS_OLD_INDEX</name></expr></argument>,
                                             <argument><expr><name>oldId</name></expr></argument>,
                                             <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>indstmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>old_pktable_oid</name></name> <operator>=</operator> <name>refRelId</name></expr>;</expr_stmt>
                    <comment type="block">/* rewriting neither side of a FK */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name> <operator>&amp;&amp;</operator>
                        <operator>!</operator><name>rewrite</name> <operator>&amp;&amp;</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>TryReuseForeignKey</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddConstraint</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name> <operator>=</operator>
                        <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* recreate any comment on the constraint */</comment>
                    <expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
                                             <argument><expr><name>AT_PASS_OLD_CONSTR</name></expr></argument>,
                                             <argument><expr><name>oldId</name></expr></argument>,
                                             <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement subtype: %d"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse() to recreate a comment entry for
 * a constraint that is being re-added.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RebuildConstraintComment</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>,
                         <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>comment_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>

    <comment type="block">/* Look for comment for object wanted, and leave if none */</comment>
    <expr_stmt><expr><name>comment_str</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>comment_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Build node CommentStmt */</comment>
    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABCONSTRAINT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>comment_str</name></expr>;</expr_stmt>

    <comment type="block">/* Append it to list of commands */</comment>
    <expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddComment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse().  Calls out to CheckIndexCompatible()
 * for the real analysis, then mutates the IndexStmt based on that verdict.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryReuseIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>CheckIndexCompatible</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>,
                             <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>,
                             <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>,
                             <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>irel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>nParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>nParts</name> <operator>=</operator> <call><name>RelationGetNParts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partsOldNode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type> <name>iprel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>RelationGetPartitionIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
				                            <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partsOldNode</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partsOldNode</name></name></expr></argument>,
				                                            <argument><expr><name><name>iprel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>iprel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse().
 *
 * Stash the old P-F equality operator into the Constraint node, for possible
 * use by ATAddForeignKeyConstraint() in determining whether revalidation of
 * this constraint can be skipped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryReuseForeignKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>adatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>rawarr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* already prepared this node */</comment>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>adatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
                             <argument><expr><name>Anum_pg_constraint_conpfeqop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conpfeqop for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>adatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* ensure not toasted */</comment>
    <expr_stmt><expr><name>numkeys</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
    <comment type="block">/* test follows the one in ri_FetchConstraintInfo() */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
        <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"conpfeqop is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rawarr</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* stash a List of the operator Oids in our Constraint node */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name><name>rawarr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE OWNER
 *
 * recursing is true if we are recursing from a table to its indexes,
 * sequences, or toast table.  We don't allow the ownership of those things to
 * be changed separately from the parent table.  Also, we can skip permission
 * checks (this is necessary not just an optimization, else we'd fail to
 * handle toast tables properly).
 *
 * recursing is also true if ALTER TYPE OWNER is calling us to fix up a
 * free-standing composite type.
 */</comment>
<function><type><name>void</name></type>
<name>ATExecChangeOwner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>target_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>class_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>tuple_class</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get exclusive lock till end of transaction on the target table. Use
     * relation_open so that we can work on indexes and sequences.
     */</comment>
    <expr_stmt><expr><name>target_rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get its pg_class tuple, too */</comment>
    <expr_stmt><expr><name>class_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tuple_class</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Can we change the ownership of this tuple? */</comment>
    <switch>switch <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
        <case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
        <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
        <case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
        <case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
            <comment type="block">/* ok to change owner */</comment>
            <break>break;</break>
        <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Because ALTER INDEX OWNER used to be allowed, and in fact
                 * is generated by old versions of pg_dump, we give a warning
                 * and do nothing rather than erroring out.  Also, to avoid
                 * unnecessary chatter while restoring those old dumps, say
                 * nothing at all if the command would be a no-op anyway.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of index \"%s\""</literal></expr></argument>,
                                    <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Change the ownership of the index's table, instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* quick hack to exit via the no-op path */</comment>
                <expr_stmt><expr><name>newOwnerId</name> <operator>=</operator> <name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Change the ownership of the index's table, instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
        <case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator>
                <name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* if it's an owned sequence, disallow changing it by itself */</comment>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>tableId</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type>        <name>colId</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of sequence \"%s\""</literal></expr></argument>,
                                    <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s\" is linked to table \"%s\"."</literal></expr></argument>,
                                       <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a composite type"</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TYPE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <comment type="block">/* FALL THRU */</comment>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, sequence, or foreign table"</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/*
     * If the new owner is the same as the existing owner, consider the
     * command to have succeeded.  This is for dump restoration purposes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Acl</name>           <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>aclDatum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtuple</name></decl>;</decl_stmt>

        <comment type="block">/* skip permission checks when recursing to index or toast table */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Superusers can always do it */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>namespaceOid</name> <init>= <expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

                <comment type="block">/* Otherwise, must be owner of the existing object */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                                   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Must be able to become new owner */</comment>
                <expr_stmt><expr><call><name>check_is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* New owner must have CREATE privilege on namespace */</comment>
                <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
                                                  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_NAMESPACE</name></expr></argument>,
                                   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_relowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_relowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Determine the modified ACL for the new owner.  This is only
         * necessary when the ACL is non-null.
         */</comment>
        <expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                   <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We must similarly update any per-column ACLs to reflect the new
         * owner; for neatness reasons that's split out as a subroutine.
         */</comment>
        <expr_stmt><expr><call><name>change_owner_fix_column_acls</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>,
                                     <argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
                                     <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Update owner dependency reference, if any.  A composite type has
         * none, because it's tracked for the pg_type entry instead of here;
         * indexes and TOAST tables don't have their own entries either.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
            <name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
            <name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>changeDependencyOnOwner</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>,
                                    <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Also change the ownership of the table's row type, if it has one
         */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>AlterTypeOwnerInternal</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If we are operating on a table or materialized view, also change
         * the ownership of any indexes and sequences that belong to the
         * relation, as well as its toast table (if it has one).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
            <name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
            <name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>index_oid_list</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

            <comment type="block">/* Find all the indexes belonging to this relation */</comment>
            <expr_stmt><expr><name>index_oid_list</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* For each index, recursively change its ownership */</comment>
            <macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>index_oid_list</argument>)</argument_list></macro>
                <expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>index_oid_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
            <name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If it has a toast table, recurse to change its ownership */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
                                  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* If it has dependent sequences, recurse to change them too */</comment>
            <expr_stmt><expr><call><name>change_owner_recurse_to_sequences</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* 
     * if this a interval partition parent, we do alter action recursively, 
     * need to be mentioned, orignal partition table does not change its children recursively,
     * and interval partition could not be the root entry of alter owner, we forbit in ATPrepCmd.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type> <name>children</name> <init>= <expr><call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name><modifier>*</modifier></type> <name>child</name></decl>;</decl_stmt>
        <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>      <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * change_owner_fix_column_acls
 *
 * Helper function for ATExecChangeOwner.  Scan the columns of the table
 * and fix any non-null column ACLs to reflect the new owner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_owner_fix_column_acls</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldOwnerId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>attributeTuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>attRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Acl</name>           <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>aclDatum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtuple</name></decl>;</decl_stmt>

        <comment type="block">/* Ignore dropped columns */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>,
                                <argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>,
                                <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Null ACLs do not require changes */</comment>
        <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>oldOwnerId</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>,
                                     <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * change_owner_recurse_to_sequences
 *
 * Helper function for ATExecChangeOwner.  Examines pg_depend searching
 * for sequences that are dependent on serial columns, and changes their
 * ownership.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_owner_recurse_to_sequences</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <comment type="block">/*
     * SERIAL sequences are those having an auto dependency on one of the
     * table's columns (we don't care *which* column, exactly).
     */</comment>
    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* we leave refobjsubid unspecified */</comment>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>depForm</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>seqRel</name></decl>;</decl_stmt>

        <comment type="block">/* skip dependencies other than auto dependencies on columns */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>depForm</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <name><name>depForm</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
            <name><name>depForm</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>!</operator><operator>(</operator><name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator> <name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Use relation_open just in case it's an index */</comment>
        <expr_stmt><expr><name>seqRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* skip non-sequence relations */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* No need to keep the lock */</comment>
            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* We don't need to close the sequence while we alter it. */</comment>
        <expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now we can close it.  Keep the lock till end of transaction. */</comment>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE CLUSTER ON
 *
 * The only thing we have to do is to change the indisclustered bits.
 *
 * Return the address of the new clustering index.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecClusterOn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>indexOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>indexName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check index is valid to cluster on */</comment>
    <expr_stmt><expr><call><name>check_index_is_clusterable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And do the work */</comment>
    <expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
                     <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET WITHOUT CLUSTER
 *
 * We have to find any indexes on the table that have indisclustered bit
 * set and turn it off.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET TABLESPACE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetTableSpace</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>tablespaceId</name></decl>;</decl_stmt>

    <comment type="block">/* Check that the tablespace exists */</comment>
    <expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check permissions except when moving to database's default */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_TABLESPACE</name></expr></argument>, <argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Save info for Phase 3 to do the real work */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have multiple SET TABLESPACE subcommands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name> <operator>=</operator> <name>tablespaceId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set, reset, or replace reloptions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defList</name></decl></parameter>, <parameter><decl><type><name>AlterTableType</name></type> <name>operation</name></decl></parameter>,
                    <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pgclass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>newOptions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>defList</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>operation</name> <operator>!=</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>

    <expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch heap tuple */</comment>
    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we're supposed to replace the reloptions list, we just pretend
         * there were none before.
         */</comment>
        <expr_stmt><expr><name>datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Get the old reloptions */</comment>
        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Generate new proposed reloptions (text array) */</comment>
    <expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
                                     <argument><expr><name>defList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                     <argument><expr><name>operation</name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Validate */</comment>
    <switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
        <case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
        <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
        <case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>view_reloptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_reloptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amoptions</name></name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, index, or TOAST table"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Special-case validation of view options */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>view_query</name> <init>= <expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>view_options</name> <init>= <expr><call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>check_option</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>view_options</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"check_option"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>check_option</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * If the check option is specified, look to see if the view is
         * actually auto-updatable or not.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>check_option</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_updatable_error</name> <init>=
            <expr><call><name>view_query_is_auto_updatable</name><argument_list>(<argument><expr><name>view_query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>view_updatable_error</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH CHECK OPTION is supported only on automatically updatable views"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>view_updatable_error</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * All we need do here is update the pg_class row; the new options will be
     * propagated into relcaches during post-commit cache inval.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* repeat the whole exercise for the toast table, if there's one */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>toastrel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>toastid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Fetch heap tuple */</comment>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we're supposed to replace the reloptions list, we just
             * pretend there were none before.
             */</comment>
            <expr_stmt><expr><name>datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Get the old reloptions */</comment>
            <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
                                         <argument><expr><name>defList</name></expr></argument>, <argument><expr><literal type="string">"toast"</literal></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><name>operation</name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                     <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                     <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE SET TABLESPACE for cases where there is no tuple
 * rewriting to be done, so we just want to copy the data as fast as possible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>oldTableSpace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>reltoastrelid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>newrelfilenode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name></type> <name>newrnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SMgrRelation</name></type> <name>dstrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ForkNumber</name></type>    <name>forkNum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>reltoastidxids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Need lock here in case we are recursing to toast table or index
     */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * No work if no change in tablespace.
     */</comment>
    <expr_stmt><expr><name>oldTableSpace</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>oldTableSpace</name> <operator>||</operator>
        <operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator> <name>oldTableSpace</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We cannot support moving mapped relations into different tablespaces.
     * (In particular this eliminates all shared catalogs.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move system relation \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Can't move a non-shared relation into pg_global */</comment>
    <if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Don't allow moving temp tables of other backends ... their local buffer
     * manager is not going to cope.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>reltoastrelid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
    <comment type="block">/* Fetch the list of indexes on toast relation if necessary */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>toastRel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>reltoastidxids</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get a modifiable copy of the relation's pg_class row */</comment>
    <expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since we copy the file directly without looking at the shared buffers,
     * we'd better first flush out any pages of the source relation that are
     * in shared buffers.  We assume no new changes will be made while we are
     * holding exclusive lock on the rel.
     */</comment>
    <expr_stmt><expr><call><name>FlushRelationBuffers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Relfilenodes are not unique in databases across tablespaces, so we need
     * to allocate a new one in the new tablespace.
     */</comment>
    <expr_stmt><expr><name>newrelfilenode</name> <operator>=</operator> <call><name>GetNewRelFileNode</name><argument_list>(<argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Open old and new relation */</comment>
    <expr_stmt><expr><name>newrnode</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>newTableSpace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dstrel</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create and copy all forks of the relation, and schedule unlinking of
     * old physical files.
     *
     * NOTE: any conflict in relfilenode value will be caught in
     * RelationCreateStorage().
     */</comment>
    <expr_stmt><expr><call><name>RelationCreateStorage</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy main fork */</comment>
    <expr_stmt><expr><call><name>copy_relation_data</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
                       <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy those extra forks that exist */</comment>
    <for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <name>MAIN_FORKNUM</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * WAL log creation if the relation is persistent, or this is the
             * init fork of an unlogged relation.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator>
                <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
                 <name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>log_smgrcreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newrnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>copy_relation_data</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>,
                               <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* drop old relation, and close new one */</comment>
    <expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* update the pg_class row */</comment>
    <expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>newTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure the reltablespace change is visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Move associated toast relation and/or indexes, too */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>reltoastidxids</argument>)</argument_list></macro>
        <expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up */</comment>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>reltoastidxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Special handling of ALTER TABLE SET TABLESPACE for relations with no
 * storage that have an interest in preserving tablespace.
 *
 * Since these have no storage the tablespace can be updated with a simple
 * metadata only operation to update the tablespace.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetTableSpaceNoStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldTableSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Shouldn't be called on relations having storage; these are processed
	 * in phase 3.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RELKIND_CAN_HAVE_STORAGE</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't allow a non-shared relation in pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No work if no change in tablespace.
	 */</comment>
	<expr_stmt><expr><name>oldTableSpace</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>oldTableSpace</name> <operator>||</operator>
		<operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator> <name>oldTableSpace</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get a modifiable copy of the relation's pg_class row */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update the pg_class row */</comment>
	<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>newTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the reltablespace change is visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Alter Table ALL ... SET TABLESPACE
 *
 * Allows a user to move all objects of some type in a given tablespace in the
 * current database to another tablespace.  Objects can be chosen based on the
 * owner of the object also, to allow users to move only their objects.
 * The user must have CREATE rights on the new tablespace, as usual.   The main
 * permissions handling is done by the lower-level table move function.
 *
 * All to-be-moved objects are locked first. If NOWAIT is specified and the
 * lock can't be acquired then we ereport(ERROR).
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterTableMoveAll</name><parameter_list>(<parameter><decl><type><name>AlterTableMoveAllStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>relations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>orig_tablespaceoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>new_tablespaceoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>role_oids</name> <init>= <expr><call><name>roleSpecsToIds</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Ensure we were not asked to move something we can't */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator>
        <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only tables, indexes, and materialized views exist in tablespaces"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get the orig and new tablespace OIDs */</comment>
    <expr_stmt><expr><name>orig_tablespaceoid</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>orig_tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_tablespaceoid</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>new_tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Can't move shared relations in to or out of pg_global */</comment>
    <comment type="block">/* This is also checked by ATExecSetTableSpace, but nice to stop earlier */</comment>
    <if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name> <operator>||</operator>
        <name>new_tablespaceoid</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move relations in to or out of pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Must have CREATE rights on the new tablespace, unless it is the
     * database default tablespace (which all users implicitly have CREATE
     * rights on).
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>new_tablespaceoid</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_TABLESPACE</name></expr></argument>,
                           <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now that the checks are done, check if we should set either to
     * InvalidOid because it is our database's default tablespace.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>orig_tablespaceoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>new_tablespaceoid</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>new_tablespaceoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* no-op */</comment>
    <if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>new_tablespaceoid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>new_tablespaceoid</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Walk the list of objects in the tablespace and move them. This will
     * only find objects in our database, of course.
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_class_reltablespace</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>orig_tablespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relForm</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>relForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Do not move objects in pg_catalog as part of this, if an admin
         * really wishes to do so, they can issue the individual ALTER
         * commands directly.
         *
         * Also, explicitly avoid any shared tables, temp tables, or TOAST
         * (TOAST will be moved with the main table).
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>relForm</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>||</operator>
            <call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_TOAST_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Only move the object type requested */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator>
             <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
             <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name> <operator>&amp;&amp;</operator>
             <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Check if we are only moving objects owned by certain roles */</comment>
        <if_stmt><if>if <condition>(<expr><name>role_oids</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>role_oids</name></expr></argument>, <argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Handle permissions-checking here since we are locking the tables
         * and also to avoid doing a bunch of work only to fail part-way. Note
         * that permissions will also be checked by AlterTableInternal().
         *
         * Caller must be considered an owner on the table to move it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                           <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>nowait</name></name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aborting because lock on relation \"%s.%s\" is not available"</literal></expr></argument>,
                            <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Add to our list of objects to move */</comment>
        <expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relations</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>relations</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no matching relations in tablespace \"%s\" found"</literal></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>InvalidOid</name></expr> ?</condition><then> <expr><literal type="string">"(database default)"</literal></expr> </then><else>:
                        <expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>orig_tablespaceoid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Everything is locked, loop through and move all of the relations. */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>relations</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetTableSpace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>new_tablespacename</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* OID is set by AlterTableInternal */</comment>
        <expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>new_tablespaceoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy data, block by block
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_relation_data</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>dst</name></decl></parameter>,
                   <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>use_wal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>copying_initfork</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int16</name></type>       <name>algo_id</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * palloc the buffer so that it's MAXALIGN'd.  If it were just a local
     * char[] array, the compiler might align it on any byte boundary, which
     * can seriously hurt transfer speed to and from the kernel; not to
     * mention possibly making log_newpage's accesses to the page header fail.
     */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The init fork for an unlogged relation in many respects has to be
     * treated the same as normal relation, changes need to be WAL logged and
     * it needs to be synced to disk.
     */</comment>
    <expr_stmt><expr><name>copying_initfork</name> <operator>=</operator> <name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
        <name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to log the copied data in WAL iff WAL archiving/streaming is
     * enabled AND it's a permanent relation.
     */</comment>
    <expr_stmt><expr><name>use_wal</name> <operator>=</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator> <name>copying_initfork</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>blkno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>nblocks</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* If we got a cancel signal during the copy of the data, quit */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>smgrread</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <comment type="block">/* after verify, decrypt if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name>MAIN_FORKNUM</name> <operator>==</operator> <name>forkNum</name> <operator>||</operator> <name>EXTENT_FORKNUM</name> <operator>==</operator> <name>forkNum</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>algo_id</name> <operator>=</operator> <call><name>PageGetAlgorithmId</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ALGO_ID_IS_VALID</name><argument_list>(<argument><expr><name>algo_id</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>algo_id</name> <operator>==</operator> <name><name>src</name><operator>-&gt;</operator><name>smgr_relcrypt</name><operator>.</operator><name>algo_id</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>rel_crypt_page_decrypt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>src</name><operator>-&gt;</operator><name>smgr_relcrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>Page</name><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"found one page whose algo_id:%d diffs with smgr_relcrypt_algo_id:%d, relfilenode:%d:%d:%d, forknum:%d, blknum:%d"</literal></expr></argument>,
                        <argument><expr><name>algo_id</name></expr></argument>,
                        <argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_relcrypt</name><operator>.</operator><name>algo_id</name></name></expr></argument>,
                        <argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsVerified</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s"</literal></expr></argument>,
                            <argument><expr><name>blkno</name></expr></argument>,
                            <argument><expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>,
                                           <argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
                                           <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * WAL-log the copied page. Unfortunately we don't know what kind of a
         * page this is, so we have to log the full page including any unused
         * space.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now write the page.  We say isTemp = true even if it's not a temp
         * rel, because there's no need for smgr to schedule an fsync for this
         * write; we'll do it ourselves below.
         */</comment>
        <expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the rel is WAL-logged, must fsync before commit.  We use heap_sync
     * to ensure that the toast table gets fsync'd too.  (For a temp or
     * unlogged rel we don't care since the data will be gone after a crash
     * anyway.)
     *
     * It's obvious that we must do this when not WAL-logging the copy. It's
     * less obvious that we have to do it even if we did WAL-log the copied
     * pages. The reason is that since we're copying outside shared buffers, a
     * CHECKPOINT occurring during the copy has no way to flush the previously
     * written data to disk (indeed it won't know the new rel even exists).  A
     * crash later on would replay WAL from the checkpoint, therefore it
     * wouldn't replay our earlier WAL entries. If we do not fsync those pages
     * here, they might still not be on disk when the crash occurs.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator> <name>copying_initfork</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE TRIGGER
 *
 * We just pass this off to trigger.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableDisableTrigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>,
                           <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>EnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>trigname</name></expr></argument>, <argument><expr><name>fires_when</name></expr></argument>, <argument><expr><name>skip_system</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE RULE
 *
 * We just pass this off to rewriteDefine.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableDisableRule</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
                        <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>EnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rulename</name></expr></argument>, <argument><expr><name>fires_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE INHERIT
 *
 * Add a parent to the child's parents. This verifies that all the columns and
 * check constraints of the parent appear in the child and that they have the
 * same data types and expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the address of the new parent relation.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>parent_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigger_name</name></decl>;</decl_stmt>

    <comment type="block">/*
     * A self-exclusive lock is needed here.  See the similar case in
     * MergeAttributes() for a full explanation.
     */</comment>
    <expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Must be owner of both parent and child -- child was checked by
     * ATSimplePermissions call in ATPrepCmd
     */</comment>
    <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Permanent rels cannot inherit from temporary ones */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
        <name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from temporary relation \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If parent rel is temp, it must belong to this session */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Ditto for the child */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>child_rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit to temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Prevent partitioned tables from becoming inheritance parents */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partitioned table \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Likewise for partitions */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Prevent circularity by seeing if proposed parent inherits from child.
     * (In particular, this disallows making a rel inherit from itself.)
     *
     * This is not completely bulletproof because of race conditions: in
     * multi-level inheritance trees, someone else could concurrently be
     * making another inheritance link that closes the loop but does not join
     * either of the rels we have locked.  Preventing that seems to require
     * exclusive locks on the entire inheritance tree, which is a cure worse
     * than the disease.  find_all_inheritors() will cope with circularity
     * anyway, so don't sweat it too much.
     *
     * We use weakest lock we can on child's children, namely AccessShareLock.
     */</comment>
    <expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular inheritance not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a child of \"%s\"."</literal></expr></argument>,
                           <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If parent has OIDs then child must have OIDs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" without OIDs cannot inherit from table \"%s\" with OIDs"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If child_rel has row-level triggers with transition tables, we
     * currently don't allow it to become an inheritance child.  See also
     * prohibitions in ATExecAttachPartition() and CreateTrigger().
     */</comment>
    <expr_stmt><expr><name>trigger_name</name> <operator>=</operator> <call><name>FindTriggerIncompatibleWithInheritance</name><argument_list>(<argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>trigger_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" prevents table \"%s\" from becoming an inheritance child"</literal></expr></argument>,
                        <argument><expr><name>trigger_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported in inheritance hierarchies"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OK to create inheritance */</comment>
    <expr_stmt><expr><call><name>CreateInheritance</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                     <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* keep our lock on the parent relation until commit */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateInheritance
 *        Catalog manipulation portion of creating inheritance between a child
 *        table and a parent table.
 *
 * Common to ATExecAddInherit() and ATExecAttachPartition().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>catalogRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>inheritsTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>inhseqno</name></decl>;</decl_stmt>

    <comment type="block">/* Note: get RowExclusiveLock because we will write pg_inherits below. */</comment>
    <expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for duplicates in the list of parents, and determine the highest
     * inhseqno already present; we'll use the next one for the new parent.
     * Also, if proposed child is a partition, it cannot already be
     * inheriting.
     *
     * Note: we do not reject the case where the child already inherits from
     * the parent indirectly; CREATE TABLE doesn't reject comparable cases.
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
                <argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* inhseqno sequences start at 1 */</comment>
    <expr_stmt><expr><name>inhseqno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>inheritsTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inh</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>inh</name><operator>-&gt;</operator><name>inhparent</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" would be inherited from more than once"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>inh</name><operator>-&gt;</operator><name>inhseqno</name></name> <operator>&gt;</operator> <name>inhseqno</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>inhseqno</name> <operator>=</operator> <name><name>inh</name><operator>-&gt;</operator><name>inhseqno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Match up the columns and bump attinhcount as needed */</comment>
    <expr_stmt><expr><call><name>MergeAttributesIntoExisting</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Match up the constraints and bump coninhcount as needed */</comment>
    <expr_stmt><expr><call><name>MergeConstraintsIntoExisting</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Match up the distribution mechanism.
         *
         * If do the check only on the coordinator since the distribution
         * information is not available on the datanodes. This should not cause
         * any problem since if the check fails on the coordinator, the entire
         * transaction will be aborted and changes will be rolled back on the
         * datanodes too. In fact, since we first run the command on the
         * coordinator, the error will be caught even before any changes are
         * made on the datanodes.
         */</comment>
        <expr_stmt><expr><call><name>MergeDistributionIntoExisting</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * OK, it looks valid.  Make the catalog entries that show inheritance.
     */</comment>
    <expr_stmt><expr><call><name>StoreCatalogInheritance1</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>inhseqno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                             <argument><expr><name>catalogRelation</name></expr></argument>,
                             <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator>
                             <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now we're done with pg_inherits */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain the source-text form of the constraint expression for a check
 * constraint, given its pg_constraint tuple
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>decompile_conbin</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>contup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>expr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>contup</name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>,
                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether two check constraints are functionally equivalent
 *
 * The test we apply is to see whether they reverse-compile to the same
 * source string.  This insulates us from issues like whether attributes
 * have the same physical column numbers in parent and child relations.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>constraints_equivalent</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>acon</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>bcon</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>acon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>bcon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>||</operator>
        <name><name>acon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>bcon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>||</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><call><name>decompile_conbin</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>decompile_conbin</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check columns in child table match up with columns in parent, and increment
 * their attinhcount.
 *
 * Called by CreateInheritance
 *
 * Currently all parent columns must be found in child. Missing columns are an
 * error.  One day we might consider creating new columns like CREATE TABLE
 * does.  However, that is widely unpopular --- in the common use case of
 * partitioned tables it's a foot-gun.
 *
 * The data type must match exactly. If the parent column is NOT NULL then
 * the child must be as well. Defaults are not compared, however.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeAttributesIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attrrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>parent_attno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>parent_natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>attrrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>parent_natts</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name>parent_natts</name></expr>;</condition> <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Ignore dropped columns in the parent. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Find same column in child (matching on column name). */</comment>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Check they are same type, typmod, and collation */</comment>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
                <name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different collation for column \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Check child doesn't discard NOT NULL property.  (Other
             * constraints are checked elsewhere.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>childatt</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" in child table must be marked NOT NULL"</literal></expr></argument>,
                                <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * In Postgres-XL, we demand that the attribute positions of the
             * child and the parent table must match too. This seems overly
             * restrictive and may have other side-effects when one of the
             * tables have dropped columns, thus impacting the attribute
             * numbering. But having this restriction helps us generate far
             * more efficient plans without worrying too much about attribute
             * number mismatch.
             *
             * In common cases of partitioning, the parent table and the
             * partition tables will be created at the very beginning and if
             * altered, they will be altered together.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attnum</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attnum</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" contains column \"%s\" at "</literal>
                             <literal type="string">"position %d, but parent \"%s\" has it at position %d"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check for column ordering and dropped columns, if any"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Postgres-XL requires attribute positions to match"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/*
             * OK, bump the child column's inheritance count.  (If we fail
             * later on, this change will just roll back.)
             */</comment>
            <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/*
             * In case of partitions, we must enforce that value of attislocal
             * is same in all partitions. (Note: there are only inherited
             * attributes in partitions)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing column \"%s\""</literal></expr></argument>,
                            <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If the parent has an OID column, so must the child, and we'd better
     * update the child's attinhcount and attislocal the same as for normal
     * columns.  We needn't check data type or not-nullness though.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Here we match by column number not name; the match *must* be the
         * system column, not some random column named "oid".
         */</comment>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
                                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* See comments above; these changes should be the same */</comment>
            <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing column \"%s\""</literal></expr></argument>,
                            <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check constraints in child table match up with constraints in parent,
 * and increment their coninhcount.
 *
 * Constraints that are marked ONLY in the parent are ignored.
 *
 * Called by CreateInheritance
 *
 * Currently all constraints in parent must be present in the child. One day we
 * may consider adding new constraints like CREATE TABLE does.
 *
 * XXX This is O(N^2) which may be an issue with tables with hundreds of
 * constraints. As long as tables have more like 10 constraints it shouldn't be
 * a problem though. Even 100 constraints ought not be the end of the world.
 *
 * XXX See MergeWithExistingConstraint too if you change this code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeConstraintsIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>catalog_relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tuple_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>parent_scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>parent_key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>parent_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>catalog_relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Outer loop scans through the parent's constraint definitions */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_key</name></expr></argument>,
                <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>parent_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                                     <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>parent_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>parent_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>parent_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>parent_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>child_scan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>child_key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>child_tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* if the parent's constraint is marked NO INHERIT, it's not inherited */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Search for a child constraint matching this one */</comment>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child_key</name></expr></argument>,
                    <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>child_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                                        <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>child_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>child_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>child_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>child_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>child_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>child_copy</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>child_con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>constraints_equivalent</name><argument_list>(<argument><expr><name>parent_tuple</name></expr></argument>, <argument><expr><name>child_tuple</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different definition for check constraint \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* If the child constraint is "no inherit" then cannot merge */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>child_con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with non-inherited constraint on child table \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If the child constraint is "not valid" then cannot merge with a
             * valid parent constraint
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>child_con</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with NOT VALID constraint on child table \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * OK, bump the child constraint's inheritance count.  (If we fail
             * later on, this change will just roll back.)
             */</comment>
            <expr_stmt><expr><name>child_copy</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>child_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>child_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>child_con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/*
             * In case of partitions, an inherited constraint must be
             * inherited only once since it cannot have multiple parents and
             * it is never considered local.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>child_con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>child_copy</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>child_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing constraint \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>parent_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeDistributionIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>parent_locinfo</name> <init>= <expr><call><name>RelationGetLocInfo</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>child_locinfo</name> <init>= <expr><call><name>RelationGetLocInfo</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nodeList2</name></decl>;</decl_stmt>


    <expr_stmt><expr><name>nodeList1</name> <operator>=</operator> <name><name>parent_locinfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodeList2</name> <operator>=</operator> <name><name>child_locinfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr>;</expr_stmt>

    <comment type="block">/* Same locator type? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_locinfo</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name><name>child_locinfo</name><operator>-&gt;</operator><name>locatorType</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is using distribution type %c, but the "</literal>
                    <literal type="string">"parent table \"%s\" is using distribution type %c"</literal></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>child_locinfo</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>parent_locinfo</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution type for the child must be same as the parent"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/*
     * Same attribute number?
     *
     * For table distributed by roundrobin or replication, the partAttrNum will
     * be -1 and inheritance is allowed for tables distributed by roundrobin or
     * replication, as long as the distribution type matches (i.e. all tables
     * are either roundrobin or all tables are replicated).
     *
     * Tables distributed by roundrobin or replication do not have partAttrName
     * set. We should have checked for distribution type above. So if the
     * partAttrNum does not match below, we must be dealing with either modulo
     * or hash distributed tables and partAttrName must be set in both the
     * cases.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_locinfo</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>!=</operator> <name><name>child_locinfo</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is distributed on column \"%s\", but the "</literal>
                    <literal type="string">"parent table \"%s\" is distributed on column \"%s\""</literal></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>child_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>parent_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution column for the child must be same as the parent"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Same attribute name? partAttrName could be NULL if we are dealing with
     * roundrobin or replicated tables. So check for that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name> <operator>&amp;&amp;</operator>
        <name><name>child_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name> <operator>&amp;&amp;</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><name><name>parent_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>, <argument><expr><name><name>child_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is distributed on column \"%s\", but the "</literal>
                    <literal type="string">"parent table \"%s\" is distributed on column \"%s\""</literal></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>child_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>parent_locinfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution column for the child must be same as the parent"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/* Same node list? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodeList1</name></expr></argument>, <argument><expr><name>nodeList2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
        <call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodeList2</name></expr></argument>, <argument><expr><name>nodeList1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" and the parent table \"%s\" "</literal>
                    <literal type="string">"are distributed on different sets of nodes"</literal></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution nodes for the child must be same as the parent"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE NO INHERIT
 *
 * Return value is the address of the relation that is no longer parent.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>parent_rel</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * AccessShareLock on the parent is probably enough, seeing that DROP
     * TABLE doesn't lock parent tables at all.  We need some lock since we'll
     * be inspecting the parent's schema.
     */</comment>
    <expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We don't bother to check ownership of the parent table --- ownership of
     * the child is presumed enough rights.
     */</comment>

    <comment type="block">/* Off to RemoveInheritance() where most of the work happens */</comment>
    <expr_stmt><expr><call><name>RemoveInheritance</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* keep our lock on the parent relation until commit */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
                     <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveInheritance
 *
 * Drop a parent from the child's parents. This just adjusts the attinhcount
 * and attislocal of the columns and removes the pg_inherit and pg_depend
 * entries.
 *
 * If attinhcount goes to 0 then attislocal gets set to true. If it goes back
 * up attislocal stays true, which means if a child is ever removed from a
 * parent then its columns will never be automatically dropped which may
 * surprise. But at least we'll never surprise by dropping columns someone
 * isn't expecting to be dropped which would actually mean data loss.
 *
 * coninhcount and conislocal for inherited constraints are adjusted in
 * exactly the same way.
 *
 * Common to ATExecDropInherit() and ATExecDetachPartition().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>catalogRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attributeTuple</name></decl>,
                <decl><type ref="prev"/><name>constraintTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>connames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>DeleteInheritsTuple</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a partition of relation \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a parent of relation \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Search through child columns looking for ones matching parent rel
     */</comment>
    <expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Ignore if dropped or not inherited */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExistsAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Decrement inhcount and possibly set islocal to true */</comment>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>copyTuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>copy_att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>copy_att</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>copy_att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>copy_att</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Likewise, find inherited check constraints and disinherit them. To do
     * this, we first need a list of the names of the parent's check
     * constraints.  (We cheat a bit by only checking for name matches,
     * assuming that the expressions will match.)
     */</comment>
    <expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>connames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>constraintTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>connames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connames</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now scan the child's constraints */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>ConstraintRelidIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>constraintTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>match</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>connames</argument>)</argument_list></macro>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Decrement inhcount and possibly set islocal to true */</comment>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>copyTuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited constraint \"%s\""</literal></expr></argument>,
                     <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>copy_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>RelationRelationId</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>child_dependency_type</name><argument_list>(<argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Post alter hook of this inherits. Since object_access_hook doesn't take
     * multiple object identifiers, we relay oid of parent relation using
     * auxiliary_id argument.
     */</comment>
    <expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>,
                                 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop the dependency created by StoreCatalogInheritance1 (CREATE TABLE
 * INHERITS/ALTER TABLE INHERIT -- refclassid will be RelationRelationId) or
 * heap_create_with_catalog (CREATE TABLE OF/ALTER TABLE OF -- refclassid will
 * be TypeRelationId).  There's no convenient way to do this, so go trawling
 * through pg_depend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_parent_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
                       <parameter><decl><type><name>DependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>catalogRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>depTuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>dep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>dep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>refclassid</name> <operator>&amp;&amp;</operator>
            <name><name>dep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name>refobjid</name> <operator>&amp;&amp;</operator>
            <name><name>dep</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>dep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>deptype</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>depTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE OF
 *
 * Attach a table to a composite type, as though it had been created with CREATE
 * TABLE OF.  All attname, atttypid, atttypmod and attcollation must match.  The
 * subject table must not have inheritance parents.  These restrictions ensure
 * that you cannot create a configuration impossible with CREATE TABLE OF alone.
 *
 * The address of the type is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Type</name></type>        <name>typetuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>typeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>inheritsRelation</name></decl>,
                <decl><type ref="prev"/><name>relationRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>table_attno</name></decl>,
                <decl><type ref="prev"/><name>type_attno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>typeTupleDesc</name></decl>,
                <decl><type ref="prev"/><name>tableTupleDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>tableobj</name></decl>,
                <decl><type ref="prev"/><name>typeobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>classtuple</name></decl>;</decl_stmt>

    <comment type="block">/* Validate the type. */</comment>
    <expr_stmt><expr><name>typetuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ofTypename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_of_type</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>typeid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fail if the table has any inheritance parents. */</comment>
    <expr_stmt><expr><name>inheritsRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
                <argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inheritsRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typed tables cannot inherit"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>inheritsRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check the tuple descriptors for compatibility.  Unlike inheritance, we
     * require that the order also match.  However, attnotnull need not match.
     * Also unlike inheritance, we do not require matching relhasoids.
     */</comment>
    <expr_stmt><expr><name>typeTupleDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tableTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>table_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>type_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>type_attno</name> <operator>&lt;=</operator> <name><name>typeTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>type_attno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>type_attr</name></decl>,
                    <decl><type ref="prev"/><name>table_attr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_attname</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>table_attname</name></decl>;</decl_stmt>

        <comment type="block">/* Get the next non-dropped type attribute. */</comment>
        <expr_stmt><expr><name>type_attr</name> <operator>=</operator> <name><name>typeTupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>type_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>type_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>type_attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>type_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Get the next non-dropped table attribute. */</comment>
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>table_attno</name> <operator>&gt;</operator> <name><name>tableTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table is missing column \"%s\""</literal></expr></argument>,
                                <argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>table_attr</name> <operator>=</operator> <name><name>tableTupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>table_attno</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><name><name>table_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>;</do>
        <expr_stmt><expr><name>table_attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>table_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Compare name. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>table_attname</name></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table has column \"%s\" where type requires \"%s\""</literal></expr></argument>,
                            <argument><expr><name>table_attname</name></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Compare type. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>table_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
            <name><name>table_attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>||</operator>
            <name><name>table_attr</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>typeTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Any remaining columns at the end of the table had better be dropped. */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>table_attno</name> <operator>&lt;=</operator> <name><name>tableTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>table_attno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>table_attr</name> <init>= <expr><name><name>tableTupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>table_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>table_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table has extra column \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>table_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If the table was already typed, drop the existing dependency. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>,
                               <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Record a dependency on the new type. */</comment>
    <expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableobj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeobj</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update pg_class.reloftype */</comment>
    <expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>classtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>reloftype</name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>classtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>typeobj</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE NOT OF
 *
 * Detach a typed table from its originating type.  Just clear reloftype and
 * remove the dependency.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relationRelation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a typed table"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We don't bother to check ownership of the type --- ownership of the
     * table is presumed enough rights.  No lock required on the type, either.
     */</comment>

    <expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>,
                           <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear pg_class.reloftype */</comment>
    <expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>reloftype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * relation_mark_replica_identity: Update a table's replica identity
 *
 * Iff ri_type = REPLICA_IDENTITY_INDEX, indexOid must be the Oid of a suitable
 * index. Otherwise, it should be InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>relation_mark_replica_identity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ri_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>,
                               <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>pg_class_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>pg_index_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_form</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>pg_index_form</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check whether relreplident has changed, and update it if so.
     */</comment>
    <expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
                                         <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation \"%s\""</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pg_class_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pg_class_form</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>!=</operator> <name>ri_type</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pg_class_form</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>=</operator> <name>ri_type</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check whether the correct index is marked indisreplident; if so, we're
     * done.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ri_type</name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pg_index_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pg_index_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Clear the indisreplident flag from any index that had it previously,
     * and set it for any index that should have it now.
     */</comment>
    <expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>index</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>thisIndexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>pg_index_tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
                                             <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pg_index_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Unset the bit if set.  We know it's wrong because we checked this
         * earlier.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>thisIndexOid</name> <operator>==</operator> <name>indexOid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pg_index_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                         <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE &lt;name&gt; REPLICA IDENTITY ...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>indexOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>key</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_DEFAULT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>)</condition>
    <block>{<block_content>
         <comment type="block">/* fallthrough */</comment> <empty_stmt>;</empty_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected identity type %u"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


    <comment type="block">/* Check that the index exists */</comment>
    <expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check that the index is on the relation we're altering. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index for table \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* The AM must support uniqueness, and the index must in fact be unique. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>||</operator>
        <operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use non-unique index \"%s\" as replica identity"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Deferred indexes are not guaranteed to be always unique. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use non-immediate index \"%s\" as replica identity"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Expression indexes aren't supported. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use expression index \"%s\" as replica identity"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Predicate indexes aren't supported. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use partial index \"%s\" as replica identity"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* And neither are invalid indexes. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use invalid index \"%s\" as replica identity"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check index for nullable columns. */</comment>
    <for>for <control>(<init><expr><name>key</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>key</name> <operator>&lt;</operator> <name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>key</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int16</name></type>        <name>attno</name> <init>= <expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

        <comment type="block">/* Allow OID column to be indexed; it's certainly not nullable */</comment>
        <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Reject any other system columns.  (Going forward, we'll disallow
         * indexes containing such columns in the first place, but they might
         * exist in older branches.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" cannot be used as replica identity because column %d is a system column"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" cannot be used as replica identity because column \"%s\" is nullable"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* This index is suitable for use as a replica identity. Mark it. */</comment>
    <expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE ROW LEVEL SECURITY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relrowsecurity</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDisableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Pull the record for this relation and update it */</comment>
    <expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relrowsecurity</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE FORCE/NO FORCE ROW LEVEL SECURITY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecForceNoForceRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_rls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relforcerowsecurity</name> <operator>=</operator> <name>force_rls</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER FOREIGN TABLE &lt;name&gt; OPTIONS (...)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>ftrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>repl_val</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_null</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>repl_repl</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_foreign_table</name></type> <name>tableform</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ftrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>tableform</name><operator>-&gt;</operator><name>ftserver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fdw</name> <operator>=</operator> <call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Extract the current options */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>,
                            <argument><expr><name>tuple</name></expr></argument>,
                            <argument><expr><name>Anum_pg_foreign_table_ftoptions</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Transform the options */</comment>
    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>transformGenericOptions</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>,
                                    <argument><expr><name>datum</name></expr></argument>,
                                    <argument><expr><name>options</name></expr></argument>,
                                    <argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Everything looks good - update the tuple */</comment>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Invalidate relcache so that all sessions will refresh any cached plans
     * that might depend on the old options.
     */</comment>
    <expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>,
                              <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * ALTER TABLE &lt;name&gt; DISTRIBUTE BY ...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtExecDistributeBy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>DistributeBy</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>locatortype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hashalgorithm</name></decl>, <decl><type ref="prev"/><name>hashbuckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>secattnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Nothing to do on Datanodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <name>options</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get necessary distribution information */</comment>
    <expr_stmt><expr><call><name>GetRelationDistributionItems</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
                                 <argument><expr><name>options</name></expr></argument>,
                                 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>locatortype</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>hashalgorithm</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>hashbuckets</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                                 <argument><expr><operator>&amp;</operator><name>secattnum</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                 <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * It is not checked if the distribution type list is the same as the old one,
     * user might define a different sub-cluster at the same time.
     */</comment>

    <comment type="block">/* Update pgxc_class entry */</comment>
    <expr_stmt><expr><call><name>PgxcClassAlter</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
                   <argument><expr><name>locatortype</name></expr></argument>,
                   <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>attnum</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                   <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>secattnum</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   <argument><expr><name>hashalgorithm</name></expr></argument>,
                   <argument><expr><name>hashbuckets</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                   <argument><expr><name>NULL</name></expr></argument>,
                   <argument><expr><name>NULL</name></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><name>NULL</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   <argument><expr><name>PGXC_CLASS_ALTER_DISTRIBUTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make the additional catalog changes visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE &lt;name&gt; TO [ NODE nodelist | GROUP groupname ]
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtExecSubCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PGXCSubCluster</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name><name>nodeoids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>numnodes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name>  <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>nodeoids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numnodes</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Nothing to do on Datanodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <name>options</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * It is not checked if the new subcluster list is the same as the old one,
     * user might define a different distribution type.
     */</comment>

    <comment type="block">/* Obtain new node information */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>GetRelationDistributionNodes</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>nodeoids</name></expr></argument>, <argument><expr><name>numnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>nodeoids</name> <operator>=</operator> <call><name>GetRelationDistributionNodes</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Update pgxc_class entry */</comment>
    <expr_stmt><expr><call><name>PgxcClassAlter</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><literal type="char">'\0'</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><name>numnodes</name></expr></argument>,
                   <argument><expr><name>nodeoids</name></expr></argument>,
                   <argument><expr><name>PGXC_CLASS_ALTER_NODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make the additional catalog changes visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE &lt;name&gt; ADD NODE nodelist
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtExecAddNode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>add_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>add_num</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name><name>old_oids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>old_num</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>old_num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>old_oids</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Nothing to do on Datanodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Build a new array of sorted node Oids given the list of name nodes
     * to be added.
     */</comment>
    <expr_stmt><expr><name>add_oids</name> <operator>=</operator> <call><name>BuildRelationDistributionNodes</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>add_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <comment type="block">/*
     * Then check if nodes to be added are not in existing node
     * list and build updated list of nodes.
     */</comment>
    <expr_stmt><expr><name><name>old_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>get_pgxc_classnodes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add elements to array */</comment>
    <expr_stmt><expr><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>add_node_list</name><argument_list>(<argument><expr><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>old_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>add_oids</name></expr></argument>, <argument><expr><name>add_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort once again the newly-created array of node Oids to maintain consistency */</comment>
    <expr_stmt><expr><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>SortRelationDistributionNodes</name><argument_list>(<argument><expr><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>old_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * Then check if nodes to be added are not in existing node
     * list and build updated list of nodes.
     */</comment>
    <expr_stmt><expr><name>old_num</name> <operator>=</operator> <call><name>get_pgxc_classnodes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add elements to array */</comment>
    <expr_stmt><expr><name>old_oids</name> <operator>=</operator> <call><name>add_node_list</name><argument_list>(<argument><expr><name>old_oids</name></expr></argument>, <argument><expr><name>old_num</name></expr></argument>, <argument><expr><name>add_oids</name></expr></argument>, <argument><expr><name>add_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort once again the newly-created array of node Oids to maintain consistency */</comment>
    <expr_stmt><expr><name>old_oids</name> <operator>=</operator> <call><name>SortRelationDistributionNodes</name><argument_list>(<argument><expr><name>old_oids</name></expr></argument>, <argument><expr><name>old_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Update pgxc_class entry */</comment>
    <expr_stmt><expr><call><name>PgxcClassAlter</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><literal type="char">'\0'</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><name>old_num</name></expr></argument>,
                   <argument><expr><name>old_oids</name></expr></argument>,
                   <argument><expr><name>PGXC_CLASS_ALTER_NODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make the additional catalog changes visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE &lt;name&gt; DELETE NODE nodelist
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtExecDeleteNode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>del_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>del_num</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name><name>old_oids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>old_num</name><index>[<expr><literal type="number">2</literal></expr>]</index></name>  <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>old_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_num</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Nothing to do on Datanodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Build a new array of sorted node Oids given the list of name nodes
     * to be deleted.
     */</comment>
    <expr_stmt><expr><name>del_oids</name> <operator>=</operator> <call><name>BuildRelationDistributionNodes</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>del_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <comment type="block">/*
     * Check if nodes to be deleted are really included in existing
     * node list and get updated list of nodes.
     */</comment>
    <expr_stmt><expr><name><name>old_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>get_pgxc_classnodes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Delete elements on array */</comment>
    <expr_stmt><expr><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>delete_node_list</name><argument_list>(<argument><expr><name><name>old_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>old_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>del_oids</name></expr></argument>, <argument><expr><name>del_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>old_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * Check if nodes to be deleted are really included in existing
     * node list and get updated list of nodes.
     */</comment>
    <expr_stmt><expr><name>old_num</name> <operator>=</operator> <call><name>get_pgxc_classnodes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Delete elements on array */</comment>
    <expr_stmt><expr><name>old_oids</name> <operator>=</operator> <call><name>delete_node_list</name><argument_list>(<argument><expr><name>old_oids</name></expr></argument>, <argument><expr><name>old_num</name></expr></argument>, <argument><expr><name>del_oids</name></expr></argument>, <argument><expr><name>del_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Update pgxc_class entry */</comment>
    <expr_stmt><expr><call><name>PgxcClassAlter</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><literal type="char">'\0'</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><name>old_num</name></expr></argument>,
                   <argument><expr><name>old_oids</name></expr></argument>,
                   <argument><expr><name>PGXC_CLASS_ALTER_NODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make the additional catalog changes visible */</comment>
    <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ATCheckCmd
 *
 * Check ALTER TABLE restrictions in Postgres-XC
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATCheckCmd</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Do nothing in the case of a remote node */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>AT_DropColumn</name></expr>:</case>
            <comment type="block">/* Distribution column cannot be dropped */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsDistColumnForRelId</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Distribution column cannot be dropped"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <call><name>mls_cls_column_drop_check</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_cls column could be altered by mls_admin"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>

        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * BuildRedistribCommands
 * Evaluate new and old distribution and build the list of operations
 * necessary to perform table redistribution.
 */</comment>
<function><type><specifier>static</specifier> <name>RedistribState</name> <modifier>*</modifier></type>
<name>BuildRedistribCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subCmds</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RedistribState</name>   <modifier>*</modifier></type><name>redistribState</name> <init>= <expr><call><name>makeRedistribState</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>oldLocInfo</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newLocInfo</name></decl>;</decl_stmt> <comment type="block">/* Former locator info */</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>new_oid_array</name></decl>;</decl_stmt>    <comment type="block">/* Modified list of Oids */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>new_num</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>    <comment type="block">/* Modified number of Oids */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type>        <name>node_type</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name>        <modifier>*</modifier></type><name><name>tmp_oid_array</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>tmp_num</name><index>[<expr><literal type="number">2</literal></expr>]</index></name>          <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Get necessary information about relation */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>redistribState</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldLocInfo</name> <operator>=</operator> <call><name>RelationGetLocInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldLocInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get a copy of the locator information that will be modified by
     * successive ALTER TABLE commands.
     */</comment>
    <expr_stmt><expr><name>newLocInfo</name> <operator>=</operator> <call><name>CopyRelationLocInfo</name><argument_list>(<argument><expr><name>oldLocInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The node list of this locator information will be rebuilt after command scan */</comment>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>newLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Get the list to be modified */</comment>
    <expr_stmt><expr><name>new_num</name> <operator>=</operator> <call><name>get_pgxc_classnodes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_oid_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>item</argument>, <argument>subCmds</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>AT_DistributeBy</name></expr>:</case>
                <comment type="block">/*
                 * Get necessary distribution information and update to new
                 * distribution type.
                 */</comment>
                <expr_stmt><expr><call><name>GetRelationDistributionItems</name><argument_list>(<argument><expr><name><name>redistribState</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>DistributeBy</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
                                             <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newLocInfo</name><operator>-&gt;</operator><name>locatorType</name></name><operator>)</operator></expr></argument>,
                                             <argument><expr><name>NULL</name></expr></argument>,
                                             <argument><expr><name>NULL</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                                             <argument><expr><operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>newLocInfo</name><operator>-&gt;</operator><name>secAttrNum</name></name><operator>)</operator></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                             <argument><expr><operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>newLocInfo</name><operator>-&gt;</operator><name>partAttrNum</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>AT_SubCluster</name></expr>:</case>
                <comment type="block">/* Update new list of nodes */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <expr_stmt><expr><call><name>GetRelationDistributionNodes</name><argument_list>(<argument><expr><operator>(</operator><name>PGXCSubCluster</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>tmp_oid_array</name></expr></argument>, <argument><expr><name>tmp_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>new_num</name> <operator>=</operator> <name><name>tmp_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>new_oid_array</name> <operator>=</operator> <name><name>tmp_oid_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>new_oid_array</name> <operator>=</operator> <call><name>GetRelationDistributionNodes</name><argument_list>(<argument><expr><operator>(</operator><name>PGXCSubCluster</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>
            <case>case <expr><name>AT_AddNodeList</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>add_oids</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>add_num</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>add_oids</name> <operator>=</operator> <call><name>BuildRelationDistributionNodes</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>add_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Add elements to array */</comment>
                    <expr_stmt><expr><name>new_oid_array</name> <operator>=</operator> <call><name>add_node_list</name><argument_list>(<argument><expr><name>new_oid_array</name></expr></argument>, <argument><expr><name>new_num</name></expr></argument>, <argument><expr><name>add_oids</name></expr></argument>, <argument><expr><name>add_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <case>case <expr><name>AT_DeleteNodeList</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>del_oids</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>del_num</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>del_oids</name> <operator>=</operator> <call><name>BuildRelationDistributionNodes</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>del_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Delete elements from array */</comment>
                    <expr_stmt><expr><name>new_oid_array</name> <operator>=</operator> <call><name>delete_node_list</name><argument_list>(<argument><expr><name>new_oid_array</name></expr></argument>, <argument><expr><name>new_num</name></expr></argument>, <argument><expr><name>del_oids</name></expr></argument>, <argument><expr><name>del_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Should not happen */</comment>
        </block_content>}</block></switch>
    </block_content>}</block>

    <comment type="block">/* Build relation node list for new locator info */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>new_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>newLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>newLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>,
                                           <argument><expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>new_oid_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                             <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <comment type="block">/* Build the command tree for table redistribution */</comment>
    <expr_stmt><expr><call><name>PGXCRedistribCreateCommandList</name><argument_list>(<argument><expr><name>redistribState</name></expr></argument>, <argument><expr><name>newLocInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up */</comment>
    <expr_stmt><expr><call><name>FreeRelationLocInfo</name><argument_list>(<argument><expr><name>newLocInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_oid_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>redistribState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Delete from given Oid array old_oids the given oid list del_oids
 * and build a new one.
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>delete_node_list</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>old_oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>old_num</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>del_oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>del_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>new_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Allocate former array and data */</comment>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>new_oids</name> <init>= <expr><name>old_oids</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>loc_new_num</name> <init>= <expr><name>old_num</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Delete from existing node Oid array the elements to be removed.
     * An error is returned if an element to be deleted is not in existing array.
     * It is not necessary to sort once again the result array of node Oids
     * as here only a deletion of elements is done.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>del_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name> <init>= <expr><name><name>del_oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>position</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>is_listed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>position</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>loc_new_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Check if element can be removed */</comment>
            <if_stmt><if>if <condition>(<expr><name>nodeoid</name> <operator>==</operator> <name><name>new_oids</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_listed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>position</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Move all the elements from [j+1, n-1] to [j, n-2] */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_listed</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>position</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>loc_new_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>new_oids</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>new_oids</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

            <expr_stmt><expr><name>loc_new_num</name><operator>--</operator></expr>;</expr_stmt>

            <comment type="block">/* Not possible to have an empty list */</comment>
            <if_stmt><if>if <condition>(<expr><name>loc_new_num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Node list is empty: one node at least is mandatory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>new_oids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>new_oids</name></expr></argument>, <argument><expr><name>loc_new_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not in relation node list"</literal></expr></argument>,
                            <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Save new number of nodes */</comment>
    <expr_stmt><expr><operator>*</operator><name>new_num</name> <operator>=</operator> <name>loc_new_num</name></expr>;</expr_stmt>
    <return>return <expr><name>new_oids</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Add to given Oid array old_oids the given oid list add_oids
 * and build a new one.
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>add_node_list</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>old_oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>old_num</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>add_oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>new_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Allocate former array and data */</comment>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>new_oids</name> <init>= <expr><name>old_oids</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>loc_new_num</name> <init>= <expr><name>old_num</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Build new Oid list, both addition and old list are already sorted.
     * The idea here is to go through the list of nodes to be added and
     * add the elements one-by-one on the existing list.
     * An error is returned if an element to be added already exists
     * in relation node array.
     * Here we do O(n^2) scan to avoid a dependency with the way
     * oids are sorted by heap APIs. They are sorted once again once
     * the addition operation is completed.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>add_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name> <init>= <expr><name><name>add_oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <comment type="block">/* Check if element is already a part of array */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>loc_new_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Item is already in node list */</comment>
            <if_stmt><if>if <condition>(<expr><name>nodeoid</name> <operator>==</operator> <name><name>new_oids</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object already in relation node list"</literal></expr></argument>,
                                <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* If we are here, element can be added safely in node array */</comment>
        <expr_stmt><expr><name>loc_new_num</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_oids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>new_oids</name></expr></argument>, <argument><expr><name>loc_new_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_oids</name><index>[<expr><name>loc_new_num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nodeoid</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Sort once again the newly-created array of node Oids to maintain consistency */</comment>
    <expr_stmt><expr><name>new_oids</name> <operator>=</operator> <call><name>SortRelationDistributionNodes</name><argument_list>(<argument><expr><name>new_oids</name></expr></argument>, <argument><expr><name>loc_new_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Save new number of nodes */</comment>
    <expr_stmt><expr><operator>*</operator><name>new_num</name> <operator>=</operator> <name>loc_new_num</name></expr>;</expr_stmt>
    <return>return <expr><name>new_oids</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtExecRebuildExtent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RebuildExtentMap</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"building extent is allowed only at datanode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Preparation phase for SET LOGGED/UNLOGGED
 *
 * This verifies that we're not trying to change a temp table.  Also,
 * existing foreign key constraints are checked to avoid ending up with
 * permanent tables referencing unlogged tables.
 *
 * Return value is false if the operation is a no-op (in which case the
 * checks are skipped), otherwise true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ATPrepChangePersistence</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toLogged</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pg_constraint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Disallow changing status for a temp table.  Also verify whether we can
     * get away with doing nothing; in such cases we don't need to run the
     * checks below, either.
     */</comment>
    <switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change logged status of table \"%s\" because it is temporary"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errtable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>toLogged</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* nothing to do */</comment>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>toLogged</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* nothing to do */</comment>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Check that the table is not part any publication when changing to
     * UNLOGGED as UNLOGGED tables can't be published.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>toLogged</name> <operator>&amp;&amp;</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><call><name>GetRelationPublications</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change table \"%s\" to unlogged because it is part of a publication"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unlogged relations cannot be replicated."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check existing foreign key constraints to preserve the invariant that
     * permanent tables cannot reference unlogged ones.  Self-referencing
     * foreign keys can safely be ignored.
     */</comment>
    <expr_stmt><expr><name>pg_constraint</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan conrelid if changing to permanent, else confrelid.  This also
     * determines whether a useful index exists.
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name>Anum_pg_constraint_conrelid</name></expr> </then><else>:
                <expr><name>Anum_pg_constraint_confrelid</name></expr></else></ternary></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>,
                              <argument><expr><ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name>ConstraintRelidIndexId</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></argument>,
                              <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>foreignrelid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>foreignrel</name></decl>;</decl_stmt>

            <comment type="block">/* the opposite end of what we used as scankey */</comment>
            <expr_stmt><expr><name>foreignrelid</name> <operator>=</operator> <ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr> </then><else>: <expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></else></ternary></expr>;</expr_stmt>

            <comment type="block">/* ignore if self-referencing */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>foreignrelid</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>foreignrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>foreignrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>toLogged</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change table \"%s\" to logged because it references unlogged table \"%s\""</literal></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change table \"%s\" to unlogged because it references logged table \"%s\""</literal></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>AlterTableNamespaceRecruse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldschema</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newschema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>newschemaname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>objsMoved</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AlterTableNamespaceInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldschema</name></expr></argument>, <argument><expr><name>newschema</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>, <argument><expr><name>newschemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>   

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Execute ALTER TABLE SET SCHEMA
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterTableNamespace</name><parameter_list>(<parameter><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oldschema</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>oldNspOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>nspOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>newrv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>schema_crypted</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>tbl_crypted</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                                     <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                     <argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* altet partition table namespace is not permitted */</comment>
    <if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"alter interval child partition's namespace is not permitted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If it's an owned sequence, disallow moving it by itself. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>tableId</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>colId</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move an owned sequence into another schema"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s\" is linked to table \"%s\"."</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get and lock schema OID and check its permissions. */</comment>
    <expr_stmt><expr><name>newrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nspOid</name> <operator>=</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name>newrv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* common checks on switching namespaces */</comment>
    <expr_stmt><expr><call><name>CheckSetNamespace</name><argument_list>(<argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <comment type="block">/*
     *  | table crypted | src schema crypted | dst schema crypted | result |
     *  |   yes         | no                 | yes/no             | fail   |
     * other couples are ok, cause: 
     * 1. table moved to another schema is still bound with crypt policy, so data is protected.
     * 2. new table created in crypted schema will be crypted, data is protected.
     * 3. table having no crypto, no care data privacy.
     *
     */</comment>
    <expr_stmt><expr><name>tbl_crypted</name> <operator>=</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_crypted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>true</name> <operator>==</operator> <name>tbl_crypted</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>false</name> <operator>==</operator> <name>schema_crypted</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not alter table:%s schema, cause mls poilcy is bound"</literal></expr></argument>, 
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>objsMoved</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AlterTableNamespaceInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>oldschema</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>oldschema</name> <operator>=</operator> <name>oldNspOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
     * if this is interval partition, we change its children's schema too.
     * while, change child schema directly is forbidden.
     * and, orginal partition keep its own way.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>RELKIND_RELATION</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type> <name>children</name> <init>= <expr><call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name><modifier>*</modifier></type> <name>child</name></decl>;</decl_stmt>
            <macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>      <name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>AlterTableNamespaceRecruse</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* close rel, but keep lock until commit */</comment>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The guts of relocating a table or materialized view to another namespace:
 * besides moving the relation itself, its dependent objects are relocated to
 * the new schema.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTableNamespaceInternal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>,
                            <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
                            , <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>newschemaname</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            )</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>classRel</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>objsMoved</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* OK, modify the pg_class row and pg_depend entry */</comment>
    <expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>,
                                   <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fix the table's row type too */</comment>
    <expr_stmt><expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
                               <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fix other dependent stuff */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AlterIndexNamespaces</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AlterSeqNamespaces</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>,
                           <argument><expr><name>objsMoved</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AlterConstraintNamespaces</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Rename also sequence on GTM for a sequence */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>oldNspOid</name> <operator>!=</operator> <name>nspOid</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newseqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We also need to rename it on the GTM */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RenameSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>newseqname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not rename sequence"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RegisterRenameSequence</name><argument_list>(<argument><expr><name>newseqname</name></expr></argument>, <argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newseqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>AlterCryptdTableNamespace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>newschemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * The guts of relocating a relation to another namespace: fix the pg_class
 * entry, and the pg_depend entry if any.  Caller must already have
 * opened and write-locked pg_class.
 */</comment>
<function><type><name>void</name></type>
<name>AlterRelationNamespaceInternal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>,
                               <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>,
                               <parameter><decl><type><name>bool</name></type> <name>hasDependEntry</name></decl></parameter>,
                               <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>classTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>thisobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>already_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>classTup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>oldNspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * If the object has already been moved, don't move it again.  If it's
     * already in the right place, don't move it, but still fire the object
     * access hook.
     */</comment>
    <expr_stmt><expr><name>already_done</name> <operator>=</operator> <call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_done</name> <operator>&amp;&amp;</operator> <name>oldNspOid</name> <operator>!=</operator> <name>newNspOid</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* check for duplicate name (more friendly than unique-index failure) */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* classTup is a copy, so OK to scribble on */</comment>
        <expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>=</operator> <name>newNspOid</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>classTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Update dependency on schema if caller said so */</comment>
        <if_stmt><if>if <condition>(<expr><name>hasDependEntry</name> <operator>&amp;&amp;</operator>
            <call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                <argument><expr><name>relOid</name></expr></argument>,
                                <argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                <argument><expr><name>oldNspOid</name></expr></argument>,
                                <argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to change schema dependency for relation \"%s\""</literal></expr></argument>,
                 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_done</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Move all indexes for the specified relation to another namespace.
 *
 * Note: we assume adequate permission checking was done by the caller,
 * and that the caller has a suitable lock on the owning relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterIndexNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                     <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>indexList</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>indexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>thisobj</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Note: currently, the index will not have its own dependency on the
         * namespace, so we don't need to do changeDependencyFor(). There's no
         * row type in pg_type, either.
         *
         * XXX this objsMoved test may be pointless -- surely we have a single
         * dependency link from a relation to each index?
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>,
                                           <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>newNspOid</name></expr></argument>,
                                           <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Move all identity and SERIAL-column sequences of the specified relation to another
 * namespace.
 *
 * Note: we assume adequate permission checking was done by the caller,
 * and that the caller has a suitable lock on the owning relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterSeqNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>,
                   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>depRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <comment type="block">/*
     * SERIAL sequences are those having an auto dependency on one of the
     * table's columns (we don't care *which* column, exactly).
     */</comment>
    <expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* we leave refobjsubid unspecified */</comment>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>depForm</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>seqRel</name></decl>;</decl_stmt>

        <comment type="block">/* skip dependencies other than auto dependencies on columns */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>depForm</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <name><name>depForm</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
            <name><name>depForm</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>!</operator><operator>(</operator><name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator> <name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Use relation_open just in case it's an index */</comment>
        <expr_stmt><expr><name>seqRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* skip non-sequence relations */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* No need to keep the lock */</comment>
            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Fix the pg_class and pg_depend entries */</comment>
        <expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
                                       <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>newNspOid</name></expr></argument>,
                                       <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Sequences have entries in pg_type. We need to be careful to move
         * them to the new namespace, too.
         */</comment>
        <expr_stmt><expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
                                   <argument><expr><name>newNspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/* Change also this sequence name on GTM */</comment>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>oldNspOid</name> <operator>!=</operator> <name>newNspOid</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newseqname</name> <init>= <expr><call><name>GetGlobalSeqName</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* We also need to rename it on the GTM */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>RenameSequenceGTM</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>, <argument><expr><name>newseqname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GTM error, could not rename sequence"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><call><name>RegisterRenameSequence</name><argument_list>(<argument><expr><name>newseqname</name></expr></argument>, <argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>seqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newseqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Now we can close it.  Keep the lock till end of transaction. */</comment>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * This code supports
 *    CREATE TEMP TABLE ... ON COMMIT { DROP | PRESERVE ROWS | DELETE ROWS }
 *
 * Because we only support this for TEMP tables, it's sufficient to remember
 * the state in a backend-local data structure.
 */</comment>

<comment type="block">/*
 * Register a newly-created relation's ON COMMIT action.
 */</comment>
<function><type><name>void</name></type>
<name>register_on_commit_action</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>OnCommitAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We needn't bother registering the relation unless there is an ON COMMIT
     * action we need to take.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>ONCOMMIT_NOOP</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>ONCOMMIT_PRESERVE_ROWS</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oc</name> <operator>=</operator> <operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OnCommitItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>oc</name></expr></argument>, <argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unregister any ON COMMIT action when a relation is deleted.
 *
 * Actually, we only mark the OnCommitItem entry as to be deleted after commit.
 */</comment>
<function><type><name>void</name></type>
<name>remove_on_commit_action</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Perform ON COMMIT actions.
 *
 * This is invoked just before actually committing, since it's possible
 * to encounter errors.
 */</comment>
<function><type><name>void</name></type>
<name>PreCommit_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>oids_to_truncate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>oids_to_drop</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * If we are being called outside a valid transaction, do nothing. This can
     * only happen when the function gets called while we are still processing
     * CommitTransaction/PrepareTransaction
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Ignore entry if already dropped in this xact */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>ONCOMMIT_NOOP</name></expr>:</case>
            <case>case <expr><name>ONCOMMIT_PRESERVE_ROWS</name></expr>:</case>
                <comment type="block">/* Do nothing (there shouldn't be such entries, actually) */</comment>
                <break>break;</break>
            <case>case <expr><name>ONCOMMIT_DELETE_ROWS</name></expr>:</case>

                <comment type="block">/*
                 * If this transaction hasn't accessed any temporary
                 * relations, we can skip truncating ON COMMIT DELETE ROWS
                 * tables, as they must still be empty.
                 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XCP</name></cpp:ifndef>
                <comment type="block">/*
                 * This optimization does not work in XL since temporary tables
                 * are handled differently in XL.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>MyXactFlags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACCESSEDTEMPREL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>oids_to_truncate</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids_to_truncate</name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>ONCOMMIT_DROP</name></expr>:</case>
				<expr_stmt><expr><name>oids_to_drop</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids_to_drop</name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * Truncate relations before dropping so that all dependencies between
	 * relations are removed after they are worked on.  Doing it like this
	 * might be a waste as it is possible that a relation being truncated will
	 * be dropped anyway due to its parent being dropped, but this makes the
	 * code more robust because of not having to re-check that the relation
	 * exists at truncation time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oids_to_truncate</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_truncate</name><argument_list>(<argument><expr><name>oids_to_truncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* XXX needed? */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>oids_to_drop</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name> <init>= <expr><call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>oids_to_drop</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

                    <comment type="block">/*
		 * Since this is an automatic drop, rather than one directly initiated
		 * by the user, we pass the PERFORM_DELETION_INTERNAL flag.
                     */</comment>
		<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>, <argument><expr><name>DROP_CASCADE</name></expr></argument>,
								 <argument><expr><name>PERFORM_DELETION_INTERNAL</name> <operator>|</operator> <name>PERFORM_DELETION_QUIETLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

                    <comment type="block">/*
		 * Note that table deletion will call remove_on_commit_action, so the
		 * entry should get marked as deleted.
                     */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>!=</operator> <name>ONCOMMIT_DROP</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Post-commit or post-abort cleanup for ON COMMIT management.
 *
 * All we do here is remove no-longer-needed OnCommitItem entries.
 *
 * During commit, remove entries that were deleted during this transaction;
 * during abort, remove those created during this transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev_item</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>cur_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>isCommit</name></expr> ?</condition><then> <expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr> </then><else>:
            <expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr></else></ternary></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* cur_item must be removed */</comment>
            <expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>, <argument><expr><name>cur_item</name></expr></argument>, <argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>prev_item</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* cur_item must be preserved */</comment>
            <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>cur_item</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Post-subcommit or post-subabort cleanup for ON COMMIT management.
 *
 * During subabort, we can immediately remove entries created during this
 * subtransaction.  During subcommit, just relabel entries marked during
 * this subtransaction as being the parent's responsibility.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
                              <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev_item</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>cur_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name> <operator>&amp;&amp;</operator> <name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* cur_item must be removed */</comment>
            <expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>, <argument><expr><name>cur_item</name></expr></argument>, <argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>prev_item</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* cur_item must be preserved */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <ternary><condition><expr><name>isCommit</name></expr> ?</condition><then> <expr><name>parentSubid</name></expr> </then><else>: <expr><name>InvalidSubTransactionId</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>cur_item</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * This is intended as a callback for RangeVarGetRelidExtended().  It allows
 * the relation to be locked only if (1) it's a plain table, materialized
 * view, or TOAST table and (2) the current user is the owner (or the
 * superuser).  This meets the permission-checking needs of CLUSTER, REINDEX
 * TABLE, and REFRESH MATERIALIZED VIEW; we expose it here so that it can be
 * used by all.
 */</comment>
<function><type><name>void</name></type>
<name>RangeVarCallbackOwnsTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>

    <comment type="block">/* Nothing to do if the relation was not found. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the relation does exist, check whether it's an index.  But note that
     * the relation might have been dropped between the time we did the name
     * lookup and now.  In that case, there's nothing to do.
     */</comment>
    <expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>relkind</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check permissions */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback to RangeVarGetRelidExtended(), similar to
 * RangeVarCallbackOwnsTable() but without checks on the type of the relation.
 */</comment>
<function><type><name>void</name></type>
<name>RangeVarCallbackOwnsRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
                             <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <comment type="block">/* Nothing to do if the relation was not found. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
                       <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator>
        <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
                        <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common RangeVarGetRelid callback for rename, set schema, and alter table
 * processing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForAlterRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
                                 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectType</name></type>    <name>reltype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>relkind</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* concurrently dropped */</comment>
    <expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <comment type="block">/* Must own relation, or mls_admin to add "_cls" column, or mls_admin detach mls policy table */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>mls_policy_check</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* No system table modifications unless explicitly allowed. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
                        <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Extract the specified relation type from the statement parse tree.
     *
     * Also, for ALTER .. RENAME, check permissions: the user must (still)
     * have CREATE rights on the containing namespace.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>,
                                          <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_NAMESPACE</name></expr></argument>,
                           <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr>;</expr_stmt></block_content></block></if>

    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>reltype</name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt> <comment type="block">/* placate compiler */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * For compatibility with prior releases, we allow ALTER TABLE to be used
     * with most other types of relations (but not composite types). We allow
     * similar flexibility for ALTER INDEX in the case of RENAME, but not
     * otherwise.  Otherwise, the user must select the correct form of the
     * command for the relation at issue.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_SEQUENCE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_MATVIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a materialized view"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_TYPE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a composite type"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name>
        <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Don't allow ALTER TABLE on composite types. We want people to use ALTER
     * TYPE for that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>!=</operator> <name>OBJECT_TYPE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a composite type"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TYPE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Don't allow ALTER TABLE .. SET SCHEMA on relations that can't be moved
     * to a different schema, such as indexes and TOAST tables.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
        <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, sequence, or foreign table"</literal></expr></argument>,
                        <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<comment type="block">/*
 * IsTempTable
 *
 * Check if given table Oid is temporary.
 */</comment>
<function><type><name>bool</name></type>
<name>IsTempTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>
    <comment type="block">/*
     * PGXCTODO: Is it correct to open without locks?
     * we just check if this table is temporary though...
     */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsLocalTempTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
            <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsIndexUsingTemp
 *
 * Check if given index relation uses temporary tables.
 */</comment>
<function><type><name>bool</name></type>
<name>IsIndexUsingTempTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>parent_id</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>parent_id</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>

        <comment type="block">/* Release system cache BEFORE looking at the parent table */</comment>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>IsTempTable</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* Default case */</comment>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsOnCommitActions
 *
 * Check if there are any on-commit actions activated.
 */</comment>
<function><type><name>bool</name></type>
<name>IsOnCommitActions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DropTableThrowErrorExternal
 *
 * Error interface for DROP when looking for execution node type.
 */</comment>
<function><type><name>void</name></type>
<name>DropTableThrowErrorExternal</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>ObjectType</name></type> <name>removeType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>relkind</name></decl>;</decl_stmt>

    <comment type="block">/* Determine required relkind */</comment>
    <switch>switch <condition>(<expr><name>removeType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_SEQUENCE</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_VIEW</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized drop object type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>removeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>relkind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>DropErrorMsgNonExistent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Transform any expressions present in the partition key
 *
 * Returns a transformed PartitionSpec, as well as the strategy code
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type>
<name>transformPartitionSpec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>partspec</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>newspec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>newspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <comment type="block">/* Parse partitioning strategy name */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"interval"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_INTERVAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized partitioning strategy \"%s\""</literal></expr></argument>,
                        <argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Check valid number of columns for strategy */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>&amp;&amp;</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"list\" partition strategy with more than one column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create a dummy ParseState and insert the target relation as its sole
     * rangetable entry.  We need a ParseState for transformExpr.
     */</comment>
    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* take care of any partition expressions */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>partspec-&gt;partParams</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>pelem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/* Check for PARTITION BY ... (foo, foo) */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>newspec-&gt;partParams</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>pparam</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>pparam</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pparam</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" appears more than once in partition key"</literal></expr></argument>,
                                <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Copy, to avoid scribbling on the input */</comment>
            <expr_stmt><expr><name>pelem</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>pelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Now do parse transformation of the expression */</comment>
            <expr_stmt><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                        <argument><expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* we have to fix its collations too */</comment>
            <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>newspec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute per-partition-column information from a list of PartitionElems.
 * Expressions in the PartitionElems must be parse-analyzed already.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ComputePartitionAttrs</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partParams</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partattrs</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					  <parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>attn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>am_oid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>attn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partParams</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>pelem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>atttype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>attcollation</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Simple attribute reference */</comment>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>atttuple</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in partition key does not exist"</literal></expr></argument>,
								<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use system column \"%s\" in partition key"</literal></expr></argument>,
								<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Expression */</comment>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>atttype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Strip any top-level COLLATE clause.  This ensures that we treat
             * "x COLLATE y" and "(x COLLATE y)" alike.
             */</comment>
            <while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * User wrote "(column)" or "(column COLLATE something)".
                 * Treat it like simple attribute anyway.
                 */</comment>
                <expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>expr_attrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* marks the column as expression */</comment>
                <expr_stmt><expr><operator>*</operator><name>partexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Try to simplify the expression before checking for
                 * mutability.  The main practical value of doing it in this
                 * order is that an inline-able SQL-language function will be
                 * accepted if its expansion is immutable, whether or not the
                 * function itself is marked immutable.
                 *
                 * Note that expression_planner does not change the passed in
                 * expression destructively and we have already saved the
                 * expression to be stored into the catalog above.
                 */</comment>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Partition expression cannot contain mutable functions,
                 * because a given row must always map to the same partition
                 * as long as there is no change in the partition boundary
                 * structure.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"functions in partition key expression must be marked IMMUTABLE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * transformPartitionSpec() should have already rejected
                 * subqueries, aggregates, window functions, and SRFs, based
                 * on the EXPR_KIND_ for partition expressions.
                 */</comment>

                <comment type="block">/*
                 * Cannot have expressions containing whole-row references or
                 * system column references.
                 */</comment>
                <expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
                                  <argument><expr><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition key expressions cannot contain whole-row references"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
                                      <argument><expr><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition key expressions cannot contain system column references"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="block">/*
                 * While it is not exactly *wrong* for a partition expression
                 * to be a constant, it seems better to reject such keys.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use constant expression as partition key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Apply collation override if any
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check we have a collation iff it's a collatable type.  The only
         * expected failures here are (1) COLLATE applied to a noncollatable
         * type, or (2) partition expression had an unresolved collation. But
         * we might as well code this to be a complete consistency check.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for partition expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>partcollation</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>attcollation</name></expr>;</expr_stmt>

        <comment type="block">/*
		 * Identify the appropriate operator class.  For list and range
		 * partitioning, we use a btree operator class; hash partitioning uses
		 * a hash operator class.
         */</comment>
		<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>am_oid</name> <operator>=</operator> <name>HASH_AM_OID</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>am_oid</name> <operator>=</operator> <name>BTREE_AM_OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pelem</name><operator>-&gt;</operator><name>opclass</name></name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>am_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default hash operator class"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify a hash operator class or define a default hash operator class for the data type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default btree operator class"</literal></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify a btree operator class or define a default btree operator class for the data type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			</block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>ResolveOpClass</name><argument_list>(<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>,
                                               <argument><expr><name>atttype</name></expr></argument>,
											   <argument><expr><ternary><condition><expr><name>am_oid</name> <operator>==</operator> <name>HASH_AM_OID</name></expr> ?</condition><then> <expr><literal type="string">"hash"</literal></expr> </then><else>: <expr><literal type="string">"btree"</literal></expr></else></ternary></expr></argument>,
											   <argument><expr><name>am_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>attn</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * PartConstraintImpliedByRelConstraint
 *		Does scanrel's existing constraints imply the partition constraint?
 *
 * Existing constraints includes its check constraints and column-level
 * NOT NULL constraints and partConstraint describes the partition constraint.
 */</comment>
<function><type><name>bool</name></type>
<name>PartConstraintImpliedByRelConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>existConstraint</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_check</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>i</name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * argisrow=false is correct even for a composite column,
				 * because attnotnull does not represent a SQL-spec IS NOT
				 * NULL test in such a case, just IS DISTINCT FROM NULL.
				 */</comment>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>existConstraint</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>existConstraint</name></expr></argument>, <argument><expr><name>ntest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>num_check</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_check</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this constraint hasn't been fully validated yet, we must ignore
		 * it here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccvalid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run each expression through const-simplification and
		 * canonicalization.  It is necessary, because we will be comparing it
		 * to similarly-processed partition constraint expressions, and may
		 * fail to detect valid matches without this.
		 */</comment>
		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>existConstraint</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>existConstraint</name></expr></argument>,
									  <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>existConstraint</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>existConstraint</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>existConstraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And away we go ... */</comment>
	<return>return <expr><call><name>predicate_implied_by</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><name>existConstraint</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * QueuePartitionConstraintValidation
 *
 * Add an entry to wqueue to have the given partition constraint validated by
 * Phase 3, for the given relation, and all its children.
 *
 * We first verify whether the given constraint is implied by pre-existing
 * relation constraints; if it is, there's no need to scan the table to
 * validate, so don't queue in that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>QueuePartitionConstraintValidation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>validate_default</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Based on the table's existing constraints, determine whether or not we
	 * may skip scanning the table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>, <argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>validate_default</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint for table \"%s\" is implied by existing constraints"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" is implied by existing constraints"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Constraints proved insufficient. For plain relations, queue a validation
	 * item now; for partitioned tables, recurse to process each partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

		<comment type="block">/* Grab a work queue entry. */</comment>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>validate_default</name></name> <operator>=</operator> <name>validate_default</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>part_rel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>thisPartConstraint</name></decl>;</decl_stmt>

		<comment type="block">/*
			 * This is the minimum lock we need to prevent deadlocks.
		 */</comment>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Adjust the constraint for scanrel so that it matches this
			 * partition's attribute numbers.
			 */</comment>
			<expr_stmt><expr><name>thisPartConstraint</name> <operator>=</operator>
				<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>scanrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There can never be a whole-row reference here */</comment>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in partition constraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>part_rel</name></expr></argument>,
											   <argument><expr><name>thisPartConstraint</name></expr></argument>,
											   <argument><expr><name>validate_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep lock till commit */</comment>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE &lt;name&gt; ATTACH PARTITION &lt;partition-name&gt; FOR VALUES
 *
 * Return the address of the newly attached partition.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAttachPartition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>attachrel</name></decl>,
                <decl><type ref="prev"/><name>catalog</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attachrel_children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partConstraint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigger_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found_whole_row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>defaultPartOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partBoundConstraint</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must lock the default partition if one exists, because attaching a
     * new partition will change its partition constraint.
	 */</comment>
	<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
		<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>attachrel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Must be owner of both parent and source table -- parent was checked by
     * ATSimplePermissions call in ATPrepCmd
     */</comment>
    <expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* A partition can only have one parent */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a partition"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a typed table as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Table being attached should not already be part of inheritance; either
     * as a child table...
     */</comment>
    <expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
                <argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach inheritance child as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ...or as a parent table (except the case when it is partitioned) */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
                <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach inheritance parent as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Prevent circularity by seeing if rel is a partition of attachrel. (In
     * particular, this disallows making a rel a partition of itself.)
     *
     * We do that by checking if rel is a member of the list of attachRel's
     * partitions provided the latter is partitioned at all.  We want to avoid
	 * having to construct this list again, so we request the strongest lock
     * on all partitions.  We need the strongest lock, because we may decide
     * to scan them if we find out that the table being attached (or its leaf
     * partitions) may contain rows that violate the partition constraint. If
     * the table has a constraint that would prevent such rows, which by
     * definition is present in all the partitions, we need not scan the
     * table, nor its partitions.  But we cannot risk a deadlock by taking a
     * weaker lock now and the stronger one only when needed.
     */</comment>
    <expr_stmt><expr><name>attachrel_children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
			                                 <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>attachrel_children</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular inheritance not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a child of \"%s\"."</literal></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Temp parent cannot have a partition that is itself not a temp */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
        <name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a permanent relation as partition of temporary relation \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If the parent is temp, it must belong to this session */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach as partition of temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Ditto for the partition */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>attachrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach temporary relation of another session as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If parent has OIDs then child must have OIDs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach table \"%s\" without OIDs as partition of"</literal>
                        <literal type="string">" table \"%s\" with OIDs"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* OTOH, if parent doesn't have them, do not allow in attachrel either */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach table \"%s\" with OIDs as partition of table"</literal>
                        <literal type="string">" \"%s\" without OIDs"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check if there are any columns in attachrel that aren't in the parent */</comment>
    <expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Ignore dropped */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Try to find the column in parent (matching on column name) */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" contains column \"%s\" not found in parent \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"New partition should contain only the columns present in parent."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If child_rel has row-level triggers with transition tables, we
     * currently don't allow it to become a partition.  See also prohibitions
     * in ATExecAddInherit() and CreateTrigger().
     */</comment>
    <expr_stmt><expr><name>trigger_name</name> <operator>=</operator> <call><name>FindTriggerIncompatibleWithInheritance</name><argument_list>(<argument><expr><name><name>attachrel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>trigger_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" prevents table \"%s\" from becoming a partition"</literal></expr></argument>,
                        <argument><expr><name>trigger_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported on partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Update the default partition oid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the new partition's bound is valid and does not overlap any
     * of existing partitions of the parent - note that it does not return on
     * error.
     */</comment>
    <expr_stmt><expr><call><name>check_new_partition_bound</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                              <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK to create inheritance.  Rest of the checks performed there */</comment>
	<expr_stmt><expr><call><name>CreateInheritance</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update the pg_class entry. */</comment>
    <expr_stmt><expr><call><name>StorePartitionBound</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure there exists a correct set of indexes in the partition. */</comment>
	<expr_stmt><expr><call><name>AttachPartitionEnsureIndexes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate partition constraint from the partition bound specification.
     * If the parent itself is a partition, make sure to include its
     * constraint as well.
     */</comment>
	<expr_stmt><expr><name>partBoundConstraint</name> <operator>=</operator> <call><name>get_qual_from_partbound</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>partBoundConstraint</name></expr></argument>,
                                 <argument><expr><call><name>RelationGetPartitionQual</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Skip validation if there are no constraints to validate. */</comment>
	<if_stmt><if>if <condition>(<expr><name>partConstraint</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partConstraint</name> <operator>=</operator>
			<operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                                     <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>partConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Adjust the generated constraint to match this partition's attribute
     * numbers.
     */</comment>
    <expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>,
                                             <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* There can never be a whole-row reference here */</comment>
    <if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unexpected whole-row reference found in partition key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Validate partition constraints against the table being attached. */</comment>
		<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>partConstraint</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're attaching a partition other than the default partition and a
	 * default one exists, then that partition's partition constraint changes,
	 * so add an entry to the work queue to validate it, too.  (We must not
	 * do this when the partition being attached is the default one; we
	 * already did it above!)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>defaultrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>defPartConstraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>bound</name><operator>-&gt;</operator><name>is_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we already hold a lock on the default partition */</comment>
		<expr_stmt><expr><name>defaultrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator>
			<call><name>get_proposed_default_constraint</name><argument_list>(<argument><expr><name>partBoundConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>defaultrel</name></expr></argument>,
									 <argument><expr><name>defPartConstraint</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* keep our lock until commit. */</comment>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>defaultrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* keep our lock until commit */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AttachPartitionEnsureIndexes
 *		subroutine for ATExecAttachPartition to create/match indexes
 *
 * Enforce the indexing rule for partitioned tables during ALTER TABLE / ATTACH
 * PARTITION: every partition must have an index attached to each index on the
 * partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AttachPartitionEnsureIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>attachrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attachRelIdxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>attachrelIdxRels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>attachInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								<argument><expr><literal type="string">"AttachPartitionEnsureIndexes"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>idxes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachRelIdxs</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachrelIdxRels</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachInfos</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build arrays of all existing indexes and their IndexInfos */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>attachRelIdxs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cldIdxId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>cldIdxId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attachInfos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * For each index on the partitioned table, find a matching one in the
	 * partition-to-be; if one is not found, create one.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>idx</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore indexes in the partitioned table other than partitioned
		 * indexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* construct an indexinfo to compare existing indexes against */</comment>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan the list of existing indexes in the partition-to-be, and mark
		 * the first matching, unattached one we find, if any, as partition of
		 * the parent index.  If we find one, we're done.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>		<name>cldConstrOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* does this index have a parent?  if so, can't use it */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>has_superclass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CompareIndexInfo</name><argument_list>(<argument><expr><name><name>attachInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>info</name></expr></argument>,
								 <argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rd_indcollation</name></expr></argument>,
								 <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
								 <argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rd_opfamily</name></expr></argument>,
								 <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
								 <argument><expr><name>attmap</name></expr></argument>,
								 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If this index is being created in the parent because of a
				 * constraint, then the child needs to have a constraint also,
				 * so look for one.  If there is no such constraint, this
				 * index is no good, so keep looking.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cldConstrOid</name> <operator>=</operator>
						<call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* no dice */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cldConstrOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* bingo. */</comment>
				<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>cldConstrOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If no suitable index was found in the partition-to-be, create one
		 * now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>attmap</name></expr></argument>,
										   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>constraintOid</name></expr></argument>,
						<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Clean up. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE DETACH PARTITION
 *
 * Return the address of the relation that is no longer a partition of rel.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDetachPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>partRel</name></decl>,
                <decl><type ref="prev"/><name>classRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>,
                <decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>new_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>,
                <decl><type ref="prev"/><name><name>new_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>,
                <decl><type ref="prev"/><name><name>new_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>defaultPartOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>schema_bound</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>partRel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_bound</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>schema_bound</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not detach partition for table:%s, cause mls poilcy is bound"</literal></expr></argument>, 
                    <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>   
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"must be owner of relation %s"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

   <comment type="block">/*
    * We must lock the default partition, because detaching this partition
    * will changing its partition constrant.
    */</comment>
   <expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
       <call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>partRel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* All inheritance related checks are performed within the function */</comment>
    <expr_stmt><expr><call><name>RemoveInheritance</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update pg_class tuple */</comment>
    <expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
                                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear relpartbound and reset relispartition */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>new_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the detach relation is the default partition itself, invalidate
		 * its entry in pg_partitioned_table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>defaultPartOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>update_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We must invalidate default partition's relcache, for the same
			 * reasons explained in StorePartitionBound().
			 */</comment>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* detach indexes too */</comment>
	<expr_stmt><expr><name>indexes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>idxid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idx</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_superclass</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>IndexGetRelation</name><argument_list>(<argument><expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator>
			   <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

    <comment type="block">/*
     * Invalidate the parent's relcache so that the partition is no longer
     * included in its partition descriptor.
     */</comment>
    <expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* keep our lock until commit */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Before acquiring lock on an index, acquire the same lock on the owning
 * table.
 */</comment>
<struct>struct <name>AttachIndexCallbackState</name>
<block>{
   <decl_stmt><decl><type><name>Oid</name></type>     <name>partitionOid</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Oid</name></type>     <name>parentTblOid</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>bool</name></type>    <name>lockedParentTbl</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForAttachIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>,
                              <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name><name>struct</name> <name>AttachIndexCallbackState</name></name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>

   <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>AttachIndexCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

   <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>lockedParentTbl</name></name></expr>)</condition>
   <block>{<block_content>
       <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parentTblOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lockedParentTbl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>

   <comment type="block">/*
    * If we previously locked some other heap, and the name we're looking up
    * no longer refers to an index on that relation, release the now-useless
    * lock.  XXX maybe we should do *after* we verify whether the index does
    * not actually belong to the same relation ...
    */</comment>
   <if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
   <block>{<block_content>
       <expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>

   <comment type="block">/* Didn't find a relation, so no need for locking or permission checks. */</comment>
   <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return;</return></block_content></block></if></if_stmt>

   <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return;</return></block_content></block></if></if_stmt>                 <comment type="block">/* concurrently dropped, so nothing to do */</comment>
   <expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
       <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
       <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
               <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
   <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <comment type="block">/*
    * Since we need only examine the heap's tupledesc, an access share lock
    * on it (preventing any DDL) is sufficient.
    */</comment>
   <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER INDEX i1 ATTACH PARTITION i2
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAttachPartitionIdx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>Relation</name></type>    <name>partIdx</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Relation</name></type>    <name>partTbl</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Relation</name></type>    <name>parentTbl</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Oid</name></type>         <name>partIdxId</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Oid</name></type>         <name>currParent</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name><name>struct</name> <name>AttachIndexCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>

   <comment type="block">/*
    * We need to obtain lock on the index 'name' to modify it, but we also
    * need to read its owning table's tuple descriptor -- so we need to lock
    * both.  To avoid deadlocks, obtain lock on the table before doing so on
    * the index.  Furthermore, we need to examine the parent table of the
    * partition, so lock that one too.
    */</comment>
   <expr_stmt><expr><name><name>state</name><operator>.</operator><name>partitionOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
   <expr_stmt><expr><name><name>state</name><operator>.</operator><name>parentTblOid</name></name> <operator>=</operator> <name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
   <expr_stmt><expr><name><name>state</name><operator>.</operator><name>lockedParentTbl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
   <expr_stmt><expr><name>partIdxId</name> <operator>=</operator>
       <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>RangeVarCallbackForAttachIndex</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <comment type="block">/* Not there? */</comment>
   <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
               <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>name</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

   <comment type="block">/* no deadlock risk: RangeVarGetRelidExtended already acquired the lock */</comment>
   <expr_stmt><expr><name>partIdx</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <comment type="block">/* we already hold locks on both tables, so this is safe: */</comment>
   <expr_stmt><expr><name>parentTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>partTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <comment type="block">/* Silently do nothing if already in the right state */</comment>
   <expr_stmt><expr><name>currParent</name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><call><name>has_superclass</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>:
       <expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
   <if_stmt><if>if <condition>(<expr><name>currParent</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
   <block>{<block_content>
       <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>childInfo</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>parentInfo</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>,
					<decl><type ref="prev"/><name>cldConstrId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

       <comment type="block">/*
        * If this partition already has an index attached, refuse the operation.
        */</comment>
       <expr_stmt><expr><call><name>refuseDupeIndexAttach</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>currParent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                   <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is already attached to another index."</literal></expr></argument>,
                              <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

       <comment type="block">/* Make sure it indexes a partition of the other index's table */</comment>
       <expr_stmt><expr><name>partDesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
       <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partDesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
       <block>{<block_content>
           <if_stmt><if>if <condition>(<expr><name><name>partDesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>state</name><operator>.</operator><name>partitionOid</name></name></expr>)</condition>
           <block>{<block_content>
               <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
               <break>break;</break>
           </block_content>}</block></if></if_stmt>
       </block_content>}</block></for>
       <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                   <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is not an index on any partition of table \"%s\"."</literal></expr></argument>,
                              <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

       <comment type="block">/* Ensure the indexes are compatible */</comment>
       <expr_stmt><expr><name>childInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>parentInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CompareIndexInfo</name><argument_list>(<argument><expr><name>childInfo</name></expr></argument>, <argument><expr><name>parentInfo</name></expr></argument>,
                             <argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
                             <argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
                             <argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
                             <argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
                             <argument><expr><name>attmap</name></expr></argument>,
                             <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                   <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The index definitions do not match."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If there is a constraint in the parent, make sure there is one
		 * in the child too.
		 */</comment>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cldConstrId</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cldConstrId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The index \"%s\" belongs to a constraint in table \"%s\" but no constraint exists for index \"%s\"."</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

       <comment type="block">/* All good -- do it */</comment>
       <expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>cldConstrId</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

       <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

       <expr_stmt><expr><call><name>validatePartitionedIndex</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>

   <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <comment type="block">/* keep these locks till commit */</comment>
   <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify whether the given partition already contains an index attached
 * to the given partitioned index.  If so, raise an error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>refuseDupeIndexAttach</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partitionTbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>Relation</name></type>        <name>pg_inherits</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>ScanKeyData</name></type>     <name>key</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>tuple</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>SysScanDesc</name></type>     <name>scan</name></decl>;</decl_stmt>

   <expr_stmt><expr><name>pg_inherits</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
               <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
   <block>{<block_content>
       <decl_stmt><decl><type><name>Form_pg_inherits</name></type>    <name>inhForm</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>Oid</name></type>         <name>tab</name></decl>;</decl_stmt>

       <expr_stmt><expr><name>inhForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>tab</name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partitionTbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                   <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Another index is already attached for partition \"%s\"."</literal></expr></argument>,
                              <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partitionTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
   </block_content>}</block></while>

   <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify whether the set of attached partition indexes to a parent index on
 * a partitioned table is complete.  If it is, mark the parent index valid.
 *
 * This should be called each time a partition index is attached.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validatePartitionedIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partedIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partedTbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>Relation</name></type>        <name>inheritsRel</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>SysScanDesc</name></type>     <name>scan</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>ScanKeyData</name></type>     <name>key</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type>             <name>tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>inhTup</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>bool</name></type>            <name>updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

   <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <comment type="block">/*
    * Scan pg_inherits for this parent index.  Count each valid index we find
    * (verifying the pg_index entry for each), and if we reach the total
    * amount we expect, we can mark this parent index as valid.
    */</comment>
   <expr_stmt><expr><name>inheritsRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
               <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inheritsRel</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <while>while <condition>(<expr><operator>(</operator><name>inhTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
   <block>{<block_content>
       <decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inhForm</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inhTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>HeapTuple</name></type>       <name>indTup</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>Form_pg_index</name></type>   <name>indexForm</name></decl>;</decl_stmt>

       <expr_stmt><expr><name>indTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><operator>!</operator><name>indTup</name></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>,
                <argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
       <expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexForm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><name>tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
       <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></while>

   <comment type="block">/* Done with pg_inherits */</comment>
   <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>inheritsRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <comment type="block">/*
    * If we found as many inherited indexes as the partitioned table has
    * partitions, we're good; update pg_index to set indisvalid.
    */</comment>
   <if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>==</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>partedTbl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nparts</name></expr>)</condition>
   <block>{<block_content>
       <decl_stmt><decl><type><name>Relation</name></type>    <name>idxRel</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>newtup</name></decl>;</decl_stmt>

       <expr_stmt><expr><name>idxRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>indisvalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
       <expr_stmt><expr><name>updated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

       <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>

   <comment type="block">/*
    * If this index is in turn a partition of a larger index, validating it
    * might cause the parent to become valid also.  Try that.
    */</comment>
   <if_stmt><if>if <condition>(<expr><name>updated</name> <operator>&amp;&amp;</operator>
       <call><name>has_superclass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
   <block>{<block_content>
       <decl_stmt><decl><type><name>Oid</name></type>         <name>parentIdxId</name></decl>,
                   <decl><type ref="prev"/><name>parentTblId</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>Relation</name></type>    <name>parentIdx</name></decl>,
                   <decl><type ref="prev"/><name>parentTbl</name></decl>;</decl_stmt>

       <comment type="block">/* make sure we see the validation we just did */</comment>
       <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

       <expr_stmt><expr><name>parentIdxId</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>parentTblId</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>parentIdx</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>parentIdxId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>parentTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>parentTblId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <expr_stmt><expr><call><name>validatePartitionedIndex</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
<function><type><name>bool</name></type>
<name>oidarray_contian_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>old_oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>old_num</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>new_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>old_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>old_oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>new_oid</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<comment type="block">/*
 * Check cold and hot datanodes overlaps
 */</comment>
<function><type><name>void</name></type> <name>ExecCheckOverLapStmt</name><parameter_list>(<parameter><decl><type><name>CheckOverLapStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>             <name>hotnode</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>             <name>coldnode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>name_cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name>           <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

    <comment type="block">/*hot name */</comment>
    <macro><name>foreach</name><argument_list>(<argument>name_cell</argument>, <argument>stmt-&gt;first</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>name_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><name>nodename</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hotnode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>pg_get_node_access</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node %s is cold node, can't use it to store hot data"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>


    <comment type="block">/*cold name */</comment>
    <macro><name>foreach</name><argument_list>(<argument>name_cell</argument>, <argument>stmt-&gt;second</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>name_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><name>nodename</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>    
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>coldnode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_get_node_access</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node %s is hot node, can't use it to store cold data"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>coldnode</name> <operator>&amp;&amp;</operator> <name>hotnode</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node %s can't be used as cold and hot storage at the same time"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>mls_allow_add_cls_col</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLS_CLS_COL_NAME</name></cpp:macro> <cpp:value>"_cls"</cpp:value></cpp:define>
    
    <decl_stmt><decl><type><name>ObjectType</name></type>    <name>reltype</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>OBJECT_TABLE</name> <operator>==</operator> <name>reltype</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type> <name>cmd_stmt</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>cmds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cmd_stmt</name></expr></argument>, <argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type> <name>altertblcmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name><operator>*</operator><operator>)</operator><name>cmd_stmt</name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>AT_DropColumn</name> <operator>==</operator> <name><name>altertblcmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>altertblcmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>MLS_CLS_COL_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <return>return <expr><name>true</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>AT_AddColumn</name> <operator>==</operator> <name><name>altertblcmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type> <name>def_node</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>AlterTableCmd</name><operator>*</operator><operator>)</operator><name>cmd_stmt</name><operator>)</operator><operator>-&gt;</operator><name>def</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>def_node</name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnDef</name><operator>*</operator><operator>)</operator><name>def_node</name><operator>)</operator><operator>-&gt;</operator><name>colname</name></expr></argument>, <argument><expr><name>MLS_CLS_COL_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <return>return <expr><name>true</name></expr>;</return>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>mls_allow_detach_parition</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ObjectType</name></type>    <name>reltype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>partoid</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>is_mls_user</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SYSTEM_REL</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>OBJECT_TABLE</name> <operator>==</operator> <name>reltype</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type> <name>cmd_stmt</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>cmds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cmd_stmt</name></expr></argument>, <argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type> <name>altertblcmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name><operator>*</operator><operator>)</operator><name>cmd_stmt</name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>AT_DetachPartition</name> <operator>==</operator> <name><name>altertblcmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type> <name>cmd_stmt2</name> <init>= <expr><name><name>altertblcmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cmd_stmt2</name></expr></argument>, <argument><expr><name>PartitionCmd</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type> <name>partitioncmd</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name><operator>*</operator><operator>)</operator><name>cmd_stmt2</name></expr></init></decl>;</decl_stmt>
                                <if_stmt><if>if<condition>(<expr><name><name>partitioncmd</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>relname</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>RelnameGetRelid</name><argument_list>(<argument><expr><name><name>partitioncmd</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <comment type="block">/* if mls_admin handle an relation binding with the mls policy, ok */</comment>
                                    <if_stmt><if>if <condition>(<expr><call><name>mls_check_relation_permission</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <return>return <expr><name>true</name></expr>;</return>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* others fail */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>mls_policy_check</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>mls_allow_add_cls_col</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>mls_allow_detach_parition</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


</unit>
