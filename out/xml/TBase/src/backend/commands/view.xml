<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/view.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * view.c
 *      use rewrite rules to construct views
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/view.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/view.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteSupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkViewTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>newdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>olddesc</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*---------------------------------------------------------------------
 * Validator for "check_option" reloption on views. The allowed values
 * are "local" and "cascaded".
 */</comment>
<function><type><name>void</name></type>
<name>validateWithCheckOption</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"local"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
         <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"cascaded"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for \"check_option\" option"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Valid values are \"local\" and \"cascaded\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------
 * DefineVirtualRelation
 *
 * Create a view relation and use the rules system to store the query
 * for the view.
 *
 * EventTriggerAlterTableStart must have been called already.
 *---------------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>DefineVirtualRelation</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>viewParse</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>viewOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LOCKMODE</name></type>    <name>lockmode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>attrList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

    <comment type="block">/*
     * create a list of ColumnDef nodes based on the names and types of the
     * (non-junk) targetlist items from the view's SELECT list.
     */</comment>
    <expr_stmt><expr><name>attrList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>t</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>makeColumnDef</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
                                            <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * It's possible that the column is of a collatable type but the
             * collation could not be resolved, so double-check.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for view column \"%s\""</literal></expr></argument>,
                                    <argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>attrList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attrList</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>attrList</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"view must have at least one column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Look up, check permissions on, and lock the creation namespace; also
     * check for a preexisting view with the same name.  This will also set
     * relation-&gt;relpersistence to RELPERSISTENCE_TEMP if the selected
     * namespace is temporary.
     */</comment>
    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name>replace</name></expr> ?</condition><then> <expr><name>AccessExclusiveLock</name></expr> </then><else>: <expr><name>NoLock</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>replace</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>descriptor</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>atcmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>atcmd</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

        <comment type="block">/* Relation is already locked, but we must build a relcache entry. */</comment>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make sure it *is* a view. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Also check it's not in use already */</comment>
        <expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE VIEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Due to the namespace visibility rules for temporary objects, we
         * should only end up replacing a temporary view with another
         * temporary view, and similarly for permanent views.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Create a tuple descriptor to compare against the existing view, and
         * verify that the old column list is an initial prefix of the new
         * column list.
         */</comment>
        <expr_stmt><expr><name>descriptor</name> <operator>=</operator> <call><name>BuildDescForRelation</name><argument_list>(<argument><expr><name>attrList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>checkViewTupleDesc</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If new attributes have been added, we must add pg_attribute entries
         * for them.  It is convenient (although overkill) to use the ALTER
         * TABLE ADD COLUMN infrastructure for this.
         *
         * Note that we must do this before updating the query for the view,
         * since the rules system requires that the correct view columns be in
         * place when defining the new rules.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>attrList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>skip</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>attrList</argument>)</argument_list></macro>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>skip</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>skip</name><operator>--</operator></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>atcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddColumnToView</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>atcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>atcmds</name></expr></argument>, <argument><expr><name>atcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

			<comment type="block">/* EventTriggerAlterTableStart called by ProcessUtilitySlow */</comment>
            <expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>atcmds</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Make the new view columns visible */</comment>
            <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Update the query for the view.
         *
         * Note that we must do this before updating the view options, because
         * the new options may not be compatible with the old view query (for
         * example if we attempt to add the WITH CHECK OPTION, we require that
         * the new view be automatically updatable, but the old view may not
         * have been).
         */</comment>
        <expr_stmt><expr><call><name>StoreViewQuery</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>viewParse</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make the new view query visible */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Finally update the view options.
         *
         * The new options list replaces the existing options list, even if
         * it's empty.
         */</comment>
        <expr_stmt><expr><name>atcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReplaceRelOptions</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>options</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>atcmds</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>atcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* EventTriggerAlterTableStart called by ProcessUtilitySlow */</comment>
        <expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>atcmds</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Seems okay, so return the OID of the pre-existing view.
         */</comment>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* keep the lock! */</comment>

        <return>return <expr><name>address</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Set the parameters for keys/inheritance etc. All of these are
         * uninteresting for views...
         */</comment>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name>attrList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Create the relation (this will error out if there's an existing
         * view, so we don't need more code to complain if "replace" is
         * false).
         */</comment>
        <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><name>createStmt</name></expr></argument>, <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make the new view relation visible */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Store the query for the view */</comment>
        <expr_stmt><expr><call><name>StoreViewQuery</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>viewParse</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>address</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that tupledesc associated with proposed new view definition
 * matches tupledesc of old view.  This is basically a cut-down version
 * of equalTupleDescs(), with code added to generate specific complaints.
 * Also, we allow the new tupledesc to have more columns than the old.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkViewTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>newdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>olddesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>newdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;</operator> <name><name>olddesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop columns from view"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* we can ignore tdhasoid */</comment>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>olddesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>newattr</name> <init>= <expr><name><name>newdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>oldattr</name> <init>= <expr><name><name>olddesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* XXX msg not right, but we don't support DROP COL on view anyway */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>newattr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>!=</operator> <name><name>oldattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop columns from view"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>newattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oldattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change name of view column \"%s\" to \"%s\""</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oldattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>newattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* XXX would it be safe to allow atttypmod to change?  Not sure */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>newattr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>oldattr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
            <name><name>newattr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>oldattr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change data type of view column \"%s\" from %s to %s"</literal></expr></argument>,
                            <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oldattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>oldattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
                                                     <argument><expr><name><name>oldattr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>newattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
                                                     <argument><expr><name><name>newattr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* We can ignore the remaining attributes of an attribute... */</comment>
    </block_content>}</block></for>

    <comment type="block">/*
     * We ignore the constraint fields.  The new view desc can't have any
     * constraints, and the only ones that could be on the old view are
     * defaults, which we are happy to leave in place.
     */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DefineViewRules</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>viewParse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Set up the ON SELECT rule.  Since the query has already been through
     * parse analysis, we use DefineQueryRewrite() directly.
     */</comment>
    <expr_stmt><expr><call><name>DefineQueryRewrite</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>ViewSelectRuleName</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>viewOid</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>CMD_SELECT</name></expr></argument>,
                       <argument><expr><name>true</name></expr></argument>,
                       <argument><expr><name>replace</name></expr></argument>,
                       <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>viewParse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Someday: automatic ON INSERT, etc
     */</comment>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------
 * UpdateRangeTableOfViewParse
 *
 * Update the range table of the given parsetree.
 * This update consists of adding two new entries IN THE BEGINNING
 * of the range table (otherwise the rule system will die a slow,
 * horrible and painful death, and we do not want that now, do we?)
 * one for the OLD relation and one for the NEW one (both of
 * them refer in fact to the "view" relation).
 *
 * Of course we must also increase the 'varnos' of all the Var nodes
 * by 2...
 *
 * These extra RT entries are not actually used in the query,
 * except for run-time permission checking.
 *---------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>UpdateRangeTableOfViewParse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>viewParse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>viewRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rt_entry1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>rt_entry2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Make a copy of the given parsetree.  It's not so much that we don't
     * want to scribble on our input, it's that the parser has a bad habit of
     * outputting multiple links to the same subtree for constructs like
     * BETWEEN, and we mustn't have OffsetVarNodes increment the varno of a
     * Var node twice.  copyObject will expand any multiply-referenced subtree
     * into multiple copies.
     */</comment>
    <expr_stmt><expr><name>viewParse</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>viewParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a dummy ParseState for addRangeTableEntryForRelation */</comment>
    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* need to open the rel for addRangeTableEntryForRelation */</comment>
    <expr_stmt><expr><name>viewRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the 2 new range table entries and form the new range table...
     * OLD first, then NEW....
     */</comment>
    <expr_stmt><expr><name>rt_entry1</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>viewRel</name></expr></argument>,
                                              <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rt_entry2</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>viewRel</name></expr></argument>,
                                              <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Must override addRangeTableEntry's default access-check flags */</comment>
    <expr_stmt><expr><name><name>rt_entry1</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt_entry2</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>new_rt</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>rt_entry1</name></expr></argument>, <argument><expr><call><name>lcons</name><argument_list>(<argument><expr><name>rt_entry2</name></expr></argument>, <argument><expr><name><name>viewParse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>viewParse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>new_rt</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Now offset all var nodes by 2, and jointree RT indexes too.
     */</comment>
    <expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>viewParse</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>viewRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>viewParse</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * MakeViewParse
 * Run parse analysis to convert the raw parse tree to a Query.  Note this
 * also acquires sufficient locks on the source table(s).
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>MakeViewParse</name><parameter_list>(<parameter><decl><type><name>ViewStmt</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>query_string</name></decl></parameter>,
           <parameter><decl><type><name>int</name></type> <name>stmt_location</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stmt_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	<modifier>*</modifier></type><name>viewParse</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>rawstmt</name></decl>;</decl_stmt>
    <comment type="block">/*
     * Since parse analysis scribbles on its input, copy the raw parse tree;
     * this ensures we don't corrupt a prepared statement, for example.
     */</comment>
    <expr_stmt><expr><name>rawstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name>stmt_location</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name>stmt_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>viewParse</name> <operator>=</operator> <call><name>parse_analyze</name><argument_list>(<argument><expr><name>rawstmt</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>viewParse</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * IsViewTemp
 *		Check whethe we need a temporary view.
 */</comment>
<function><type><name>bool</name></type>
<name>IsViewTemp</name><parameter_list>(<parameter><decl><type><name>ViewStmt</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>query_string</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>stmt_location</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stmt_len</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>relation_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>		<modifier>*</modifier></type><name>viewParse</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name>	<modifier>*</modifier></type><name>view</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	

	<comment type="block">/* don't corrupt original command */</comment>
    <expr_stmt><expr><name>view</name> <operator>=</operator> <operator>(</operator><name>RangeVar</name><operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>viewParse</name> <operator>=</operator> <call><name>MakeViewParse</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>stmt_location</name></expr></argument>, <argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the user didn't explicitly ask for a temporary view, check whether
     * we need one implicitly.	We allow TEMP to be inserted automatically as
     * long as the CREATE command is consistent with that --- no explicit
     * schema name.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>&amp;&amp;</operator>
		<call><name>CheckAndGetRelation</name><argument_list>(<argument><expr><name>viewParse</name></expr></argument>, <argument><expr><name>relation_list</name></expr></argument>)</argument_list></call></expr>)</condition> 
	<block>{<block_content>
        <expr_stmt><expr><name><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * DefineView
 *		Execute a CREATE VIEW command.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineView</name><parameter_list>(<parameter><decl><type><name>ViewStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>stmt_location</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stmt_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>viewParse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>view</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>check_option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>viewParse</name> <operator>=</operator> <call><name>MakeViewParse</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>stmt_location</name></expr></argument>, <argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * The grammar should ensure that the result is a single SELECT Query.
     * However, it doesn't forbid SELECT INTO, so we have to check for that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>viewParse</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected parse analysis result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>viewParse</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name><name>viewParse</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"views must not contain SELECT INTO"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>viewParse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected parse analysis result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check for unsupported cases.  These tests are redundant with ones in
     * DefineQueryRewrite(), but that function will complain about a bogus ON
     * SELECT rule, and we'd rather the message complain about a view.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>viewParse</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"views must not contain data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the user specified the WITH CHECK OPTION, add it to the list of
     * reloptions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withCheckOption</name></name> <operator>==</operator> <name>LOCAL_CHECK_OPTION</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
                                <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"check_option"</literal></expr></argument>,
                                            <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"local"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>withCheckOption</name></name> <operator>==</operator> <name>CASCADED_CHECK_OPTION</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
                                <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"check_option"</literal></expr></argument>,
                                            <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"cascaded"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check that the view is auto-updatable if WITH CHECK OPTION was
     * specified.
     */</comment>
    <expr_stmt><expr><name>check_option</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"check_option"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>check_option</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If the check option is specified, look to see if the view is actually
     * auto-updatable or not.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>check_option</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_updatable_error</name> <init>=
        <expr><call><name>view_query_is_auto_updatable</name><argument_list>(<argument><expr><name>viewParse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>view_updatable_error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH CHECK OPTION is supported only on automatically updatable views"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>view_updatable_error</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If a list of column names was given, run through and insert these into
     * the actual query tree. - thomas 2000-03-08
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>aliases</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>alist_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>aliases</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>targetList</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>targetList</argument>, <argument>viewParse-&gt;targetList</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* junk columns don't get aliases */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>alist_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>alist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>alist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>alist_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>            <comment type="block">/* done assigning aliases */</comment>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>alist_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE VIEW specifies more column "</literal>
                            <literal type="string">"names than columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Unlogged views are not sensible. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"views cannot be unlogged because they do not have storage"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the user didn't explicitly ask for a temporary view, check whether
     * we need one implicitly.  We allow TEMP to be inserted automatically as
     * long as the CREATE command is consistent with that --- no explicit
     * schema name.
     */</comment>
    <expr_stmt><expr><name>view</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* don't corrupt original command */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name>
        <operator>&amp;&amp;</operator> <call><name>isQueryUsingTempRelation</name><argument_list>(<argument><expr><name>viewParse</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>view</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* don't corrupt original command */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/*
         * Change original command as well - we do not want to create that view
         * on other coordinators where temp table does not exist
         */</comment>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>view</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" will be a temporary view"</literal></expr></argument>,
                        <argument><expr><name><name>view</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Create the view relation
     *
     * NOTE: if it already exists and replace is false, the xact will be
     * aborted.
     */</comment>
    <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineVirtualRelation</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name><name>viewParse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                    <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>viewParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Use the rules system to store the query for the view.
 */</comment>
<function><type><name>void</name></type>
<name>StoreViewQuery</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>viewParse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * The range table of 'viewParse' does not contain entries for the "OLD"
     * and "NEW" relations. So... add them!
     */</comment>
    <expr_stmt><expr><name>viewParse</name> <operator>=</operator> <call><name>UpdateRangeTableOfViewParse</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>viewParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now create the rules associated with the view.
     */</comment>
    <expr_stmt><expr><call><name>DefineViewRules</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>viewParse</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
