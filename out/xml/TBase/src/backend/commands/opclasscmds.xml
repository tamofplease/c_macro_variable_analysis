<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/opclasscmds.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * opclasscmds.c
 *
 *      Routines for opclass (and opfamily) manipulation commands
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/opclasscmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/opfam_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterOpFamilyAdd</name><parameter_list>(<parameter><decl><type><name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
                 <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>maxOpNumber</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxProcNumber</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterOpFamilyDrop</name><parameter_list>(<parameter><decl><type><name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
                  <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
                  <parameter><decl><type><name>int</name></type> <name>maxOpNumber</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxProcNumber</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processTypesSpec</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>righttype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assignOperTypes</name><parameter_list>(<parameter><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assignProcTypes</name><parameter_list>(<parameter><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addFamilyMember</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isProc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>storeOperators</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opclassoid</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>operators</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAdd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>storeProcedures</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opclassoid</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procedures</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAdd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dropOperators</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>operators</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dropProcedures</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procedures</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * OpFamilyCacheLookup
 *        Look up an existing opfamily by name.
 *
 * Returns a syscache tuple reference, or NULL if not found.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>OpFamilyCacheLookup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>amID</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>opfname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>

    <comment type="block">/* deconstruct the name list */</comment>
    <expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Look in specific schema only */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>namespaceId</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>OPFAMILYAMNAMENSP</name></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amID</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opfname</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Unqualified opfamily name, so search the search path */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opfID</name> <init>= <expr><call><name>OpfamilynameGetOpfid</name><argument_list>(<argument><expr><name>amID</name></expr></argument>, <argument><expr><name>opfname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPFAMILYOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>amtup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>amtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>amtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for access method %u"</literal></expr></argument>, <argument><expr><name>amID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator family \"%s\" does not exist for access method \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>amtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>htup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opfamily_oid
 *      find an opfamily OID by possibly qualified name
 *
 * If not found, returns InvalidOid if missing_ok, else throws error.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opfamily_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>amID</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>opfID</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>OpFamilyCacheLookup</name><argument_list>(<argument><expr><name>amID</name></expr></argument>, <argument><expr><name>opfamilyname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>opfID</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>opfID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OpClassCacheLookup
 *        Look up an existing opclass by name.
 *
 * Returns a syscache tuple reference, or NULL if not found.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>OpClassCacheLookup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>amID</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opclassname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>

    <comment type="block">/* deconstruct the name list */</comment>
    <expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>opclassname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Look in specific schema only */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>namespaceId</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>CLAAMNAMENSP</name></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amID</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Unqualified opclass name, so search the search path */</comment>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opcID</name> <init>= <expr><call><name>OpclassnameGetOpcid</name><argument_list>(<argument><expr><name>amID</name></expr></argument>, <argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opcID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opcID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>amtup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>amtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>amtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for access method %u"</literal></expr></argument>, <argument><expr><name>amID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" does not exist for access method \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opclassname</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>amtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>htup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opclass_oid
 *      find an opclass OID by possibly qualified name
 *
 * If not found, returns InvalidOid if missing_ok, else throws error.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opclass_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>amID</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opclassname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>opcID</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>OpClassCacheLookup</name><argument_list>(<argument><expr><name>amID</name></expr></argument>, <argument><expr><name>opclassname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>opcID</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>opcID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateOpFamily
 *        Internal routine to make the catalog entry for a new operator family.
 *
 * Caller must have done permissions checks etc. already.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>CreateOpFamily</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>opfname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespaceoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>opfamilyoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_opfamily</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_opfamily</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type>    <name>opfName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
                <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>OperatorFamilyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make sure there is no existing opfamily of this name (this is just to
     * give a more friendly error message than "duplicate key").
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>OPFAMILYAMNAMENSP</name></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opfname</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator family \"%s\" for access method \"%s\" already exists"</literal></expr></argument>,
                        <argument><expr><name>opfname</name></expr></argument>, <argument><expr><name>amname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Okay, let's create the pg_opfamily entry.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opfamily_opfmethod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opfName</name></expr></argument>, <argument><expr><name>opfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opfamily_opfname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opfName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opfamily_opfnamespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opfamily_opfowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>opfamilyoid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create dependencies for the opfamily proper.
     */</comment>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorFamilyRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>opfamilyoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* dependency on access method */</comment>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AccessMethodRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>amoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dependency on namespace */</comment>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>NamespaceRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>namespaceoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dependency on owner */</comment>
    <expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>OperatorFamilyRelationId</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dependency on extension */</comment>
    <expr_stmt><expr><call><name>recordDependencyOnCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Post creation hook for new operator family */</comment>
    <expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>OperatorFamilyRelationId</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DefineOpClass
 *        Define a new index operator class.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineOpClass</name><parameter_list>(<parameter><decl><type><name>CreateOpClassStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>        <comment type="block">/* name of opclass we're creating */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>amoid</name></decl>,            <comment type="block">/* our AM's oid */</comment>
                <decl><type ref="prev"/><name>typeoid</name></decl>,        <comment type="block">/* indexable datatype oid */</comment>
                <decl><type ref="prev"/><name>storageoid</name></decl>,        <comment type="block">/* storage datatype oid, if any */</comment>
                <decl><type ref="prev"/><name>namespaceoid</name></decl>,    <comment type="block">/* namespace to create opclass in */</comment>
                <decl><type ref="prev"/><name>opfamilyoid</name></decl>,    <comment type="block">/* oid of containing opfamily */</comment>
                <decl><type ref="prev"/><name>opclassoid</name></decl>;</decl_stmt>        <comment type="block">/* oid of opclass we create */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxOpNumber</name></decl>,    <comment type="block">/* amstrategies value */</comment>
                <decl><type ref="prev"/><name>maxProcNumber</name></decl>;</decl_stmt>    <comment type="block">/* amsupport value */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>amstorage</name></decl>;</decl_stmt>        <comment type="block">/* amstorage flag */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>operators</name></decl>;</decl_stmt>        <comment type="block">/* OpFamilyMember list for operators */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>procedures</name></decl>;</decl_stmt>        <comment type="block">/* OpFamilyMember list for support procs */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_opclass</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_opclass</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type>    <name>opcName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
                <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

    <comment type="block">/* Convert list of names to a name and namespace */</comment>
    <expr_stmt><expr><name>namespaceoid</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opclassname</name></name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check we have creation rights in target namespace */</comment>
    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_NAMESPACE</name></expr></argument>,
                       <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get necessary info about access method */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMNAME</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>amoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>amroutine</name> <operator>=</operator> <call><name>GetIndexAmRoutineByAmId</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>maxOpNumber</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amstrategies</name></name></expr>;</expr_stmt>
    <comment type="block">/* if amstrategies is zero, just enforce that op numbers fit in int16 */</comment>
    <if_stmt><if>if <condition>(<expr><name>maxOpNumber</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>maxOpNumber</name> <operator>=</operator> <name>SHRT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>maxProcNumber</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amsupport</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>amstorage</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amstorage</name></name></expr>;</expr_stmt>

    <comment type="block">/* XXX Should we make any privilege check against the AM? */</comment>

    <comment type="block">/*
     * The question of appropriate permissions for CREATE OPERATOR CLASS is
     * interesting.  Creating an opclass is tantamount to granting public
     * execute access on the functions involved, since the index machinery
     * generally does not check access permission before using the functions.
     * A minimum expectation therefore is that the caller have execute
     * privilege with grant option.  Since we don't have a way to make the
     * opclass go away if the grant option is revoked, we choose instead to
     * require ownership of the functions.  It's also not entirely clear what
     * permissions should be required on the datatype, but ownership seems
     * like a safe choice.
     *
     * Currently, we require superuser privileges to create an opclass. This
     * seems necessary because we have no way to validate that the offered set
     * of operators and functions are consistent with the AM's expectations.
     * It would be nice to provide such a check someday, if it can be done
     * without solving the halting problem :-(
     *
     * XXX re-enable NOT_USED code sections below if you remove this test.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to create an operator class"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Look up the datatype */</comment>
    <expr_stmt><expr><name>typeoid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
    <comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
    <comment type="block">/* Check we have ownership of the datatype */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Look up the containing operator family, or create one if FAMILY option
     * was omitted and there's not a match already.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>opfamilyoid</name> <operator>=</operator> <call><name>get_opfamily_oid</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Lookup existing family of same name and namespace */</comment>
        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>OPFAMILYAMNAMENSP</name></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>opfamilyoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * XXX given the superuser check above, there's no need for an
             * ownership check here
             */</comment>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>tmpAddr</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Create it ... again no need for more permissions ...
             */</comment>
            <expr_stmt><expr><name>tmpAddr</name> <operator>=</operator> <call><name>CreateOpFamily</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>, <argument><expr><name>opcname</name></expr></argument>,
                                     <argument><expr><name>namespaceoid</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>opfamilyoid</name> <operator>=</operator> <name><name>tmpAddr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>operators</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>procedures</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/* Storage datatype is optional */</comment>
    <expr_stmt><expr><name>storageoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan the "items" list to obtain additional info.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;items</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CreateOpClassItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CreateOpClassItem</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>operOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>funcOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>sortfamilyOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>OPCLASS_ITEM_OPERATOR</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&gt;</operator> <name>maxOpNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid operator number %d,"</literal>
                                    <literal type="string">" must be between 1 and %d"</literal></expr></argument>,
                                    <argument><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>maxOpNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>objargs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>operOid</name> <operator>=</operator> <call><name>LookupOperWithArgs</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Default to binary op on input datatype */</comment>
                    <expr_stmt><expr><name>operOid</name> <operator>=</operator> <call><name>LookupOperName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>,
                                             <argument><expr><name>typeoid</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>order_family</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>sortfamilyOid</name> <operator>=</operator> <call><name>get_opfamily_oid</name><argument_list>(<argument><expr><name>BTREE_AM_OID</name></expr></argument>,
                                                     <argument><expr><name><name>item</name><operator>-&gt;</operator><name>order_family</name></name></expr></argument>,
                                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>sortfamilyOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
                <comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
                <comment type="block">/* Caller must own operator and its underlying function */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_oper_ownercheck</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_OPER</name></expr></argument>,
                                   <argument><expr><call><name>get_opname</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>funcOid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Save the info */</comment>
                <expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpFamilyMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>operOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>sortfamily</name></name> <operator>=</operator> <name>sortfamilyOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assignOperTypes</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addFamilyMember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operators</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPCLASS_ITEM_FUNCTION</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&gt;</operator> <name>maxProcNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid procedure number %d,"</literal>
                                    <literal type="string">" must be between 1 and %d"</literal></expr></argument>,
                                    <argument><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>maxProcNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>funcOid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
                <comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
                <comment type="block">/* Caller must own function */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Save the info */</comment>
                <expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpFamilyMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>funcOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>

                <comment type="block">/* allow overriding of the function's actual arg types */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>class_args</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>processTypesSpec</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>class_args</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>assignProcTypes</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addFamilyMember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procedures</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPCLASS_ITEM_STORAGETYPE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>storageoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"storage type specified more than once"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>storageoid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>storedtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
                <comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
                <comment type="block">/* Check we have ownership of the datatype */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><name>storageoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>storageoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized item type: %d"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>itemtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>

    <comment type="block">/*
     * If storagetype is specified, make sure it's legal.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>storageoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Just drop the spec if same as column datatype */</comment>
        <if_stmt><if>if <condition>(<expr><name>storageoid</name> <operator>==</operator> <name>typeoid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>storageoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name>amstorage</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"storage type cannot be different from data type for access method \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make sure there is no existing opclass of this name (this is just to
     * give a more friendly error message than "duplicate key").
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>CLAAMNAMENSP</name></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" for access method \"%s\" already exists"</literal></expr></argument>,
                        <argument><expr><name>opcname</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we are creating a default opclass, check there isn't one already.
     * (Note we do not restrict this test to visible opclasses; this ensures
     * that typcache.c can find unique solutions to its questions.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isDefault</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pg_opclass_opcmethod</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>OpclassAmNameNspIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opclass</name> <init>= <expr><operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>opclass</name><operator>-&gt;</operator><name>opcintype</name></name> <operator>==</operator> <name>typeoid</name> <operator>&amp;&amp;</operator> <name><name>opclass</name><operator>-&gt;</operator><name>opcdefault</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not make operator class \"%s\" be default for type %s"</literal></expr></argument>,
                                <argument><expr><name>opcname</name></expr></argument>,
                                <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>datatype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Operator class \"%s\" already is the default."</literal></expr></argument>,
                                   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opclass</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Okay, let's create the pg_opclass entry.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opcmethod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opcName</name></expr></argument>, <argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opcname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opcName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opcnamespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opcowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opcfamily</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opcintype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opcdefault</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>isDefault</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_opclass_opckeytype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>storageoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>opclassoid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now add tuples to pg_amop and pg_amproc tying in the operators and
     * functions.  Dependencies on them are inserted, too.
     */</comment>
    <expr_stmt><expr><call><name>storeOperators</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                   <argument><expr><name>opclassoid</name></expr></argument>, <argument><expr><name>operators</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>storeProcedures</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                    <argument><expr><name>opclassoid</name></expr></argument>, <argument><expr><name>procedures</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* let event triggers know what happened */</comment>
    <expr_stmt><expr><call><name>EventTriggerCollectCreateOpClass</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>opclassoid</name></expr></argument>, <argument><expr><name>operators</name></expr></argument>, <argument><expr><name>procedures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create dependencies for the opclass proper.  Note: we do not need a
     * dependency link to the AM, because that exists through the opfamily.
     */</comment>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorClassRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>opclassoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* dependency on namespace */</comment>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>NamespaceRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>namespaceoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dependency on opfamily */</comment>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorFamilyRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>opfamilyoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dependency on indexed datatype */</comment>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typeoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dependency on storage datatype */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>storageoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>storageoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* dependency on owner */</comment>
    <expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>opclassoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dependency on extension */</comment>
    <expr_stmt><expr><call><name>recordDependencyOnCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Post creation hook for new operator class */</comment>
    <expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>opclassoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DefineOpFamily
 *        Define a new index operator family.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineOpFamily</name><parameter_list>(<parameter><decl><type><name>CreateOpFamilyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>opfname</name></decl>;</decl_stmt>        <comment type="block">/* name of opfamily we're creating */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>amoid</name></decl>,            <comment type="block">/* our AM's oid */</comment>
                <decl><type ref="prev"/><name>namespaceoid</name></decl>;</decl_stmt>    <comment type="block">/* namespace to create opfamily in */</comment>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

    <comment type="block">/* Convert list of names to a name and namespace */</comment>
    <expr_stmt><expr><name>namespaceoid</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>opfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check we have creation rights in target namespace */</comment>
    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_NAMESPACE</name></expr></argument>,
                       <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get access method OID, throwing an error if it doesn't exist. */</comment>
    <expr_stmt><expr><name>amoid</name> <operator>=</operator> <call><name>get_index_am_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XXX Should we make any privilege check against the AM? */</comment>

    <comment type="block">/*
     * Currently, we require superuser privileges to create an opfamily. See
     * comments in DefineOpClass.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to create an operator family"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Insert pg_opfamily catalog entry */</comment>
    <return>return <expr><call><name>CreateOpFamily</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>, <argument><expr><name>opfname</name></expr></argument>, <argument><expr><name>namespaceoid</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterOpFamily
 *        Add or remove operators/procedures within an existing operator family.
 *
 * Note: this implements only ALTER OPERATOR FAMILY ... ADD/DROP.  Some
 * other commands called ALTER OPERATOR FAMILY exist, but go through
 * different code paths.
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterOpFamily</name><parameter_list>(<parameter><decl><type><name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>amoid</name></decl>,            <comment type="block">/* our AM's oid */</comment>
                <decl><type ref="prev"/><name>opfamilyoid</name></decl>;</decl_stmt>    <comment type="block">/* oid of opfamily */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxOpNumber</name></decl>,    <comment type="block">/* amstrategies value */</comment>
                <decl><type ref="prev"/><name>maxProcNumber</name></decl>;</decl_stmt>    <comment type="block">/* amsupport value */</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>

    <comment type="block">/* Get necessary info about access method */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMNAME</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>amoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>amroutine</name> <operator>=</operator> <call><name>GetIndexAmRoutineByAmId</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>maxOpNumber</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amstrategies</name></name></expr>;</expr_stmt>
    <comment type="block">/* if amstrategies is zero, just enforce that op numbers fit in int16 */</comment>
    <if_stmt><if>if <condition>(<expr><name>maxOpNumber</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>maxOpNumber</name> <operator>=</operator> <name>SHRT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>maxProcNumber</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amsupport</name></name></expr>;</expr_stmt>

    <comment type="block">/* XXX Should we make any privilege check against the AM? */</comment>

    <comment type="block">/* Look up the opfamily */</comment>
    <expr_stmt><expr><name>opfamilyoid</name> <operator>=</operator> <call><name>get_opfamily_oid</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Currently, we require superuser privileges to alter an opfamily.
     *
     * XXX re-enable NOT_USED code sections below if you remove this test.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to alter an operator family"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * ADD and DROP cases need separate code from here on down.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isDrop</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>AlterOpFamilyDrop</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                          <argument><expr><name>maxOpNumber</name></expr></argument>, <argument><expr><name>maxProcNumber</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>AlterOpFamilyAdd</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                         <argument><expr><name>maxOpNumber</name></expr></argument>, <argument><expr><name>maxProcNumber</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>opfamilyoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ADD part of ALTER OP FAMILY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterOpFamilyAdd</name><parameter_list>(<parameter><decl><type><name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>maxOpNumber</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxProcNumber</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>operators</name></decl>;</decl_stmt>        <comment type="block">/* OpFamilyMember list for operators */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>procedures</name></decl>;</decl_stmt>        <comment type="block">/* OpFamilyMember list for support procs */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>operators</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>procedures</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan the "items" list to obtain additional info.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>items</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CreateOpClassItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CreateOpClassItem</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>operOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>funcOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>sortfamilyOid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>OPCLASS_ITEM_OPERATOR</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&gt;</operator> <name>maxOpNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid operator number %d,"</literal>
                                    <literal type="string">" must be between 1 and %d"</literal></expr></argument>,
                                    <argument><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>maxOpNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>objargs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>operOid</name> <operator>=</operator> <call><name>LookupOperWithArgs</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator argument types must be specified in ALTER OPERATOR FAMILY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>operOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>order_family</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>sortfamilyOid</name> <operator>=</operator> <call><name>get_opfamily_oid</name><argument_list>(<argument><expr><name>BTREE_AM_OID</name></expr></argument>,
                                                     <argument><expr><name><name>item</name><operator>-&gt;</operator><name>order_family</name></name></expr></argument>,
                                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>sortfamilyOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
                <comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
                <comment type="block">/* Caller must own operator and its underlying function */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_oper_ownercheck</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_OPER</name></expr></argument>,
                                   <argument><expr><call><name>get_opname</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>funcOid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Save the info */</comment>
                <expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpFamilyMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>operOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>sortfamily</name></name> <operator>=</operator> <name>sortfamilyOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assignOperTypes</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addFamilyMember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operators</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPCLASS_ITEM_FUNCTION</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&gt;</operator> <name>maxProcNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid procedure number %d,"</literal>
                                    <literal type="string">" must be between 1 and %d"</literal></expr></argument>,
                                    <argument><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>maxProcNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>funcOid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
                <comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
                <comment type="block">/* Caller must own function */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Save the info */</comment>
                <expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpFamilyMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>funcOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>

                <comment type="block">/* allow overriding of the function's actual arg types */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>class_args</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>processTypesSpec</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>class_args</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>assignProcTypes</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addFamilyMember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procedures</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPCLASS_ITEM_STORAGETYPE</name></expr>:</case>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"STORAGE cannot be specified in ALTER OPERATOR FAMILY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized item type: %d"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>itemtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>

    <comment type="block">/*
     * Add tuples to pg_amop and pg_amproc tying in the operators and
     * functions.  Dependencies on them are inserted, too.
     */</comment>
    <expr_stmt><expr><call><name>storeOperators</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>operators</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>storeProcedures</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                    <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>procedures</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make information available to event triggers */</comment>
    <expr_stmt><expr><call><name>EventTriggerCollectAlterOpFam</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                                  <argument><expr><name>operators</name></expr></argument>, <argument><expr><name>procedures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DROP part of ALTER OP FAMILY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterOpFamilyDrop</name><parameter_list>(<parameter><decl><type><name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
                  <parameter><decl><type><name>int</name></type> <name>maxOpNumber</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxProcNumber</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>operators</name></decl>;</decl_stmt>        <comment type="block">/* OpFamilyMember list for operators */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>procedures</name></decl>;</decl_stmt>        <comment type="block">/* OpFamilyMember list for support procs */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>operators</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>procedures</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan the "items" list to obtain additional info.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>items</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CreateOpClassItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CreateOpClassItem</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>lefttype</name></decl>,
                    <decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>OPCLASS_ITEM_OPERATOR</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&gt;</operator> <name>maxOpNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid operator number %d,"</literal>
                                    <literal type="string">" must be between 1 and %d"</literal></expr></argument>,
                                    <argument><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>maxOpNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>processTypesSpec</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>class_args</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Save the info */</comment>
                <expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpFamilyMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>=</operator> <name>lefttype</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name> <operator>=</operator> <name>righttype</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addFamilyMember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operators</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPCLASS_ITEM_FUNCTION</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&gt;</operator> <name>maxProcNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid procedure number %d,"</literal>
                                    <literal type="string">" must be between 1 and %d"</literal></expr></argument>,
                                    <argument><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>maxProcNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>processTypesSpec</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>class_args</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Save the info */</comment>
                <expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpFamilyMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>=</operator> <name>lefttype</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name> <operator>=</operator> <name>righttype</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addFamilyMember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procedures</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPCLASS_ITEM_STORAGETYPE</name></expr>:</case>
                <comment type="block">/* grammar prevents this from appearing */</comment>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized item type: %d"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>itemtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>

    <comment type="block">/*
     * Remove tuples from pg_amop and pg_amproc.
     */</comment>
    <expr_stmt><expr><call><name>dropOperators</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>, <argument><expr><name>operators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dropProcedures</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opfamilyname</name></name></expr></argument>, <argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>, <argument><expr><name>procedures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make information available to event triggers */</comment>
    <expr_stmt><expr><call><name>EventTriggerCollectAlterOpFam</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>opfamilyoid</name></expr></argument>,
                                  <argument><expr><name>operators</name></expr></argument>, <argument><expr><name>procedures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Deal with explicit arg types used in ALTER ADD/DROP
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processTypesSpec</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>righttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>args</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>typeName</name> <operator>=</operator> <operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>lefttype</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>typeName</name> <operator>=</operator> <operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>righttype</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>righttype</name> <operator>=</operator> <operator>*</operator><name>lefttype</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"one or two argument types must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Determine the lefttype/righttype to assign to an operator,
 * and do any validity checking we can manage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assignOperTypes</name><parameter_list>(<parameter><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Operator</name></type>    <name>optup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>opform</name></decl>;</decl_stmt>

    <comment type="block">/* Fetch the operator definition */</comment>
    <expr_stmt><expr><name>optup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>optup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>opform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>optup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Opfamily operators must be binary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>opform</name><operator>-&gt;</operator><name>oprkind</name></name> <operator>!=</operator> <literal type="char">'b'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index operators must be binary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>sortfamily</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Ordering op, check index supports that.  (We could perhaps also
         * check that the operator returns a type supported by the sortfamily,
         * but that seems more trouble than it's worth here.  If it does not,
         * the operator will never be matchable to any ORDER BY clause, but no
         * worse consequences can ensue.  Also, trying to check that would
         * create an ordering hazard during dump/reload: it's possible that
         * the family has been created but not yet populated with the required
         * operators.)
         */</comment>
        <decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name> <init>= <expr><call><name>GetIndexAmRoutineByAmId</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not support ordering operators"</literal></expr></argument>,
                            <argument><expr><call><name>get_am_name</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Search operators must return boolean.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>opform</name><operator>-&gt;</operator><name>oprresult</name></name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index search operators must return boolean"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If lefttype/righttype isn't specified, use the operator's input types
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>=</operator> <name><name>opform</name><operator>-&gt;</operator><name>oprleft</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name> <operator>=</operator> <name><name>opform</name><operator>-&gt;</operator><name>oprright</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>optup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the lefttype/righttype to assign to a support procedure,
 * and do any validity checking we can manage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assignProcTypes</name><parameter_list>(<parameter><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>proctup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>

    <comment type="block">/* Fetch the procedure definition */</comment>
    <expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>proctup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * btree comparison procs must be 2-arg procs returning int4, while btree
     * sortsupport procs must take internal and return void.  hash support
	 * proc 1 must be a 1-arg proc returning int4, while proc 2 must be a
	 * 2-arg proc returning int8.  Otherwise we don't know.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>amoid</name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name>BTORDER_PROC</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"btree comparison procedures must have two arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"btree comparison procedures must return integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If lefttype/righttype isn't specified, use the proc's input
             * types
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name>BTSORTSUPPORT_PROC</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
                <name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"btree sort support procedures must accept type \"internal\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>VOIDOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"btree sort support procedures must return void"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Can't infer lefttype/righttype from proc, so use default rule
             */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>amoid</name> <operator>==</operator> <name>HASH_AM_OID</name></expr>)</condition>
    <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name>HASHSTANDARD_PROC</name></expr>)</condition>
		<block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
		                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash procedure 1 must have one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
		        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		                   <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
		                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash procedure 1 must return integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name>HASHEXTENDED_PROC</name></expr>)</condition>
		<block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		                   <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
		                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash procedure 2 must have two arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    <if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
		        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		                   <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
		                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash procedure 2 must return bigint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If lefttype/righttype isn't specified, use the proc's input type
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The default in CREATE OPERATOR CLASS is to use the class' opcintype as
     * lefttype and righttype.  In CREATE or ALTER OPERATOR FAMILY, opcintype
     * isn't available, so make the user specify the types.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>=</operator> <name>typeoid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name> <operator>=</operator> <name>typeoid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"associated data types must be specified for index support procedure"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new family member to the appropriate list, after checking for
 * duplicated strategy or proc number.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addFamilyMember</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>member</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isProc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>*list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>old</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name><name>member</name><operator>-&gt;</operator><name>number</name></name> <operator>&amp;&amp;</operator>
            <name><name>old</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>==</operator> <name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name> <operator>&amp;&amp;</operator>
            <name><name>old</name><operator>-&gt;</operator><name>righttype</name></name> <operator>==</operator> <name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isProc</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedure number %d for (%s,%s) appears more than once"</literal></expr></argument>,
                                <argument><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator number %d for (%s,%s) appears more than once"</literal></expr></argument>,
                                <argument><expr><name><name>member</name><operator>-&gt;</operator><name>number</name></name></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>member</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>list</name></expr></argument>, <argument><expr><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dump the operators to pg_amop
 *
 * We also make dependency entries in pg_depend for the opfamily entries.
 * If opclassoid is valid then make an INTERNAL dependency on that opclass,
 * else make an AUTO dependency on the opfamily.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storeOperators</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opclassoid</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>operators</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAdd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_amop</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_amop</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>entryoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
                <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AccessMethodOperatorRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>operators</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>oppurpose</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If adding to an existing family, check for conflict with an
         * existing pg_amop entry (just to give a nicer error message)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>isAdd</name> <operator>&amp;&amp;</operator>
            <call><name>SearchSysCacheExists4</name><argument_list>(<argument><expr><name>AMOPSTRATEGY</name></expr></argument>,
                                  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyoid</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator %d(%s,%s) already exists in operator family \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>op</name><operator>-&gt;</operator><name>number</name></name></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>oppurpose</name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>sortfamily</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>AMOP_ORDER</name></expr> </then><else>: <expr><name>AMOP_SEARCH</name></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* Create the pg_amop entry */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amopfamily</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amoplefttype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amoprighttype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amopstrategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amoppurpose</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>oppurpose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amopopr</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amopmethod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amop_amopsortfamily</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>sortfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>entryoid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make its dependencies */</comment>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AccessMethodOperatorRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>entryoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>object</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opclassoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* if contained in an opclass, use a NORMAL dep on operator */</comment>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* ... and an INTERNAL dep on the opclass */</comment>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorClassRelationId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>opclassoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* if "loose" in the opfamily, use a AUTO dep on operator */</comment>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* ... and an AUTO dep on the opfamily */</comment>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorFamilyRelationId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>opfamilyoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* A search operator also needs a dep on the referenced opfamily */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>sortfamily</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorFamilyRelationId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>sortfamily</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Post create hook of this access method operator */</comment>
        <expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>AccessMethodOperatorRelationId</name></expr></argument>,
                                   <argument><expr><name>entryoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dump the procedures (support routines) to pg_amproc
 *
 * We also make dependency entries in pg_depend for the opfamily entries.
 * If opclassoid is valid then make an INTERNAL dependency on that opclass,
 * else make an AUTO dependency on the opfamily.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storeProcedures</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opclassoid</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procedures</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAdd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_amproc</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_amproc</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>entryoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
                <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AccessMethodProcedureRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>procedures</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If adding to an existing family, check for conflict with an
         * existing pg_amproc entry (just to give a nicer error message)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>isAdd</name> <operator>&amp;&amp;</operator>
            <call><name>SearchSysCacheExists4</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
                                  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyoid</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %d(%s,%s) already exists in operator family \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>number</name></name></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Create the pg_amproc entry */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amproc_amprocfamily</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amproc_amproclefttype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amproc_amprocrighttype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amproc_amprocnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_amproc_amproc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>entryoid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make its dependencies */</comment>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AccessMethodProcedureRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>entryoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>object</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opclassoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* if contained in an opclass, use a NORMAL dep on procedure */</comment>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* ... and an INTERNAL dep on the opclass */</comment>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorClassRelationId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>opclassoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* if "loose" in the opfamily, use a AUTO dep on procedure */</comment>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* ... and an AUTO dep on the opfamily */</comment>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorFamilyRelationId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>opfamilyoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Post create hook of access method procedure */</comment>
        <expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>AccessMethodProcedureRelationId</name></expr></argument>,
                                   <argument><expr><name>entryoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove operator entries from an opfamily.
 *
 * Note: this is only allowed for "loose" members of an opfamily, hence
 * behavior is always RESTRICT.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dropOperators</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>operators</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>operators</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>amopid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>amopid</name> <operator>=</operator> <call><name>GetSysCacheOid4</name><argument_list>(<argument><expr><name>AMOPSTRATEGY</name></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyoid</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>amopid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator %d(%s,%s) does not exist in operator family \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>op</name><operator>-&gt;</operator><name>number</name></name></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AccessMethodOperatorRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>amopid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Remove procedure entries from an opfamily.
 *
 * Note: this is only allowed for "loose" members of an opfamily, hence
 * behavior is always RESTRICT.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dropProcedures</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilyname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>amoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamilyoid</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procedures</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>procedures</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpFamilyMember</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpFamilyMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>amprocid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>amprocid</name> <operator>=</operator> <call><name>GetSysCacheOid4</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyoid</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>amprocid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %d(%s,%s) does not exist in operator family \"%s\""</literal></expr></argument>,
                            <argument><expr><name><name>op</name><operator>-&gt;</operator><name>number</name></name></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>lefttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>righttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AccessMethodProcedureRelationId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>amprocid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Deletion subroutines for use by dependency.c.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveOpFamilyById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfamilyOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>OperatorFamilyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPFAMILYOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamilyOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamilyOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RemoveOpClassById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclassOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclassOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclassOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RemoveAmOpEntryById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>entryOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>entryOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AccessMethodOperatorRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessMethodOperatorOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we expect exactly one match */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for amop entry %u"</literal></expr></argument>, <argument><expr><name>entryOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RemoveAmProcEntryById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>entryOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>entryOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AccessMethodProcedureRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessMethodProcedureOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we expect exactly one match */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for amproc entry %u"</literal></expr></argument>, <argument><expr><name>entryOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ALTER OPERATOR CLASS SET SCHEMA/RENAME
 *
 * Is there an operator class with the given name and signature already
 * in the given namespace?    If so, raise an appropriate error message.
 */</comment>
<function><type><name>void</name></type>
<name>IsThereOpClassInNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opcname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opcmethod</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>opcnamespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* make sure the new name doesn't exist */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>CLAAMNAMENSP</name></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opcmethod</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opcnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" for access method \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
                        <argument><expr><name>opcname</name></expr></argument>,
                        <argument><expr><call><name>get_am_name</name><argument_list>(<argument><expr><name>opcmethod</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>opcnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ALTER OPERATOR FAMILY SET SCHEMA/RENAME
 *
 * Is there an operator family with the given name and signature already
 * in the given namespace?    If so, raise an appropriate error message.
 */</comment>
<function><type><name>void</name></type>
<name>IsThereOpFamilyInNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opfname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfmethod</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name></type> <name>opfnamespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* make sure the new name doesn't exist */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>OPFAMILYAMNAMENSP</name></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfmethod</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opfname</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator family \"%s\" for access method \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
                        <argument><expr><name>opfname</name></expr></argument>,
                        <argument><expr><call><name>get_am_name</name><argument_list>(<argument><expr><name>opfmethod</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>opfnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>get_opclass_name_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opcid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nspace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>opctup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opcform</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>opctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>opcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>opcform</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>nspace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opcform</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
