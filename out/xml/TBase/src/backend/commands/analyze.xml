<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/analyze.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * analyze.c
 *      the Postgres statistics generator
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/analyze.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/extended_stats_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/attoptcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmisc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Per-index data for ANALYZE */</comment>
<typedef>typedef <type><struct>struct <name>AnlIndexData</name>
<block>{
    <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>        <comment type="block">/* BuildIndexInfo result */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>tupleFract</name></decl>;</decl_stmt>        <comment type="block">/* fraction of rows for partial index */</comment>
    <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl>;</decl_stmt>    <comment type="block">/* index attrs to analyze */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>attr_cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>AnlIndexData</name>;</typedef>


<comment type="block">/* Default statistics target (GUC parameter) */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>default_statistics_target</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* enable calculate coordinator statistics by sampling rows from data node */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_sampling_analyze</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* enable collecting distributed query info */</comment>
<decl_stmt><decl><type><name>bool</name></type>        <name>distributed_query_analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>        <name>explain_query_analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>QueryInfoList</name> <modifier>*</modifier></type><name>distributed_query_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>QueryInfoListIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>AnalyzeInfoHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* A few variables that don't seem worth passing around as parameters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>anl_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BufferAccessStrategy</name></type> <name>vac_strategy</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_analyze_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
               <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>,
               <parameter><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_index_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>,
                    <parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
                    <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VacAttrStats</name> <modifier>*</modifier></type><name>examine_attribute</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>,
                  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>index_expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
                    <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
                    <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>compare_rows</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>acquire_inherited_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
                              <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
                              <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_attstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>std_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ind_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>analyze_rel_coordinator</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attr_cnt</name></decl></parameter>,
                        <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
                        <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>indexes</name></decl></parameter>, <parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>random_collect_stats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rel_pages_visiblepages</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, 
						   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, 
						   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>visiblepages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>acquire_coordinator_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
												<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
												<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>,
												<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>totalpages</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>visiblepages</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 *    analyze_rel() -- analyze one relation
 */</comment>
<function><type><name>void</name></type>
<name>analyze_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
            <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
            <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>onerel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>elevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>childs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>childs</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>childs</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>analyze_rel</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>,
                            <argument><expr><name>bstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>childs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>childs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>childs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Select logging level */</comment>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>INFO</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Set up static variables */</comment>
    <expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <name>bstrategy</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for user-requested abort.
     */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the relation, getting ShareUpdateExclusiveLock to ensure that two
     * ANALYZEs don't run on it concurrently.  (This also locks out a
     * concurrent VACUUM, which doesn't matter much at the moment but might
     * matter if we ever try to accumulate stats on dead tuples.) If the rel
     * has been dropped since we last saw it, we don't need to process it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_NOWAIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s\" --- lock not available"</literal></expr></argument>,
                            <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check permissions --- this should match vacuum's check!
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
          <operator>(</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* No need for a WARNING if we already complained during VACUUM */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser can analyze it"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_ORCL_</name></cpp:ifdef>
            <if type="elseif">else if <condition>(<expr><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if_stmt><if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser or database owner can analyze it"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only table or database owner can analyze it"</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Silently ignore tables that are temp tables of other backends ---
     * trying to analyze these is rather pointless, since their contents are
     * probably not up-to-date on disk.  (We don't throw a warning here; it
     * would just lead to chatter during a database-wide ANALYZE.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We can ANALYZE any table except pg_statistic. See update_attstats
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>StatisticRelationId</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check that it's a plain table, materialized view, or foreign table; we
     * used to do this in get_rel_oids() but seems safer to check after we've
     * locked the relation.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
        <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Regular table, so we'll use the regular row acquisition function */</comment>
        <expr_stmt><expr><name>acquirefunc</name> <operator>=</operator> <name>acquire_sample_rows</name></expr>;</expr_stmt>
        <comment type="block">/* Also get regular table's size */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>     <name>part_pages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childs</name> <init>= <expr><call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>childs</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type> <name>childoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if<condition>(<expr><call><name>get_rel_stat</name><argument_list>(<argument><expr><name>childoid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>part_pages</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>relpages</name> <operator>+=</operator> <name>part_pages</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>relpages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For a foreign table, call the FDW's hook function to see whether it
         * supports analysis.
         */</comment>
        <decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>acquirefunc</name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze this foreign table"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For partitioned tables, we want to do the recursive ANALYZE below.
         */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* No need for a WARNING if we already complained during VACUUM */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze non-tables or special system tables"</literal></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * OK, let's do it.  First let other backends know I'm in ANALYZE.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>|=</operator> <name>PROC_IN_ANALYZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do the normal non-recursive ANALYZE.  We can skip this for partitioned
     * tables, which don't contain any rows.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>do_analyze_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>acquirefunc</name></expr></argument>,
                       <argument><expr><name>relpages</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If there are child tables, do recursive ANALYZE.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>do_analyze_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>acquirefunc</name></expr></argument>, <argument><expr><name>relpages</name></expr></argument>,
                       <argument><expr><name>true</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Close source relation now, but keep lock so that no one deletes it
     * before we commit.  (If someone did, they'd fail to clean up the entries
     * we made in pg_statistic.  Also, releasing the lock before commit would
     * expose us to concurrent-update failures in update_attstats.)
     */</comment>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reset my PGXACT flag.  Note: we need this here, and not in vacuum_rel,
     * because the vacuum flag is cleared by the end-of-xact code.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PROC_IN_ANALYZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    do_analyze_rel() -- analyze one relation, recursively or not
 *
 * Note that "acquirefunc" is only relevant for the non-inherited case.
 * For the inherited case, acquire_inherited_sample_rows() determines the
 * appropriate acquirefunc for each child table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_analyze_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name></decl></parameter>,
               <parameter><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>attr_cnt</name></decl>,
                <decl><type ref="prev"/><name>tcnt</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>,
                <decl><type ref="prev"/><name>ind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>Irel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nindexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>targrows</name></decl>,
                <decl><type ref="prev"/><name>numrows</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>totalrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>totaldeadrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>rows</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGRUsage</name></type>    <name>ru0</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>starttime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>caller_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>save_userid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_sec_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>iscoordinator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>coordpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>coordvisiblepages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"analyzing \"%s.%s\" inheritance tree"</literal></expr></argument>,
                        <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"analyzing \"%s.%s\""</literal></expr></argument>,
                        <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Set up a working context so that we can easily free whatever junk gets
     * created.
     */</comment>
    <expr_stmt><expr><name>anl_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                        <argument><expr><literal type="string">"Analyze"</literal></expr></argument>,
                                        <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>caller_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Switch to the table owner's userid, so that any index functions are run
     * as that user.  Also lock down security-restricted operations and
     * arrange to make GUC variable changes local to this command.
     */</comment>
    <expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
                           <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* measure elapsed time iff autovacuum logging requires it */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Determine which columns to analyze
     *
     * Note that system attributes are never analyzed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>va_cols</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>vacattrstats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>)</argument_list></call> <operator>*</operator>
                                                <sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>va_cols</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>col</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
                                <argument><expr><name>col</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_ENABLE</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>examine_attribute</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_DISABLE</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            <if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vacattrstats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_ENABLE</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            <expr_stmt><expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>examine_attribute</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_DISABLE</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
            <if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Open all indexes of the relation, and see if there are any analyzable
     * columns in the indexes.  We do not analyze index columns if there was
     * an explicit column list in the ANALYZE command, however.  If we are
     * doing a recursive scan, we don't want to touch the parent's indexes at
     * all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>vac_open_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nindexes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>Irel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nindexes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>hasindex</name> <operator>=</operator> <operator>(</operator><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>indexdata</name> <operator>=</operator> <operator>(</operator><name>AnlIndexData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nindexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AnlIndexData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>indexInfo</name></name> <operator>=</operator> <name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt> <comment type="block">/* fix later if partial */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>va_cols</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name></name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                    <call><name>palloc</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>keycol</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_KeyAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>keycol</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Found an index expression */</comment>
                        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator>
                            <call><name>examine_attribute</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>iscoordinator</name> <operator>=</operator> <operator>(</operator><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> 
					 <name><name>onerel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>&amp;&amp;</operator> 
					 <operator>!</operator><call><name>RELATION_IS_COORDINATOR_LOCAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_sampling_analyze</name> <operator>&amp;&amp;</operator> <name>iscoordinator</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>iscoordinator</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <comment type="block">/*
         * Fetch relation statistics from remote nodes and update
         */</comment>
		<expr_stmt><expr><call><name>vacuum_rel_coordinator</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Fetch attribute statistics from remote nodes.
         */</comment>
        <expr_stmt><expr><call><name>analyze_rel_coordinator</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>inh</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>,
                                <argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>indexdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Skip acquiring local stats. Coordinator does not store data of
         * distributed tables.
         */</comment>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Determine how many rows we need to sample, using the worst case from
     * all analyzable columns.  We use a lower bound of 100 rows to avoid
     * possible overflow in Vitter's algorithm.  (Note: that will also be the
     * target in the corner case where there are no analyzable columns.)
     */</comment>
    <expr_stmt><expr><name>targrows</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>targrows</name> <operator>&lt;</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>targrows</name> <operator>=</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>targrows</name> <operator>&lt;</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>targrows</name> <operator>=</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/*
     * Acquire the sample rows
     */</comment>
    <expr_stmt><expr><name>rows</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>targrows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>enable_sampling_analyze</name> <operator>&amp;&amp;</operator> <name>iscoordinator</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>acquire_coordinator_sample_rows</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>totalrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaldeadrows</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>coordpages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coordvisiblepages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	if <condition>(<expr><name>inh</name> <operator>||</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>acquire_inherited_sample_rows</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
                                                <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>totalrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>numrows</name> <operator>=</operator> <call>(<modifier>*</modifier><name>acquirefunc</name>) <argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
                                  <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>totalrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Compute the statistics.  Temporary results during the calculations for
     * each column are stored in a child context.  The calc routines are
     * responsible to make sure that whatever they store into the VacAttrStats
     * structure is allocated in anl_context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl>,
                    <decl><type ref="prev"/><name>old_context</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>col_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>,
                                            <argument><expr><literal type="string">"Analyze Column"</literal></expr></argument>,
                                            <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AttributeOpts</name> <modifier>*</modifier></type><name>aopt</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <comment type="block">/* has column crypt */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_ENABLE</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call>(<modifier>*</modifier><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name>) <argument_list>(<argument><expr><name>stats</name></expr></argument>,
                                     <argument><expr><name>std_fetch_func</name></expr></argument>,
                                     <argument><expr><name>numrows</name></expr></argument>,
                                     <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_DISABLE</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
             * If the appropriate flavor of the n_distinct option is
             * specified, override with the corresponding value.
             */</comment>
            <expr_stmt><expr><name>aopt</name> <operator>=</operator> <call><name>get_attribute_options</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>aopt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>float8</name></type>        <name>n_distinct</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>n_distinct</name> <operator>=</operator> <ternary><condition><expr><name>inh</name></expr> ?</condition><then> <expr><name><name>aopt</name><operator>-&gt;</operator><name>n_distinct_inherited</name></name></expr> </then><else>: <expr><name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name></expr></else></ternary></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>n_distinct</name> <operator>!=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>n_distinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>compute_index_stats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>,
                                <argument><expr><name>indexdata</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>,
                                <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>,
                                <argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Emit the completed stats rows into pg_statistic, replacing any
         * previous statistics for the target columns.  (If there are stats in
         * pg_statistic for columns we didn't process, we leave them alone.)
         */</comment>
        <expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inh</name></expr></argument>,
                        <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                            <argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr></argument>, <argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Build extended statistics (if there are any). */</comment>
        <expr_stmt><expr><call><name>BuildRelationExtStatistics</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>,
                                   <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Update pages/tuples stats in pg_class ... but not if we're doing
     * inherited stats.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>iscoordinator</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>relpages</name> <operator>=</operator> <name>coordpages</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>relallvisible</name> <operator>=</operator> <name>coordvisiblepages</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>visibilitymap_count</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relallvisible</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if<condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_rel_pages_visiblepages</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relallvisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
                            <argument><expr><name>relpages</name></expr></argument>,
                            <argument><expr><name>totalrows</name></expr></argument>,
                            <argument><expr><name>relallvisible</name></expr></argument>,
                            <argument><expr><name>hasindex</name></expr></argument>,
                            <argument><expr><name>InvalidTransactionId</name></expr></argument>,
                            <argument><expr><name>InvalidMultiXactId</name></expr></argument>,
                            <argument><expr><name>in_outer_xact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Same for indexes. Vacuum always scans all indexes, so if we're part of
     * VACUUM ANALYZE, don't overwrite the accurate count already inserted by
     * VACUUM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>totalindexrows</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>totalindexrows</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>*</operator> <name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>,
                                <argument><expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>totalindexrows</name></expr></argument>,
                                <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>InvalidTransactionId</name></expr></argument>,
                                <argument><expr><name>InvalidMultiXactId</name></expr></argument>,
                                <argument><expr><name>in_outer_xact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Coordinator skips getting local stats of distributed table up to here
     */</comment>
<label><name>cleanup</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Report ANALYZE to the stats collector, too.  However, if doing
     * inherited stats we shouldn't report, because the stats collector only
     * tracks per-table stats.  Reset the changes_since_analyze counter only
     * if we analyzed all columns; otherwise, there is still work for
     * auto-analyze to do.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgstat_report_analyze</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>totaldeadrows</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>va_cols</name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If this isn't part of VACUUM ANALYZE, let index AMs do cleanup */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IndexVacuumInfo</name></type> <name>ivinfo</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>estimated_count</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>message_level</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>num_heap_tuples</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name>vac_strategy</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name>index_vacuum_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>stats</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Done with indexes */</comment>
    <expr_stmt><expr><call><name>vac_close_indexes</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Log the action if appropriate */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                                       <argument><expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"automatic analyze of table \"%s.%s.%s\" system usage: %s"</literal></expr></argument>,
                            <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
    <expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore userid and security context */</comment>
    <expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore current context and release memory */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>caller_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>anl_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute statistics about indexes of a relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_index_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>,
                    <parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
                    <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>,
                    <parameter><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>ind_context</name></decl>,
                <decl><type ref="prev"/><name>old_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ind</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ind_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>,
                                        <argument><expr><literal type="string">"Analyze Index"</literal></expr></argument>,
                                        <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>indexInfo</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>attr_cnt</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>exprvals</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>exprnulls</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numindexrows</name></decl>,
                    <decl><type ref="prev"/><name>tcnt</name></decl>,
                    <decl><type ref="prev"/><name>rowno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>totalindexrows</name></decl>;</decl_stmt>

        <comment type="block">/* Ignore index if no columns to analyze and not partial */</comment>
        <if_stmt><if>if <condition>(<expr><name>attr_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Need an EState for evaluation of index expressions and
         * partial-index predicates.  Create it in the per-index context to be
         * sure it gets cleaned up at the bottom of the loop.
         */</comment>
        <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Need a slot to hold the current heap tuple, too */</comment>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

        <comment type="block">/* Set up execution state for predicate. */</comment>
        <expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Compute and save index expression values */</comment>
        <expr_stmt><expr><name>exprvals</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>exprnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numindexrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>heapTuple</name> <init>= <expr><name><name>rows</name><index>[<expr><name>rowno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Reset the per-tuple context each time, to reclaim any cruft
             * left behind by evaluating the predicate or index expressions.
             */</comment>
            <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Set up for predicate or expression evaluation */</comment>
            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If index is partial, check predicate */</comment>
            <if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>numindexrows</name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>attr_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Evaluate the index row to compute expression values. We
                 * could do this by hand, but FormIndexDatum is convenient.
                 */</comment>
                <expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
                               <argument><expr><name>slot</name></expr></argument>,
                               <argument><expr><name>estate</name></expr></argument>,
                               <argument><expr><name>values</name></expr></argument>,
                               <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Save just the columns we care about.  We copy the values
                 * into ind_context from the estate's per-tuple context.
                 */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>exprvals</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>exprnulls</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>exprvals</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                                   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
                                                   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>exprnulls</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Having counted the number of rows that pass the predicate in the
         * sample, we can estimate the total number of rows in the index.
         */</comment>
        <expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numindexrows</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numrows</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalindexrows</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>*</operator> <name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now we can compute the statistics for the expression columns.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>numindexrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AttributeOpts</name> <modifier>*</modifier></type><name>aopt</name> <init>=
                <expr><call><name>get_attribute_options</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>,
                                      <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprvals</name></name> <operator>=</operator> <name>exprvals</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprnulls</name></name> <operator>=</operator> <name>exprnulls</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rowstride</name></name> <operator>=</operator> <name>attr_cnt</name></expr>;</expr_stmt>
                <expr_stmt><expr><call>(<modifier>*</modifier><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name>) <argument_list>(<argument><expr><name>stats</name></expr></argument>,
                                         <argument><expr><name>ind_fetch_func</name></expr></argument>,
                                         <argument><expr><name>numindexrows</name></expr></argument>,
                                         <argument><expr><name>totalindexrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If the n_distinct option is specified, it overrides the
                 * above computation.  For indices, we always use just
                 * n_distinct, not n_distinct_inherited.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>aopt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name> <operator>!=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* And clean up */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * examine_attribute -- pre-analysis of a single column
 *
 * Determine whether the column is analyzable; if so, create and initialize
 * a VacAttrStats struct for it.  If not, return NULL.
 *
 * If index_expr isn't NULL, then we're trying to analyze an expression index,
 * and index_expr is the expression tree representing the column's data.
 */</comment>
<function><type><specifier>static</specifier> <name>VacAttrStats</name> <modifier>*</modifier></type>
<name>examine_attribute</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>index_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>typtuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>ok</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ATTRS_EXT_IS_ENABLED</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs_ext</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    <comment type="block">/* Never analyze dropped columns */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Don't analyze column if user has specified not to */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create the VacAttrStats struct.  Note that we only have a copy of the
     * fixed fields of the pg_attribute tuple.
     */</comment>
    <expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * When analyzing an expression index, believe the expression tree's type
     * not the column datatype --- the latter might be the opckeytype storage
     * type of the opclass, which is not interesting for our purposes.  (Note:
     * if we did anything with non-expression index columns, we'd need to
     * figure out where to get the correct type info from, but for now that's
     * not a problem.)    It's not clear whether anyone will care about the
     * typmod, but we store that too just in case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>index_expr</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>index_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>index_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>typtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name> <operator>=</operator> <name>anl_context</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>tupattnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The fields describing the stats-&gt;stavalues[n] element types default to
     * the type of the data being analyzed, but the type-specific typanalyze
     * function can change them if it wants to store something else.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Call the type-specific typanalyze function.  If none is specified, use
     * std_typanalyze().
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typanalyze</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typanalyze</name></name></expr></argument>,
                                           <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>std_typanalyze</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>||</operator> <name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * acquire_sample_rows -- acquire a random sample of rows from the table
 *
 * Selected rows are returned in the caller-allocated array rows[], which
 * must have at least targrows entries.
 * The actual number of rows selected is returned as the function result.
 * We also estimate the total numbers of live and dead rows in the table,
 * and return them into *totalrows and *totaldeadrows, respectively.
 *
 * The returned list of tuples is in order by physical position in the table.
 * (We will rely on this later to derive correlation estimates.)
 *
 * As of May 2004 we use a new two-stage method:  Stage one selects up
 * to targrows random blocks (or all blocks, if there aren't so many).
 * Stage two scans these blocks and uses the Vitter algorithm to create
 * a random sample of targrows rows (or less, if there are less in the
 * sample of blocks).  The two stages are executed simultaneously: each
 * block is processed as soon as stage one returns its number and while
 * the rows are read stage two controls which ones are to be inserted
 * into the sample.
 *
 * Although every row has an equal chance of ending up in the final
 * sample, this sampling method is not perfect: not every possible
 * sample has an equal chance of being selected.  For large relations
 * the number of different blocks represented by the sample tends to be
 * too small.  We can live with that for now.  Improvements are welcome.
 *
 * An important property of this sampling method is that because we do
 * look at a statistically unbiased set of blocks, we should get
 * unbiased estimates of the average numbers of live and dead rows per
 * block.  The previous sampling method put too much credence in the row
 * density near the start of the table.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
                    <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
                    <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* # rows now in reservoir */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>samplerows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* total # rows collected */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>liverows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* # live rows seen */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>deadrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* # dead rows seen */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>rowstoskip</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* -1 means not set yet */</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>totalblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockSamplerData</name></type> <name>bs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>totalblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Need a cutoff xmin for HeapTupleSatisfiesVacuum */</comment>
    <expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Prepare for sampling block numbers */</comment>
    <expr_stmt><expr><call><name>BlockSampler_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>, <argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Prepare for sampling rows */</comment>
    <expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Outer loop over blocks to sample */</comment>
    <while>while <condition>(<expr><call><name>BlockSampler_HasMore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>targblock</name> <init>= <expr><call><name>BlockSampler_Next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>targbuffer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Page</name></type>        <name>targpage</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>targoffset</name></decl>,
                    <decl><type ref="prev"/><name>maxoffset</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We must maintain a pin on the target page's buffer to ensure that
         * the maxoffset value stays good (else concurrent VACUUM might delete
         * tuples out from under us).  Hence, pin the page until we are done
         * looking at it.  We also choose to hold sharelock on the buffer
         * throughout --- we could release and re-acquire sharelock for each
         * tuple, but since we aren't doing much work per tuple, the extra
         * lock traffic is probably better avoided.
         */</comment>
        <expr_stmt><expr><name>targbuffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>targblock</name></expr></argument>,
                                        <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targbuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>maxoffset</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Inner loop over all tuples on the selected page */</comment>
        <for>for <control>(<init><expr><name>targoffset</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>targoffset</name> <operator>&lt;=</operator> <name>maxoffset</name></expr>;</condition> <incr><expr><name>targoffset</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ItemId</name></type>        <name>itemid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>targtuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>newTuple</name> <init>= <expr><operator>&amp;</operator><name>targtuple</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>sample_it</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * We ignore unused and redirect line pointers.  DEAD line
             * pointers should be counted as dead, because we need vacuum to
             * run to get rid of them.  Note that this rule agrees with the
             * way that heap_page_prune() counts things.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targtuple</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>targblock</name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>targtuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targtuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targtuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targtuple</name></expr></argument>,
                                             <argument><expr><name>OldestXmin</name></expr></argument>,
                                             <argument><expr><name>targbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
                    <expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
                <case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>
                    <comment type="block">/* Count dead and recently-dead rows */</comment>
                    <expr_stmt><expr><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

                    <comment type="block">/*
                     * Insert-in-progress rows are not counted.  We assume
                     * that when the inserting transaction commits or aborts,
                     * it will send a stats message to increment the proper
                     * count.  This works right only if that transaction ends
                     * after we finish analyzing the table; if things happen
                     * in the other order, its stats update will be
                     * overwritten by ours.  However, the error will be large
                     * only if the other transaction runs long enough to
                     * insert many tuples, so assuming it will finish after us
                     * is the safer option.
                     *
                     * A special case is that the inserting transaction might
                     * be our own.  In this case we should count and sample
                     * the row, to accommodate users who load a table and
                     * analyze it in one transaction.  (pgstat_report_analyze
                     * has to adjust the numbers we send to the stats
                     * collector to make this come out right.)
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>targtuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>

                    <comment type="block">/*
                     * We count delete-in-progress rows as still live, using
                     * the same reasoning given above; but we don't bother to
                     * include them in the sample.
                     *
                     * If the delete was done by our own transaction, however,
                     * we must count the row as dead to make
                     * pgstat_report_analyze's stats adjustments come out
                     * right.  (Note: this works out properly when the row was
                     * both inserted and deleted in our xact.)
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>targtuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <if_stmt><if>if <condition>(<expr><name>sample_it</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If connection is from Coordinator on datanodes, we discard TOAST fields in sample,
                 * which will lighten the load of memory usage on coordinator.
                 */</comment>
			    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
			    <block>{<block_content>
			        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
			        <decl_stmt><decl><type><name>bool</name>        <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
			        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			        <decl_stmt><decl><type><name>int</name></type>     <name>nattrs</name></decl>;</decl_stmt>
			        <decl_stmt><decl><type><name>Form_pg_attribute</name>   <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
			        <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>

			        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			        <expr_stmt><expr><name>nattrs</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
			        <expr_stmt><expr><name>attrs</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>

			        <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			        <expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			        <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targtuple</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			        <block>{<block_content>
			            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attbyval</name> <operator>&amp;&amp;</operator> <name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			            <block>{<block_content>
			                <comment type="block">/* varlena */</comment>
			                <decl_stmt><decl><type><name>Pointer</name></type>     <name>val</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			                <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
			                <block>{<block_content>
			                    <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			                </block_content>}</block></if></if_stmt>
			            </block_content>}</block></if></if_stmt>
			        </block_content>}</block></for>

			        <expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * copy the identification info of the old tuple: t_ctid, t_self, and OID
                     * (if any)
                     */</comment>
                    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>targtuple</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>targtuple</name><operator>.</operator><name>t_self</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>targtuple</name><operator>.</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
                    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>targtuple</name><operator>.</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targtuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			    </block_content>}</block></if></if_stmt>
				<comment type="block">/*
                 * The first targrows sample rows are simply copied into the
                 * reservoir. Then we start replacing tuples in the sample
                 * until we reach the end of the relation.  This algorithm is
                 * from Jeff Vitter's paper (see full citation below). It
                 * works by repeatedly computing the number of tuples to skip
                 * before selecting a tuple, which replaces a randomly chosen
                 * element of the reservoir (current set of tuples).  At all
                 * times the reservoir is a true random sample of the tuples
                 * we've passed over so far, so when we fall off the end of
                 * the relation we're done.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&lt;</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * t in Vitter's paper is the number of records already
                     * processed.  If we need to compute a new S value, we
                     * must use the not-yet-incremented value of samplerows as
                     * t.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rowstoskip</name> <operator>=</operator> <call><name>reservoir_get_next_S</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Found a suitable tuple, so save it, replacing one
                         * old tuple at random
                         */</comment>
                        <decl_stmt><decl><type><name>int</name></type>            <name>k</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>rowstoskip</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name>samplerows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Now release the lock and pin on the page */</comment>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * If we didn't find as many tuples as we wanted then we're done. No sort
     * is needed, since they're already in order.
     *
     * Otherwise we need to sort the collected tuples by position
     * (itempointer). It's not worth worrying about corner cases where the
     * tuples are already sorted.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>==</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Estimate total numbers of rows in relation.  For live rows, use
     * vac_estimate_reltuples; for dead rows, we have no source of old
     * information, so we have to assume the density is the same in unseen
     * pages as in the pages we scanned.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <call><name>vac_estimate_reltuples</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                        <argument><expr><name>totalblocks</name></expr></argument>,
                                        <argument><expr><name><name>bs</name><operator>.</operator><name>m</name></name></expr></argument>,
                                        <argument><expr><name>liverows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>bs</name><operator>.</operator><name>m</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>deadrows</name> <operator>/</operator> <name><name>bs</name><operator>.</operator><name>m</name></name><operator>)</operator> <operator>*</operator> <name>totalblocks</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Emit some interesting relation info
     */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": scanned %d of %u pages, "</literal>
                    <literal type="string">"containing %.0f live rows and %.0f dead rows; "</literal>
                    <literal type="string">"%d rows in sample, %.0f estimated total rows"</literal></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>bs</name><operator>.</operator><name>m</name></name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>,
                    <argument><expr><name>liverows</name></expr></argument>, <argument><expr><name>deadrows</name></expr></argument>,
                    <argument><expr><name>numrows</name></expr></argument>, <argument><expr><operator>*</operator><name>totalrows</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting rows[] array
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_rows</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>ha</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>hb</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>ba</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ha</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>oa</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ha</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>bb</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hb</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>ob</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hb</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&lt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&gt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&lt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&gt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * acquire_inherited_sample_rows -- acquire sample rows from inheritance tree
 *
 * This has the same API as acquire_sample_rows, except that rows are
 * collected from all inheritance children as well as the specified table.
 * We fail and return zero if there are no inheritance children, or if all
 * children are foreign tables that don't support ANALYZE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>acquire_inherited_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
                              <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
                              <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tableOIDs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>acquirefuncs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name>       <modifier>*</modifier></type><name>relblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>totalblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numrows</name></decl>,
                <decl><type ref="prev"/><name>nrels</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_child</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Find all members of inheritance set.  We only need AccessShareLock on
     * the children.
     */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tableOIDs</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<expr_stmt><expr><name>tableOIDs</name> <operator>=</operator>
			<call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
    <comment type="block">/*
     * Check that there's at least one descendant, else fail.  This could
     * happen despite analyze_rel's relhassubclass check, if table once had a
     * child but no longer does.  In that case, we can clear the
     * relhassubclass field so as not to make the same mistake again later.
     * (This is safe because we hold ShareUpdateExclusiveLock.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* CCI because we already updated the pg_class row in this command */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetRelationHasSubclass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s.%s\" inheritance tree --- this inheritance tree contains no child tables"</literal></expr></argument>,
                        <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Identify acquirefuncs to use, and count blocks in all the relations.
     * The result could overflow BlockNumber, so we use double arithmetic.
     */</comment>
    <expr_stmt><expr><name>rels</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>acquirefuncs</name> <operator>=</operator> <operator>(</operator><name>AcquireSampleRowsFunc</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AcquireSampleRowsFunc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relblocks</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>totalblocks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nrels</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>has_child</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tableOIDs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>childOID</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We already got the needed lock */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <comment type="block">/* Ignore if temp table of another backend */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* ... but release the lock on it */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check table type (MATVIEW can't happen, but might as well allow) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
            <name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Regular table, so use the regular row acquisition function */</comment>
            <expr_stmt><expr><name>acquirefunc</name> <operator>=</operator> <name>acquire_sample_rows</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>relpages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * For a foreign table, call the FDW's hook function to see
             * whether it supports analysis.
             */</comment>
            <decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name><argument_list>(<argument><expr><name>childrel</name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>acquirefunc</name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* ignore, but release the lock on it */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * ignore, but release the lock on it.  don't try to unlock the
             * passed-in relation
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* OK, we'll process this child */</comment>
        <expr_stmt><expr><name>has_child</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rels</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <name>childrel</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>acquirefuncs</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <name>acquirefunc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>relblocks</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalblocks</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nrels</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If we don't have at least one child table to consider, fail.  If the
     * relation is a partitioned table, it's not counted as a child table.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_child</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s.%s\" inheritance tree --- this inheritance tree contains no analyzable child tables"</literal></expr></argument>,
                        <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now sample rows from each relation, proportionally to its fraction of
     * the total block count.  (This might be less than desirable if the child
     * rels have radically different free-space percentages, but it's not
     * clear that it's worth working harder.)
     */</comment>
    <expr_stmt><expr><name>numrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>childrel</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name><name>acquirefuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>childblocks</name> <init>= <expr><name><name>relblocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>childblocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>childtargrows</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>childtargrows</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>targrows</name> <operator>*</operator> <name>childblocks</name> <operator>/</operator> <name>totalblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Make sure we don't overrun due to roundoff error */</comment>
            <expr_stmt><expr><name>childtargrows</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>childtargrows</name></expr></argument>, <argument><expr><name>targrows</name> <operator>-</operator> <name>numrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>childtargrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>childrows</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name></type>        <name>trows</name></decl>,
                            <decl><type ref="prev"/><name>tdrows</name></decl>;</decl_stmt>

                <comment type="block">/* Fetch a random sample of the child's rows */</comment>
                <expr_stmt><expr><name>childrows</name> <operator>=</operator> <call>(<modifier>*</modifier><name>acquirefunc</name>) <argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
                                            <argument><expr><name>rows</name> <operator>+</operator> <name>numrows</name></expr></argument>, <argument><expr><name>childtargrows</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>trows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* We may need to convert from child's rowtype to parent's */</comment>
                <if_stmt><if>if <condition>(<expr><name>childrows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>equalTupleDescs</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>childrows</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newtup</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <expr_stmt><expr><call><name>free_conversion_map</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* And add to counts */</comment>
                <expr_stmt><expr><name>numrows</name> <operator>+=</operator> <name>childrows</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>+=</operator> <name>trows</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>+=</operator> <name>tdrows</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Note: we cannot release the child-table locks, since we may have
         * pointers to their TOAST tables in the sampled rows.
         */</comment>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *    update_attstats() -- update attribute statistics for one relation
 *
 *        Statistics are stored in several places: the pg_class row for the
 *        relation has stats about the whole relation, and there is a
 *        pg_statistic row for each (non-system) attribute that has ever
 *        been analyzed.  The pg_class values are updated by VACUUM, not here.
 *
 *        pg_statistic rows are just added or updated normally.  This means
 *        that pg_statistic will probably contain some deleted rows at the
 *        completion of a vacuum cycle, unless it happens to get vacuumed last.
 *
 *        To keep things simple, we punt for pg_statistic, and don't try
 *        to compute or store rows for pg_statistic itself in pg_statistic.
 *        This could possibly be made to work, but it's not worth the trouble.
 *        Note analyze_rel() has seen to it that we won't come here when
 *        vacuuming pg_statistic itself.
 *
 *        Note: there would be a race condition here if two backends could
 *        ANALYZE the same table concurrently.  Presently, we lock that out
 *        by taking a self-exclusive lock on the relation in analyze_rel().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_attstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>sd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attno</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>natts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>

    <expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>attno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>stup</name></decl>,
                    <decl><type ref="prev"/><name>oldtup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                    <decl><type ref="prev"/><name>k</name></decl>,
                    <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>replaces</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* Ignore attr if we weren't able to collect stats */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Construct a new pg_statistic tuple
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_statistic</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_starelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_staattnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stainherit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stanullfrac</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stawidth</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stadistinct</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stakind1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stakindN */</comment>
        </block_content>}</block></for>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_staop1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* staopN */</comment>
        </block_content>}</block></for>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stanumbers1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>nnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>nnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>numdatums</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nnum</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nnum</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>numdatums</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                <comment type="block">/* XXX knows more than it should about type float4: */</comment>
                <expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>numdatums</name></expr></argument>, <argument><expr><name>nnum</name></expr></argument>,
                                       <argument><expr><name>FLOAT4OID</name></expr></argument>,
                                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FLOAT4PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* stanumbersN */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stavalues1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* stavaluesN */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Is there already a pg_statistic tuple for this attribute? */</comment>
        <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Yes, replace it */</comment>
            <expr_stmt><expr><name>stup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>,
                                     <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>values</name></expr></argument>,
                                     <argument><expr><name>nulls</name></expr></argument>,
                                     <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* No, insert new tuple */</comment>
            <expr_stmt><expr><name>stup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    update_ext_stats() -- update extended statistics
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_ext_stats</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>nspname</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>,
                 <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>ndistinct</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>dependencies</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>nspoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>sd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>stup</name></decl>,
                <decl><type ref="prev"/><name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pg_statistic_ext</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pg_statistic_ext</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>replaces</name><index>[<expr><name>Natts_pg_statistic_ext</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nspoid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct a new pg_statistic_ext tuple
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_statistic_ext</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_statistic_ext_stxndistinct</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_statistic_ext_stxdependencies</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* ndistinct */</comment>
    <if_stmt><if>if <condition>(<expr><name>ndistinct</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxndistinct</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_statistic_ext_stxndistinct</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* dependencies */</comment>
    <if_stmt><if>if <condition>(<expr><name>dependencies</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxdependencies</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_statistic_ext_stxdependencies</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Is there already a pg_statistic_ext tuple for this attribute? */</comment>
    <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>STATEXTNAMENSP</name></expr></argument>,
                             <argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We only expect data for extended statistics already defined on
     * the coordinator, so fail if we got something unexpected.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown extended statistic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Yes, replace it */</comment>
    <expr_stmt><expr><name>stup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>,
                             <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>values</name></expr></argument>,
                             <argument><expr><name>nulls</name></expr></argument>,
                             <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Standard fetch function for use by compute_stats subroutines.
 *
 * This exists to provide some insulation between compute_stats routines
 * and the actual storage of the sample data.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>std_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>tupattnum</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name><index>[<expr><name>rownum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch function for analyzing index expressions.
 *
 * We have not bothered to construct index tuples, instead the data is
 * just in Datum arrays.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ind_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* exprvals and exprnulls are already offset for proper column */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>rownum</name> <operator>*</operator> <name><name>stats</name><operator>-&gt;</operator><name>rowstride</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>exprnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name><name>stats</name><operator>-&gt;</operator><name>exprvals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*==========================================================================
 *
 * Code below this point represents the "standard" type-specific statistics
 * analysis algorithms.  This code can be replaced on a per-data-type basis
 * by setting a nonzero value in pg_type.typanalyze.
 *
 *==========================================================================
 */</comment>


<comment type="block">/*
 * To avoid consuming too much memory during analysis and/or too much space
 * in the resulting pg_statistic rows, we ignore varlena datums that are wider
 * than WIDTH_THRESHOLD (after detoasting!).  This is legitimate for MCV
 * and distinct-value calculations since a wide value is unlikely to be
 * duplicated at all, much less be a most-common value.  For the same reason,
 * ignoring wide values will not affect our estimates of histogram bin
 * boundaries very much.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIDTH_THRESHOLD</name></cpp:macro>  <cpp:value>1024</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swapInt</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>do {int _tmp; _tmp=a; a=b; b=_tmp;} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swapDatum</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>do {Datum _tmp; _tmp=a; a=b; b=_tmp;} while(0)</cpp:value></cpp:define>

<comment type="block">/*
 * Extra information used by the default analysis routines
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name></decl>;</decl_stmt>            <comment type="block">/* # of duplicates */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>first</name></decl>;</decl_stmt>            <comment type="block">/* values[] index of first occurrence */</comment>
}</block></struct></type> <name>ScalarMCVItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>tupnoLink</name></decl>;</decl_stmt>
}</block></struct></type> <name>CompareScalarsContext</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_trivial_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
                      <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
                      <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_distinct_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
                       <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
                       <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_scalar_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
                     <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
                     <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>compare_scalars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>compare_mcvs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * std_typanalyze -- the default type-specific typanalyze function
 */</comment>
<function><type><name>bool</name></type>
<name>std_typanalyze</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>ltopr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>eqopr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name></decl>;</decl_stmt>

    <comment type="block">/* If the attstattarget column is negative, use the default value */</comment>
    <comment type="block">/* NB: it is okay to scribble on stats-&gt;attr since it's a copy */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <name>default_statistics_target</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Look for default "&lt;" and "=" operators for column's type */</comment>
    <expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>,
                             <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>ltopr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqopr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Save the operator info for compute_stats routines */</comment>
    <expr_stmt><expr><name>mystats</name> <operator>=</operator> <operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StdAnalyzeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name> <operator>=</operator> <name>eqopr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqfunc</name></name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name> <operator>=</operator> <name>ltopr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>mystats</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine which standard statistics algorithm to use
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Seems to be a scalar datatype */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_scalar_stats</name></expr>;</expr_stmt>
        <comment type="block">/*--------------------
         * The following choice of minrows is based on the paper
         * "Random sampling for histogram construction: how much is enough?"
         * by Surajit Chaudhuri, Rajeev Motwani and Vivek Narasayya, in
         * Proceedings of ACM SIGMOD International Conference on Management
         * of Data, 1998, Pages 436-447.  Their Corollary 1 to Theorem 5
         * says that for table size n, histogram size k, maximum relative
         * error in bin size f, and error probability gamma, the minimum
         * random sample size is
         *        r = 4 * k * ln(2*n/gamma) / f^2
         * Taking f = 0.5, gamma = 0.01, n = 10^6 rows, we obtain
         *        r = 305.82 * k
         * Note that because of the log function, the dependence on n is
         * quite weak; even at n = 10^12, a 300*k sample gives &lt;= 0.66
         * bin size error with probability 0.99.  So there's no real need to
         * scale for n, which is a good thing because we don't necessarily
         * know it at this point.
         *--------------------
         */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We can still recognize distinct values */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_distinct_stats</name></expr>;</expr_stmt>
        <comment type="block">/* Might as well use the same minrows as above */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Can't do much but the trivial stuff */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_trivial_stats</name></expr>;</expr_stmt>
        <comment type="block">/* Might as well use the same minrows as above */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *    compute_trivial_stats() -- compute very basic column statistics
 *
 *    We use this when we cannot find a hash "=" operator for the datatype.
 *
 *    We determine the fraction of non-null rows and the average datum width.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_trivial_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
                      <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
                      <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
                              <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
                               <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check for null/nonnull */</comment>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * If it's a variable-width field, add up widths for average width
         * calculation.  Note that if the value is toasted, we use the toasted
         * width.  We don't bother with this calculation if it's a fixed-width
         * type.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* must be cstring */</comment>
            <expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* We can only compute average width if we found some non-null values. */</comment>
    <if_stmt><if>if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* Do the simple null-frac and width stats */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>    <comment type="block">/* "unknown" */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* "unknown" */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>    <comment type="block">/* "unknown" */</comment>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    compute_distinct_stats() -- compute column statistics including ndistinct
 *
 *    We use this when we can find only an "=" operator for the datatype.
 *
 *    We determine the fraction of non-null rows, the average width, the
 *    most common values, and the (estimated) number of distinct values.
 *
 *    The most common values are determined by brute force: we keep a list
 *    of previously seen values, ordered by number of times seen, as we scan
 *    the samples.  A newly seen value is inserted just after the last
 *    multiply-seen value, causing the bottommost (oldest) singly-seen value
 *    to drop off the list.  The accuracy of this method, and also its cost,
 *    depend mainly on the length of the list we are willing to keep.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_distinct_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
                       <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
                       <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>toowide_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
                              <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
                               <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>f_cmpeq</name></decl>;</decl_stmt>
    <typedef>typedef <type><struct>struct
    <block>{
        <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>count</name></decl>;</decl_stmt>
    }</block></struct></type> <name>TrackItem</name>;</typedef>
    <decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>track_cnt</name></decl>,
                <decl><type ref="prev"/><name>track_max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_mcv</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name> <init>= <expr><operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We track up to 2*n values for an n-element MCV list; but at least 10
     */</comment>
    <expr_stmt><expr><name>track_max</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>num_mcv</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>track_max</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>track_max</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>track</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>track_max</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>track_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqfunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_cmpeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>match</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>firstcount1</name></decl>,
                    <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check for null/nonnull */</comment>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * If it's a variable-width field, add up widths for average width
         * calculation.  Note that if the value is toasted, we use the toasted
         * width.  We don't bother with this calculation if it's a fixed-width
         * type.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the value is toasted, we want to detoast it just once to
             * avoid repeated detoastings and resultant excess memory usage
             * during the comparisons.  Also, check to see if the value is
             * excessively wide, and if so don't detoast at all --- just
             * ignore the value.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>WIDTH_THRESHOLD</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>toowide_cnt</name><operator>++</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* must be cstring */</comment>
            <expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * See if the value matches anything we're already tracking.
         */</comment>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>firstcount1</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>track_cnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* We always use the default collation for statistics */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f_cmpeq</name></expr></argument>,
                                               <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
                                               <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>firstcount1</name> <operator>&amp;&amp;</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>firstcount1</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Found a match */</comment>
            <expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
            <comment type="block">/* This value may now need to "bubble up" in the track list */</comment>
            <while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>swapDatum</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>swapInt</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* No match.  Insert at head of count-1 list */</comment>
            <if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>track_max</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>track_cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <name>firstcount1</name></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>firstcount1</name> <operator>&lt;</operator> <name>track_cnt</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>track</name><index>[<expr><name>firstcount1</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>track</name><index>[<expr><name>firstcount1</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* We can only compute real stats if we found some non-null values. */</comment>
    <if_stmt><if>if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>nmultiple</name></decl>,
                    <decl><type ref="prev"/><name>summultiple</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* Do the simple null-frac and width stats */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Count the number of values we found multiple times */</comment>
        <expr_stmt><expr><name>summultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>nmultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nmultiple</name> <operator>&lt;</operator> <name>track_cnt</name></expr>;</condition> <incr><expr><name>nmultiple</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>track</name><index>[<expr><name>nmultiple</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>summultiple</name> <operator>+=</operator> <name><name>track</name><index>[<expr><name>nmultiple</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>nmultiple</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we found no repeated non-null values, assume it's a unique
             * column; but be sure to discount for any nulls we found.
             */</comment>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>track_max</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name>nmultiple</name> <operator>==</operator> <name>track_cnt</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Our track list includes every value in the sample, and every
             * value appeared more than once.  Assume the column has just
             * these values.  (This case is meant to address columns with
             * small, fixed sets of possible values, such as boolean or enum
             * columns.  If there are any values that appear just once in the
             * sample, including too-wide values, we should assume that that's
             * not what we're dealing with.)
             */</comment>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*----------
             * Estimate the number of distinct values using the estimator
             * proposed by Haas and Stokes in IBM Research Report RJ 10025:
             *        n*d / (n - f1 + f1*n/N)
             * where f1 is the number of distinct values that occurred
             * exactly once in our sample of n rows (from a total of N),
             * and d is the total number of distinct values in the sample.
             * This is their Duj1 estimator; the other estimators they
             * recommend are considerably more complex, and are numerically
             * very unstable when n is much smaller than N.
             *
             * In this calculation, we consider only non-nulls.  We used to
             * include rows with null values in the n and N counts, but that
             * leads to inaccurate answers in columns with many nulls, and
             * it's intuitively bogus anyway considering the desired result is
             * the number of distinct non-null values.
             *
             * We assume (not very reliably!) that all the multiply-occurring
             * values are reflected in the final track[] list, and the other
             * nonnull values all appeared but once.  (XXX this usually
             * results in a drastic overestimate of ndistinct.  Can we do
             * any better?)
             *----------
             */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>f1</name> <init>= <expr><name>nonnull_cnt</name> <operator>-</operator> <name>summultiple</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>d</name> <init>= <expr><name>f1</name> <operator>+</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>n</name> <init>= <expr><name>samplerows</name> <operator>-</operator> <name>null_cnt</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>N</name> <init>= <expr><name>totalrows</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>stadistinct</name></decl>;</decl_stmt>

            <comment type="block">/* N == 0 shouldn't happen, but just in case ... */</comment>
            <if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>*</operator> <name>d</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>f1</name><operator>)</operator> <operator>+</operator> <name>f1</name> <operator>*</operator> <name>n</name> <operator>/</operator> <name>N</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Clamp to sane range in case of roundoff error */</comment>
            <if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* And round to integer */</comment>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>stadistinct</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If we estimated the number of distinct values at more than 10% of
         * the total row count (a very arbitrary limit), then assume that
         * stadistinct should scale with the row count rather than be a fixed
         * value.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>totalrows</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>/</operator> <name>totalrows</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Decide how many values are worth storing as most-common values. If
         * we are able to generate a complete MCV list (all the values in the
         * sample will fit, and we think these are all the ones in the table),
         * then do so.  Otherwise, store only those values that are
         * significantly more common than the (estimated) average. We set the
         * threshold rather arbitrarily at 25% more than average, with at
         * least 2 instances in the sample.
         *
         * Note: the first of these cases is meant to address columns with
         * small, fixed sets of possible values, such as boolean or enum
         * columns.  If we can *completely* represent the column population by
         * an MCV list that will fit into the stats target, then we should do
         * so and thus provide the planner with complete information.  But if
         * the MCV list is not complete, it's generally worth being more
         * selective, and not just filling it all the way up to the stats
         * target.  So for an incomplete list, we try to take only MCVs that
         * are significantly more common than average.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>track_cnt</name> <argument_list type="generic">&lt; <argument><expr><name>track_max</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>track_cnt</name> <operator>&lt;=</operator> <name>num_mcv</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Track list includes all values seen, and all will fit */</comment>
            <expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>double</name></type>        <name>ndistinct_table</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>avgcount</name></decl>,
                        <decl><type ref="prev"/><name>mincount</name></decl>;</decl_stmt>

            <comment type="block">/* Re-extract estimate of # distinct nonnull values in table */</comment>
            <if_stmt><if>if <condition>(<expr><name>ndistinct_table</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ndistinct_table</name> <operator>=</operator> <operator>-</operator><name>ndistinct_table</name> <operator>*</operator> <name>totalrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* estimate # occurrences in sample of a typical nonnull value */</comment>
            <expr_stmt><expr><name>avgcount</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name> <operator>/</operator> <name>ndistinct_table</name></expr>;</expr_stmt>
            <comment type="block">/* set minimum threshold count to store a value */</comment>
            <expr_stmt><expr><name>mincount</name> <operator>=</operator> <name>avgcount</name> <operator>*</operator> <literal type="number">1.25</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>mincount</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>mincount</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <name>track_cnt</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <name>mincount</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Generate MCV slot entry */</comment>
        <if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>mcv_values</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float4</name>       <modifier>*</modifier></type><name>mcv_freqs</name></decl>;</decl_stmt>

            <comment type="block">/* Must copy the target values into anl_context */</comment>
            <expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mcv_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mcv_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
                                          <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
                                          <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mcv_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCV</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcv_freqs</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcv_values</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Accept the defaults for stats-&gt;statypid and others. They have
             * been set before we were called (see vacuum.h)
             */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* "unknown" */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>    <comment type="block">/* "unknown" */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We don't need to bother cleaning up any of our temporary palloc's */</comment>
</block_content>}</block></function>


<comment type="block">/*
 *    compute_scalar_stats() -- compute column statistics
 *
 *    We use this when we can find "=" and "&lt;" operators for the datatype.
 *
 *    We determine the fraction of non-null rows, the average width, the
 *    most common values, the (estimated) number of distinct values, the
 *    distribution histogram, and the correlation of physical to logical order.
 *
 *    The desired stats can be determined fairly easily after sorting the
 *    data values into order.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_scalar_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
                     <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
                     <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>toowide_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>curr_attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
                              <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
                               <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>corr_xysum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SortSupportData</name></type> <name>ssup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScalarItem</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>values_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>tupnoLink</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScalarMCVItem</name> <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>track_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_mcv</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_bins</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type>     <name>tuple_values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>  <modifier>*</modifier></type>     <name>tuple_isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_decrypt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name> <init>= <expr><operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>ScalarItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>samplerows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupnoLink</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>samplerows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>track</name> <operator>=</operator> <operator>(</operator><name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarMCVItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ssup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <comment type="block">/* We always use the default collation for statistics */</comment>
    <expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_collation</name></name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * For now, don't perform abbreviated key conversion, because full values
     * are required for MCV slot generation.  Supporting that optimization
     * would necessitate teaching compare_scalars() to call a tie-breaker.
     */</comment>
    <expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>trsprt_crypt_chk_tbl_has_col_crypt</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>curr_attnum</name>  <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple_isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>need_decrypt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initial scan to find sortable values */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>need_decrypt</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>transp_crypt</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>transp_crypt</name><index>[<expr><name>curr_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>algo_id</name></expr>)</condition>
                <block>{<block_content>
                	<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
	                <block>{<block_content>
                    <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_ENABLE</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	                </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>, <argument><expr><name>tuple_values</name></expr></argument>, <argument><expr><name>tuple_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	                <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
	                <block>{<block_content>
                    <expr_stmt><expr><call><name>TRANSP_CRYPT_ATTRS_EXT_DISABLE</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	                </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>tuple_isnull</name><index>[<expr><name>curr_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>tuple_values</name><index>[<expr><name>curr_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Check for null/nonnull */</comment>
        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * If it's a variable-width field, add up widths for average width
         * calculation.  Note that if the value is toasted, we use the toasted
         * width.  We don't bother with this calculation if it's a fixed-width
         * type.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the value is toasted, we want to detoast it just once to
             * avoid repeated detoastings and resultant excess memory usage
             * during the comparisons.  Also, check to see if the value is
             * excessively wide, and if so don't detoast at all --- just
             * ignore the value.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>WIDTH_THRESHOLD</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>toowide_cnt</name><operator>++</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* must be cstring */</comment>
            <expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Add it to the list to be sorted */</comment>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>values_cnt</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>values_cnt</name></expr>]</index></name><operator>.</operator><name>tupno</name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tupnoLink</name><index>[<expr><name>values_cnt</name></expr>]</index></name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>values_cnt</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* We can only compute real stats if we found some sortable values. */</comment>
    <if_stmt><if>if <condition>(<expr><name>values_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>ndistinct</name></decl>,    <comment type="block">/* # distinct values in sample */</comment>
                    <decl><type ref="prev"/><name>nmultiple</name></decl>,    <comment type="block">/* # that appear multiple times */</comment>
                    <decl><type ref="prev"/><name>num_hist</name></decl>,
                    <decl><type ref="prev"/><name>dups_cnt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>slot_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CompareScalarsContext</name></type> <name>cxt</name></decl>;</decl_stmt>

        <comment type="block">/* Sort the collected values */</comment>
        <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ssup</name></name> <operator>=</operator> <operator>&amp;</operator><name>ssup</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>tupnoLink</name></name> <operator>=</operator> <name>tupnoLink</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>, <argument><expr><name>values_cnt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                  <argument><expr><name>compare_scalars</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now scan the values in order, find the most common ones, and also
         * accumulate ordering-correlation statistics.
         *
         * To determine which are most common, we first have to count the
         * number of duplicates of each value.  The duplicates are adjacent in
         * the sorted list, so a brute-force approach is to compare successive
         * datum values until we find two that are not equal. However, that
         * requires N-1 invocations of the datum comparison routine, which are
         * completely redundant with work that was done during the sort.  (The
         * sort algorithm must at some point have compared each pair of items
         * that are adjacent in the sorted order; otherwise it could not know
         * that it's ordered the pair correctly.) We exploit this by having
         * compare_scalars remember the highest tupno index that each
         * ScalarItem has been found equal to.  At the end of the sort, a
         * ScalarItem's tupnoLink will still point to itself if and only if it
         * is the last item of its group of duplicates (since the group will
         * be ordered by tupno).
         */</comment>
        <expr_stmt><expr><name>corr_xysum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nmultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>dups_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>values_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>tupno</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tupno</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>corr_xysum</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>tupno</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>dups_cnt</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>tupnoLink</name><index>[<expr><name>tupno</name></expr>]</index></name> <operator>==</operator> <name>tupno</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Reached end of duplicates of this value */</comment>
                <expr_stmt><expr><name>ndistinct</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>dups_cnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>nmultiple</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>track_cnt</name> <argument_list type="generic">&lt; <argument><expr><name>num_mcv</name> <operator>||</operator>
                        <name>dups_cnt</name></expr></argument> &gt;</argument_list></name> <name><name>track</name><index>[<expr><name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Found a new item for the mcv list; find its
                         * position, bubbling down old items if needed. Loop
                         * invariant is that j points at an empty/ replaceable
                         * slot.
                         */</comment>
                        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>num_mcv</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>track_cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>dups_cnt</name> <operator>&lt;=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition><block type="pseudo"><block_content>
                                <break>break;</break></block_content></block></if></if_stmt>
                            <expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name>dups_cnt</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>dups_cnt</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>dups_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* Do the simple null-frac and width stats */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nmultiple</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we found no repeated non-null values, assume it's a unique
             * column; but be sure to discount for any nulls we found.
             */</comment>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nmultiple</name> <operator>==</operator> <name>ndistinct</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Every value in the sample appeared more than once.  Assume the
             * column has just these values.  (This case is meant to address
             * columns with small, fixed sets of possible values, such as
             * boolean or enum columns.  If there are any values that appear
             * just once in the sample, including too-wide values, we should
             * assume that that's not what we're dealing with.)
             */</comment>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*----------
             * Estimate the number of distinct values using the estimator
             * proposed by Haas and Stokes in IBM Research Report RJ 10025:
             *        n*d / (n - f1 + f1*n/N)
             * where f1 is the number of distinct values that occurred
             * exactly once in our sample of n rows (from a total of N),
             * and d is the total number of distinct values in the sample.
             * This is their Duj1 estimator; the other estimators they
             * recommend are considerably more complex, and are numerically
             * very unstable when n is much smaller than N.
             *
             * In this calculation, we consider only non-nulls.  We used to
             * include rows with null values in the n and N counts, but that
             * leads to inaccurate answers in columns with many nulls, and
             * it's intuitively bogus anyway considering the desired result is
             * the number of distinct non-null values.
             *
             * Overwidth values are assumed to have been distinct.
             *----------
             */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>f1</name> <init>= <expr><name>ndistinct</name> <operator>-</operator> <name>nmultiple</name> <operator>+</operator> <name>toowide_cnt</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>d</name> <init>= <expr><name>f1</name> <operator>+</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>n</name> <init>= <expr><name>samplerows</name> <operator>-</operator> <name>null_cnt</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>N</name> <init>= <expr><name>totalrows</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>stadistinct</name></decl>;</decl_stmt>

            <comment type="block">/* N == 0 shouldn't happen, but just in case ... */</comment>
            <if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>*</operator> <name>d</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>f1</name><operator>)</operator> <operator>+</operator> <name>f1</name> <operator>*</operator> <name>n</name> <operator>/</operator> <name>N</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Clamp to sane range in case of roundoff error */</comment>
            <if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* And round to integer */</comment>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>stadistinct</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If we estimated the number of distinct values at more than 10% of
         * the total row count (a very arbitrary limit), then assume that
         * stadistinct should scale with the row count rather than be a fixed
         * value.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>totalrows</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>/</operator> <name>totalrows</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Decide how many values are worth storing as most-common values. If
         * we are able to generate a complete MCV list (all the values in the
         * sample will fit, and we think these are all the ones in the table),
         * then do so.  Otherwise, store only those values that are
         * significantly more common than the (estimated) average. We set the
         * threshold rather arbitrarily at 25% more than average, with at
         * least 2 instances in the sample.  Also, we won't suppress values
         * that have a frequency of at least 1/K where K is the intended
         * number of histogram bins; such values might otherwise cause us to
         * emit duplicate histogram bin boundaries.  (We might end up with
         * duplicate histogram entries anyway, if the distribution is skewed;
         * but we prefer to treat such values as MCVs if at all possible.)
         *
         * Note: the first of these cases is meant to address columns with
         * small, fixed sets of possible values, such as boolean or enum
         * columns.  If we can *completely* represent the column population by
         * an MCV list that will fit into the stats target, then we should do
         * so and thus provide the planner with complete information.  But if
         * the MCV list is not complete, it's generally worth being more
         * selective, and not just filling it all the way up to the stats
         * target.  So for an incomplete list, we try to take only MCVs that
         * are significantly more common than average.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>==</operator> <name>ndistinct</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>track_cnt</name> <operator>&lt;=</operator> <name>num_mcv</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Track list includes all values seen, and all will fit */</comment>
            <expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>double</name></type>        <name>ndistinct_table</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>avgcount</name></decl>,
                        <decl><type ref="prev"/><name>mincount</name></decl>,
                        <decl><type ref="prev"/><name>maxmincount</name></decl>;</decl_stmt>

            <comment type="block">/* Re-extract estimate of # distinct nonnull values in table */</comment>
            <if_stmt><if>if <condition>(<expr><name>ndistinct_table</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ndistinct_table</name> <operator>=</operator> <operator>-</operator><name>ndistinct_table</name> <operator>*</operator> <name>totalrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* estimate # occurrences in sample of a typical nonnull value */</comment>
            <expr_stmt><expr><name>avgcount</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name> <operator>/</operator> <name>ndistinct_table</name></expr>;</expr_stmt>
            <comment type="block">/* set minimum threshold count to store a value */</comment>
            <expr_stmt><expr><name>mincount</name> <operator>=</operator> <name>avgcount</name> <operator>*</operator> <literal type="number">1.25</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>mincount</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>mincount</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* don't let threshold exceed 1/K, however */</comment>
            <expr_stmt><expr><name>maxmincount</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>values_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>num_bins</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>mincount</name> <operator>&gt;</operator> <name>maxmincount</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>mincount</name> <operator>=</operator> <name>maxmincount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <name>track_cnt</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <name>mincount</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Generate MCV slot entry */</comment>
        <if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>mcv_values</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float4</name>       <modifier>*</modifier></type><name>mcv_freqs</name></decl>;</decl_stmt>

            <comment type="block">/* Must copy the target values into anl_context */</comment>
            <expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mcv_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mcv_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
                                          <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
                                          <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mcv_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCV</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcv_freqs</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcv_values</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Accept the defaults for stats-&gt;statypid and others. They have
             * been set before we were called (see vacuum.h)
             */</comment>
            <expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Generate a histogram slot entry if there are at least two distinct
         * values not accounted for in the MCV list.  (This ensures the
         * histogram won't collapse to empty or a singleton.)
         */</comment>
        <expr_stmt><expr><name>num_hist</name> <operator>=</operator> <name>ndistinct</name> <operator>-</operator> <name>num_mcv</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>num_hist</name> <operator>&gt;</operator> <name>num_bins</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>num_hist</name> <operator>=</operator> <name>num_bins</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>num_hist</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>hist_values</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>nvals</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>,
                        <decl><type ref="prev"/><name>posfrac</name></decl>,
                        <decl><type ref="prev"/><name>delta</name></decl>,
                        <decl><type ref="prev"/><name>deltafrac</name></decl>;</decl_stmt>

            <comment type="block">/* Sort the MCV items into position order to speed next loop */</comment>
            <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>track</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScalarMCVItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Collapse out the MCV items from the values[] array.
             *
             * Note we destroy the values[] array here... but we don't need it
             * for anything more.  We do, however, still need values_cnt.
             * nvals will be the number of remaining entries in values[].
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>src</name></decl>,
                            <decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>src</name> <operator>=</operator> <name>dest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* index of next interesting MCV item */</comment>
                <while>while <condition>(<expr><name>src</name> <operator>&lt;</operator> <name>values_cnt</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>ncopy</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>num_mcv</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type>            <name>first</name> <init>= <expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>src</name> <operator>&gt;=</operator> <name>first</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* advance past this MCV item */</comment>
                            <expr_stmt><expr><name>src</name> <operator>=</operator> <name>first</name> <operator>+</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>ncopy</name> <operator>=</operator> <name>first</name> <operator>-</operator> <name>src</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>ncopy</name> <operator>=</operator> <name>values_cnt</name> <operator>-</operator> <name>src</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>dest</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>,
                            <argument><expr><name>ncopy</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>src</name> <operator>+=</operator> <name>ncopy</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dest</name> <operator>+=</operator> <name>ncopy</name></expr>;</expr_stmt>
                </block_content>}</block></while>
                <expr_stmt><expr><name>nvals</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>nvals</name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvals</name> <operator>&gt;=</operator> <name>num_hist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Must copy the target values into anl_context */</comment>
            <expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hist_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_hist</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The object of this loop is to copy the first and last values[]
             * entries along with evenly-spaced values in between.  So the
             * i'th value is values[(i * (nvals - 1)) / (num_hist - 1)].  But
             * computing that subscript directly risks integer overflow when
             * the stats target is more than a couple thousand.  Instead we
             * add (nvals - 1) / (num_hist - 1) to pos at each step, tracking
             * the integral and fractional parts of the sum separately.
             */</comment>
            <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>nvals</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>deltafrac</name> <operator>=</operator> <operator>(</operator><name>nvals</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>posfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_hist</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>hist_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
                                           <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
                                           <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>posfrac</name> <operator>+=</operator> <name>deltafrac</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>posfrac</name> <operator>&gt;=</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* fractional part exceeds 1, carry to integer part */</comment>
                    <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>posfrac</name> <operator>-=</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_HISTOGRAM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>hist_values</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_hist</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Accept the defaults for stats-&gt;statypid and others. They have
             * been set before we were called (see vacuum.h)
             */</comment>
            <expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Generate a correlation entry if there are multiple values */</comment>
        <if_stmt><if>if <condition>(<expr><name>values_cnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float4</name>       <modifier>*</modifier></type><name>corrs</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type>        <name>corr_xsum</name></decl>,
                        <decl><type ref="prev"/><name>corr_x2sum</name></decl>;</decl_stmt>

            <comment type="block">/* Must copy the target values into anl_context */</comment>
            <expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>corrs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*----------
             * Since we know the x and y value sets are both
             *        0, 1, ..., values_cnt-1
             * we have sum(x) = sum(y) =
             *        (values_cnt-1)*values_cnt / 2
             * and sum(x^2) = sum(y^2) =
             *        (values_cnt-1)*values_cnt*(2*values_cnt-1) / 6.
             *----------
             */</comment>
            <expr_stmt><expr><name>corr_xsum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator>
                <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>values_cnt</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>corr_x2sum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator>
                <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>values_cnt</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">6.0</literal></expr>;</expr_stmt>

            <comment type="block">/* And the correlation coefficient reduces to */</comment>
            <expr_stmt><expr><name><name>corrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>values_cnt</name> <operator>*</operator> <name>corr_xysum</name> <operator>-</operator> <name>corr_xsum</name> <operator>*</operator> <name>corr_xsum</name><operator>)</operator> <operator>/</operator>
                <operator>(</operator><name>values_cnt</name> <operator>*</operator> <name>corr_x2sum</name> <operator>-</operator> <name>corr_xsum</name> <operator>*</operator> <name>corr_xsum</name><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_CORRELATION</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>corrs</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We found some non-null values, but they were all too wide */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nonnull_cnt</name> <operator>==</operator> <name>toowide_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* Do the simple null-frac and width stats */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <comment type="block">/* Assume all too-wide values are distinct, so it's a unique column */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* "unknown" */</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>    <comment type="block">/* "unknown" */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We don't need to bother cleaning up any of our temporary palloc's */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_arg comparator for sorting ScalarItems
 *
 * Aside from sorting the items, we update the tupnoLink[] array
 * whenever two ScalarItems are found to contain equal datums.  The array
 * is indexed by tupno; for each ScalarItem, it contains the highest
 * tupno that that item's datum has been found to be equal to.  This allows
 * us to avoid additional comparisons in compute_scalar_stats().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_scalars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>da</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ta</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>tupno</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tb</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>tupno</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CompareScalarsContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><operator>(</operator><name>CompareScalarsContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>compare</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ssup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The two datums are equal, so update cxt-&gt;tupnoLink[].
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>ta</name></expr>]</index></name> <operator>&lt;</operator> <name>tb</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>ta</name></expr>]</index></name> <operator>=</operator> <name>tb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>tb</name></expr>]</index></name> <operator>&lt;</operator> <name>ta</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>tb</name></expr>]</index></name> <operator>=</operator> <name>ta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * For equal datums, sort by tupno
     */</comment>
    <return>return <expr><name>ta</name> <operator>-</operator> <name>tb</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting ScalarMCVItems by position
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_mcvs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>da</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>first</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>first</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><name>da</name> <operator>-</operator> <name>db</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * coord_accu_distinct_stat
 *        Accumulate the distinct statistics for the attribute.
 *
 * Three kinds of distinct statistics value should be considered:
 * -1: all the values of the attribute are distinct. Then the relation tuple count is the distinct value;
 * (-1, 0): the ratio of the distinct attribute. Tuble count * (-1) * ratio is the count of distinct value;
 * &gt;=0: the actual count of distinct value. 
 *
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>coord_accu_distinct_stat</name><parameter_list>(<parameter><decl><type><name>float4</name></type> <name>src_dist_value</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>distinct_value</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>rel_tuple</name></decl></parameter>, <parameter><decl><type><name>float4</name> <modifier>*</modifier></type> <name>tar_dist_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>rel_tuple</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>tar_dist_value</name> <operator>=</operator> <name>src_dist_value</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>distinct_value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>tar_dist_value</name> <operator>=</operator> <name>src_dist_value</name> <operator>+</operator> <name>rel_tuple</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>distinct_value</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>distinct_value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>tar_dist_value</name> <operator>=</operator> <name>src_dist_value</name> <operator>+</operator> <name>rel_tuple</name> <operator>*</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>distinct_value</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>tar_dist_value</name> <operator>=</operator> <name>src_dist_value</name> <operator>+</operator> <name>distinct_value</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * coord_calc_distinct_stat
 *        Caculate the distinct statistics for the attribute.
 *
 * We already get the total count of the distinct value. But we must convert the count to the three kinds 
 * of distinct statistics value for further use:
 * 1, If the distinct count equal with tuple count, the final result must be -1.
 * 2, If the the ratio of the distinct value is begger than 0.1, the final result should be -1 * ratio.
 * 3, if the ratio of the distinct value is less than 0.1, the final result is the actual distinct value.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>coord_calc_distinct_stat</name><parameter_list>(<parameter><decl><type><name>float4</name></type> <name>total_dist_value</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>total_tuples</name></decl></parameter>, <parameter><decl><type><name>float4</name> <modifier>*</modifier></type> <name>distinct_result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>float4</name></type> <name>dist_rate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>total_dist_value</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>total_tuples</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>distinct_result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>dist_rate</name> <operator>=</operator> <name>total_dist_value</name> <operator>/</operator> <name>total_tuples</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dist_rate</name> <operator>&lt;</operator> <literal type="number">0.1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>distinct_result</name> <operator>=</operator> <name>total_tuples</name> <operator>*</operator> <name>dist_rate</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>distinct_result</name> <operator>=</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>dist_rate</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * coord_collect_fit_simple_stats
 *        Collect and fit simple stats for a relation (pg_statistic contents).
 *
 * Collects statistics from the datanodes, and then try to fit the recived
 * statistics for each attribute.
 *
 * XXX We try to build statistics covering data from all the nodes, by collecting 
 * fresh sample of rows or merging the statistics somehow. 
 * We try to use the same formula in the single data node to fit the statistics
 * in corordinator. However, for some statistics we cannot fit them without raw
 * data, so we try to pick up the data with more sample.
 * 
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>coord_collect_fit_simple_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attr_cnt</name></decl></parameter>,
                           <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
    <comment type="block">/* Fields to run query to read statistics from data nodes */</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>            <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>     <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>        <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* Number of data nodes from which attribute statistics are received. */</comment>
    <decl_stmt><decl><type><name>int</name>               <modifier>*</modifier></type><name>numnodes</name></decl>;</decl_stmt>

    <comment type="block">/* Number of tuples from which attribute statistics are received. */</comment>
    <decl_stmt><decl><type><name>int</name>            <modifier>*</modifier></type><name>atttuples</name></decl>;</decl_stmt>

    <comment type="block">/* Number of maximum non-null count of each attribute*/</comment>
    <decl_stmt><decl><type><name>int</name>        <modifier>*</modifier></type><name>nonnull_max_count</name></decl>;</decl_stmt>
    
    <comment type="block">/* Get the relation identifier */</comment>
    <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make up query string */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Generic statistic fields */</comment>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT s.staattnum, "</literal>
<comment type="line">// assume the number of tuples approximately the same on all nodes</comment>
<comment type="line">// to build more precise statistics get this number</comment>
                                          <literal type="string">"c.reltuples, "</literal>
                                          <literal type="string">"s.stanullfrac, "</literal>
                                          <literal type="string">"s.stawidth, "</literal>
                                          <literal type="string">"s.stadistinct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Detailed statistic slots */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">", s.stakind%d"</literal>
                                 <literal type="string">", o%d.oprname"</literal>
                                 <literal type="string">", no%d.nspname"</literal>
                                 <literal type="string">", t%dl.typname"</literal>
                                 <literal type="string">", nt%dl.nspname"</literal>
                                 <literal type="string">", t%dr.typname"</literal>
                                 <literal type="string">", nt%dr.nspname"</literal>
                                 <literal type="string">", s.stanumbers%d"</literal>
                                 <literal type="string">", s.stavalues%d"</literal></expr></argument>,
                         <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Common part of FROM clause */</comment>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">" FROM pg_statistic s JOIN pg_class c "</literal>
                                    <literal type="string">"    ON s.starelid = c.oid "</literal>
                                    <literal type="string">"JOIN pg_namespace nc "</literal>
                                    <literal type="string">"    ON c.relnamespace = nc.oid "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Info about involved operations */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"LEFT JOIN (pg_operator o%d "</literal>
                                 <literal type="string">"           JOIN pg_namespace no%d "</literal>
                                 <literal type="string">"               ON o%d.oprnamespace = no%d.oid "</literal>
                                 <literal type="string">"           JOIN pg_type t%dl "</literal>
                                 <literal type="string">"               ON o%d.oprleft = t%dl.oid "</literal>
                                 <literal type="string">"           JOIN pg_namespace nt%dl "</literal>
                                 <literal type="string">"               ON t%dl.typnamespace = nt%dl.oid "</literal>
                                 <literal type="string">"           JOIN pg_type t%dr "</literal>
                                 <literal type="string">"               ON o%d.oprright = t%dr.oid "</literal>
                                 <literal type="string">"           JOIN pg_namespace nt%dr "</literal>
                                 <literal type="string">"               ON t%dr.typnamespace = nt%dr.oid) "</literal>
                                 <literal type="string">"    ON s.staop%d = o%d.oid "</literal></expr></argument>,
                         <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                         <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"WHERE nc.nspname = '%s' "</literal>
                              <literal type="string">"AND c.relname = '%s'"</literal></expr></argument>,
                     <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build up RemoteQuery */</comment>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>query</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>

    <comment type="block">/* Add targetlist entries */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"staattnum"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_class"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"reltuples"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stanullfrac"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stawidth"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stadistinct"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* 16 characters would be enough */</comment>
        <decl_stmt><decl><type><name>char</name></type>     <name><name>colname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"stakind%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                               <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>OperatorRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_operator"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"oprname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_namespace"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_type"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"typname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_namespace"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_type"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"typname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_namespace"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"stanumbers%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                               <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"stavalues%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                               <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Execute query on the data nodes */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Take a fresh snapshot so that we see the effects of the ANALYZE command
     * on the datanode. That command is run in auto-commit mode hence just
     * bumping up the command ID is not good enough
     */</comment>
    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get ready to combine results */</comment>
    <expr_stmt><expr><name>numnodes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>   
        <expr_stmt><expr><name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>               
    </block_content>}</block></for>

    <expr_stmt><expr><name>atttuples</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nonnull_max_count</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>   
        <expr_stmt><expr><name><name>atttuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nonnull_max_count</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>             <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>             <name>colnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>            <name>attnum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float4</name></type>            <name>reltuples</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float4</name></type>            <name>nullfrac</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>             <name>width</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float4</name></type>            <name>distinct</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VacAttrStats</name>   <modifier>*</modifier></type><name>stats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


        <comment type="block">/* Process statistics from the data node */</comment>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* staattnum */</comment>
        <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name>attnum</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>stats</name> <operator>=</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt></block_content></block></for>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* reltuples */</comment>
        <expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Record the total tuple number for each attribute */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>atttuples</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>atttuples</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>reltuples</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>atttuples</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>stats</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stanullfrac */</comment>
            <expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>+=</operator> <name>nullfrac</name> <operator>*</operator> <name>reltuples</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>reltuples</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>nullfrac</name><operator>)</operator> <operator>&gt;</operator> <name><name>nonnull_max_count</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>nonnull_max_count</name><index>[<expr><name>attnum</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>reltuples</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>nullfrac</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stawidth */</comment>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>+=</operator> <name>width</name> <operator>*</operator> <name>reltuples</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>nullfrac</name><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stadistinct */</comment>
            <expr_stmt><expr><name>distinct</name> <operator>=</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>coord_accu_distinct_stat</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>, <argument><expr><name>distinct</name></expr></argument>, <argument><expr><name>reltuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Detailed statistics */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int16</name></type>         <name>kind</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>float4</name>       <modifier>*</modifier></type><name>numbers</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nnumbers</name></decl>, <decl><type ref="prev"/><name>nvalues</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>         <name>k</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* kind */</comment>
                <expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Empty slot - skip next 8 fields: 6 fields of the
                     * operation identifier and two data fields (numbers and
                     * values)
                     */</comment>
                    <expr_stmt><expr><name>colnum</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>oprid</name></decl>;</decl_stmt>

                    <comment type="block">/* Get operator */</comment>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* oprname */</comment>
                    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Operator is not specified for that kind, skip remaining
                         * fields to lookup the operator
                         */</comment>
                        <expr_stmt><expr><name>oprid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>colnum</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt> <comment type="block">/* skip operation nsp and types */</comment>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprnspname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Oid</name></type>            <name>ltypid</name></decl>, <decl><type ref="prev"/><name>rtypid</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ltypname</name></decl>,
                                   <decl><type ref="prev"><modifier>*</modifier></type><name>rtypname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ltypnspname</name></decl>,
                                   <decl><type ref="prev"><modifier>*</modifier></type><name>rtypnspname</name></decl>;</decl_stmt>
                        <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* oprnspname */</comment>
                        <expr_stmt><expr><name>oprnspname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Get left operand data type */</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typname */</comment>
                        <expr_stmt><expr><name>ltypname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typnspname */</comment>
                        <expr_stmt><expr><name>ltypnspname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ltypid</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>ltypname</name></expr></argument>,
                                               <argument><expr><call><name>get_namespaceid</name><argument_list>(<argument><expr><name>ltypnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Get right operand data type */</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typname */</comment>
                        <expr_stmt><expr><name>rtypname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typnspname */</comment>
                        <expr_stmt><expr><name>rtypnspname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>rtypid</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rtypname</name></expr></argument>,
                                               <argument><expr><call><name>get_namespaceid</name><argument_list>(<argument><expr><name>rtypnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* lookup operator */</comment>
                        <expr_stmt><expr><name>oprid</name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>, <argument><expr><name>ltypid</name></expr></argument>, <argument><expr><name>rtypid</name></expr></argument>,
                                           <argument><expr><call><name>get_namespaceid</name><argument_list>(<argument><expr><name>oprnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <comment type="block">/*
                     * Look up a statistics slot. If there is an entry of the
                     * same kind already, leave it, assuming the statistics
                     * is approximately the same on all nodes, so values from
                     * one node are representing entire relation well.
                     * If empty slot is found store values here. If no more
                     * slots skip remaining values.
                     */</comment>
                    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                                <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name>kind</name> <operator>&amp;&amp;</operator> <name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name>oprid</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                    </block_content>}</block></for>

                    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* No empty slots */</comment>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * If it is an existing slot which has numbers or values
                     * continue to the next set. If slot exists but without
                     * numbers and values, try to acquire them now
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                            <name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>reltuples</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>nullfrac</name><operator>)</operator> <operator>&lt;</operator> <name><name>nonnull_max_count</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                           <block>{<block_content>
                            <expr_stmt><expr><name>colnum</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* skip numbers and values */</comment>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * Initialize slot
                     */</comment>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>oprid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>


                <comment type="block">/* get numbers */</comment>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* numbers */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * We expect the array to be a 1-D float4 array; verify that. We don't
                     * need to use deconstruct_array() since the array data is just going
                     * to look like a C array of float4 values.
                     */</comment>
                    <expr_stmt><expr><name>nnumbers</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>nnumbers</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
                        <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stanumbers is not a 1-D float4 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>numbers</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nnumbers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>numbers</name></expr></argument>, <argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>nnumbers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Free arry if it's a detoasted copy.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>arry</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>nnumbers</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>numbers</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* get values */</comment>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* values */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>         <name>j</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int16</name></type>        <name>elmlen</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>elmbyval</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name></type>        <name>elmalign</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* We could cache this data, but not clear it's worth it */</comment>
                    <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Deconstruct array into Datum elements; NULLs not expected */</comment>
                    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arry</name></expr></argument>,
                                      <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>values</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If the element type is pass-by-reference, we now have a bunch of
                     * Datums that are pointers into the syscache value.  Copy them to
                     * avoid problems if syscache decides to drop the entry.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>elmbyval</name></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nvalues</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * Free statarray if it's a detoasted copy.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>arry</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>nvalues</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
                    <comment type="block">/* store details about values data type */</comment>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>elmlen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>elmalign</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>elmbyval</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* fetch next */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>/=</operator> <name><name>atttuples</name><index>[<expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>/=</operator> <name><name>atttuples</name><index>[<expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>coord_calc_distinct_stat</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>, <argument><expr><name><name>atttuples</name><index>[<expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inh</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * coord_collect_simple_stats
 *        Collect simple stats for a relation (pg_statistic contents).
 *
 * Collects statistics from the datanodes, and then keeps the one of the
 * received statistics for each attribute (the first one we receive, but
 * it's mostly random).
 *
 * XXX We do not try to build statistics covering data fro all the nodes,
 * either by collecting fresh sample of rows or merging the statistics
 * somehow. The current approach is very simple and cheap, but may have
 * negative impact on estimate accuracy as the stats only covers data
 * from a single node, and we may end up with stats from different node
 * for each attribute.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>coord_collect_simple_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attr_cnt</name></decl></parameter>,
                           <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
    <comment type="block">/* Fields to run query to read statistics from data nodes */</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>            <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>     <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>        <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* Number of data nodes from which attribute statistics are received. */</comment>
    <decl_stmt><decl><type><name>int</name>               <modifier>*</modifier></type><name>numnodes</name></decl>;</decl_stmt>

    <comment type="block">/* Get the relation identifier */</comment>
    <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make up query string */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Generic statistic fields */</comment>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT s.staattnum, "</literal>
<comment type="line">// assume the number of tuples approximately the same on all nodes</comment>
<comment type="line">// to build more precise statistics get this number</comment>
<comment type="line">//                                          "c.reltuples, "</comment>
                                          <literal type="string">"s.stanullfrac, "</literal>
                                          <literal type="string">"s.stawidth, "</literal>
                                          <literal type="string">"s.stadistinct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Detailed statistic slots */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">", s.stakind%d"</literal>
                                 <literal type="string">", o%d.oprname"</literal>
                                 <literal type="string">", no%d.nspname"</literal>
                                 <literal type="string">", t%dl.typname"</literal>
                                 <literal type="string">", nt%dl.nspname"</literal>
                                 <literal type="string">", t%dr.typname"</literal>
                                 <literal type="string">", nt%dr.nspname"</literal>
                                 <literal type="string">", s.stanumbers%d"</literal>
                                 <literal type="string">", s.stavalues%d"</literal></expr></argument>,
                         <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* Common part of FROM clause */</comment>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">" FROM pg_statistic s JOIN pg_class c "</literal>
                                    <literal type="string">"    ON s.starelid = c.oid "</literal>
                                    <literal type="string">"JOIN pg_namespace nc "</literal>
                                    <literal type="string">"    ON c.relnamespace = nc.oid "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Info about involved operations */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"LEFT JOIN (pg_operator o%d "</literal>
                                 <literal type="string">"           JOIN pg_namespace no%d "</literal>
                                 <literal type="string">"               ON o%d.oprnamespace = no%d.oid "</literal>
                                 <literal type="string">"           JOIN pg_type t%dl "</literal>
                                 <literal type="string">"               ON o%d.oprleft = t%dl.oid "</literal>
                                 <literal type="string">"           JOIN pg_namespace nt%dl "</literal>
                                 <literal type="string">"               ON t%dl.typnamespace = nt%dl.oid "</literal>
                                 <literal type="string">"           JOIN pg_type t%dr "</literal>
                                 <literal type="string">"               ON o%d.oprright = t%dr.oid "</literal>
                                 <literal type="string">"           JOIN pg_namespace nt%dr "</literal>
                                 <literal type="string">"               ON t%dr.typnamespace = nt%dr.oid) "</literal>
                                 <literal type="string">"    ON s.staop%d = o%d.oid "</literal></expr></argument>,
                         <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                         <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"WHERE nc.nspname = '%s' "</literal>
                              <literal type="string">"AND c.relname = '%s'"</literal></expr></argument>,
                     <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build up RemoteQuery */</comment>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>query</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>

    <comment type="block">/* Add targetlist entries */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"staattnum"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//    step-&gt;scan.plan.targetlist = lappend(step-&gt;scan.plan.targetlist,</comment>
<comment type="line">//                                         make_relation_tle(RelationRelationId,</comment>
<comment type="line">//                                                           "pg_class",</comment>
<comment type="line">//                                                           "reltuples"));</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stanullfrac"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stawidth"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stadistinct"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* 16 characters would be enough */</comment>
        <decl_stmt><decl><type><name>char</name></type>     <name><name>colname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"stakind%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                               <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>OperatorRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_operator"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"oprname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_namespace"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_type"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"typname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_namespace"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_type"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"typname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_namespace"</literal></expr></argument>,
                                                               <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"stanumbers%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                               <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"stavalues%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                             <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>,
                                                               <argument><expr><literal type="string">"pg_statistic"</literal></expr></argument>,
                                                               <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Execute query on the data nodes */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Take a fresh snapshot so that we see the effects of the ANALYZE command
     * on the datanode. That command is run in auto-commit mode hence just
     * bumping up the command ID is not good enough
     */</comment>
    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get ready to combine results */</comment>
    <expr_stmt><expr><name>numnodes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>             <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>             <name>colnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>            <name>attnum</name></decl>;</decl_stmt>
<comment type="line">//        float4            reltuples;</comment>
        <decl_stmt><decl><type><name>float4</name></type>            <name>nullfrac</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>             <name>width</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float4</name></type>            <name>distinct</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VacAttrStats</name>   <modifier>*</modifier></type><name>stats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


        <comment type="block">/* Process statistics from the data node */</comment>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* staattnum */</comment>
        <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>        
            <if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name>attnum</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>stats</name> <operator>=</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt></block_content></block></for>

<comment type="line">//        value = slot_getattr(result, colnum++, &amp;isnull); /* reltuples */</comment>
<comment type="line">//        reltuples = DatumGetFloat4(value);</comment>

        <if_stmt><if>if <condition>(<expr><name>stats</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stanullfrac */</comment>
            <expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>+=</operator> <name>nullfrac</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stawidth */</comment>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>+=</operator> <name>width</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stadistinct */</comment>
            <expr_stmt><expr><name>distinct</name> <operator>=</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>+=</operator> <name>distinct</name></expr>;</expr_stmt>

            <comment type="block">/* Detailed statistics */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int16</name></type>         <name>kind</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>float4</name>       <modifier>*</modifier></type><name>numbers</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nnumbers</name></decl>, <decl><type ref="prev"/><name>nvalues</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>         <name>k</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* kind */</comment>
                <expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Empty slot - skip next 8 fields: 6 fields of the
                     * operation identifier and two data fields (numbers and
                     * values)
                     */</comment>
                    <expr_stmt><expr><name>colnum</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>oprid</name></decl>;</decl_stmt>

                    <comment type="block">/* Get operator */</comment>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* oprname */</comment>
                    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Operator is not specified for that kind, skip remaining
                         * fields to lookup the operator
                         */</comment>
                        <expr_stmt><expr><name>oprid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>colnum</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt> <comment type="block">/* skip operation nsp and types */</comment>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprnspname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Oid</name></type>            <name>ltypid</name></decl>, <decl><type ref="prev"/><name>rtypid</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ltypname</name></decl>,
                                   <decl><type ref="prev"><modifier>*</modifier></type><name>rtypname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ltypnspname</name></decl>,
                                   <decl><type ref="prev"><modifier>*</modifier></type><name>rtypnspname</name></decl>;</decl_stmt>
                        <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* oprnspname */</comment>
                        <expr_stmt><expr><name>oprnspname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Get left operand data type */</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typname */</comment>
                        <expr_stmt><expr><name>ltypname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typnspname */</comment>
                        <expr_stmt><expr><name>ltypnspname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ltypid</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>ltypname</name></expr></argument>,
                                               <argument><expr><call><name>get_namespaceid</name><argument_list>(<argument><expr><name>ltypnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Get right operand data type */</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typname */</comment>
                        <expr_stmt><expr><name>rtypname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typnspname */</comment>
                        <expr_stmt><expr><name>rtypnspname</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>rtypid</name> <operator>=</operator> <call><name>get_typname_typid</name><argument_list>(<argument><expr><name>rtypname</name></expr></argument>,
                                               <argument><expr><call><name>get_namespaceid</name><argument_list>(<argument><expr><name>rtypnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* lookup operator */</comment>
                        <expr_stmt><expr><name>oprid</name> <operator>=</operator> <call><name>get_operid</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>, <argument><expr><name>ltypid</name></expr></argument>, <argument><expr><name>rtypid</name></expr></argument>,
                                           <argument><expr><call><name>get_namespaceid</name><argument_list>(<argument><expr><name>oprnspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <comment type="block">/*
                     * Look up a statistics slot. If there is an entry of the
                     * same kind already, leave it, assuming the statistics
                     * is approximately the same on all nodes, so values from
                     * one node are representing entire relation well.
                     * If empty slot is found store values here. If no more
                     * slots skip remaining values.
                     */</comment>
                    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                                <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name>kind</name> <operator>&amp;&amp;</operator> <name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name>oprid</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                    </block_content>}</block></for>

                    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* No empty slots */</comment>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * If it is an existing slot which has numbers or values
                     * continue to the next set. If slot exists but without
                     * numbers and values, try to acquire them now
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                            <name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>colnum</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* skip numbers and values */</comment>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * Initialize slot
                     */</comment>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>oprid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>


                <comment type="block">/* get numbers */</comment>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* numbers */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * We expect the array to be a 1-D float4 array; verify that. We don't
                     * need to use deconstruct_array() since the array data is just going
                     * to look like a C array of float4 values.
                     */</comment>
                    <expr_stmt><expr><name>nnumbers</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>nnumbers</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
                        <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call> <operator>||</operator>
                        <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stanumbers is not a 1-D float4 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>numbers</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nnumbers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>numbers</name></expr></argument>, <argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>nnumbers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Free arry if it's a detoasted copy.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>arry</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>nnumbers</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>numbers</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* get values */</comment>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>colnum</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* values */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>         <name>j</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int16</name></type>        <name>elmlen</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>elmbyval</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name></type>        <name>elmalign</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* We could cache this data, but not clear it's worth it */</comment>
                    <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Deconstruct array into Datum elements; NULLs not expected */</comment>
                    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arry</name></expr></argument>,
                                      <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>values</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If the element type is pass-by-reference, we now have a bunch of
                     * Datums that are pointers into the syscache value.  Copy them to
                     * avoid problems if syscache decides to drop the entry.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>elmbyval</name></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nvalues</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * Free statarray if it's a detoasted copy.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>arry</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>nvalues</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
                    <comment type="block">/* store details about values data type */</comment>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>elmlen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>elmalign</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>elmbyval</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* fetch next */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>/=</operator> <name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>/=</operator> <name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>/=</operator> <name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inh</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * coord_collect_extended_stats
 *        Collect extended stats for a relation (pg_statistic_ext contents).
 *
 * Collects statistics from the datanodes, and then keeps the one of the
 * received statistics for each attribute (the first one we receive, but
 * it's mostly random).
 *
 * XXX This has similar issues as coord_collect_simple_stats.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>coord_collect_extended_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attr_cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
    <comment type="block">/* Fields to run query to read statistics from data nodes */</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>            <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>     <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>        <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* Number of data nodes from which attribute statistics are received. */</comment>
    <decl_stmt><decl><type><name>int</name>               <modifier>*</modifier></type><name>numnodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>           <modifier>*</modifier></type><name>stat_oids</name></decl>;</decl_stmt>

    <comment type="block">/* Get the relation identifier */</comment>
    <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build extended statistics on the coordinator.
     *
     * We take an approach similar to the simple per-attribute stats by
     * fetching the already-built extended statistics, and pick data
     * from a random datanode on the assumption that the datanodes are
     * fairly similar in terms of data volume and distribution.
     *
     * That seems to be working fairly well, although there are likely
     * some weaknesses too - e.g. on distribution keys it may easily
     * neglect large portions of the data.
     */</comment>

    <comment type="block">/* Make up query string fetching data from pg_statistic_ext */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT ns.nspname, "</literal>
                                    <literal type="string">"stxname, "</literal>
                                    <literal type="string">"stxndistinct::bytea AS stxndistinct, "</literal>
                                    <literal type="string">"stxdependencies::bytea AS stxdependencies "</literal>
                                <literal type="string">" FROM pg_statistic_ext s JOIN pg_class c "</literal>
                                <literal type="string">"    ON s.stxrelid = c.oid "</literal>
                                <literal type="string">"JOIN pg_namespace nc "</literal>
                                <literal type="string">"    ON c.relnamespace = nc.oid "</literal>
                                <literal type="string">"JOIN pg_namespace ns "</literal>
                                <literal type="string">"    ON s.stxnamespace = ns.oid "</literal>
                                <literal type="string">"WHERE nc.nspname = '%s' AND c.relname = '%s'"</literal></expr></argument>,
                    <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build up RemoteQuery */</comment>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>query</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>

    <comment type="block">/* Add targetlist entries */</comment>
    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_namespace"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic_ext"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stxname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic_ext"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stxndistinct"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                         <argument><expr><call><name>make_relation_tle</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>,
                                                           <argument><expr><literal type="string">"pg_statistic_ext"</literal></expr></argument>,
                                                           <argument><expr><literal type="string">"stxdependencies"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Execute query on the data nodes */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Take a fresh snapshot so that we see the effects of the ANALYZE
     * command on datanodes. That command is run in auto-commit mode
     * hence just bumping up the command ID is not good enough.
     */</comment>
    <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get ready to combine results */</comment>
    <expr_stmt><expr><name>numnodes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>numnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We only want to update each statistics once, as we'd get errors
     * about self-updated tuples otherwise. So keep a list of OIDs for
     * stats we already updated, and check before each update.
     */</comment>
    <expr_stmt><expr><name>stat_oids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>             <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Name</name></type>            <name>nspname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Name</name></type>            <name>stxname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bytea</name>           <modifier>*</modifier></type><name>stxndistinct</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bytea</name>           <modifier>*</modifier></type><name>stxdependencies</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>HeapTuple</name></type>        <name>htup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>                <name>nspoid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>                <name>stat_oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name>updated</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>       <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        
        <comment type="block">/* Process statistics from the data node */</comment>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* nspname */</comment>
        <expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>DatumGetName</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stxname */</comment>
        <expr_stmt><expr><name>stxname</name> <operator>=</operator> <call><name>DatumGetName</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stxndistinct */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>stxndistinct</name> <operator>=</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stxdependencies */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>stxdependencies</name> <operator>=</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>nspoid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* get OID of the statistics */</comment>
        <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>STATEXTNAMENSP</name></expr></argument>,
                               <argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><name>stxname</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							   
		<comment type="block">/* if relation is already dropped */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>htup</name></expr>)</condition>
        <block>{<block_content>
		    <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>stat_oid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* see if we already updated this pg_statistic_ext tuple */</comment>
        <expr_stmt><expr><name>updated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stat_oids</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type> <name>oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>stat_oid</name> <operator>==</operator> <name>oid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>updated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <comment type="block">/* if not, update it (with all the available data) */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>updated</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>update_ext_stats</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>stxname</name></expr></argument>, <argument><expr><name>stxndistinct</name></expr></argument>, <argument><expr><name>stxdependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>stat_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>stat_oids</name></expr></argument>, <argument><expr><name>stat_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* fetch stats from next node */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * analyze_rel_coordinator
 *        Collect all statistics for a particular relation.
 *
 * We collect three types of statistics for each table:
 *
 * - simple statistics (pg_statistic)
 * - extended statistics (pg_statistic_ext)
 * - index statistics (including expression indexes)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>analyze_rel_coordinator</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attr_cnt</name></decl></parameter>,
                        <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
                        <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>indexes</name></decl></parameter>, <parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>random_collect_stats</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* simple statistics (pg_statistic) for the relation */</comment>
        <expr_stmt><expr><call><name>coord_collect_simple_stats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>inh</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* simple statistics (pg_statistic) for all indexes */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>coord_collect_simple_stats</name><argument_list>(<argument><expr><name><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                       <argument><expr><name><name>indexdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attr_cnt</name></expr></argument>,
                                       <argument><expr><name><name>indexdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>    
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* collect and fit simple statistics (pg_statistic) for the relation */</comment>
        <expr_stmt><expr><call><name>coord_collect_fit_simple_stats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>inh</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* collect and fit simple statistics (pg_statistic) for all indexes */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>coord_collect_fit_simple_stats</name><argument_list>(<argument><expr><name><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                       <argument><expr><name><name>indexdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attr_cnt</name></expr></argument>,
                                       <argument><expr><name><name>indexdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>        
    </block_content>}</block></else></if_stmt>


    <comment type="block">/* extended statistics (pg_statistic) for the relation */</comment>
    <expr_stmt><expr><call><name>coord_collect_extended_stats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>Size</name></type>
<name>QueryAnalyzeInfoShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryInfoList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>MAX_DISTRIBUTED_QUERIES</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AnalyzeInfoEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>QueryAnalyzeInfoInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>distributed_query_info</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Distributed QueryInfo List"</literal></expr></argument>,
                                                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryInfoList</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>distributed_query_info</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_DISTRIBUTED_QUERIES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name> <operator>=</operator> <name>MAX_DISTRIBUTED_QUERIES</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>AnalyzeInfoHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASHCTL</name></type> <name>ctl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>        <name>flags</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>QUERY_SIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AnalyzeInfoEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FIXED_SIZE</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>AnalyzeInfoHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Analyze QueryInfo"</literal></expr></argument>, <argument><expr><name>MAX_DISTRIBUTED_QUERIES</name></expr></argument>,
                                         <argument><expr><name>MAX_DISTRIBUTED_QUERIES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>distributed_query_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>StoreQueryAnalyzeInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>plan</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* query string is too long, skip */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>QUERY_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* store query info */</comment>
        <expr_stmt><expr><name>plannedstmt</name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* plan is too long, skip */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PLAN_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>QueryInfoListIndex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"StoreQueryAnalyzeInfo: unexpected query list index %d"</literal></expr></argument>, <argument><expr><name>QueryInfoListIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
                
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name> <operator>&gt;</operator> <name>MAX_DISTRIBUTED_QUERIES</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
            <name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"StoreQueryAnalyzeInfo: analyze query list corrupted, freeindex %d"</literal></expr></argument>,
                         <argument><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name><operator>--</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>QueryInfoListIndex</name> <operator>=</operator> <name><name>distributed_query_info</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>QueryInfoListIndex</name></expr>]</index></name><operator>.</operator><name>query</name></expr></argument>, <argument><expr><name>QUERY_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>QueryInfoListIndex</name></expr>]</index></name><operator>.</operator><name>plan</name></expr></argument>, <argument><expr><name>PLAN_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>QueryInfoListIndex</name></expr>]</index></name><operator>.</operator><name><name>info</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AnalyzeInfoEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>plan</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>QUERY_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* store query info */</comment>
        <expr_stmt><expr><name>plannedstmt</name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>
        

        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* plan is too long, skip */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PLAN_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>AnalyzeInfoEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>AnalyzeInfoHash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>PLAN_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DropQueryAnalyzeInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>QueryInfoListIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>QueryInfoListIndex</name> <operator>&lt;</operator> <name>MAX_DISTRIBUTED_QUERIES</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name> <operator>&gt;=</operator> <name>MAX_DISTRIBUTED_QUERIES</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
                <name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"DropQueryAnalyzeInfo: analyze query list corrupted, freeindex %d"</literal></expr></argument>,
                             <argument><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name><operator>++</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>QueryInfoListIndex</name></expr>]</index></name><operator>.</operator><name><name>info</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>freeindex</name></name></expr>]</index></name> <operator>=</operator> <name>QueryInfoListIndex</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>QueryInfoListIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>QueryInfoListIndex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"DropQueryAnalyzeInfo: unexpected query list index %d"</literal></expr></argument>, <argument><expr><name>QueryInfoListIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AnalyzeInfoEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>QUERY_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>AnalyzeInfoEntry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>AnalyzeInfoHash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>FetchQueryAnalyzeInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>distributed_query_info</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>info</name><operator>.</operator><name>pid</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>distributed_query_info</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AnalyzeInfoEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>QUERY_SIZE</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>AnalyzeInfoEntry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>AnalyzeInfoHash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ent</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AnalyzeInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>AnalyzeInfo</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>pid</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AnalyzeInfoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AnalyzeInfoEntry</name> <modifier>*</modifier></type>
<name>FetchAllQueryAnalyzeInfo</name><parameter_list>(<parameter><decl><type><name>HASH_SEQ_STATUS</name> <modifier>*</modifier></type><name>status</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>AnalyzeInfoHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>AnalyzeInfoEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>AnalyzeInfoEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>ent</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ClearQueryAnalyzeInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>QueryInfoListIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>QueryInfoListIndex</name> <operator>&lt;</operator> <name>MAX_DISTRIBUTED_QUERIES</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>DropQueryAnalyzeInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetAnalyzeInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_LEN</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>analyze_attr_num</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>query</name><index>[<expr><name>QUERY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfo</name></type> <name>info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>                <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>        <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>         <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name>    <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name>        <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Var</name>                 <modifier>*</modifier></type><name>dummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type><name><name>attrname</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"Pid"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>key</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GetAnalyzeInfo:query info is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_LEN</name></expr></argument>, <argument><expr><literal type="string">"select pid::text from tbase_get_analyze_info('%s')"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_NONE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>query</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/*
     * We only need the target entry to determine result data type.
     * So create dummy even if real expression is a function.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>analyze_attr_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                          <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* prepare to execute */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

        <expr_stmt><expr><name>tups</name><operator>++</operator></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>info</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>analyze_attr_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<comment type="block">/*
            if (i &gt; 1)
            {
                appendStringInfo(info, ", %s:%s", attrname[i], value);
            }
            else
*/</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name><name>attrname</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></for>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>tups</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"got more than one tuple of analyze info for query %s"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>info</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> 
<name>get_rel_pages_visiblepages</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>,
						   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, 
						   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>visiblepages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>||</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>childs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>lc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>childs</name> <operator>=</operator> <call><name>RelationGetAllPartitions</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
			<expr_stmt><expr><name>childs</name> <operator>=</operator>
				<call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>visiblepages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>childs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>visible</name></decl>;</decl_stmt>

			<comment type="block">/* We already got the needed lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Ignore if temp table of another backend */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ... but release the lock on it */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Check table type (MATVIEW can't happen, but might as well allow) */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
				<name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>+=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>visibilitymap_count</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visible</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>visiblepages</name> <operator>+=</operator> <name>visible</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>childs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_count</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>visiblepages</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAMPLE_ATTR_NUM</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>ExecSample</name><parameter_list>(<parameter><decl><type><name>SampleStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>Oid</name></type>			 <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	 <name>onerel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> 	 <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	 <name>rowdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name> 	<modifier>*</modifier></type><name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		 <name>targetrows</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>rownum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SampleRowsContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		 <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		 <name><name>nulls</name><index>[<expr><name>SAMPLE_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> 		 <name><name>values</name><index>[<expr><name>SAMPLE_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SAMPLE only support on Coordinator or Datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rownum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SAMPLE row number must larger than 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check permissions --- this should match vacuum's check!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		  <operator>(</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Permission denied for ownership"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Silently ignore tables that are temp tables of other backends ---
	 * trying to analyze these is rather pointless, since their contents are
	 * probably not up-to-date on disk.  (We don't throw a warning here; it
	 * would just lead to chatter during a database-wide ANALYZE.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SAMPLE do not suppport temp table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can ANALYZE any table except pg_statistic. See update_attstats
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>StatisticRelationId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SAMPLE do not support pg_statistic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check that it's a plain table, materialized view */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SAMPLE only support Tables or Materialized Views"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>

	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rowdesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rows</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>targetrows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <operator>(</operator><name>SampleRowsContext</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SampleRowsContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize acquire sample rows */</comment>
	<if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>&amp;&amp;</operator> 
		<operator>!</operator><call><name>RELATION_IS_COORDINATOR_LOCAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>samplenum</name></name> <operator>=</operator> <call><name>acquire_coordinator_sample_rows</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>,
 														   <argument><expr><name>rows</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rownum</name></name></expr></argument>, 
 														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>totalnum</name></name></expr></argument>, 
 														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>deadnum</name></name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>totalpages</name></name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>visiblepages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>get_rel_pages_visiblepages</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>relallvisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>totalpages</name></name> <operator>=</operator> <name>relpages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>visiblepages</name></name> <operator>=</operator> <name>relallvisible</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>||</operator> <call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>samplenum</name></name> <operator>=</operator> <call><name>acquire_inherited_sample_rows</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>, 
	 														   <argument><expr><name>rows</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rownum</name></name></expr></argument>, 
	 														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>totalnum</name></name></expr></argument>, 
	 														   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>deadnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 	</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>samplenum</name></name> <operator>=</operator> <call><name>acquire_sample_rows</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>, 
													 <argument><expr><name>rows</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rownum</name></name></expr></argument>, 
													 <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>totalnum</name></name></expr></argument>, 
													 <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>deadnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>SAMPLE_ATTR_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"samplenum"</literal></expr></argument>,
					   <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"totalnum"</literal></expr></argument>,
					   <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"deadnum"</literal></expr></argument>,
					   <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"totalpages"</literal></expr></argument>,
					   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"visiblepages"</literal></expr></argument>,
					   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"rows"</literal></expr></argument>,
					   <argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>samplenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>totalnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>deadnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>totalpages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>visiblepages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>samplenum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>samplenum</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>heap_copy_tuple_as_datum</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rows</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>rowdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>acquire_coordinator_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
												<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
												<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>,
												<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>totalpages</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>visiblepages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<comment type="block">/* Fields to run query to read statistics from data nodes */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>		   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQuery</name> 	<modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rellocinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>isreplica</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>			   <modifier>*</modifier></type><name>dummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>samplenum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>totalnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>deadnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>samplerows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>rowstoskip</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* -1 means not set yet */</comment>
	<decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>			<name>totalpagesnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>			<name>visiblepagesnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get the relation identifier */</comment>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rellocinfo</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>isreplica</name> <operator>=</operator> <call><name>IsRelationReplicated</name><argument_list>(<argument><expr><name>rellocinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make up query string */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SAMPLE %s(%d)"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SAMPLE %s.%s(%d)"</literal></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Build up RemoteQuery */</comment>
	<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isreplica</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>rellocinfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name><name>rellocinfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>query</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										 <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"samplenum"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										 <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"totalnum"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										 <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"deadnum"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										 <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"totalpages"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										 <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"visiblepages"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										 <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"rows"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * ANALYZE has known it's result slot desc, should
	 * ignore received one to avoid duplicate name issue
	 */</comment>
	<expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>ignore_tuple_desc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Execute query on the data nodes */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ExecInitRemoteQuery</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for sampling rows */</comment>
	<expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<while>while <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>samplenum</name> <operator>+=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>totalnum</name> <operator>+=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>deadnum</name> <operator>+=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>totalpagesnum</name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>visiblepagesnum</name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&lt;</operator> <name>targrows</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name> <init>= <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

				<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
				<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

				<comment type="block">/* Build a copy and return it */</comment>
				<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
					* t in Vitter's paper is the number of records already
					* processed.  If we need to compute a new S value, we
					* must use the not-yet-incremented value of samplerows as
					* t.
					*/</comment>
				<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rowstoskip</name> <operator>=</operator> <call><name>reservoir_get_next_S</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
						* Found a suitable tuple, so save it, replacing one
						* old tuple at random
						*/</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name> <init>= <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

					<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
					<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>rowstoskip</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>samplerows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecEndRemoteQuery</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <name>totalnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <name>deadnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totalpages</name> <operator>=</operator> <name>totalpagesnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>visiblepages</name> <operator>=</operator> <name>visiblepagesnum</name></expr>;</expr_stmt>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
