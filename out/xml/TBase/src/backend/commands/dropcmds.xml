<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/dropcmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dropcmds.c
 *      handle various "DROP" operations
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/catalog/dropcmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaddress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>,
						<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>owningrel_does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>schema_does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>type_in_list_does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>typenames</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Check object exists or not before remove.
 */</comment>
<function><type><name>ObjectAddresses</name><modifier>*</modifier></type> <name>PreCheckforRemoveObjects</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>,
										<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_drop</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>need_unlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>querystring_omit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>need_drop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell1</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>namespaceId</name></decl>;</decl_stmt>

        <comment type="block">/* Get an ObjectAddress for the object. */</comment>
        <expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>,
                                     <argument><expr><name>object</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>,
                                     <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
                                     <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Issue NOTICE if supplied object was not found.  Note this is only
         * relevant in the missing_ok case, because otherwise
         * get_object_address would have thrown an error.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relation_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>query_string</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>querystring_omit</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>OmitqueryStringSpace</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>querystring_omit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>relation_name</name> <operator>=</operator> <call><name>GetRemoveObjectName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>RemoveObjnameInQueryString</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>relation_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* could not drop trigger on child partition */</comment>
        <if_stmt><if>if <condition>(<expr><name>OBJECT_TRIGGER</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>&amp;&amp;</operator> <name>relation</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"drop trigger on child interval partition is not permitted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Although COMMENT ON FUNCTION, SECURITY LABEL ON FUNCTION, etc. are
         * happy to operate on an aggregate as on any other function, we have
         * historically not allowed this for DROP FUNCTION.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_FUNCTION</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>funcOid</name> <init>= <expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proisagg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is an aggregate function"</literal></expr></argument>,
                                <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>objname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use DROP AGGREGATE to drop aggregate functions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check permissions. */</comment>
        <expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_object_namespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>pg_namespace_ownercheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>check_object_ownership</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>, <argument><expr><name>address</name></expr></argument>,
                                   <argument><expr><name>object</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Release any relcache reference count, but keep lock until commit. */</comment>
        <if_stmt><if>if <condition>(<expr><name>relation</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>OBJECT_SCHEMA</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>true</name> <operator>==</operator> <call><name>mls_check_schema_permission</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not drop schema, cause there are tables having crypt poilcy bound in this schema or schema has crypt bound"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not drop schema oid:%d, cause there are tables having crypt poilcy bound in this schema or schema has crypt bound"</literal></expr></argument>, 
                        <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><operator>*</operator><name>need_drop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_unlock</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            	<expr_stmt><expr><call><name>UnlockSharedObject</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockDatabaseObject</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>objects</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop one or more objects.
 *
 * We don't currently handle all object types here.  Relations, for example,
 * require special handling, because (for example) indexes have additional
 * locking requirements.
 *
 * We look up all the objects first, and then delete them in a single
 * performMultipleDeletions() call.  This avoids unnecessary DROP RESTRICT
 * errors if there are dependencies between them.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveObjects</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_drop</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
        
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>PreCheckforRemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>, <argument><expr><name>need_drop</name></expr></argument>,
										<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Here we really delete them. */</comment>
    <expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * owningrel_does_not_exist_skipping
 *        Subroutine for RemoveObjects
 *
 * After determining that a specification for a rule or trigger returns that
 * the specified object does not exist, test whether its owning relation, and
 * its schema, exist or not; if they do, return false --- the trigger or rule
 * itself is missing instead.  If the owning relation or its schema do not
 * exist, fill the error message format string and name, and return true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>owningrel_does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>parent_object</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>parent_rel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>parent_object</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name>parent_object</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>parent_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><name>parent_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * schema_does_not_exist_skipping
 *        Subroutine for RemoveObjects
 *
 * After determining that a specification for a schema-qualifiable object
 * refers to an object that does not exist, test whether the specified schema
 * exists or not.  If no schema was specified, or if the schema does exist,
 * return false -- the object itself is missing instead.  If the specified
 * schema does not exist, fill the error message format string and the
 * specified schema name, and return true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>schema_does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr>;</expr_stmt>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * type_in_list_does_not_exist_skipping
 *        Subroutine for RemoveObjects
 *
 * After determining that a specification for a function, cast, aggregate or
 * operator returns that the specified object does not exist, test whether the
 * involved datatypes, and their schemas, exist or not; if they do, return
 * false --- the original object itself is missing instead.  If the datatypes
 * or schemas do not exist, fill the error message format string and the
 * missing name, and return true.
 *
 * First parameter is a list of TypeNames.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>type_in_list_does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>typenames</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>,
                                     <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>typenames</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>typeName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* type doesn't exist, try to find why */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

                <expr_stmt><expr><operator>*</operator><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * does_not_exist_skipping
 *        Subroutine for RemoveObjects
 *
 * Generate a NOTICE stating that the named object was not found, and is
 * being skipped.  This is only relevant when "IF EXISTS" is used; otherwise,
 * get_object_address() in RemoveObjects would have thrown an ERROR.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>does_not_exist_skipping</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>missmsg</name> <init>= <expr><literal type="string">"skipping"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><name>NOTICE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>missmsg</name> <operator>=</operator> <literal type="string">"can not skip in parallel ddl mode"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"access method \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
        <case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typ</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>names</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"collation \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"conversion \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"statistics object \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search parser \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search dictionary \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search template \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search configuration \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>owa</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>type_in_list_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"function %s(%s) does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>TypeNameListToString</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>owa</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>type_in_list_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"aggregate %s(%s) does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>TypeNameListToString</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>owa</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>type_in_list_does_not_exist_skipping</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"operator %s does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><name><name>owa</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"language \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_CAST</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_in_list_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>type_in_list_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* XXX quote or no quote? */</comment>
					<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"cast from type %s to type %s does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>TypeNameToString</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>TypeNameToString</name><argument_list>(<argument><expr><call><name>lsecond_node</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_in_list_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"transform for type %s language \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>TypeNameToString</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>owningrel_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" for relation \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>owningrel_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"policy \"%s\" for relation \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"event trigger \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_RULE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>owningrel_does_not_exist_skipping</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"rule \"%s\" for relation \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign-data wrapper \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"server \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>opcname</name> <init>= <expr><call><name>list_copy_tail</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" does not exist for access method \"%s\", %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>opfname</name> <init>= <expr><call><name>list_copy_tail</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>schema_does_not_exist_skipping</name><argument_list>(<argument><expr><name>opfname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"operator family \"%s\" does not exist for access method \"%s\", %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameListToString</name><argument_list>(<argument><expr><name>opfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"publication \"%s\" does not exist, %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>args</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>missmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>missmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
