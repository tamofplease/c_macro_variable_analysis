<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/commands/statscmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * statscmds.c
 *      Commands for creating and altering extended statistics objects
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/commands/statscmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* qsort comparator for the attnums in CreateStatistics */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>av</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int16</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bv</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int16</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* this can't overflow if int is wider than int16 */</comment>
    <return>return <expr><operator>(</operator><name>av</name> <operator>-</operator> <name>bv</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *        CREATE STATISTICS
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateStatistics</name><parameter_list>(<parameter><decl><type><name>CreateStatsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>attnums</name><index>[<expr><name>STATS_MAX_DIMENSIONS</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>attnums_ori</name><index>[<expr><name>STATS_MAX_DIMENSIONS</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int</name></type>			<name>numcols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>namestr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>stxname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>statoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>stxowner</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_statistic_ext</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_statistic_ext</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>stxkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>statrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>parentobject</name></decl>,
				<decl><type ref="prev"/><name>myself</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Datum</name></type>		<name><name>types</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* one for each possible type of statistic */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>types</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* one for each possible type of statistic */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>int</name></type>			<name>ntypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>stxkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>build_ndistinct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>build_dependencies</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type>		<name>build_subset</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>bool</name></type>		<name>requested_type</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateStatsStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* resolve the pieces of the name (namespace etc.) */</comment>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stxname</name></expr></argument>, <argument><expr><name>namestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deal with the possibility that the statistics object already exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>STATEXTNAMENSP</name></expr></argument>,
							  <argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stxname</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics object \"%s\" already exists, skipping"</literal></expr></argument>,
							<argument><expr><name>namestr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics object \"%s\" already exists"</literal></expr></argument>, <argument><expr><name>namestr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Examine the FROM clause.  Currently, we only allow it to be a single
	 * simple table, but later we'll probably allow multiple tables and JOIN
	 * syntax.  The grammar is already prepared for that, so we have to check
	 * here that what we got is what we can support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only a single relation is allowed in CREATE STATISTICS"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rln</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rln</name></expr></argument>, <argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only a single relation is allowed in CREATE STATISTICS"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * CREATE STATISTICS will influence future execution plans but does
		 * not interfere with currently executing plans.  So it should be
		 * enough to take only ShareUpdateExclusiveLock on relation,
		 * conflicting with ANALYZE and other DDL that sets statistical
		 * information, but not with normal queries.
		 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name>rln</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restrict to allowed relation types */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a table, foreign table, or materialized view"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* You must own the relation to create stats on it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stxowner</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_CLASS</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we only allow simple column references in the expression
	 * list.  That will change someday, and again the grammar already supports
	 * it so we have to enforce restrictions here.  For now, we can convert
	 * the expression list to a simple array of attnums.  While at it, enforce
	 * some constraints.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only simple column references are allowed in CREATE STATISTICS"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cref</name> <operator>=</operator> <operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only simple column references are allowed in CREATE STATISTICS"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" referenced in statistics does not exist"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Disallow use of system attributes in extended stats */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attForm</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics creation on system columns is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Disallow data types without a less-than operator */</comment>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>attForm</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" cannot be used in statistics because its type has no default btree operator class"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure no more than STATS_MAX_DIMENSIONS columns are used */</comment>
		<if_stmt><if>if <condition>(<expr><name>numcols</name> <operator>&gt;=</operator> <name>STATS_MAX_DIMENSIONS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have more than %d columns in statistics"</literal></expr></argument>,
							<argument><expr><name>STATS_MAX_DIMENSIONS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>attnums</name><index>[<expr><name>numcols</name></expr>]</index></name> <operator>=</operator> <name><name>attForm</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><name><name>attnums_ori</name><index>[<expr><name>numcols</name></expr>]</index></name> <operator>=</operator> <name><name>attForm</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>numcols</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check that at least two columns were specified in the statement. The
	 * upper bound was already checked in the loop above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numcols</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extended statistics require at least 2 columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sort the attnums, which makes detecting duplicates somewhat easier, and
	 * it does not hurt (it does not affect the efficiency, unlike for
	 * indexes, for example).
	 */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>numcols</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_int16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for duplicates in the list of columns. The attnums are sorted so
	 * just check consecutive elements.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numcols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>attnums</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate column name in statistics definition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Form an int2vector representation of the sorted column list */</comment>
	<expr_stmt><expr><name>stxkeys</name> <operator>=</operator> <call><name>buildint2vector</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>numcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse the statistics types.
	 */</comment>
	<expr_stmt><expr><name>build_ndistinct</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>build_dependencies</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name>build_subset</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;stat_types</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"ndistinct"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>build_ndistinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>requested_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"dependencies"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>build_dependencies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>requested_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"subset"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subset statistics require exactly 2 columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>build_subset</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>requested_type</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * The original stmt expr order implies the relation between them,
			 * thus we need to keep the original order stored.
			 */</comment>
			<expr_stmt><expr><name>stxkeys</name> <operator>=</operator> <call><name>buildint2vector</name><argument_list>(<argument><expr><name>attnums_ori</name></expr></argument>, <argument><expr><name>numcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized statistic type \"%s\""</literal></expr></argument>,
							<argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<comment type="block">/* If no statistic type was specified, build them all. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>requested_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>build_ndistinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>build_dependencies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* No need to build user defined knowledge */</comment>
		<expr_stmt><expr><name>build_subset</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* construct the char array of enabled statistic types */</comment>
	<expr_stmt><expr><name>ntypes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>build_ndistinct</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>types</name><index>[<expr><name>ntypes</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>STATS_EXT_NDISTINCT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>build_dependencies</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>types</name><index>[<expr><name>ntypes</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * User defined subset hint should not coexists with other
	 * types. Thus we don't need to extend the size of 'types'
	 * array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>build_subset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>types</name><index>[<expr><name>ntypes</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>STATS_EXT_SUBSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntypes</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ntypes</name> <operator>&lt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stxkind</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>ntypes</name></expr></argument>, <argument><expr><name>CHAROID</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Everything seems fine, so let's build the pg_statistic_ext tuple.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxnamespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>stxowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxkeys</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stxkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_ext_stxkind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stxkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no statistics built yet */</comment>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_statistic_ext_stxndistinct</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_statistic_ext_stxdependencies</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_statistic_ext_stxsubset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* insert it into pg_statistic_ext */</comment>
	<expr_stmt><expr><name>statrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>statrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>statoid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>statrel</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>statrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate relcache so that others see the new statistics object.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add an AUTO dependency on each column used in the stats, so that the
	 * stats object goes away if any or all of them get dropped.
	 */</comment>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><name>statoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numcols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>parentobject</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Also add dependencies on namespace and owner.  These are required
	 * because the stats object might have a different namespace and/or owner
	 * than the underlying table(s).
	 */</comment>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>parentobject</name></expr></argument>, <argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><name>statoid</name></expr></argument>, <argument><expr><name>stxowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX probably there should be a recordDependencyOnCurrentExtension call
	 * here too, but we'd have to add support for ALTER EXTENSION ADD/DROP
	 * STATISTICS, which is more work than it seems worth.
	 */</comment>

	<comment type="block">/* Return stats object's address */</comment>
	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of statistics object deletion.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveStatisticsById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>statsOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_statistic_ext</name></type> <name>statext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Delete the pg_statistic_ext tuple.  Also send out a cache inval on the
     * associated table, so that dependent plans will be rebuilt.
     */</comment>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>statsOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>statsOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>statext</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>statext</name><operator>-&gt;</operator><name>stxrelid</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update a statistics object for ALTER COLUMN TYPE on a source column.
 *
 * This could throw an error if the type change can't be supported.
 * If it can be supported, but the stats must be recomputed, a likely choice
 * would be to set the relevant column(s) of the pg_statistic_ext tuple to
 * null until the next ANALYZE.  (Note that the type change hasn't actually
 * happened yet, so one option that's *not* on the table is to recompute
 * immediately.)
 */</comment>
<function><type><name>void</name></type>
<name>UpdateStatisticsForTypeChange</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>statsOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>,
                              <parameter><decl><type><name>Oid</name></type> <name>oldColumnType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newColumnType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Currently, we don't actually need to do anything here.  For both
     * ndistinct and functional-dependencies stats, the on-disk representation
     * is independent of the source column data types, and it is plausible to
     * assume that the old statistic values will still be good for the new
     * column contents.  (Obviously, if the ALTER COLUMN TYPE has a USING
     * expression that substantially alters the semantic meaning of the column
     * values, this assumption could fail.  But that seems like a corner case
     * that doesn't justify zapping the stats in common cases.)
     *
     * Future types of extended stats will likely require us to work harder.
     */</comment>
</block_content>}</block></function>
</unit>
