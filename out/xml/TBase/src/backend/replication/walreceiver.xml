<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/replication/walreceiver.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * walreceiver.c
 *
 * The WAL receiver process (walreceiver) is new as of Postgres 9.0. It
 * is the process in the standby server that takes charge of receiving
 * XLOG records from a primary server during streaming replication.
 *
 * When the startup process determines that it's time to start streaming,
 * it instructs postmaster to start walreceiver. Walreceiver first connects
 * to the primary server (it will be served by a walsender process
 * in the primary server), and then keeps receiving XLOG records and
 * writing them to the disk as long as the connection is alive. As XLOG
 * records are received and flushed to disk, it updates the
 * WalRcv-&gt;receivedUpto variable in shared memory, to inform the startup
 * process of how far it can proceed with XLOG replay.
 *
 * If the primary server ends streaming, but doesn't disconnect, walreceiver
 * goes into "waiting" mode, and waits for the startup process to give new
 * instructions. The startup process will treat that the same as
 * disconnection, and will rescan the archive/pg_wal directory. But when the
 * startup process wants to try streaming replication again, it will just
 * nudge the existing walreceiver process that's waiting, instead of launching
 * a new one.
 *
 * Normal termination is by SIGTERM, which instructs the walreceiver to
 * exit(0). Emergency termination is by SIGQUIT; like any postmaster child
 * process, the walreceiver will simply abort and exit on SIGQUIT. A close
 * of the connection and a FATAL error are treated not as a crash but as
 * normal operation.
 *
 * This file contains the server-facing parts of walreceiver. The libpq-
 * specific parts are in the libpqwalreceiver module. It's loaded
 * dynamically to avoid linking the server with libpq.
 *
 * Portions Copyright (c) 2010-2017, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/replication/walreceiver.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>wal_receiver_status_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>wal_receiver_timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>hot_standby_feedback</name></decl>;</decl_stmt>

<comment type="block">/* libpqwalreceiver connection */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WalReceiverFunctionsType</name> <modifier>*</modifier></type><name>WalReceiverFunctions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAPTIME_PER_CYCLE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>    <comment type="block">/* max sleep time between cycles (100ms) */</comment>

<comment type="block">/*
 * These variables are used similarly to openLogFile/SegNo/Off,
 * but for walreceiver to write the XLOG. recvFileTLI is the TimeLineID
 * corresponding the filename of recvFile.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>recvFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>recvFileTLI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>recvSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>recvOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flags set by interrupt handlers of walreceiver for later service in the
 * main loop.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * LogstreamResult indicates the byte positions that we have already
 * written/fsynced.
 */</comment>
<struct><specifier>static</specifier> struct
<block>{
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>Write</name></decl>;</decl_stmt>            <comment type="block">/* last byte + 1 written out in the standby */</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>Flush</name></decl>;</decl_stmt>            <comment type="block">/* last byte + 1 flushed in the standby */</comment>
}</block>            <decl><name>LogstreamResult</name></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>reply_message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>incoming_message</name></decl>;</decl_stmt>

<comment type="block">/*
 * About SIGTERM handling:
 *
 * We can't just exit(1) within SIGTERM signal handler, because the signal
 * might arrive in the middle of some critical operation, like while we're
 * holding a spinlock. We also can't just set a flag in signal handler and
 * check it in the main loop, because we perform some blocking operations
 * like libpqrcv_PQexec(), which can take a long time to finish.
 *
 * We use a combined approach: When WalRcvImmediateInterruptOK is true, it's
 * safe for the signal handler to elog(FATAL) immediately. Otherwise it just
 * sets got_SIGTERM flag, which is checked in the main loop when convenient.
 *
 * This is very much like what regular backends do with ImmediateInterruptOK,
 * ProcessInterrupts() etc.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>WalRcvImmediateInterruptOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Prototypes for private functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessWalRcvInterrupts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnableWalRcvImmediateExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DisableWalRcvImmediateExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvFetchTimeLineHistoryFiles</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>last</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvWaitForStartPosition</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>startpoint</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>startpointTLI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvDie</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvProcessMsg</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvWrite</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvFlush</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>dying</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvSendReply</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvSendHSFeedback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>immed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessWalSndrMessage</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>walEnd</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>sendTime</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Signal handlers */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvSigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvQuickDieHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessWalRcvInterrupts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Although walreceiver interrupt handling doesn't use the same scheme as
     * regular backends, call CHECK_FOR_INTERRUPTS() to make sure we receive
     * any incoming signals on Win32.
     */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>WalRcvImmediateInterruptOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating walreceiver process due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnableWalRcvImmediateExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>WalRcvImmediateInterruptOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisableWalRcvImmediateExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>WalRcvImmediateInterruptOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Main entry point for walreceiver process */</comment>
<function><type><name>void</name></type>
<name>WalReceiverMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>conninfo</name><index>[<expr><name>MAXCONNINFO</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tmp_conninfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>slotname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>startpoint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>startpointTLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>primaryTLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>first_stream</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_recv_timestamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>ping_sent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>

    <comment type="block">/*
     * WalRcv should be set up already (if we are a backend, we inherit this
     * by fork() or EXEC_BACKEND mechanism from the postmaster).
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>walrcv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark walreceiver as running in shared memory.
     *
     * Do this as early as possible, so that if we fail later on, we'll set
     * state to STOPPED. If we die before this, the startup process will keep
     * waiting for us to start up, until it times out.
     */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>WALRCV_STOPPING</name></expr>:</case>
            <comment type="block">/* If we've already been requested to stop, don't start up. */</comment>
            <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STOPPED</name></expr>;</expr_stmt>
            <comment type="block">/* fall through */</comment>

        <case>case <expr><name>WALRCV_STOPPED</name></expr>:</case>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>WALRCV_STARTING</name></expr>:</case>
            <comment type="block">/* The usual case */</comment>
            <break>break;</break>

        <case>case <expr><name>WALRCV_WAITING</name></expr>:</case>
        <case>case <expr><name>WALRCV_STREAMING</name></expr>:</case>
        <case>case <expr><name>WALRCV_RESTARTING</name></expr>:</case>
        <default>default:</default>
            <comment type="block">/* Shouldn't happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"walreceiver still running according to shared memory state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <comment type="block">/* Advertise our PID so that the startup process can kill us */</comment>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STREAMING</name></expr>;</expr_stmt>

    <comment type="block">/* Fetch information required to start streaming */</comment>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>ready_to_display</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name>MAXCONNINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>startpoint</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>startpointTLI</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name></expr>;</expr_stmt>

    <comment type="block">/* Initialise to a sanish value */</comment>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgSendTime</name></name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgReceiptTime</name></name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEndTime</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Arrange to clean up at walreceiver exit */</comment>
    <expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>WalRcvDie</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr>;</expr_stmt>

    <comment type="block">/* Properly accept or ignore signals the postmaster might send us */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>WalRcvSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* set flag to read config file */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>WalRcvShutdownHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* request shutdown */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>WalRcvQuickDieHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* hard crash time */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>WalRcvSigUsr1Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset some signals that are accepted by postmaster but not here */</comment>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We allow SIGQUIT (quickdie) at all times */</comment>
    <expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the libpq-specific functions */</comment>
    <expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><literal type="string">"libpqwalreceiver"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>WalReceiverFunctions</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"libpqwalreceiver didn't initialize correctly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create a resource owner to keep track of our resources (not clear that
     * we need this, but may as well have one).
     */</comment>
    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Wal Receiver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Unblock signals (they were blocked when the postmaster forked us) */</comment>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Establish the connection to the primary for XLOG streaming */</comment>
    <expr_stmt><expr><call><name>EnableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wrconn</name> <operator>=</operator> <call><name>walrcv_connect</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"walreceiver"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>wrconn</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to the primary server: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>DisableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Save user-visible connection string.  This clobbers the original
     * conninfo, for security.
     */</comment>
    <expr_stmt><expr><name>tmp_conninfo</name> <operator>=</operator> <call><name>walrcv_get_conninfo</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAXCONNINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tmp_conninfo</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name>tmp_conninfo</name></expr></argument>, <argument><expr><name>MAXCONNINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp_conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>ready_to_display</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>first_stream</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>primary_sysid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>standby_sysid</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>server_version</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WalRcvStreamOptions</name></type> <name>options</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Check that we're connected to a valid server using the
         * IDENTIFY_SYSTEM replication command.
         */</comment>
        <expr_stmt><expr><call><name>EnableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>primary_sysid</name> <operator>=</operator> <call><name>walrcv_identify_system</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>primaryTLI</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>server_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>standby_sysid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>standby_sysid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
                 <argument><expr><call><name>GetSystemIdentifier</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>primary_sysid</name></expr></argument>, <argument><expr><name>standby_sysid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system identifier differs between the primary and standby"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The primary's identifier is %s, the standby's identifier is %s."</literal></expr></argument>,
                               <argument><expr><name>primary_sysid</name></expr></argument>, <argument><expr><name>standby_sysid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>DisableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Confirm that the current timeline of the primary is the same or
         * ahead of ours.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>primaryTLI</name> <operator>&lt;</operator> <name>startpointTLI</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"highest timeline %u of the primary is behind recovery timeline %u"</literal></expr></argument>,
                            <argument><expr><name>primaryTLI</name></expr></argument>, <argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Get any missing history files. We do this always, even when we're
         * not interested in that timeline, so that if we're promoted to
         * become the master later on, we don't select the same timeline that
         * was already used in the current master. This isn't bullet-proof -
         * you'll need some external software to manage your cluster if you
         * need to ensure that a unique timeline id is chosen in every case,
         * but let's avoid the confusion of timeline id collisions where we
         * can.
         */</comment>
        <expr_stmt><expr><call><name>WalRcvFetchTimeLineHistoryFiles</name><argument_list>(<argument><expr><name>startpointTLI</name></expr></argument>, <argument><expr><name>primaryTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Start streaming.
         *
         * We'll try to start at the requested starting point and timeline,
         * even if it's different from the server's latest timeline. In case
         * we've already reached the end of the old timeline, the server will
         * finish the streaming immediately, and we will go back to await
         * orders from the startup process. If recovery_target_timeline is
         * 'latest', the startup process will scan pg_wal and find the new
         * history file, bump recovery target timeline, and ask us to restart
         * on the new timeline.
         */</comment>
        <expr_stmt><expr><name><name>options</name><operator>.</operator><name>logical</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>options</name><operator>.</operator><name>startpoint</name></name> <operator>=</operator> <name>startpoint</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>options</name><operator>.</operator><name>slotname</name></name> <operator>=</operator> <ternary><condition><expr><name><name>slotname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> ?</condition><then> <expr><name>slotname</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>options</name><operator>.</operator><name>proto</name><operator>.</operator><name>physical</name><operator>.</operator><name>startpointTLI</name></name> <operator>=</operator> <name>startpointTLI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name>startpointTLI</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>walrcv_startstreaming</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>first_stream</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"started streaming WAL from primary at %X/%X on timeline %u"</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpoint</name></expr></argument>,
                                <argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"restarted WAL streaming at %X/%X on timeline %u"</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpoint</name></expr></argument>,
                                <argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>first_stream</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <comment type="block">/* Initialize LogstreamResult and buffers for processing messages */</comment>
            <expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Initialize the last recv timestamp */</comment>
            <expr_stmt><expr><name>last_recv_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <comment type="block">/* Loop until end-of-streaming or error */</comment>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>endofwal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>pgsocket</name></type>    <name>wait_fd</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>rc</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Exit walreceiver if we're not in recovery. This should not
                 * happen, but cross-check the status here.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot continue WAL streaming, recovery has already ended"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* Process any requests or signals received recently */</comment>
                <expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogWalRcvSendHSFeedback</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* See if we can read data immediately */</comment>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>walrcv_receive</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Process the received data, and any subsequent data we
                     * can read without blocking.
                     */</comment>
                    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/*
                             * Something was received from master, so reset
                             * timeout
                             */</comment>
                            <expr_stmt><expr><name>last_recv_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>XLogWalRcvProcessMsg</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if>
                        <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replication terminated by primary server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"End of WAL reached on timeline %u at %X/%X."</literal></expr></argument>,
                                               <argument><expr><name>startpointTLI</name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>endofwal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>walrcv_receive</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>

                    <comment type="block">/* Let the master know that we received some data. */</comment>
                    <expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If we've written some records, flush them to disk and
                     * let the startup process and primary server know about
                     * them.
                     */</comment>
                    <expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Check if we need to exit the streaming loop. */</comment>
                <if_stmt><if>if <condition>(<expr><name>endofwal</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Ideally we would reuse a WaitEventSet object repeatedly
                 * here to avoid the overheads of WaitLatchOrSocket on epoll
                 * systems, but we can't be sure that libpq (or any other
                 * walreceiver implementation) has the same socket (even if
                 * the fd is the same number, it may have been closed and
                 * reopened since the last time).  In future, if there is a
                 * function for removing sockets from WaitEventSet, then we
                 * could add and remove just the socket each time, potentially
                 * avoiding some system calls.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wait_fd</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>,
                                       <argument><expr><name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator>
                                       <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_LATCH_SET</name></expr></argument>,
                                       <argument><expr><name>wait_fd</name></expr></argument>,
                                       <argument><expr><name>NAPTIME_PER_CYCLE</name></expr></argument>,
                                       <argument><expr><name>WAIT_EVENT_WAL_RECEIVER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>force_reply</name></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * The recovery process has asked us to send apply
                         * feedback now.  Make sure the flag is really set to
                         * false in shared memory before sending the reply, so
                         * we don't miss a new request for a reply.
                         */</comment>
                        <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Emergency bailout if postmaster has died.  This is to
                     * avoid the necessity for manual cleanup of all
                     * postmaster children.
                     */</comment>
                    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * We didn't receive anything new. If we haven't heard
                     * anything from the server for more than
                     * wal_receiver_timeout / 2, ping the server. Also, if
                     * it's been longer than wal_receiver_status_interval
                     * since the last update we sent, send a status update to
                     * the master anyway, to report any progress in applying
                     * WAL.
                     */</comment>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>requestReply</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Check if time since last receive from standby has
                     * reached the configured limit.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>wal_receiver_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>timeout</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>timeout</name> <operator>=</operator>
                            <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_recv_timestamp</name></expr></argument>,
                                                        <argument><expr><name>wal_receiver_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>timeout</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating walreceiver due to timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <comment type="block">/*
                         * We didn't receive anything new, for half of
                         * receiver replication timeout. Ping the server.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ping_sent</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_recv_timestamp</name></expr></argument>,
                                                                  <argument><expr><operator>(</operator><name>wal_receiver_timeout</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>timeout</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>requestReply</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>requestReply</name></expr></argument>, <argument><expr><name>requestReply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogWalRcvSendHSFeedback</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * The backend finished streaming. Exit streaming COPY-mode from
             * our side, too.
             */</comment>
            <expr_stmt><expr><call><name>EnableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>walrcv_endstreaming</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>primaryTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DisableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the server had switched to a new timeline that we didn't
             * know about when we began streaming, fetch its timeline history
             * file now.
             */</comment>
            <expr_stmt><expr><call><name>WalRcvFetchTimeLineHistoryFiles</name><argument_list>(<argument><expr><name>startpointTLI</name></expr></argument>, <argument><expr><name>primaryTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary server contains no more WAL on requested timeline %u"</literal></expr></argument>,
                            <argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * End of WAL reached on the requested timeline. Close the last
         * segment, and await for new orders from the startup process.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>recvFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>xlogfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close log segment %s: %m"</literal></expr></argument>,
                                <argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Create .done file forcibly to prevent the streamed segment from
             * being archived later.
             */</comment>
            <expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>XLogArchiveMode</name> <operator>!=</operator> <name>ARCHIVE_MODE_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>XLogArchiveForceDone</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>recvFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"walreceiver ended streaming and awaits new instructions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WalRcvWaitForStartPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startpoint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>startpointTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* not reached */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for startup process to set receiveStart and receiveStartTLI.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvWaitForStartPosition</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>startpoint</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>startpointTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>WALRCV_STREAMING</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unexpected walreceiver state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_WAITING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receiveStart</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * nudge startup process to notice that we've stopped streaming and are
     * now waiting for instructions.
     */</comment>
    <expr_stmt><expr><call><name>WakeupRecovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Emergency bailout if postmaster has died.  This is to avoid the
         * necessity for manual cleanup of all postmaster children.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_RESTARTING</name> <operator>||</operator>
               <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_WAITING</name> <operator>||</operator>
               <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_RESTARTING</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we don't expect primary_conninfo to change */</comment>
            <expr_stmt><expr><operator>*</operator><name>startpoint</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStart</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>startpointTLI</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STREAMING</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We should've received SIGTERM if the startup process wants us
             * to die, but might as well check it here too.
             */</comment>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                  <argument><expr><name>WAIT_EVENT_WAL_RECEIVER_WAIT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>activitymsg</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"restarting at %X/%X"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>*</operator><name>startpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch any missing timeline history files between 'first' and 'last'
 * (inclusive) from the server.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvFetchTimeLineHistoryFiles</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>tli</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>tli</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>tli</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>tli</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* there's no history file for timeline 1 */</comment>
        <if_stmt><if>if <condition>(<expr><name>tli</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>existsTimeLineHistory</name><argument_list>(<argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>content</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>expectedfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fetching timeline history file for timeline %u from primary server"</literal></expr></argument>,
                            <argument><expr><name>tli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>EnableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>walrcv_readtimelinehistoryfile</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>content</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DisableWalRcvImmediateExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Check that the filename on the master matches what we
             * calculated ourselves. This is just a sanity check, it should
             * always match.
             */</comment>
            <expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>expectedfname</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>expectedfname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"primary reported unexpected file name for timeline history file of timeline %u"</literal></expr></argument>,
                                         <argument><expr><name>tli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Write the file to pg_wal.
             */</comment>
            <expr_stmt><expr><call><name>writeTimeLineHistoryFile</name><argument_list>(<argument><expr><name>tli</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Mark us as STOPPED in shared memory at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvDie</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Ensure that all WAL records received are flushed to disk */</comment>
    <expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STREAMING</name> <operator>||</operator>
           <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_RESTARTING</name> <operator>||</operator>
           <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STARTING</name> <operator>||</operator>
           <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_WAITING</name> <operator>||</operator>
           <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STOPPED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>ready_to_display</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Terminate the connection gracefully. */</comment>
    <if_stmt><if>if <condition>(<expr><name>wrconn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>walrcv_disconnect</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Wake up the startup process to notice promptly that we're gone */</comment>
    <expr_stmt><expr><call><name>WakeupRecovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGHUP: set flag to re-read config file at next convenient time */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* SIGUSR1: used by latch mechanism */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvSigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>latch_sigusr1_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGTERM: set flag for main loop, or shutdown immediately if safe */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>WalRcv</name><operator>-&gt;</operator><name>latch</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Don't joggle the elbow of proc_exit */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name> <operator>&amp;&amp;</operator> <name>WalRcvImmediateInterruptOK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WalRcvQuickDieHandler() occurs when signalled SIGQUIT by the postmaster.
 *
 * Some backend has bought the farm, so we need to stop what we're doing and
 * exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvQuickDieHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We DO NOT want to run proc_exit() callbacks -- we're here because
     * shared memory may be corrupted, so we don't want to try to clean up our
     * transaction.  Just nail the windows shut and get out of town.  Now that
     * there's an atexit callback to prevent third-party code from breaking
     * things by calling exit() directly, we have to reset the callbacks
     * explicitly to make this work as intended.
     */</comment>
    <expr_stmt><expr><call><name>on_exit_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note we do exit(2) not exit(0).  This is to force the postmaster into a
     * system reset cycle if some idiot DBA sends a manual SIGQUIT to a random
     * backend.  This is necessary precisely because we don't clean up our
     * shared memory state.  (The "dead man switch" mechanism in pmsignal.c
     * should ensure the postmaster sees this as a crash, too, but no harm in
     * being doubly sure.)
     */</comment>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accept the message from XLOG stream, and process it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvProcessMsg</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>hdrlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>dataStart</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>walEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>sendTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>replyRequested</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'w'</literal></expr>:</case>                <comment type="block">/* WAL records */</comment>
            <block>{<block_content>
                <comment type="block">/* copy message to StringInfo */</comment>
                <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid WAL message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* read the fields */</comment>
                <expr_stmt><expr><name>dataStart</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>hdrlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>hdrlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>XLogWalRcvWrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dataStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><literal type="char">'k'</literal></expr>:</case>                <comment type="block">/* Keepalive */</comment>
            <block>{<block_content>
                <comment type="block">/* copy message to StringInfo */</comment>
                <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid keepalive message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* read the fields */</comment>
                <expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>replyRequested</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* If the primary requested a reply, send one immediately */</comment>
                <if_stmt><if>if <condition>(<expr><name>replyRequested</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid replication message type %d"</literal></expr></argument>,
                                     <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Write XLOG data to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvWrite</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>startoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>byteswritten</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>segbytes</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>recvFile</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>use_existent</name></decl>;</decl_stmt>

            <comment type="block">/*
             * fsync() and close current file before we switch to next one. We
             * would otherwise have to reopen this file to fsync it later
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>recvFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type>        <name><name>xlogfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * XLOG segment files will be re-read by recovery in startup
                 * process soon, so we don't advise the OS to release cache
                 * pages associated with the file like XLogFileClose() does.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close log segment %s: %m"</literal></expr></argument>,
                                    <argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Create .done file forcibly to prevent the streamed segment
                 * from being archived later.
                 */</comment>
                <expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>XLogArchiveMode</name> <operator>!=</operator> <name>ARCHIVE_MODE_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>XLogArchiveForceDone</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>recvFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

            <comment type="block">/* Create/use new log file */</comment>
            <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>recvFile</name> <operator>=</operator> <call><name>XLogFileInit</name><argument_list>(<argument><expr><name>recvSegNo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>recvFileTLI</name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>recvOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Calculate the start offset of the received logs */</comment>
        <expr_stmt><expr><name>startoff</name> <operator>=</operator> <name>recptr</name> <operator>%</operator> <name>XLogSegSize</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>startoff</name> <operator>+</operator> <name>nbytes</name> <operator>&gt;</operator> <name>XLogSegSize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>XLogSegSize</name> <operator>-</operator> <name>startoff</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Need to seek in the file? */</comment>
        <if_stmt><if>if <condition>(<expr><name>recvOff</name> <operator>!=</operator> <name>startoff</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>startoff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in log segment %s to offset %u: %m"</literal></expr></argument>,
                                <argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>startoff</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>recvOff</name> <operator>=</operator> <name>startoff</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* OK to write the logs */</comment>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>byteswritten</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>byteswritten</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* if write didn't set errno, assume no disk space */</comment>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to log segment %s "</literal>
                            <literal type="string">"at offset %u, length %lu: %m"</literal></expr></argument>,
                            <argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>recvOff</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>segbytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update state for write */</comment>
        <expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>byteswritten</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>recvOff</name> <operator>+=</operator> <name>byteswritten</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>byteswritten</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>byteswritten</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>recptr</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Flush the log to disk.
 *
 * If we're in the midst of dying, it's unwise to do anything that might throw
 * an error, so we skip sending a reply in that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvFlush</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>dying</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>&lt;</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>issue_xlog_fsync</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>

        <comment type="block">/* Update shared-memory status */</comment>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>receivedUpto</name></name> <operator>&lt;</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestChunkStart</name></name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receivedUpto</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receivedUpto</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receivedTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Signal the startup process and walsender that new WAL has arrived */</comment>
        <expr_stmt><expr><call><name>WakeupRecovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>AllowCascadeReplication</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>WalSndWakeup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Report XLOG streaming progress in PS display */</comment>
        <if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>activitymsg</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"streaming %X/%X"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                     <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Also let the master know that we made some progress */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dying</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogWalRcvSendHSFeedback</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send reply message to primary, indicating our current WAL locations, oldest
 * xmin and the current time.
 *
 * If 'force' is not set, the message is only sent if enough time has
 * passed since last status update to reach wal_receiver_status_interval.
 * If wal_receiver_status_interval is disabled altogether and 'force' is
 * false, this is a no-op.
 *
 * If 'requestReply' is true, requests the server to reply immediately upon
 * receiving this message. This is used for heartbearts, when approaching
 * wal_receiver_timeout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvSendReply</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>writePtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>flushPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>applyPtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>sendTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If the user doesn't want status to be reported to the master, be sure
     * to exit before doing anything at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name>wal_receiver_status_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Get current timestamp. */</comment>
    <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We can compare the write and flush positions to the last message we
     * sent without taking any lock, but the apply position requires a spin
     * lock, so we don't check that unless something else has changed or 10
     * seconds have passed.  This means that the apply WAL location will
     * appear, from the master's point of view, to lag slightly, but since
     * this is only for reporting purposes and only on idle systems, that's
     * probably OK.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name>
        <operator>&amp;&amp;</operator> <name>writePtr</name> <operator>==</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name>
        <operator>&amp;&amp;</operator> <name>flushPtr</name> <operator>==</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name>
        <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>sendTime</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
                                       <argument><expr><name>wal_receiver_status_interval</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sendTime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

    <comment type="block">/* Construct a new message */</comment>
    <expr_stmt><expr><name>writePtr</name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flushPtr</name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>applyPtr</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>writePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>flushPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>applyPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><ternary><condition><expr><name>requestReply</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* I'm not a subscription apply worker, so send true as default */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Send it */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sending write %X/%X flush %X/%X apply %X/%X%s"</literal></expr></argument>,
         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>writePtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>writePtr</name></expr></argument>,
         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>flushPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flushPtr</name></expr></argument>,
         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>applyPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>applyPtr</name></expr></argument>,
         <argument><expr><ternary><condition><expr><name>requestReply</name></expr> ?</condition><then> <expr><literal type="string">" (reply requested)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>walrcv_send</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send hot standby feedback message to primary, plus the current time,
 * in case they don't have a watch.
 *
 * If the user disables feedback, send one final message to tell sender
 * to forget about the xmin on this standby. We also send this message
 * on first connect because a previous connection might have set xmin
 * on a replication slot. (If we're not using a slot it's harmless to
 * send a feedback message explicitly setting InvalidTransactionId).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvSendHSFeedback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>immed</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>xmin_epoch</name></decl>,
                <decl><type ref="prev"/><name>catalog_xmin_epoch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>,
                <decl><type ref="prev"/><name>catalog_xmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>sendTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* initially true so we always send at least one feedback message */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>master_has_standby_xmin</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If the user doesn't want status to be reported to the master, be sure
     * to exit before doing anything at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>wal_receiver_status_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>hot_standby_feedback</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>!</operator><name>master_has_standby_xmin</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Get current timestamp. */</comment>
    <expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>immed</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Send feedback at most once per wal_receiver_status_interval.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>sendTime</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
                                        <argument><expr><name>wal_receiver_status_interval</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>sendTime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If Hot Standby is not yet accepting connections there is nothing to
     * send. Check this after the interval has expired to reduce number of
     * calls.
     *
     * Bailing out here also ensures that we don't send feedback until we've
     * read our own replication slot state, so we don't tell the master to
     * discard needed xmin or catalog_xmin from any slots that may exist on
     * this replica.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HotStandbyActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Make the expensive call to get the oldest xmin once we are certain
     * everything else has been checked.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>hot_standby_feedback</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>slot_xmin</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Usually GetOldestXmin() would include both global replication slot
         * xmin and catalog_xmin in its calculations, but we want to derive
         * separate values for each of those. So we ask for an xmin that
         * excludes the catalog_xmin.
         */</comment>
        <expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>PROCARRAY_FLAGS_DEFAULT</name> <operator>|</operator> <name>PROCARRAY_SLOTS_XMIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ProcArrayGetReplicationSlotXmin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slot_xmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>catalog_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>slot_xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>slot_xmin</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>xmin</name> <operator>=</operator> <name>slot_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>xmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>catalog_xmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Get epoch and adjust if nextXid and oldestXmin are different sides of
     * the epoch boundary.
     */</comment>
    <expr_stmt><expr><call><name>GetNextXidAndEpoch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nextXid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xmin_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>catalog_xmin_epoch</name> <operator>=</operator> <name>xmin_epoch</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nextXid</name> <operator>&lt;</operator> <name>xmin</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>xmin_epoch</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nextXid</name> <operator>&lt;</operator> <name>catalog_xmin</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>catalog_xmin_epoch</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sending hot standby feedback xmin %u epoch %u catalog_xmin %u catalog_xmin_epoch %u"</literal></expr></argument>,
         <argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>xmin_epoch</name></expr></argument>, <argument><expr><name>catalog_xmin</name></expr></argument>, <argument><expr><name>catalog_xmin_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct the message and send it. */</comment>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="char">'h'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>xmin_epoch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>catalog_xmin</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>catalog_xmin_epoch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>walrcv_send</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>catalog_xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>master_has_standby_xmin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>master_has_standby_xmin</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update shared memory status upon receiving a message from primary.
 *
 * 'walEnd' and 'sendTime' are the end-of-WAL and timestamp of the latest
 * message, reported by primary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessWalSndrMessage</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>walEnd</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>sendTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastMsgReceiptTime</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Update shared-memory status */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEnd</name></name> <operator>&lt;</operator> <name>walEnd</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEndTime</name></name> <operator>=</operator> <name>sendTime</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEnd</name></name> <operator>=</operator> <name>walEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgSendTime</name></name> <operator>=</operator> <name>sendTime</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgReceiptTime</name></name> <operator>=</operator> <name>lastMsgReceiptTime</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG2</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sendtime</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>receipttime</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>applyDelay</name></decl>;</decl_stmt>

        <comment type="block">/* Copy because timestamptz_to_str returns a static buffer */</comment>
        <expr_stmt><expr><name>sendtime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>receipttime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>lastMsgReceiptTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>applyDelay</name> <operator>=</operator> <call><name>GetReplicationApplyDelay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* apply delay is not available */</comment>
        <if_stmt><if>if <condition>(<expr><name>applyDelay</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sendtime %s receipttime %s replication apply delay (N/A) transfer latency %d ms"</literal></expr></argument>,
                 <argument><expr><name>sendtime</name></expr></argument>,
                 <argument><expr><name>receipttime</name></expr></argument>,
                 <argument><expr><call><name>GetReplicationTransferLatency</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sendtime %s receipttime %s replication apply delay %d ms transfer latency %d ms"</literal></expr></argument>,
                 <argument><expr><name>sendtime</name></expr></argument>,
                 <argument><expr><name>receipttime</name></expr></argument>,
                 <argument><expr><name>applyDelay</name></expr></argument>,
                 <argument><expr><call><name>GetReplicationTransferLatency</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sendtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>receipttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wake up the walreceiver main loop.
 *
 * This is called by the startup process whenever interesting xlog records
 * are applied, so that walreceiver can check if it needs to send an apply
 * notification back to the master which may be waiting in a COMMIT with
 * synchronous_commit = remote_apply.
 */</comment>
<function><type><name>void</name></type>
<name>WalRcvForceReply</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>WalRcv</name><operator>-&gt;</operator><name>latch</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a string constant representing the state. This is used
 * in system functions and views, and should *not* be translated.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>WalRcvGetStateString</name><parameter_list>(<parameter><decl><type><name>WalRcvState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>state</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>WALRCV_STOPPED</name></expr>:</case>
            <return>return <expr><literal type="string">"stopped"</literal></expr>;</return>
        <case>case <expr><name>WALRCV_STARTING</name></expr>:</case>
            <return>return <expr><literal type="string">"starting"</literal></expr>;</return>
        <case>case <expr><name>WALRCV_STREAMING</name></expr>:</case>
            <return>return <expr><literal type="string">"streaming"</literal></expr>;</return>
        <case>case <expr><name>WALRCV_WAITING</name></expr>:</case>
            <return>return <expr><literal type="string">"waiting"</literal></expr>;</return>
        <case>case <expr><name>WALRCV_RESTARTING</name></expr>:</case>
            <return>return <expr><literal type="string">"restarting"</literal></expr>;</return>
        <case>case <expr><name>WALRCV_STOPPING</name></expr>:</case>
            <return>return <expr><literal type="string">"stopping"</literal></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><literal type="string">"UNKNOWN"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns activity of WAL receiver, including pid, state and xlog locations
 * received from the WAL sender of another server.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_stat_get_wal_receiver</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>ready_to_display</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WalRcvState</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>receive_start_lsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>receive_start_tli</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>received_lsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>received_tli</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_send_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_receipt_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>latest_end_lsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>latest_end_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>slotname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>conninfo</name></decl>;</decl_stmt>

    <comment type="block">/* Take a lock to ensure value consistency */</comment>
    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ready_to_display</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>ready_to_display</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>walRcvState</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>receive_start_lsn</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receiveStart</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>receive_start_tli</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>received_lsn</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receivedUpto</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>received_tli</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receivedTLI</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last_send_time</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>lastMsgSendTime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last_receipt_time</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>lastMsgReceiptTime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>latest_end_lsn</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>latestWalEnd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>latest_end_time</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>latestWalEndTime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>slotname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conninfo</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * No WAL receiver (or not ready yet), just return a tuple with NULL
     * values
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>ready_to_display</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* determine result type */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch values */</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Only superusers can see details. Other users only get the pid value
         * to know whether it is a WAL receiver, but no details.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>WalRcvGetStateString</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>receive_start_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>receive_start_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>receive_start_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>received_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>received_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>last_send_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>last_send_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>last_receipt_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>last_receipt_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>latest_end_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>latest_end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>latest_end_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>latest_end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>slotname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>conninfo</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Returns the record as Datum */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
