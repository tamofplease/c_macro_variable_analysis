<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/replication/logical/relation.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 * relation.c
 *       PostgreSQL logical replication
 *
 * Copyright (c) 2016-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      src/backend/replication/logical/relation.c
 *
 * NOTES
 *      This file contains helper functions for logical replication relation
 *      mapping cache.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalrelation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/worker_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical_statistic.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>LogicalRepRelMapContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>LogicalRepRelMap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>LogicalRepTypMap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>g_logical_apply_ignore_pk_conflict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>g_am_tbase_logical_apply_worker</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>logicalrep_typmap_invalidate_cb</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>,
                                <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Relcache invalidation callback for our relation map cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logicalrep_relmap_invalidate_cb</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* Just to be sure. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LogicalRepRelMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>reloid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LogicalRepRelMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* TODO, use inverse lookup hashtable? */</comment>
        <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>LogicalRepRelMapEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name> <operator>==</operator> <name>reloid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* invalidate all cache entries */</comment>
        <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LogicalRepRelMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>LogicalRepRelMapEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the relation map cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logicalrep_relmap_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>ctl</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LogicalRepRelMapContext</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>LogicalRepRelMapContext</name> <operator>=</operator>
            <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
                                  <argument><expr><literal type="string">"LogicalRepRelMapContext"</literal></expr></argument>,
                                  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Initialize the relation hash table. */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRepRelId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRepRelMapEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>LogicalRepRelMapContext</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>LogicalRepRelMap</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"logicalrep relation map cache"</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                                   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize the type hash table. */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRepTyp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>LogicalRepRelMapContext</name></expr>;</expr_stmt>

    <comment type="block">/* This will usually be small. */</comment>
    <expr_stmt><expr><name>LogicalRepTypMap</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"logicalrep type map cache"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
                                   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Watch for invalidation events. */</comment>
    <expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>logicalrep_relmap_invalidate_cb</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>logicalrep_typmap_invalidate_cb</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free the entry of a relation map cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logicalrep_relmap_free_entry</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LogicalRepRelation</name> <modifier>*</modifier></type><name>remoterel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>remoterel</name> <operator>=</operator> <operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>attnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>atttyps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>attkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>attrmap</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>attrmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Add new entry or update existing entry in the relation map cache.
 *
 * Called when new relation mapping is sent by the publisher to update
 * our expected view of incoming data from said publisher.
 */</comment>
<function><type><name>void</name></type>
<name>logicalrep_relmap_update</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelation</name> <modifier>*</modifier></type><name>remoterel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>LogicalRepRelMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>logicalrep_relmap_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * HASH_ENTER returns the existing entry if present or creates a new one.
     */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LogicalRepRelMap</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>remoterel</name><operator>-&gt;</operator><name>remoteid</name></name></expr></argument>,
                        <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>logicalrep_relmap_free_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRepRelMapEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make cached copy of the data */</comment>
    <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>LogicalRepRelMapContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>remoteid</name></name> <operator>=</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>remoteid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>nspname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>relname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>natts</name></name> <operator>=</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>attnames</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>atttyps</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>attnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>atttyps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>atttyps</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>replident</name></name> <operator>=</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>replident</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>attkeys</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>attkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_delete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_delete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find attribute index in TupleDesc struct by attribute name.
 *
 * Returns -1 if not found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>logicalrep_rel_att_by_name</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelation</name> <modifier>*</modifier></type><name>remoterel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open the local relation associated with the remote one.
 *
 * Optionally rebuilds the Relcache mapping if it was invalidated
 * by local DDL.
 */</comment>
<function><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type>
<name>logicalrep_rel_open</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelId</name></type> <name>remoteid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
	<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>LogicalRepRelMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>logicalrep_relmap_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Search for existing entry. */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LogicalRepRelMap</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>remoteid</name></expr></argument>,
                        <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>am_tbase_subscript_dispatch_worker</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="line">//elog(LOG, "no relation map entry for remote relation ID %u, ignoring this subscription", remoteid);</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no relation map entry for remote relation ID %u"</literal></expr></argument>,
			 	<argument><expr><name>remoteid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no relation map entry for remote relation ID %u"</literal></expr></argument>,
             <argument><expr><name>remoteid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Need to update the local cache? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>found</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>idkey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>desc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LogicalRepRelation</name> <modifier>*</modifier></type><name>remoterel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>remoterel</name> <operator>=</operator> <operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>remoterel</name></name></expr>;</expr_stmt>

        <comment type="block">/* Try to find and lock the relation by name. */</comment>
        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>,
                                              <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>am_tbase_subscript_dispatch_worker</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*Since the received data of the publisher's table does not have this table locally,
				 * the log will be printed frequently, which will cause log expand.
				 * So, comment it out first.
				 * */</comment>

				<comment type="line">//elog(LOG, "The subscriber cannot find the table name received from the publisher locally, ignoring the subscription for %s.%s.",</comment>
				<comment type="line">//			remoterel-&gt;nspname, remoterel-&gt;relname);</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
			    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication target relation \"%s.%s\" does not exist"</literal></expr></argument>,
                            <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>localrel</name></name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check for supported relkind. */</comment>
        <expr_stmt><expr><call><name>CheckSubscriptionRelkind</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>,
                                 <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Build the mapping of local attribute numbers to remote attribute
         * numbers and validate that we don't miss any replicated columns as
         * that would result in potentially unwanted data loss.
         */</comment>
        <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>LogicalRepRelMapContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>attrmap</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>attrmap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>logicalrep_rel_att_by_name</name><argument_list>(<argument><expr><name>remoterel</name></expr></argument>,
                                                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>attrmap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* TODO, detail message with names of missing columns */</comment>
        <if_stmt><if>if <condition>(<expr><name>found</name> <operator>&lt;</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication target relation \"%s.%s\" is missing "</literal>
                            <literal type="string">"some replicated columns"</literal></expr></argument>,
                            <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check that replica identity matches. We allow for stricter replica
         * identity (fewer columns) on subscriber as that will not stop us
         * from finding unique tuple. IE, if publisher has identity
         * (id,timestamp) and subscriber just (id) this will not be a problem,
         * but in the opposite scenario it will.
         *
         * Don't throw any error here just mark the relation entry as not
         * updatable, as replica identity is only for updates and deletes but
         * inserts can be replicated even without it.
         */</comment>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>updatable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idkey</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>,
                                           <argument><expr><name>INDEX_ATTR_BITMAP_IDENTITY_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fallback to PK if no replica identity */</comment>
        <if_stmt><if>if <condition>(<expr><name>idkey</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>idkey</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>,
                                               <argument><expr><name>INDEX_ATTR_BITMAP_PRIMARY_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If no replica identity index and no PK, the published table
             * must have replica identity FULL.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>idkey</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>remoterel</name><operator>-&gt;</operator><name>replident</name></name> <operator>!=</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>updatable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>idkey</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><name>i</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttrNumberIsForUserDefinedAttr</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication target relation \"%s.%s\" uses "</literal>
                                <literal type="string">"system columns in REPLICA IDENTITY index"</literal></expr></argument>,
                                <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>attrmap</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>remoterel</name><operator>-&gt;</operator><name>attkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>updatable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>localrel</name></name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>MySubscription</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>SUBREL_STATE_READY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>GetSubscriptionRelState</name><argument_list>(<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
					            <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>statelsn</name></name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close the previously opened logical relation.
 */</comment>
<function><type><name>void</name></type>
<name>logicalrep_rel_close</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Type cache invalidation callback for our type map cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logicalrep_typmap_invalidate_cb</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogicalRepTyp</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* Just to be sure. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LogicalRepTypMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* invalidate all cache entries */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LogicalRepTypMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>LogicalRepTyp</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Free the type map cache entry data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logicalrep_typmap_free_entry</name><parameter_list>(<parameter><decl><type><name>LogicalRepTyp</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add new entry or update existing entry in the type map cache.
 */</comment>
<function><type><name>void</name></type>
<name>logicalrep_typmap_update</name><parameter_list>(<parameter><decl><type><name>LogicalRepTyp</name> <modifier>*</modifier></type><name>remotetyp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogicalRepTyp</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>LogicalRepTypMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>logicalrep_relmap_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * HASH_ENTER returns the existing entry if present or creates a new one.
     */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LogicalRepTypMap</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>remotetyp</name><operator>-&gt;</operator><name>remoteid</name></name></expr></argument>,
                        <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>logicalrep_typmap_free_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Make cached copy of the data */</comment>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>remoteid</name></name> <operator>=</operator> <name><name>remotetyp</name><operator>-&gt;</operator><name>remoteid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>LogicalRepRelMapContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nspname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>remotetyp</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>typname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>remotetyp</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch type info from the cache.
 */</comment>
<function><type><name>Oid</name></type>
<name>logicalrep_typmap_getid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>remoteid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LogicalRepTyp</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>nspoid</name></decl>;</decl_stmt>

    <comment type="block">/* Internal types are mapped directly. */</comment>
    <if_stmt><if>if <condition>(<expr><name>remoteid</name> <operator>&lt;</operator> <name>FirstNormalObjectId</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_typisdefined</name><argument_list>(<argument><expr><name>remoteid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"builtin type %u not found"</literal></expr></argument>, <argument><expr><name>remoteid</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This can be caused by having publisher with "</literal>
                             <literal type="string">"higher major version than subscriber"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>remoteid</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>LogicalRepTypMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>logicalrep_relmap_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Try finding the mapping. */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LogicalRepTypMap</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>remoteid</name></expr></argument>,
                        <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no type map entry for remote type %u"</literal></expr></argument>,
             <argument><expr><name>remoteid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Found and mapped, return the oid. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Otherwise, try to map to local type. */</comment>
    <expr_stmt><expr><name>nspoid</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
                                        <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type \"%s.%s\" required for logical replication does not exist"</literal></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>logicalrep_statis_update_for_sync</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* Just to be sure. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LogicalRepRelMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LogicalRepRelMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>LogicalRepRelMapEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//UpdateSubTableStatistics(subid, relid, 0, entry-&gt;ntups_insert, </comment>
            <comment type="line">//                         entry-&gt;ntups_delete, entry-&gt;checksum_insert, entry-&gt;checksum_delete, STATE_APPLY, false);</comment>
            <expr_stmt><expr><call><name>UpdateSubStatistics</name><argument_list>(<argument><expr><name>subname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_insert</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_delete</name></name></expr></argument>, 
                                <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_insert</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_delete</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_delete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_delete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>logicalrep_statis_update_for_apply</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* Just to be sure. */</comment>
    <if_stmt><if>if <condition>(<expr><name>LogicalRepRelMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LogicalRepRelMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>LogicalRepRelMapEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>localreloid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//UpdateSubTableStatistics(subid, entry-&gt;localreloid, 0, entry-&gt;ntups_insert, </comment>
            <comment type="line">//                         entry-&gt;ntups_delete, entry-&gt;checksum_insert, entry-&gt;checksum_delete, STATE_APPLY, false);</comment>
            <expr_stmt><expr><call><name>UpdateSubStatistics</name><argument_list>(<argument><expr><name>subname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_insert</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_delete</name></name></expr></argument>, 
                                <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_insert</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_delete</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ntups_delete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>checksum_delete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<function><type><name>bool</name></type> <name>AmTbaseSubscriptionApplyWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>g_am_tbase_logical_apply_worker</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>TbaseSubscriptionApplyWorkerSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>g_am_tbase_logical_apply_worker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>TbaseSubscriptionApplyWorkerReset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>g_am_tbase_logical_apply_worker</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>logicl_apply_set_ignor_pk_conflict</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ignore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>g_logical_apply_ignore_pk_conflict</name> <operator>=</operator> <name>ignore</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>logicl_aply_rset_ignor_pk_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>logicl_apply_set_ignor_pk_conflict</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>logical_apply_ignore_pk_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>g_logical_apply_ignore_pk_conflict</name></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
 * Executor state preparation for evaluation of constraint expressions,
 * indexes and triggers.
 *
 * This is based on similar code in copy.c
 */</comment>
static EState *
logical_apply_create_estate_for_rel_dn_exec(Relation rel)
{
    EState       *estate = NULL;
    ResultRelInfo *resultRelInfo = NULL;
    RangeTblEntry *rte = NULL;

    estate = CreateExecutorState();

    rte = makeNode(RangeTblEntry);
    rte-&gt;rtekind = RTE_RELATION;
    rte-&gt;relid = RelationGetRelid(rel);
    rte-&gt;relkind = rel-&gt;rd_rel-&gt;relkind;
    estate-&gt;es_range_table = list_make1(rte);

    resultRelInfo = makeNode(ResultRelInfo);
    InitResultRelInfo(resultRelInfo, rel, 1, NULL, 0);

    estate-&gt;es_result_relations = resultRelInfo;
    estate-&gt;es_num_result_relations = 1;
    estate-&gt;es_result_relation_info = resultRelInfo;

    <comment type="block">/* Triggers might need a slot */</comment>
    if (resultRelInfo-&gt;ri_TrigDesc)
        estate-&gt;es_trig_tuple_slot = ExecInitExtraTupleSlot(estate);

    <comment type="block">/* Prepare to catch AFTER triggers. */</comment>
    AfterTriggerBeginQuery();

    return estate;
}

<comment type="block">/*
 * Executes default values for columns for which we can't map to remote
 * relation columns.
 *
 * This allows us to support tables which have more columns on the downstream
 * than on the upstream.
 */</comment>
static void
logical_apply_slot_fill_defaults_dn_exec(Relation rel,
                                    EState *estate,
                                       TupleTableSlot *slot,
                                       char **values)
{
    TupleDesc    desc = RelationGetDescr(rel);
    int            num_phys_attrs = desc-&gt;natts;
    int            i = 0;
    int            attnum = 0,
                num_defaults = 0;
    int           *defmap = NULL;
    ExprState **defexprs = NULL;
    ExprContext *econtext = NULL;
	int         upstream_att_index = 0;

    econtext = GetPerTupleExprContext(estate);
    defmap = (int *) palloc(num_phys_attrs * sizeof(int));
    defexprs = (ExprState **) palloc(num_phys_attrs * sizeof(ExprState *));

    for (attnum = 0; attnum &lt; num_phys_attrs; attnum++)
    {
        Expr       *defexpr = NULL;

		if (desc-&gt;attrs[attnum]-&gt;attisdropped)
            continue;

		if (values[upstream_att_index] != NULL)
		{
			upstream_att_index++;
			continue;
		}

        defexpr = (Expr *) build_column_default(rel, attnum + 1);

        if (defexpr != NULL)
        {
            <comment type="block">/* Run the expression through planner */</comment>
            defexpr = expression_planner(defexpr);

            <comment type="block">/* Initialize executable expression in copycontext */</comment>
            defexprs[num_defaults] = ExecInitExpr(defexpr, NULL);
            defmap[num_defaults] = attnum;
            num_defaults++;
        }
		upstream_att_index++;
    }

    for (i = 0; i &lt; num_defaults; i++)
        slot-&gt;tts_values[defmap[i]] =
            ExecEvalExpr(defexprs[i], econtext, &amp;slot-&gt;tts_isnull[defmap[i]]);
}

<comment type="block">/*
 * Store data in C string form into slot.
 * This is similar to BuildTupleFromCStrings but TupleTableSlot fits our
 * use better.
 */</comment>
static void
logical_apply_slot_store_cstrings_dn_exec(TupleTableSlot *slot,
                                        Relation rel,
                                        char **values)
{
    int            natts = slot-&gt;tts_tupleDescriptor-&gt;natts;
    int            i = 0;
	int         upstream_att_index = 0;

    ExecClearTuple(slot);

    <comment type="block">/* Call the "in" function for each non-dropped attribute */</comment>
    for (i = 0; i &lt; natts; i++)
    {
        Form_pg_attribute att = slot-&gt;tts_tupleDescriptor-&gt;attrs[i];

		if (att-&gt;attisdropped)
		{
			<comment type="block">/*
			 * We assign NULL to dropped attributes, NULL values, and missing
			 * values (missing values should be later filled using
			 * logical_apply_slot_fill_defaults).
			 */</comment>
			slot-&gt;tts_values[i] = (Datum) 0;
			slot-&gt;tts_isnull[i] = true;
			continue;
		}

		if (values[upstream_att_index] != NULL)
        {
            Oid            typinput = InvalidOid;
            Oid            typioparam = InvalidOid;

            getTypeInputInfo(att-&gt;atttypid, &amp;typinput, &amp;typioparam);
            slot-&gt;tts_values[i] = OidInputFunctionCall(typinput,
													   values[upstream_att_index],
                                                       typioparam,
                                                       att-&gt;atttypmod);
            slot-&gt;tts_isnull[i] = false;

        }
        else
        {
            <comment type="block">/*
             * We assign NULL to dropped attributes, NULL values, and missing
             * values (missing values should be later filled using
             * logical_apply_slot_fill_defaults).
             */</comment>
            slot-&gt;tts_values[i] = (Datum) 0;
            slot-&gt;tts_isnull[i] = true;
        }

		upstream_att_index++;

    }

    ExecStoreVirtualTuple(slot);
}

<comment type="block">/*
 * Modify slot with user data provided as C strings.
 * This is somewhat similar to heap_modify_tuple but also calls the type
 * input function on the user data as the input is the text representation
 * of the types.
 */</comment>
static void
logical_apply_slot_modify_cstrings_dn_exec(TupleTableSlot *slot,
                                        Relation rel,
                                         char **values,
                                         bool *replaces)
{
    int            natts = slot-&gt;tts_tupleDescriptor-&gt;natts;
    int            i = 0;
	int         upstream_att_index = 0;

    slot_getallattrs(slot);
    ExecClearTuple(slot);

    <comment type="block">/* Call the "in" function for each replaced attribute */</comment>
    for (i = 0; i &lt; natts; i++)
    {
        Form_pg_attribute att = slot-&gt;tts_tupleDescriptor-&gt;attrs[i];

		if (att-&gt;attisdropped)
            continue;

		if (!replaces[upstream_att_index])
		{
			upstream_att_index++;
			continue;
		}

		if (values[upstream_att_index] != NULL)
        {
            Oid            typinput = InvalidOid;
            Oid            typioparam = InvalidOid;

            getTypeInputInfo(att-&gt;atttypid, &amp;typinput, &amp;typioparam);
            slot-&gt;tts_values[i] = OidInputFunctionCall(typinput,
													   values[upstream_att_index],
                                                       typioparam,
                                                       att-&gt;atttypmod);
            slot-&gt;tts_isnull[i] = false;
        }
        else
        {
            slot-&gt;tts_values[i] = (Datum) 0;
            slot-&gt;tts_isnull[i] = true;
        }

		upstream_att_index++;
    }

    ExecStoreVirtualTuple(slot);
}

<comment type="block">/*
 * logical apply insert message from CN
 */</comment>
static void
logical_apply_insert_dn_exec(StringInfo s)
{
    Relation rel = NULL;
    LogicalRepTupleData newtup;
    EState       *estate = NULL;
    TupleTableSlot *remoteslot = NULL;
    MemoryContext oldctx = NULL;

    char       *nspname = NULL;
    char       *relname = NULL;
    char        replident = 0;

    MemSet(&amp;newtup, 0, sizeof(LogicalRepTupleData));

    logicalrep_read_insert(s, &amp;nspname, &amp;relname, &amp;replident, &amp;newtup);

    rel = relation_openrv(makeRangeVar(nspname, relname, -1), RowExclusiveLock);

    <comment type="block">/* Check for supported relkind. */</comment>
    CheckSubscriptionRelkind(rel-&gt;rd_rel-&gt;relkind, nspname, relname);

    <comment type="block">/* Initialize the executor state. */</comment>
    estate = logical_apply_create_estate_for_rel(rel);
    remoteslot = ExecInitExtraTupleSlot(estate);
    ExecSetSlotDescriptor(remoteslot, RelationGetDescr(rel));

    <comment type="block">/* Process and store remote tuple in the slot */</comment>
    oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));
    logical_apply_slot_store_cstrings(remoteslot, rel, newtup.values);
    logical_apply_slot_fill_defaults(rel, estate, remoteslot, newtup.values);
    MemoryContextSwitchTo(oldctx);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <comment type="block">/* use local snapshot instead of global snapshot */</comment>
    PushActiveSnapshot(GetLocalTransactionSnapshot());
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    PushActiveSnapshot(GetTransactionSnapshot());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ExecOpenIndices(estate-&gt;es_result_relation_info, false);

    <comment type="block">/* Do the insert. */</comment>
    ExecSimpleRelationInsert(estate, remoteslot);

    <comment type="block">/* Cleanup. */</comment>
    ExecCloseIndices(estate-&gt;es_result_relation_info);
    PopActiveSnapshot();

    <comment type="block">/* Handle queued AFTER triggers. */</comment>
    AfterTriggerEndQuery(estate);

    ExecResetTupleTable(estate-&gt;es_tupleTable, false);
    FreeExecutorState(estate);

    heap_close(rel, RowExclusiveLock);

    CommandCounterIncrement();
}

<comment type="block">/*
 * logical apply update message from CN
 */</comment>
static void 
logical_apply_update_dn_exec_dn_exec(StringInfo s)
{
    Relation     rel = NULL;
    Oid            idxoid = InvalidOid;
    EState       *estate = NULL;
    EPQState    epqstate;
    LogicalRepTupleData oldtup;
    LogicalRepTupleData newtup;
    bool        has_oldtup = false;
    TupleTableSlot *localslot = NULL;
    TupleTableSlot *remoteslot = NULL;
    bool        found = false;
    MemoryContext oldctx = NULL;

    char       *nspname = NULL;
    char       *relname = NULL;
    char        replident = 0;

    MemSet(&amp;epqstate, 0, sizeof(EPQState));
    MemSet(&amp;oldtup, 0, sizeof(LogicalRepTupleData));
    MemSet(&amp;newtup, 0, sizeof(LogicalRepTupleData));

    logicalrep_read_update(s, &amp;nspname, &amp;relname, &amp;replident,
                                &amp;has_oldtup, &amp;oldtup, &amp;newtup);

    rel = relation_openrv(makeRangeVar(nspname, relname, -1), RowExclusiveLock);

    <comment type="block">/* Check for supported relkind. */</comment>
    CheckSubscriptionRelkind(rel-&gt;rd_rel-&gt;relkind, nspname, relname);

    <comment type="block">/* Initialize the executor state. */</comment>
    estate = logical_apply_create_estate_for_rel(rel);
    remoteslot = ExecInitExtraTupleSlot(estate);
    ExecSetSlotDescriptor(remoteslot, RelationGetDescr(rel));
    localslot = ExecInitExtraTupleSlot(estate);
    ExecSetSlotDescriptor(localslot, RelationGetDescr(rel));
    EvalPlanQualInit(&amp;epqstate, estate, NULL, NIL, -1);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <comment type="block">/* use local snapshot instead of global snapshot */</comment>
    PushActiveSnapshot(GetLocalTransactionSnapshot());
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    PushActiveSnapshot(GetTransactionSnapshot());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ExecOpenIndices(estate-&gt;es_result_relation_info, false);

    <comment type="block">/* Build the search tuple. */</comment>
    oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));
    logical_apply_slot_store_cstrings(remoteslot, rel,
                                            has_oldtup ? oldtup.values : newtup.values);
    MemoryContextSwitchTo(oldctx);

    <comment type="block">/*
     * Try to find tuple using either replica identity index, primary key or
     * if needed, sequential scan.
     */</comment>
    idxoid = GetRelationIdentityOrPK(rel);
    Assert(OidIsValid(idxoid) ||
           (replident == REPLICA_IDENTITY_FULL &amp;&amp; has_oldtup));

    if (OidIsValid(idxoid))
        found = RelationFindReplTupleByIndex(rel, idxoid,
                                             LockTupleExclusive,
                                             remoteslot, localslot);
    else
        found = RelationFindReplTupleSeq(rel, LockTupleExclusive,
                                         remoteslot, localslot);

    ExecClearTuple(remoteslot);

    <comment type="block">/*
     * Tuple found.
     *
     * Note this will fail if there are other conflicting unique indexes.
     */</comment>
    if (found)
    {
        <comment type="block">/* Process and store remote tuple in the slot */</comment>
        oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));
        ExecStoreTuple(localslot-&gt;tts_tuple, remoteslot, InvalidBuffer, false);
        logical_apply_slot_modify_cstrings(remoteslot, rel, newtup.values, newtup.changed);
        MemoryContextSwitchTo(oldctx);

        EvalPlanQualSetSlot(&amp;epqstate, remoteslot);

        <comment type="block">/* Do the actual update. */</comment>
        ExecSimpleRelationUpdate(estate, &amp;epqstate, localslot, remoteslot);
    }
    else
    {
        <comment type="block">/*
         * The tuple to be updated could not be found.
         *
         * TODO what to do here, change the log level to LOG perhaps?
         */</comment>
        elog(DEBUG1,
             "logical apply did not find row for update "
             "in apply target relation \"%s\"",
             RelationGetRelationName(rel));
    }

    <comment type="block">/* Cleanup. */</comment>
    ExecCloseIndices(estate-&gt;es_result_relation_info);
    PopActiveSnapshot();

    <comment type="block">/* Handle queued AFTER triggers. */</comment>
    AfterTriggerEndQuery(estate);

    EvalPlanQualEnd(&amp;epqstate);
    ExecResetTupleTable(estate-&gt;es_tupleTable, false);
    FreeExecutorState(estate);

    heap_close(rel, RowExclusiveLock);

    CommandCounterIncrement();
}

<comment type="block">/*
 * logical apply delete message from CN
 */</comment>
static void
logical_apply_delete_dn_exec(StringInfo s)
{
    Relation             rel = NULL;
    LogicalRepTupleData oldtup;
    Oid            idxoid = InvalidOid;
    EState       *estate = NULL;
    EPQState    epqstate;
    TupleTableSlot *remoteslot = NULL;
    TupleTableSlot *localslot = NULL;
    bool        found = false;
    MemoryContext oldctx = NULL;

    char       *nspname = NULL;
    char       *relname = NULL;
    char        replident = 0;

    MemSet(&amp;epqstate, 0, sizeof(EPQState));
    MemSet(&amp;oldtup, 0, sizeof(LogicalRepTupleData));

    logicalrep_read_delete(s, &amp;nspname, &amp;relname, &amp;replident, &amp;oldtup);

    rel = relation_openrv(makeRangeVar(nspname, relname, -1), RowExclusiveLock);

    <comment type="block">/* Check for supported relkind. */</comment>
    CheckSubscriptionRelkind(rel-&gt;rd_rel-&gt;relkind, nspname, relname);

    <comment type="block">/* Initialize the executor state. */</comment>
    estate = logical_apply_create_estate_for_rel(rel);
    remoteslot = ExecInitExtraTupleSlot(estate);
    ExecSetSlotDescriptor(remoteslot, RelationGetDescr(rel));
    localslot = ExecInitExtraTupleSlot(estate);
    ExecSetSlotDescriptor(localslot, RelationGetDescr(rel));
    EvalPlanQualInit(&amp;epqstate, estate, NULL, NIL, -1);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
    <comment type="block">/* use local snapshot instead of global snapshot */</comment>
    PushActiveSnapshot(GetLocalTransactionSnapshot());
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    PushActiveSnapshot(GetTransactionSnapshot());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ExecOpenIndices(estate-&gt;es_result_relation_info, false);

    <comment type="block">/* Find the tuple using the replica identity index. */</comment>
    oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));
    logical_apply_slot_store_cstrings(remoteslot, rel, oldtup.values);
    MemoryContextSwitchTo(oldctx);

    <comment type="block">/*
     * Try to find tuple using either replica identity index, primary key or
     * if needed, sequential scan.
     */</comment>
    idxoid = GetRelationIdentityOrPK(rel);
    Assert(OidIsValid(idxoid) ||
           (replident == REPLICA_IDENTITY_FULL));

    if (OidIsValid(idxoid))
        found = RelationFindReplTupleByIndex(rel, idxoid,
                                             LockTupleExclusive,
                                             remoteslot, localslot);
    else
        found = RelationFindReplTupleSeq(rel, LockTupleExclusive,
                                         remoteslot, localslot);
    <comment type="block">/* If found delete it. */</comment>
    if (found)
    {
        EvalPlanQualSetSlot(&amp;epqstate, localslot);

        <comment type="block">/* Do the actual delete. */</comment>
        ExecSimpleRelationDelete(estate, &amp;epqstate, localslot);
    }
    else
    {
        <comment type="block">/* The tuple to be deleted could not be found. */</comment>
        ereport(DEBUG1,
                (errmsg("logical apply could not find row for delete "
                        "in apply target %s",
                        RelationGetRelationName(rel))));
    }

    <comment type="block">/* Cleanup. */</comment>
    ExecCloseIndices(estate-&gt;es_result_relation_info);
    PopActiveSnapshot();

    <comment type="block">/* Handle queued AFTER triggers. */</comment>
    AfterTriggerEndQuery(estate);

    EvalPlanQualEnd(&amp;epqstate);
    ExecResetTupleTable(estate-&gt;es_tupleTable, false);
    FreeExecutorState(estate);

    heap_close(rel, RowExclusiveLock);

    CommandCounterIncrement();
}

<comment type="block">/*
 * logical apply Handle RELATION message from CN.
 *
 * Note we don't do validation against local schema here. The validation
 * against local schema is postponed until first change for given relation
 * comes as we only care about it when applying changes for it anyway and we
 * do less locking this way.
 */</comment>
static void
logical_apply_relation_dn_exec(StringInfo s)
{
	LogicalRepRelation *rel;

	rel = logicalrep_read_rel(s);
	logicalrep_relmap_update(rel);
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
