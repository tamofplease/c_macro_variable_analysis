<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/replication/logical/reorderbuffer.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * reorderbuffer.c
 *      PostgreSQL logical replay/reorder buffer management
 *
 *
 * Copyright (c) 2012-2017, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/replication/reorderbuffer.c
 *
 * NOTES
 *      This module gets handed individual pieces of transactions in the order
 *      they are written to the WAL and is responsible to reassemble them into
 *      toplevel transaction sized pieces. When a transaction is completely
 *      reassembled - signalled by reading the transaction commit record - it
 *      will then call the output plugin (c.f. ReorderBufferCommit()) with the
 *      individual changes. The output plugins rely on snapshots built by
 *      snapbuild.c which hands them to us.
 *
 *      Transactions and subtransactions/savepoints in postgres are not
 *      immediately linked to each other from outside the performing
 *      backend. Only at commit/abort (or special xact_assignment records) they
 *      are linked together. Which means that we will have to splice together a
 *      toplevel transaction from its subtransactions. To do that efficiently we
 *      build a binary heap indexed by the smallest current lsn of the individual
 *      subtransactions' changestreams. As the individual streams are inherently
 *      ordered by LSN - since that is where we build them from - the transaction
 *      can easily be reassembled by always using the subtransaction with the
 *      smallest current LSN from the heap.
 *
 *      In order to cope with large transactions - which can be several times as
 *      big as the available memory - this module supports spooling the contents
 *      of a large transactions to disk. When the transaction is replayed the
 *      contents of individual (sub-)transactions will be read from disk in
 *      chunks.
 *
 *      This module also has to deal with reassembling toast records from the
 *      individual chunks stored in WAL. When a new (or initial) version of a
 *      tuple is stored in WAL it will always be preceded by the toast chunks
 *      emitted for the columns stored out of line. Within a single toplevel
 *      transaction there will be no other data carrying records between a row's
 *      toast chunks and the row data itself. See ReorderBufferToast* for
 *      details.
 * -------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rewriteheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/binaryheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/reorderbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/snapbuild.h"</cpp:file></cpp:include>    <comment type="block">/* just for SnapBuildSnapDecRefcount */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/combocid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relfilenodemap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<comment type="block">/* entry for a hash table we use to map from xid to our transaction state */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferTXNByIdEnt</name>
<block>{
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferTXNByIdEnt</name>;</typedef>

<comment type="block">/* data structures for (relfilenode, ctid) =&gt; (cmin, cmax) mapping */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferTupleCidKey</name>
<block>{
    <decl_stmt><decl><type><name>RelFileNode</name></type> <name>relnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferTupleCidKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ReorderBufferTupleCidEnt</name>
<block>{
    <decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>cmin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>cmax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>combocid</name></decl>;</decl_stmt>        <comment type="block">/* just for debugging */</comment>
}</block></struct></type> <name>ReorderBufferTupleCidEnt</name>;</typedef>

<comment type="block">/* k-way in-order change iteration support structures */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferIterTXNEntry</name>
<block>{
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>segno</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferIterTXNEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ReorderBufferIterTXNState</name>
<block>{
    <decl_stmt><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>heap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>nr_txns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dlist_head</name></type>    <name>old_change</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferIterTXNEntry</name></type> <name><name>entries</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferIterTXNState</name>;</typedef>

<comment type="block">/* toast datastructures */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferToastEnt</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>            <name>chunk_id</name></decl>;</decl_stmt>        <comment type="block">/* toast_table.chunk_id */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>last_chunk_seq</name></decl>;</decl_stmt> <comment type="block">/* toast_table.chunk_seq of the last chunk we
                                 * have seen */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>num_chunks</name></decl>;</decl_stmt>        <comment type="block">/* number of chunks we've already seen */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>            <comment type="block">/* combined size of chunks seen */</comment>
    <decl_stmt><decl><type><name>dlist_head</name></type>    <name>chunks</name></decl>;</decl_stmt>            <comment type="block">/* linked list of chunks */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>reconstructed</name></decl>;</decl_stmt>    <comment type="block">/* reconstructed varlena now pointed to in
                                     * main tup */</comment>
}</block></struct></type> <name>ReorderBufferToastEnt</name>;</typedef>

<comment type="block">/* Disk serialization support datastructures */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferDiskChange</name>
<block>{
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferChange</name></type> <name>change</name></decl>;</decl_stmt>
    <comment type="block">/* data follows */</comment>
}</block></struct></type> <name>ReorderBufferDiskChange</name>;</typedef>

<comment type="block">/*
 * Maximum number of changes kept in memory, per transaction. After that,
 * changes are spooled to disk.
 *
 * The current value should be sufficient to decode the entire transaction
 * without hitting disk in OLTP workloads, while starting to spool to disk in
 * other workloads reasonably fast.
 *
 * At some point in the future it probably makes sense to have a more elaborate
 * resource management here, but it's not entirely clear what that would look
 * like.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Size</name></type> <name>max_changes_in_memory</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * We use a very simple form of a slab allocator for frequently allocated
 * objects, simply keeping a fixed number in a linked list when unused,
 * instead pfree()ing them. Without that in many workloads aset.c becomes a
 * major bottleneck, especially when spilling to disk while decoding batch
 * workloads.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Size</name></type> <name>max_cached_tuplebufs</name> <init>= <expr><literal type="number">4096</literal> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* ~8MB */</comment>

<comment type="block">/* ---------------------------------------
 * primary reorderbuffer support routines
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>ReorderBufferGetTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferReturnTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>ReorderBufferTXNByXid</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>,
                      <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_new</name></decl></parameter>,
                      <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_as_top</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssertTXNLsnOrder</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ---------------------------------------
 * support functions for lsn-order iterating over the -&gt;changes of a
 * transaction and its subtransactions
 *
 * used for iteration over the k-way heap merge of a transaction and its
 * subtransactions
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>ReorderBufferIterTXNInit</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferChange</name> <modifier>*</modifier></type><name>ReorderBufferIterTXNNext</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferIterTXNFinish</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>,
                           <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferExecuteInvalidations</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * ---------------------------------------
 * Disk serialization support functions
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferCheckSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferSerializeChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                             <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>ReorderBufferRestoreChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                            <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferRestoreChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                           <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferRestoreCleanup</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferFreeSnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>ReorderBufferCopySnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>orig_snap</name></decl></parameter>,
                      <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ---------------------------------------
 * toast reassembly support
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastInitHash</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastReset</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastReplace</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                          <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastAppendChunk</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                              <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Allocate a new ReorderBuffer
 */</comment>
<function><type><name>ReorderBuffer</name> <modifier>*</modifier></type>
<name>ReorderBufferAllocate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>new_ctx</name></decl>;</decl_stmt>

    <comment type="block">/* allocate memory in own context, to have better accountability */</comment>
    <expr_stmt><expr><name>new_ctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                    <argument><expr><literal type="string">"ReorderBuffer"</literal></expr></argument>,
                                    <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buffer</name> <operator>=</operator>
        <operator>(</operator><name>ReorderBuffer</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>new_ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>new_ctx</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>change_context</name></name> <operator>=</operator> <call><name>SlabContextCreate</name><argument_list>(<argument><expr><name>new_ctx</name></expr></argument>,
                                               <argument><expr><literal type="string">"Change"</literal></expr></argument>,
                                               <argument><expr><name>SLAB_DEFAULT_BLOCK_SIZE</name></expr></argument>,
                                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>txn_context</name></name> <operator>=</operator> <call><name>SlabContextCreate</name><argument_list>(<argument><expr><name>new_ctx</name></expr></argument>,
                                            <argument><expr><literal type="string">"TXN"</literal></expr></argument>,
                                            <argument><expr><name>SLAB_DEFAULT_BLOCK_SIZE</name></expr></argument>,
                                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXNByIdEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>by_txn</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ReorderBufferByXid"</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nr_cached_tuplebufs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>current_restart_decoding_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>slist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><operator>-&gt;</operator><name>cached_tuplebufs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a ReorderBuffer
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferFree</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We free separately allocated data by entirely scrapping reorderbuffer's
     * memory context.
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get an unused, possibly preallocated, ReorderBufferTXN.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type>
<name>ReorderBufferGetTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTXN</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>txn_context</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>txn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>tuplecids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>subtxns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>txn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a ReorderBufferTXN.
 *
 * Deallocation might be delayed for efficiency purposes, for details check
 * the comments above max_cached_changes's definition.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferReturnTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* clean the lookup cache if we were cached (quite likely) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>==</operator> <name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* free data that's contained */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get an unused, possibly preallocated, ReorderBufferChange.
 */</comment>
<function><type><name>ReorderBufferChange</name> <modifier>*</modifier></type>
<name>ReorderBufferGetChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>change</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferChange</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>change_context</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>change</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>change</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free an ReorderBufferChange.
 *
 * Deallocation might be delayed for efficiency purposes, for details check
 * the comments above max_cached_changes's definition.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferReturnChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* free contained data */</comment>
    <switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReorderBufferReturnTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReorderBufferReturnTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
            <comment type="block">/* no data in addition to the struct itself */</comment>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get an unused, possibly preallocated, ReorderBufferTupleBuf fitting at
 * least a tuple of size tuple_len (excluding header overhead).
 */</comment>
<function><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type>
<name>ReorderBufferGetTupleBuf</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>tuple_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>alloc_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>alloc_len</name> <operator>=</operator> <name>tuple_len</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Most tuples are below MaxHeapTupleSize, so we use a slab allocator for
     * those. Thus always allocate at least MaxHeapTupleSize. Note that tuples
     * generated for oldtuples can be bigger, as they don't have out-of-line
     * toast columns.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>alloc_len</name> <operator>&lt;</operator> <name>MaxHeapTupleSize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>alloc_len</name> <operator>=</operator> <name>MaxHeapTupleSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/* if small enough, check the slab cache */</comment>
    <if_stmt><if>if <condition>(<expr><name>alloc_len</name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name> <operator>&amp;&amp;</operator> <name><name>rb</name><operator>-&gt;</operator><name>nr_cached_tuplebufs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>nr_cached_tuplebufs</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>ReorderBufferTupleBuf</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                <argument><expr><call><name>slist_pop_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>cached_tuplebufs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name> <operator>==</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">0xa9</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><literal type="number">0xa8</literal></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleBuf</name> <operator>*</operator><operator>)</operator>
            <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleBuf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                               <name>MAXIMUM_ALIGNOF</name> <operator>+</operator> <name>alloc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name> <operator>=</operator> <name>alloc_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free an ReorderBufferTupleBuf.
 *
 * Deallocation might be delayed for efficiency purposes, for details check
 * the comments above max_cached_changes's definition.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferReturnTupleBuf</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* check whether to put into the slab cache, oversized tuples never are */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name> <operator>==</operator> <name>MaxHeapTupleSize</name> <operator>&amp;&amp;</operator>
        <name><name>rb</name><operator>-&gt;</operator><name>nr_cached_tuplebufs</name></name> <operator>&lt;</operator> <name>max_cached_tuplebufs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>nr_cached_tuplebufs</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>cached_tuplebufs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the ReorderBufferTXN from the given buffer, specified by Xid.
 * If create is true, and a transaction doesn't already exist, create it
 * (with the given LSN, and as top transaction if that's specified);
 * when this happens, is_new is set to true.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type>
<name>ReorderBufferTXNByXid</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_new</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_as_top</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTXNByIdEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>create</name> <operator>||</operator> <name>lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check the one-entry lookup cache first
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>txn</name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>txn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* found it, and it's valid */</comment>
            <if_stmt><if>if <condition>(<expr><name>is_new</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>is_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>txn</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * cached as non-existent, and asked not to create? Then nothing else
         * to do.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* otherwise fall through to create it */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the cache wasn't hit or it yielded an "does-not-exist" and we want
     * to create an entry.
     */</comment>

    <comment type="block">/* search the lookup table */</comment>
    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTXNByIdEnt</name> <operator>*</operator><operator>)</operator>
        <call><name>hash_search</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xid</name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>create</name></expr> ?</condition><then> <expr><name>HASH_ENTER</name></expr> </then><else>: <expr><name>HASH_FIND</name></expr></else></ternary></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>txn</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>txn</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>create</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* initialize the new entry, if creation was requested */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ent</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>txn</name></name> <operator>=</operator> <call><name>ReorderBufferGetTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>txn</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>txn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>restart_decoding_lsn</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>current_restart_decoding_lsn</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>create_as_top</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>AssertTXNLsnOrder</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>txn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>                <comment type="block">/* not found and not asked to create */</comment>

    <comment type="block">/* update cache */</comment>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name> <operator>=</operator> <name>txn</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_new</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>is_new</name> <operator>=</operator> <operator>!</operator><name>found</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>create</name> <operator>||</operator> <name>txn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>txn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Queue a change into a transaction so it can be replayed upon commit.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferQueueChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>,
                         <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name> <operator>!=</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReorderBufferCheckSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Queue message into a transaction so it can be processed upon commit.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferQueueMessage</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                          <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name></type> <name>transactional</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
                          <parameter><decl><type><name>Size</name></type> <name>message_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>transactional</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xid</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name> <operator>=</operator> <name>message_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>message_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>message_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>Snapshot</name></type> <name>snapshot_now</name> <init>= <expr><name>snapshot</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>xid</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* setup snapshot to allow catalog access */</comment>
        <expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>message</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>message_size</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssertTXNLsnOrder</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
    <decl_stmt><decl><type><name>dlist_iter</name></type>    <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>prev_first_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

    <macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;rb-&gt;toplevel_by_lsn</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>cur_txn</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cur_txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>&lt;=</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>prev_first_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prev_first_lsn</name> <operator>&lt;</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_txn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev_first_lsn</name> <operator>=</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type>
<name>ReorderBufferGetOldestTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>AssertTXNLsnOrder</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>txn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>txn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReorderBufferSetRestartPoint</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>current_restart_decoding_lsn</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReorderBufferAssignChild</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                         <parameter><decl><type><name>TransactionId</name></type> <name>subxid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>new_top</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>new_sub</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_top</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_sub</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>new_sub</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * we assign subtransactions to top level transaction even if we don't
         * have data for it yet, assignment records frequently reference xids
         * that have not yet produced any records. Knowing those aren't top
         * level xids allows us to make processing cheaper in some places.
         */</comment>
        <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>subtxns</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nsubtxns</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>nsubtxns</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remove from lsn order list of top-level transactions */</comment>
        <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* add to toplevel transaction */</comment>
        <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>subtxns</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nsubtxns</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>new_top</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"existing subxact assigned to unknown toplevel xact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Associate a subtransaction with its toplevel transaction at commit
 * time. There may be no further changes added after this.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferCommitChild</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                         <parameter><decl><type><name>TransactionId</name></type> <name>subxid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl></parameter>,
                         <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * No need to do anything if that subtxn didn't contain any changes
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>subtxn</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>commit_lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subxact logged without previous toplevel record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Pass our base snapshot to the parent transaction if it doesn't have
     * one, or ours is older. That can happen if there are no changes in the
     * toplevel transaction but in one of the child transactions. This allows
     * the parent to simply use its base snapshot initially.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
         <name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>&gt;</operator> <name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>commit_lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>nsubtxns</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remove from lsn order list of top-level transactions */</comment>
        <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* add to subtransaction list */</comment>
        <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>subtxns</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nsubtxns</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Support for efficiently iterating over a transaction's and its
 * subtransactions' changes.
 *
 * We do by doing a k-way merge between transactions/subtransactions. For that
 * we model the current heads of the different transactions as a binary heap
 * so we easily know which (sub-)transaction has the change with the smallest
 * lsn next.
 *
 * We assume the changes in individual transactions are already sorted by LSN.
 */</comment>

<comment type="block">/*
 * Binary heap comparison function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReorderBufferIterCompare</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ReorderBufferIterTXNState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>pos_a</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>lsn</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>pos_b</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>lsn</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pos_a</name> <operator>&lt;</operator> <name>pos_b</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>pos_a</name> <operator>==</operator> <name>pos_b</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate &amp; initialize an iterator which iterates in lsn order over a
 * transaction and all its subtransactions.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type>
<name>ReorderBufferIterTXNInit</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>nr_txns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dlist_iter</name></type>    <name>cur_txn_i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>off</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Calculate the size of our heap: one element for every transaction that
     * contains changes.  (Besides the transactions already in the reorder
     * buffer, we count the one we were directly passed.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nr_txns</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>dlist_foreach</name><argument_list>(<argument>cur_txn_i</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>cur_txn</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cur_txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cur_txn_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nr_txns</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * TODO: Consider adding fastpath for the rather common nr_txns=1 case, no
     * need to allocate/build a heap then.
     */</comment>

    <comment type="block">/* allocate iteration state */</comment>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferIterTXNState</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferIterTXNState</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                               <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferIterTXNEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nr_txns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name> <operator>=</operator> <name>nr_txns</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* allocate heap */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <call><name>binaryheap_allocate</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name></expr></argument>,
                                      <argument><expr><name>ReorderBufferIterCompare</name></expr></argument>,
                                      <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now insert items into the binary heap, in an unordered fashion.  (We
     * will run a heap assembly step at the end; this is more efficient.)
     */</comment>

    <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* add toplevel transaction if it contains changes */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cur_change</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>serialized</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* serialize remaining changes */</comment>
            <expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReorderBufferRestoreChanges</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>cur_change</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>cur_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>cur_change</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>txn</name> <operator>=</operator> <name>txn</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* add subtransactions if they contain changes */</comment>
    <macro><name>dlist_foreach</name><argument_list>(<argument>cur_txn_i</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>cur_txn</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cur_txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cur_txn_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cur_change</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>serialized</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* serialize remaining changes */</comment>
                <expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>cur_txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ReorderBufferRestoreChanges</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>cur_txn</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>cur_change</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>cur_txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>cur_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>cur_change</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>txn</name> <operator>=</operator> <name>cur_txn</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* assemble a valid binary heap */</comment>
    <expr_stmt><expr><call><name>binaryheap_build</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the next change when iterating over a transaction and its
 * subtransactions.
 *
 * Returns NULL when no further changes exist.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferChange</name> <modifier>*</modifier></type>
<name>ReorderBufferIterTXNNext</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferIterTXNEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>off</name></decl>;</decl_stmt>

    <comment type="block">/* nothing there anymore */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>heap</name><operator>-&gt;</operator><name>bh_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>binaryheap_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* free memory we might have "leaked" in the previous *Next call */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                 <argument><expr><call><name>dlist_pop_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>change</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>change</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * update heap with information about which transaction has the next
     * relevant change in LSN order
     */</comment>

    <comment type="block">/* there are in-memory changes */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>next_change</name> <init>=
        <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* txn stays the same */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>next_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>next_change</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>change</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* try to load changes from disk */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Ugly: restoring changes will reuse *Change records, thus delete the
         * current one from the per-tx list and only free in the next call.
         */</comment>
        <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ReorderBufferRestoreChanges</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>txn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* successfully restored changes from disk */</comment>
            <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>next_change</name> <init>=
            <expr><call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"restored %u/%u changes from disk"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>,
                 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* txn stays the same */</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>next_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>next_change</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>change</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ok, no changes there anymore, remove */</comment>
    <expr_stmt><expr><call><name>binaryheap_remove_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>change</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deallocate the iterator
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferIterTXNFinish</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>,
                           <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>off</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* free memory we might have "leaked" in the last *Next call */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                 <argument><expr><call><name>dlist_pop_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>binaryheap_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup the contents of a transaction, usually after the transaction
 * committed or aborted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferCleanupTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

    <comment type="block">/* cleanup subtransactions &amp; their changes */</comment>
    <macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Subtransactions are always associated to the toplevel TXN, even if
         * they originally were happening inside another subtxn, so we won't
         * ever recurse more than one level deep here.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>nsubtxns</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subtxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* cleanup changes in the toplevel txn */</comment>
    <macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;changes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Cleanup the tuplecids we stored for decoding catalog snapshot access.
     * They are always stored in the toplevel transaction.
     */</comment>
    <macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;tuplecids</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Remove TXN from its containing list.
     *
     * Note: if txn-&gt;is_known_as_subxact, we are deleting the TXN from its
     * parent's list of known subxacts; this leaves the parent's nsubxacts
     * count too high, but we don't care.  Otherwise, we are deleting the TXN
     * from the LSN-ordered list of toplevel TXNs.
     */</comment>
    <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* now remove reference from buffer */</comment>
    <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>,
                <argument><expr><name>HASH_REMOVE</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* remove entries spilled to disk */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>serialized</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReorderBufferRestoreCleanup</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* deallocate */</comment>
    <expr_stmt><expr><call><name>ReorderBufferReturnTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a hash with a (relfilenode, ctid) -&gt; (cmin, cmax) mapping for use by
 * tqual.c's HeapTupleSatisfiesHistoricMVCC.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferBuildTupleCidHash</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dlist_iter</name></type>    <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>txn</name><operator>-&gt;</operator><name>has_catalog_changes</name></name> <operator>||</operator> <call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>tuplecids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * create the hash with the exact number of to-be-stored tuplecids from
     * the start
     */</comment>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name> <operator>=</operator>
        <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ReorderBufferTupleCid"</literal></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ntuplecids</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                    <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;tuplecids</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* be careful about padding */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>tid</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
            <call><name>hash_search</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>,
                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
                        <argument><expr><name>HASH_ENTER</name> <operator>|</operator> <name>HASH_FIND</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>combocid</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>combocid</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>==</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name>InvalidCommandId</name> <operator>||</operator>
                   <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * if the tuple got valid in this transaction and now got deleted
             * we already have a valid cmin stored. The cmax will be
             * InvalidCommandId though.
             */</comment>
            <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Copy a provided snapshot so we can modify it privately. This is needed so
 * that catalog modifying transactions can look into intermediate catalog
 * states.
 */</comment>
<function><type><specifier>static</specifier> <name>Snapshot</name></type>
<name>ReorderBufferCopySnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>orig_snap</name></decl></parameter>,
                      <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dlist_iter</name></type>    <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>orig_snap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator>
        <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>txn</name><operator>-&gt;</operator><name>nsubtxns</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><name>orig_snap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* mark as active so nobody frees it */</comment>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>snap</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>orig_snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * snap-&gt;subxip contains all txids that belong to our transaction which we
     * need to check via cmin/cmax. That's why we store the toplevel
     * transaction in there as well.
     */</comment>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name></name> <operator>+</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * nsubxcnt isn't decreased when subtransactions abort, so count manually.
     * Since it's an upper boundary it is safe to use it for the allocation
     * above.
     */</comment>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>sub_txn</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>sub_txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>sub_txn</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* sort so we can bsearch() later */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* store the specified current CommandId */</comment>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>cid</name></expr>;</expr_stmt>

    <return>return <expr><name>snap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a previously ReorderBufferCopySnap'ed snapshot
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferFreeSnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform the replay of a transaction and it's non-aborted subtransactions.
 *
 * Subtransactions previously have to be processed by
 * ReorderBufferCommitChild(), even if previously assigned to the toplevel
 * transaction with ReorderBufferAssignChild.
 *
 * We currently can only decode a transaction's contents in when their commit
 * record is read because that's currently the only place where we know about
 * cache invalidations. Thus, once a toplevel commit is read, we iterate over
 * the top and subtransactions (using a k-way merge) and replay the changes in
 * lsn order.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferCommit</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                    <parameter><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>,
                    <parameter><decl><type><name>TimestampTz</name></type> <name>commit_time</name></decl></parameter>,
                    <parameter><decl><type><name>RepOriginId</name></type> <name>origin_id</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>origin_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>Snapshot</name></type> <name>snapshot_now</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>CommandId</name></type> <name>command_id</name> <init>= <expr><name>FirstCommandId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>using_subtxn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>iterstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* unknown transaction, nothing to replay */</comment>
    <if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>commit_lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>commit_time</name></name> <operator>=</operator> <name>commit_time</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <name>origin_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>origin_lsn</name></name> <operator>=</operator> <name>origin_lsn</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If this transaction didn't have any real changes in our database, it's
     * OK not to have a snapshot. Note that ReorderBufferCommitChild will have
     * transferred its snapshot to this transaction if it had one and the
     * toplevel tx didn't.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>snapshot_now</name> <operator>=</operator> <name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr>;</expr_stmt>

    <comment type="block">/* build data to be able to lookup the CommandIds of catalog tuples */</comment>
    <expr_stmt><expr><call><name>ReorderBufferBuildTupleCidHash</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* setup the initial snapshot */</comment>
    <expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Decoding needs access to syscaches et al., which in turn use
     * heavyweight locks and such. Thus we need to have enough state around to
     * keep track of those.  The easiest way is to simply use a transaction
     * internally.  That also allows us to easily enforce that nothing writes
     * to the database by checking for xid assignments.
     *
     * When we're called via the SQL SRF there's already a transaction
     * started, so start an explicit subtransaction there.
     */</comment>
    <expr_stmt><expr><name>using_subtxn</name> <operator>=</operator> <call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>specinsert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>using_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><literal type="string">"replay"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>begin</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>iterstate</name> <operator>=</operator> <call><name>ReorderBufferIterTXNInit</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>change</name> <operator>=</operator> <call><name>ReorderBufferIterTXNNext</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>iterstate</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>reloid</name></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>

                    <comment type="block">/*
                     * Confirmation for speculative insertion arrived. Simply
                     * use as a normal record. It'll be cleaned up at the end
                     * of INSERT processing.
                     */</comment>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>specinsert</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>change</name> <operator>=</operator> <name>specinsert</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INSERT</name></expr>;</expr_stmt>

                    <comment type="block">/* intentionally fall through */</comment>
                <case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
                <case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
                <case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RelidByRelfilenode</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
                                                <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Catalog tuple without data, emitted while catalog was
                     * in the process of being rewritten.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>reloid</name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
                        <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                        <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>change_done</name>;</goto></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>reloid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not map filenode \"%s\" to relation OID"</literal></expr></argument>,
                             <argument><expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>,
                                         <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open relation with OID %u (for filenode \"%s\")"</literal></expr></argument>,
                             <argument><expr><name>reloid</name></expr></argument>,
                             <argument><expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>,
                                         <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>change_done</name>;</goto></block_content></block></if></if_stmt>

                    <comment type="block">/*
                     * For now ignore sequence changes entirely. Most of the
                     * time they don't log changes using records we
                     * understand, so it doesn't make sense to handle the few
                     * cases we do.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>change_done</name>;</goto></block_content></block></if></if_stmt>

                    <comment type="block">/* user-triggered change */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsToastRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ReorderBufferToastReplace</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>apply_change</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Only clear reassembled toast chunks if we're sure
                         * they're not required anymore. The creator of the
                         * tuple tells us.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ReorderBufferToastReset</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__STORAGE_SCALABLE__</name></cpp:ifdef>
                        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                            <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>reloid</name></expr>)</condition>    
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_INSERT</name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>ntups_insert</name></name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>ntups_insert</name></name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>ntups_delete</name></name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_DELETE</name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>ntups_delete</name></name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if>
                    <comment type="block">/* we're not interested in toast deletions */</comment>
                    <if type="elseif">else if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_INSERT</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Need to reassemble the full toasted Datum in
                         * memory, to ensure the chunks don't get reused till
                         * we're done remove it from the list of this
                         * transaction's changes. Otherwise it will get
                         * freed/reused while restoring spooled data from
                         * disk.
                         */</comment>
                        <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ReorderBufferToastAppendChunk</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
                                                      <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

            <label><name>change_done</name>:</label>

                    <comment type="block">/*
                     * Either speculative insertion was confirmed, or it was
                     * unsuccessful and the record isn't needed anymore.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>specinsert</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>specinsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>relation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>relation</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>

                    <comment type="block">/*
                     * Speculative insertions are dealt with by delaying the
                     * processing of the insert until the confirmation record
                     * arrives. For that we simply unlink the record from the
                     * chain, so it does not get freed/reused while restoring
                     * spooled data from disk.
                     *
                     * This is safe in the face of concurrent catalog changes
                     * because the relevant relation can't be changed between
                     * speculative insertion and confirmation due to
                     * CheckTableNotInUse() and locking.
                     */</comment>

                    <comment type="block">/* clear out a pending (and thus failed) speculation */</comment>
                    <if_stmt><if>if <condition>(<expr><name>specinsert</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>specinsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* and memorize the pending insertion */</comment>
                    <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>change</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
                    <expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>message</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>,
                                <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>,
                                <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
                    <comment type="block">/* get rid of the old */</comment>
                    <expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>snapshot_now</name> <operator>=</operator>
                            <call><name>ReorderBufferCopySnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr></argument>,
                                                  <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>command_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>

                    <comment type="block">/*
                     * Restored from disk, need to be careful not to double
                     * free. We could introduce refcounting for that, but for
                     * now this seems infrequent enough not to care.
                     */</comment>
                    <if type="elseif">else if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>snapshot_now</name> <operator>=</operator>
                            <call><name>ReorderBufferCopySnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr></argument>,
                                                  <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>command_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>snapshot_now</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>


                    <comment type="block">/* and continue with the new one */</comment>
                    <expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name> <operator>!=</operator> <name>InvalidCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>command_id</name> <operator>&lt;</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>command_id</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* we don't use the global one anymore */</comment>
                            <expr_stmt><expr><name>snapshot_now</name> <operator>=</operator> <call><name>ReorderBufferCopySnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>,
                                                                 <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>command_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>command_id</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Every time the CommandId is incremented, we could
                         * see new catalog contents, so execute all
                         * invalidations.
                         */</comment>
                        <expr_stmt><expr><call><name>ReorderBufferExecuteInvalidations</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <break>break;</break>

                <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuplecid value in changequeue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></while>

        <comment type="block">/*
         * There's a speculative insertion remaining, just clean in up, it
         * can't have been successful, otherwise we'd gotten a confirmation
         * record.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>specinsert</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>specinsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* clean up the iterator */</comment>
        <expr_stmt><expr><call><name>ReorderBufferIterTXNFinish</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>iterstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iterstate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/* call commit callback */</comment>
        <expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>commit</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>commit_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* this is just a sanity check against bad output plugin behaviour */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>GetCurrentTransactionIdIfAny</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"output plugin used XID %u"</literal></expr></argument>,
                 <argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* cleanup */</comment>
        <expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Aborting the current (sub-)transaction as a whole has the right
         * semantics. We want all locks acquired in here to be released, not
         * reassigned to the parent and we do not want any database access
         * have persistent effects.
         */</comment>
        <expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* make sure there's no cache pollution */</comment>
        <expr_stmt><expr><call><name>ReorderBufferExecuteInvalidations</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>using_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* remove potential on-disk data, and deallocate */</comment>
        <expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/* TODO: Encapsulate cleanup from the PG_TRY and PG_CATCH blocks */</comment>
        <if_stmt><if>if <condition>(<expr><name>iterstate</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReorderBufferIterTXNFinish</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>iterstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Force cache invalidation to happen outside of a valid transaction
         * to prevent catalog access as we just caught an error.
         */</comment>
        <expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* make sure there's no cache pollution */</comment>
        <expr_stmt><expr><call><name>ReorderBufferExecuteInvalidations</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>using_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* remove potential on-disk data, and deallocate */</comment>
        <expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Abort a transaction that possibly has previous changes. Needs to be first
 * called for subtransactions and then for the toplevel xid.
 *
 * NB: Transactions handled here have to have actively aborted (i.e. have
 * produced an abort record). Implicitly aborted transactions are handled via
 * ReorderBufferAbortOld(); transactions we're just not interested in, but
 * which have committed are handled in ReorderBufferForget().
 *
 * This function purges this transaction and its contents from memory and
 * disk.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAbort</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* unknown, nothing to remove */</comment>
    <if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* cosmetic... */</comment>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>

    <comment type="block">/* remove potential on-disk data, and deallocate */</comment>
    <expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Abort all transactions that aren't actually running anymore because the
 * server restarted.
 *
 * NB: These really have to be transactions that have aborted due to a server
 * crash/immediate restart, as we don't deal with invalidations here.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAbortOld</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>oldestRunningXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>it</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Iterate through all (potential) toplevel TXNs and abort all that are
     * older than what possibly can be running. Once we've found the first
     * that is alive we stop, there might be some that acquired an xid earlier
     * but started writing later, but it's unlikely and they will cleaned up
     * in a later call to ReorderBufferAbortOld().
     */</comment>
    <macro><name>dlist_foreach_modify</name><argument_list>(<argument>it</argument>, <argument>&amp;rb-&gt;toplevel_by_lsn</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>oldestRunningXid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"aborting old transaction %u"</literal></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* remove potential on-disk data, and deallocate this tx */</comment>
            <expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return;</return></block_content></block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Forget the contents of a transaction if we aren't interested in it's
 * contents. Needs to be first called for subtransactions and then for the
 * toplevel xid.
 *
 * This is significantly different to ReorderBufferAbort() because
 * transactions that have committed need to be treated differently from aborted
 * ones since they may have modified the catalog.
 *
 * Note that this is only allowed to be called in the moment a transaction
 * commit has just been read, not earlier; otherwise later records referring
 * to this xid might re-create the transaction incompletely.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferForget</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* unknown, nothing to forget */</comment>
    <if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* cosmetic... */</comment>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Process cache invalidation messages if there are any. Even if we're not
     * interested in the transaction's contents, it could have manipulated the
     * catalog and we need to update the caches according to that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReorderBufferImmediateInvalidation</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name></expr></argument>,
                                           <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* remove potential on-disk data, and deallocate */</comment>
    <expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute invalidations happening outside the context of a decoded
 * transaction. That currently happens either for xid-less commits
 * (c.f. RecordTransactionCommit()) or for invalidations in uninteresting
 * transactions (via ReorderBufferForget()).
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferImmediateInvalidation</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>ninvalidations</name></decl></parameter>,
                                   <parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalidations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>use_subtxn</name> <init>= <expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>use_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><literal type="string">"replay"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Force invalidations to happen outside of a valid transaction - that way
     * entries will just be marked as invalid without accessing the catalog.
     * That's advantageous because we don't need to setup the full state
     * necessary for catalog access.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ninvalidations</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LocalExecuteInvalidationMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>invalidations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>use_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tell reorderbuffer about an xid seen in the WAL stream. Has to be called at
 * least once for every xid in XLogRecord-&gt;xl_xid (other places in records
 * may, but do not have to be passed through here).
 *
 * Reorderbuffer keeps some datastructures about transactions in LSN order,
 * for efficiency. To do that it has to know about when transactions are seen
 * first in the WAL. As many types of records are not actually interesting for
 * logical decoding, they do not necessarily pass though here.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferProcessXid</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* many records won't have an xid assigned, centralize check here */</comment>
    <if_stmt><if>if <condition>(<expr><name>xid</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new snapshot to this transaction that may only used after lsn 'lsn'
 * because the previous snapshot doesn't describe the catalog correctly for
 * following rows.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddSnapshot</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                         <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>= <expr><call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <name>snap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Setup the base snapshot of a transaction. The base snapshot is the snapshot
 * that is used to decode all changes until either this transaction modifies
 * the catalog or another catalog modifying transaction commits.
 *
 * Needs to be called before any changes are added with
 * ReorderBufferQueueChange().
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferSetBaseSnapshot</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                             <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_new</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_new</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snap</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name>snap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Access the catalog with this CommandId at this point in the changestream.
 *
 * May only be called for command ids &gt; 1
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddNewCommandId</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                             <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>= <expr><call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name> <operator>=</operator> <name>cid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Add new (relfilenode, tid) -&gt; (cmin, cmax) mappings.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddNewTupleCids</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                             <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>,
                             <parameter><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cmin</name></decl></parameter>,
                             <parameter><decl><type><name>CommandId</name></type> <name>cmax</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>= <expr><call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>tid</name></name> <operator>=</operator> <name>tid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmin</name></name> <operator>=</operator> <name>cmin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name> <operator>=</operator> <name>cmax</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>combocid</name></name> <operator>=</operator> <name>combocid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>tuplecids</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>ntuplecids</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Setup the invalidation of the toplevel transaction.
 *
 * This needs to be done before ReorderBufferCommit is called!
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddInvalidations</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                              <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nmsgs</name></decl></parameter>,
                              <parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>msgs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only ever add one set of invalidations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nmsgs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>=</operator> <name>nmsgs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name> <operator>=</operator> <operator>(</operator><name>SharedInvalidationMessage</name> <operator>*</operator><operator>)</operator>
        <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmsgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr></argument>, <argument><expr><name>msgs</name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmsgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply all invalidations we know. Possibly we only need parts at this point
 * in the changestream but we don't know which those are.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferExecuteInvalidations</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LocalExecuteInvalidationMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a transaction as containing catalog changes
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferXidSetCatalogChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                                  <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>has_catalog_changes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Query whether a transaction is already *known* to contain catalog
 * changes. This can be wrong until directly before the commit!
 */</comment>
<function><type><name>bool</name></type>
<name>ReorderBufferXidHasCatalogChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name><name>txn</name><operator>-&gt;</operator><name>has_catalog_changes</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Have we already added the first snapshot?
 */</comment>
<function><type><name>bool</name></type>
<name>ReorderBufferXidHasBaseSnapshot</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* transaction isn't known yet, ergo no snapshot */</comment>
    <if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * TODO: It would be a nice improvement if we would check the toplevel
     * transaction in subtransactions, but we'd need to keep track of a bit
     * more state.
     */</comment>
    <return>return <expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ---------------------------------------
 * Disk serialization support
 * ---------------------------------------
 */</comment>

<comment type="block">/*
 * Ensure the IO buffer is &gt;= sz.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferSerializeReserve</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>&lt;</operator> <name>sz</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the transaction tx should spill its data to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferCheckSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * TODO: improve accounting so we cheaply can take subtransactions into
     * account here.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>&gt;=</operator> <name>max_changes_in_memory</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Spill data of a large transaction (and its subtransactions) to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dlist_iter</name></type>    <name>subtxn_i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>change_i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>curOpenSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>spilled</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"spill %u changes in XID %u to disk"</literal></expr></argument>,
         <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* do the same to all child TXs */</comment>
    <macro><name>dlist_foreach</name><argument_list>(<argument>subtxn_i</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>subtxn_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subtxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* serialize changestream */</comment>
    <macro><name>dlist_foreach_modify</name><argument_list>(<argument>change_i</argument>, <argument>&amp;txn-&gt;changes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>change_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * store in segment in which it belongs by start lsn, don't split over
         * multiple segments tho
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>curOpenSegNo</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>curOpenSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>curOpenSegNo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * No need to care about TLIs here, only used during a single run,
             * so each LSN only maps to a specific WAL record.
             */</comment>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s/xid-%u-lsn-%X-%X.snap"</literal></expr></argument>,
                    <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* open segment, create it if necessary */</comment>
            <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                                   <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>,
                                   <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ReorderBufferSerializeChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>spilled</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spilled</name> <operator>==</operator> <name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>serialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Serialize individual change to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferSerializeChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                             <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ReorderBufferDiskChange</name> <modifier>*</modifier></type><name>ondisk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>change</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* fall through these, they're all similar enough */</comment>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>oldtup</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Size</name></type>        <name>oldlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Size</name></type>        <name>newlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>newtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>oldtup</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>sz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><name>oldlen</name> <operator>=</operator> <name><name>oldtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>oldlen</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>newtup</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>sz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><name>newlen</name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>newlen</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* make sure we have enough space */</comment>
                <expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <comment type="block">/* might have been reallocated above */</comment>
                <expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>oldlen</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>oldtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>oldlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>oldlen</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>newlen</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>newlen</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Size</name></type>        <name>prefix_size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>prefix_size</name> <operator>+</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name> <operator>+</operator>
                    <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <comment type="block">/* might have been reallocated above */</comment>
                <expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

                <comment type="block">/* write the prefix including the size */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefix_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>,
                       <argument><expr><name>prefix_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>prefix_size</name></expr>;</expr_stmt>

                <comment type="block">/* write the message including the size */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>,
                       <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snap</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>snap</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><name>sz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                    <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator>
                    <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>
                    ;</expr_stmt>

                <comment type="block">/* make sure we have enough space */</comment>
                <expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <comment type="block">/* might have been reallocated above */</comment>
                <expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
            <comment type="block">/* ReorderBufferChange contains everything important */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_BUFFER_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to data file for XID %u: %m"</literal></expr></argument>,
                        <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>change</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restore a number of changes spilled to disk back into memory.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>ReorderBufferRestoreChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                            <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>restored</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>last_segno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>cleanup_iter</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* free current entries, so we have memory for more */</comment>
    <macro><name>dlist_foreach_modify</name><argument_list>(<argument>cleanup_iter</argument>, <argument>&amp;txn-&gt;changes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cleanup</name> <init>=
        <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cleanup_iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cleanup</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name></expr></argument>, <argument><expr><name>last_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>restored</name> <operator>&lt;</operator> <name>max_changes_in_memory</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>segno</name> <operator>&lt;=</operator> <name>last_segno</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>readBytes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferDiskChange</name> <modifier>*</modifier></type><name>ondisk</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

            <comment type="block">/* first time in */</comment>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>segno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr></argument>, <argument><expr><operator>*</operator><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>segno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><operator>*</operator><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * No need to care about TLIs here, only used during a single run,
             * so each LSN only maps to a specific WAL record.
             */</comment>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s/xid-%u-lsn-%X-%X.snap"</literal></expr></argument>,
                    <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><operator>*</operator><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Read the statically sized part of a change which has information
         * about the total size. If we couldn't read a record, we're at the
         * end of this file.
         */</comment>
        <expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_BUFFER_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* eof */</comment>
        <if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: read %d instead of %u bytes"</literal></expr></argument>,
                            <argument><expr><name>readBytes</name></expr></argument>,
                            <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>,
                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_BUFFER_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                         <argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: read %d instead of %u bytes"</literal></expr></argument>,
                            <argument><expr><name>readBytes</name></expr></argument>,
                            <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * ok, read a full change from disk, now restore it into proper
         * in-memory format
         */</comment>
        <expr_stmt><expr><call><name>ReorderBufferRestoreChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>restored</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>restored</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert change from its on-disk format to in-memory format and queue it onto
 * the TXN's -&gt;changes list.
 *
 * Note: although "data" is declared char*, at entry it points to a
 * maxalign'd buffer, making it safe in most of this function to assume
 * that the pointed-to data is suitably aligned for direct access.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferRestoreChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                           <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ReorderBufferDiskChange</name> <modifier>*</modifier></type><name>ondisk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy static part */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>change</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>change</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/* restore individual stuff */</comment>
    <switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* fall through these, they're all similar enough */</comment>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type>        <name>tuplelen</name> <init>= <expr><operator>(</operator><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>data</name><operator>)</operator><operator>-&gt;</operator><name>t_len</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>=</operator>
                    <call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>tuplelen</name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* restore -&gt;tuple */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <comment type="block">/* reset t_data pointer into the new tuplebuf */</comment>
                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator>
                    <call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* restore tuple data itself */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>tuplelen</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* here, data might not be suitably aligned! */</comment>
                <decl_stmt><decl><type><name>uint32</name></type>        <name>tuplelen</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuplelen</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>, <argument><expr><name>t_len</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>=</operator>
                    <call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>tuplelen</name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* restore -&gt;tuple */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <comment type="block">/* reset t_data pointer into the new tuplebuf */</comment>
                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator>
                    <call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* restore tuple data itself */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>tuplelen</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <break>break;</break>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Size</name></type>        <name>prefix_size</name></decl>;</decl_stmt>

                <comment type="block">/* read prefix */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefix_size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                                                             <argument><expr><name>prefix_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>prefix_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name><index>[<expr><name>prefix_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>prefix_size</name></expr>;</expr_stmt>

                <comment type="block">/* read the message */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
                                                              <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
                       <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data</name> <operator>+=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Snapshot</name></type>    <name>oldsnap</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Snapshot</name></type>    <name>newsnap</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>oldsnap</name> <operator>=</operator> <operator>(</operator><name>Snapshot</name><operator>)</operator> <name>data</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                    <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>oldsnap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator>
                    <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>oldsnap</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>+</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>newsnap</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newsnap</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
                    <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newsnap</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <name><name>newsnap</name><operator>-&gt;</operator><name>xip</name></name> <operator>+</operator> <name><name>newsnap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
            <comment type="block">/* the base struct contains all the data, easy peasy */</comment>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
        <case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all on-disk stored for the passed in transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferRestoreCleanup</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>first</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>last</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* iterate over all possible filenames, and delete them */</comment>
    <for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s/xid-%u-lsn-%X-%X.snap"</literal></expr></argument>,
                <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>,
                <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Delete all data spilled to disk after we've restarted/crashed. It will be
 * recreated when the respective slots are reused.
 */</comment>
<function><type><name>void</name></type>
<name>StartupReorderBuffer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>logical_dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>logical_de</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>spill_dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>spill_de</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>logical_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_replslot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>logical_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>logical_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* if it cannot be a slot, skip the directory */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReplicationSlotValidateName</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * ok, has to be a surviving logical slot, iterate and delete
         * everything starting with xid-*
         */</comment>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s"</literal></expr></argument>, <argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* we're only creating directories here, skip if it's not our's */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>spill_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>spill_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>spill_dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* only look at names that can be ours */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"xid"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s/%s"</literal></expr></argument>, <argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>,
                        <argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
                                    <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>spill_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>logical_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete slot related all data spilled to disk after we've crashed. It will be
 * recreated when the respective slots are reused.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteSpillToDiskSnap</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>logical_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>logical_de</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>spill_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>spill_de</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>logical_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_replslot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>logical_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>logical_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>spilled_file</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name><init>=<expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if it cannot be a slot, skip the directory */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReplicationSlotValidateName</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if it cannot be myself slot, skip the directory */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
		    <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * ok, has to be a surviving logical slot, iterate and delete
		 * everything starting with xid-*
		 */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s"</literal></expr></argument>, <argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we're only creating directories here, skip if it's not our's */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>spill_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>spill_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>spill_dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>spilled_file</name></expr></argument>, <argument><expr><literal type="string">"xid-%u-lsn-"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* only look at names that can be ours */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>spilled_file</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>spilled_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s/%s"</literal></expr></argument>, <argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>,
						<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>spill_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>logical_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------
 * toast reassembly support
 * ---------------------------------------
 */</comment>

<comment type="block">/*
 * Initialize per tuple toast reconstruction support.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastInitHash</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferToastEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ReorderBufferToastHash"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                                  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Per toast-chunk handling for toast reconstruction
 *
 * Appends a toast chunk so we can reconstruct it when the tuple "owning" the
 * toasted Datum comes along.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastAppendChunk</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                              <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferToastEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chunksize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pointer</name></type>        <name>chunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>chunk_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chunk_seq</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReorderBufferToastInitHash</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsToastRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>newtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>chunk_id</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>chunk_seq</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferToastEnt</name> <operator>*</operator><operator>)</operator>
        <call><name>hash_search</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>chunk_id</name></expr></argument>,
                    <argument><expr><name>HASH_ENTER</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>chunk_id</name></name> <operator>==</operator> <name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>chunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>chunk_seq</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"got sequence entry %d for toast chunk %u instead of seq 0"</literal></expr></argument>,
                 <argument><expr><name>chunk_seq</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name>chunk_seq</name> <operator>!=</operator> <name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"got sequence entry %d for toast chunk %u instead of seq %d"</literal></expr></argument>,
             <argument><expr><name>chunk_seq</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* calculate size so we can allocate the right size at once later */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* could happen due to heap_form_tuple doing its thing */</comment>
        <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected type of toast chunk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>size</name></name> <operator>+=</operator> <name>chunksize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>=</operator> <name>chunk_seq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>num_chunks</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>chunks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rejigger change-&gt;newtuple to point to in-memory toast tuples instead to
 * on-disk toast tuples that may not longer exist (think DROP TABLE or VACUUM).
 *
 * We cannot replace unchanged toast tuples though, so those will still point
 * to on-disk toast data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastReplace</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
                          <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>free</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tmphtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toast_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>toast_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>

    <comment type="block">/* no toast tuples changed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we should only have toast tuples in an INSERT or UPDATE */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>toast_rel</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>toast_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* should we allocate from stack instead? */</comment>
    <expr_stmt><expr><name>attrs</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>free</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>newtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>natt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferToastEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>varlena</name></decl>;</decl_stmt>

        <comment type="block">/* va_rawsize is the size of the original datum -- including header */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect_pointer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_datum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>reconstructed</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dlist_iter</name></type>    <name>it</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>data_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* system columns aren't toasted */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* not a varlena datatype */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* no data */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>natt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* ok, we know we have a toast datum */</comment>
        <expr_stmt><expr><name>varlena</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><name>natt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no need to do anything if the tuple isn't external */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>varlena</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check whether the toast tuple changed, replace if so.
         */</comment>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferToastEnt</name> <operator>*</operator><operator>)</operator>
            <call><name>hash_search</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>,
                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                        <argument><expr><name>HASH_FIND</name></expr></argument>,
                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>new_datum</name> <operator>=</operator>
            <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>INDIRECT_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>free</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>reconstructed</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name> <operator>=</operator> <name>reconstructed</name></expr>;</expr_stmt>

        <comment type="block">/* stitch toast tuple back together from its parts */</comment>
        <macro><name>dlist_foreach</name><argument_list>(<argument>it</argument>, <argument>&amp;ent-&gt;chunks</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cchange</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>ctup</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Pointer</name></type>        <name>chunk</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>cchange</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ctup</name> <operator>=</operator> <name><name>cchange</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(
                                    <argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>toast_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>reconstructed</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>data_done</name></expr></argument>,
                   <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>data_done</name> <operator>+=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>data_done</name> <operator>==</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* make sure its marked as compressed or not */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>reconstructed</name></expr></argument>, <argument><expr><name>data_done</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>reconstructed</name></expr></argument>, <argument><expr><name>data_done</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>redirect_pointer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redirect_pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>redirect_pointer</name><operator>.</operator><name>pointer</name></name> <operator>=</operator> <name>reconstructed</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SET_VARTAG_EXTERNAL</name><argument_list>(<argument><expr><name>new_datum</name></expr></argument>, <argument><expr><name>VARTAG_INDIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA_EXTERNAL</name><argument_list>(<argument><expr><name>new_datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>redirect_pointer</name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redirect_pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>attrs</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Build tuple in separate memory &amp; copy tuple back into the tuplebuf
     * passed to the output plugin. We can't directly heap_fill_tuple() into
     * the tuplebuf because attrs[] will point back into the current content.
     */</comment>
    <expr_stmt><expr><name>tmphtup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tmphtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tmphtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>tmphtup</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * free resources we won't further need, more persistent stuff will be
     * free'd in ReorderBufferToastReset().
     */</comment>
    <expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmphtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>free</name><index>[<expr><name>natt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><name>natt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free all resources allocated for toast reconstruction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastReset</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferToastEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* sequentially walk over the hash and free everything */</comment>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferToastEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>it</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <macro><name>dlist_foreach_modify</name><argument_list>(<argument>it</argument>, <argument>&amp;ent-&gt;chunks</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>=
            <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ---------------------------------------
 * Visibility support for logical decoding
 *
 *
 * Lookup actual cmin/cmax values when using decoding snapshot. We can't
 * always rely on stored cmin/cmax values because of two scenarios:
 *
 * * A tuple got changed multiple times during a single transaction and thus
 *     has got a combocid. Combocid's are only valid for the duration of a
 *     single transaction.
 * * A tuple with a cmin but no cmax (and thus no combocid) got
 *     deleted/updated in another transaction than the one which created it
 *     which we are looking at right now. As only one of cmin, cmax or combocid
 *     is actually stored in the heap we don't have access to the value we
 *     need anymore.
 *
 * To resolve those problems we have a per-transaction hash of (cmin,
 * cmax) tuples keyed by (relfilenode, ctid) which contains the actual
 * (cmin, cmax) values. That also takes care of combocids by simply
 * not caring about them at all. As we have the real cmin/cmax values
 * combocids aren't interesting.
 *
 * As we only care about catalog tuples here the overhead of this
 * hashtable should be acceptable.
 *
 * Heap rewrites complicate this a bit, check rewriteheap.c for
 * details.
 * -------------------------------------------------------------------------
 */</comment>

<comment type="block">/* struct for qsort()ing mapping files by lsn somewhat efficiently */</comment>
<typedef>typedef <type><struct>struct <name>RewriteMappingFile</name>
<block>{
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RewriteMappingFile</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NOT_USED</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisplayMapping</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>tuplecid_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"mapping: node: %u/%u/%u tid: %u/%u cmin: %u, cmax: %u"</literal></expr></argument>,
             <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>relnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
             <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>relnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
             <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>relnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
             <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name></expr></argument>,
             <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Apply a single mapping file to tuplecid_data.
 *
 * The mapping file has to have been verified to be a) committed b) for our
 * transaction c) applied in LSN order.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyLogicalMappingFile</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>readBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LogicalRewriteMappingData</name></type> <name>map</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/mappings/%s"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>new_ent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

        <comment type="block">/* be careful about padding */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* read all mappings till the end of the file */</comment>
        <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>map</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRewriteMappingData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* EOF */</comment>
            <break>break;</break></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRewriteMappingData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": read %d instead of %d bytes"</literal></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>, <argument><expr><name>readBytes</name></expr></argument>,
                            <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRewriteMappingData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>map</name><operator>.</operator><name>old_node</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map</name><operator>.</operator><name>old_tid</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
            <call><name>hash_search</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
                        <argument><expr><name>HASH_FIND</name></expr></argument>,
                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no existing mapping, no need to update */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>map</name><operator>.</operator><name>new_node</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map</name><operator>.</operator><name>new_tid</name></name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>new_ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
            <call><name>hash_search</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
                        <argument><expr><name>HASH_ENTER</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Make sure the existing mapping makes sense. We sometime update
             * old records that did not yet have a cmax (e.g. pg_class' own
             * entry while rewriting it) during rewrites, so allow that.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>==</operator> <name>InvalidCommandId</name> <operator>||</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>==</operator> <name><name>new_ent</name><operator>-&gt;</operator><name>cmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name>InvalidCommandId</name> <operator>||</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name><name>new_ent</name><operator>-&gt;</operator><name>cmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* update mapping */</comment>
            <expr_stmt><expr><name><name>new_ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>new_ent</name><operator>-&gt;</operator><name>combocid</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>combocid</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the TransactionOId 'xid' is in the pre-sorted array 'xip'.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TransactionIdInArray</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xip</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><name>xip</name></expr></argument>, <argument><expr><name>num</name></expr></argument>,
                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort() comparator for sorting RewriteMappingFiles in LSN order.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_sort_by_lsn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><name>RewriteMappingFile</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a_p</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><name>RewriteMappingFile</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b_p</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply any existing logical remapping files if there are any targeted at our
 * transaction for relid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateLogicalMappings</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>mapping_dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>mapping_de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>files</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>files_a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>dboid</name> <init>= <expr><ternary><condition><expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>mapping_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_logical/mappings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>mapping_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>mapping_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/mappings"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>f_dboid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>f_relid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>f_mapped_xid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>f_create_xid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>f_lsn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>f_hi</name></decl>,
                    <decl><type ref="prev"/><name>f_lo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <call><name>strcmp</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Ignore files that aren't ours */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"map-"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>LOGICAL_REWRITE_FORMAT</name></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name>f_dboid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_lo</name></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name>f_mapped_xid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_create_xid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not parse filename \"%s\""</literal></expr></argument>, <argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>f_lsn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>f_hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>f_lo</name></expr>;</expr_stmt>

        <comment type="block">/* mapping for another database */</comment>
        <if_stmt><if>if <condition>(<expr><name>f_dboid</name> <operator>!=</operator> <name>dboid</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* mapping for another relation */</comment>
        <if_stmt><if>if <condition>(<expr><name>f_relid</name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* did the creating transaction abort? */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>f_create_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* not for our transaction */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdInArray</name><argument_list>(<argument><expr><name>f_mapped_xid</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* ok, relevant, queue for apply */</comment>
        <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteMappingFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>f_lsn</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>, <argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>files</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>files</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>mapping_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build array we can easily sort */</comment>
    <expr_stmt><expr><name>files_a</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RewriteMappingFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>file</argument>, <argument>files</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name><name>files_a</name><index>[<expr><name>off</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* sort files so we apply them in LSN order */</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>files_a</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteMappingFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
          <argument><expr><name>file_sort_by_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>files_a</name><index>[<expr><name>off</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"applying mapping: \"%s\" in %u"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>,
             <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ApplyLogicalMappingFile</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup cmin/cmax of a tuple, during logical decoding where we can't rely on
 * combocids.
 */</comment>
<function><type><name>bool</name></type>
<name>ResolveCminCmaxDuringDecoding</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>,
                              <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                              <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
                              <parameter><decl><type><name>CommandId</name> <modifier>*</modifier></type><name>cmin</name></decl></parameter>, <parameter><decl><type><name>CommandId</name> <modifier>*</modifier></type><name>cmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ForkNumber</name></type>    <name>forkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>updated_mapping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* be careful about padding */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * get relfilenode from the buffer, no convenient way to access it other
     * than that.
     */</comment>
    <expr_stmt><expr><call><name>BufferGetTag</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* tuples can only be in the main fork */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forkno</name> <operator>==</operator> <name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blockno</name> <operator>==</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>restart</name>:</label>
    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
        <call><name>hash_search</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
                    <argument><expr><name>HASH_FIND</name></expr></argument>,
                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * failed to find a mapping, check whether the table was rewritten and
     * apply mapping if so, but only do that once - there can be no new
     * mappings while we are in here since we have to hold a lock on the
     * relation.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ent</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>updated_mapping</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>UpdateLogicalMappings</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>, <argument><expr><name><name>htup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* now check but don't update for a mapping again */</comment>
        <expr_stmt><expr><name>updated_mapping</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <goto>goto <name>restart</name>;</goto>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>cmin</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>cmin</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmax</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>cmax</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
