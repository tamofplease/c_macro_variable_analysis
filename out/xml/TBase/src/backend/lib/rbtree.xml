<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/lib/rbtree.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rbtree.c
 *      implementation for PostgreSQL generic Red-Black binary tree package
 *      Adopted from http://algolist.manual.ru/ds/rbtree.php
 *
 * This code comes from Thomas Niemann's "Sorting and Searching Algorithms:
 * a Cookbook".
 *
 * See http://www.cs.auckland.ac.nz/software/AlgAnim/niemann/s_man.htm for
 * license terms: "Source code, when part of a software project, may be used
 * freely without reference to the author."
 *
 * Red-black trees are a type of balanced binary tree wherein (1) any child of
 * a red node is always black, and (2) every path from root to leaf traverses
 * an equal number of black nodes.  From these properties, it follows that the
 * longest path from root to leaf is only about twice as long as the shortest,
 * so lookups are guaranteed to run in O(lg n) time.
 *
 * Copyright (c) 2009-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      src/backend/lib/rbtree.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/rbtree.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Colors of nodes (values of RBNode.color)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RBBLACK</name></cpp:macro>        <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RBRED</name></cpp:macro>        <cpp:value>(1)</cpp:value></cpp:define>

<comment type="block">/*
 * RBTree control structure
 */</comment>
<struct>struct <name>RBTree</name>
<block>{
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>            <comment type="block">/* root node, or RBNIL if tree is empty */</comment>

    <comment type="block">/* Remaining fields are constant after rb_create */</comment>

    <decl_stmt><decl><type><name>Size</name></type>        <name>node_size</name></decl>;</decl_stmt>        <comment type="block">/* actual size of tree nodes */</comment>
    <comment type="block">/* The caller-supplied manipulation functions */</comment>
    <decl_stmt><decl><type><name>rb_comparator</name></type> <name>comparator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rb_combiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rb_allocfunc</name></type> <name>allocfunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rb_freefunc</name></type> <name>freefunc</name></decl>;</decl_stmt>
    <comment type="block">/* Passthrough arg passed to all manipulation functions */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * all leafs are sentinels, use customized NIL name to prevent
 * collision with system-wide constant NIL which is actually NULL
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RBNIL</name></cpp:macro> <cpp:value>(&amp;sentinel)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>RBNode</name></type> <name>sentinel</name> <init>= <expr><block>{<expr><name>RBBLACK</name></expr>, <expr><name>RBNIL</name></expr>, <expr><name>RBNIL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Values used in the RBTreeIterator.next_state field, with an
 * InvertedWalk iterator.
 */</comment>
<typedef>typedef <type><enum>enum <name>InvertedWalkNextStep</name>
<block>{
    <decl><name>NextStepBegin</name></decl>,
    <decl><name>NextStepUp</name></decl>,
    <decl><name>NextStepLeft</name></decl>,
    <decl><name>NextStepRight</name></decl>
}</block></enum></type> <name>InvertedWalkNextStep</name>;</typedef>

<comment type="block">/*
 * rb_create: create an empty RBTree
 *
 * Arguments are:
 *    node_size: actual size of tree nodes (&gt; sizeof(RBNode))
 *    The manipulation functions:
 *    comparator: compare two RBNodes for less/equal/greater
 *    combiner: merge an existing tree entry with a new one
 *    allocfunc: allocate a new RBNode
 *    freefunc: free an old RBNode
 *    arg: passthrough pointer that will be passed to the manipulation functions
 *
 * Note that the combiner's righthand argument will be a "proposed" tree node,
 * ie the input to rb_insert, in which the RBNode fields themselves aren't
 * valid.  Similarly, either input to the comparator may be a "proposed" node.
 * This shouldn't matter since the functions aren't supposed to look at the
 * RBNode fields, only the extra fields of the struct the RBNode is embedded
 * in.
 *
 * The freefunc should just be pfree or equivalent; it should NOT attempt
 * to free any subsidiary data, because the node passed to it may not contain
 * valid data!    freefunc can be NULL if caller doesn't require retail
 * space reclamation.
 *
 * The RBTree node is palloc'd in the caller's memory context.  Note that
 * all contents of the tree are actually allocated by the caller, not here.
 *
 * Since tree contents are managed by the caller, there is currently not
 * an explicit "destroy" operation; typically a tree would be freed by
 * resetting or deleting the memory context it's stored in.  You can pfree
 * the RBTree node if you feel the urge.
 */</comment>
<function><type><name>RBTree</name> <modifier>*</modifier></type>
<name>rb_create</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>node_size</name></decl></parameter>,
          <parameter><decl><type><name>rb_comparator</name></type> <name>comparator</name></decl></parameter>,
          <parameter><decl><type><name>rb_combiner</name></type> <name>combiner</name></decl></parameter>,
          <parameter><decl><type><name>rb_allocfunc</name></type> <name>allocfunc</name></decl></parameter>,
          <parameter><decl><type><name>rb_freefunc</name></type> <name>freefunc</name></decl></parameter>,
          <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBTree</name>       <modifier>*</modifier></type><name>tree</name> <init>= <expr><operator>(</operator><name>RBTree</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RBTree</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node_size</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RBNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>RBNIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>node_size</name></name> <operator>=</operator> <name>node_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>comparator</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>combiner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>allocfunc</name></name> <operator>=</operator> <name>allocfunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>freefunc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

    <return>return <expr><name>tree</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Copy the additional data fields from one RBNode to another */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>rb_copy_data</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RBNode</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>node_size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RBNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 *                          Search                                      *
 **********************************************************************/</comment>

<comment type="block">/*
 * rb_find: search for a value in an RBTree
 *
 * data represents the value to try to find.  Its RBNode fields need not
 * be valid, it's the extra data in the larger struct that is of interest.
 *
 * Returns the matching tree entry, or NULL if no match is found.
 */</comment>
<function><type><name>RBNode</name> <modifier>*</modifier></type>
<name>rb_find</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RBNode</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name> <init>= <expr><call><name><name>rb</name><operator>-&gt;</operator><name>comparator</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>node</name></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * rb_leftmost: fetch the leftmost (smallest-valued) tree node.
 * Returns NULL if tree is empty.
 *
 * Note: in the original implementation this included an unlink step, but
 * that's a bit awkward.  Just call rb_delete on the result if that's what
 * you want.
 */</comment>
<function><type><name>RBNode</name> <modifier>*</modifier></type>
<name>rb_leftmost</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>leftmost</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>leftmost</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>leftmost</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>leftmost</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 *                              Insertion                                  *
 **********************************************************************/</comment>

<comment type="block">/*
 * Rotate node x to left.
 *
 * x's right child takes its place in the tree, and x becomes the left
 * child of that node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_rotate_left</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>y</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>right</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* establish x-&gt;right link */</comment>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name><name>y</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* establish y-&gt;parent link */</comment>
    <if_stmt><if>if <condition>(<expr><name>y</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* link x and y */</comment>
    <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rotate node x to right.
 *
 * x's left right child takes its place in the tree, and x becomes the right
 * child of that node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_rotate_right</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>y</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>left</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* establish x-&gt;left link */</comment>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name><name>y</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* establish y-&gt;parent link */</comment>
    <if_stmt><if>if <condition>(<expr><name>y</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* link x and y */</comment>
    <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Maintain Red-Black tree balance after inserting node x.
 *
 * The newly inserted node is always initially marked red.  That may lead to
 * a situation where a red node has a red child, which is prohibited.  We can
 * always fix the problem by a series of color changes and/or "rotations",
 * which move the problem progressively higher up in the tree.  If one of the
 * two red nodes is the root, we can always fix the problem by changing the
 * root from red to black.
 *
 * (This does not work lower down in the tree because we must also maintain
 * the invariant that every leaf has equal black-height.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_insert_fixup</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * x is always a red node.  Initially, it is the newly inserted node. Each
     * iteration of this loop moves it higher up in the tree.
     */</comment>
    <while>while <condition>(<expr><name>x</name> <operator>!=</operator> <name><name>rb</name><operator>-&gt;</operator><name>root</name></name> <operator>&amp;&amp;</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBRED</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * x and x-&gt;parent are both red.  Fix depends on whether x-&gt;parent is
         * a left or right child.  In either case, we define y to be the
         * "uncle" of x, that is, the other child of x's grandparent.
         *
         * If the uncle is red, we flip the grandparent to red and its two
         * children to black.  Then we loop around again to check whether the
         * grandparent still has a problem.
         *
         * If the uncle is black, we will perform one or two "rotations" to
         * balance the tree.  Either x or x-&gt;parent will take the
         * grandparent's position in the tree and recolored black, and the
         * original grandparent will be recolored red and become a child of
         * that node. This always leaves us with a valid red-black tree, so
         * the loop will terminate.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>y</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBRED</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* uncle is RBRED */</comment>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* uncle is RBBLACK */</comment>
                <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* make x a left child */</comment>
                    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>rb_rotate_left</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* recolor and rotate */</comment>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rb_rotate_right</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* mirror image of above code */</comment>
            <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>y</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBRED</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* uncle is RBRED */</comment>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* uncle is RBBLACK */</comment>
                <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>rb_rotate_right</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rb_rotate_left</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * The root may already have been black; if not, the black-height of every
     * node in the tree increases by one.
     */</comment>
    <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rb_insert: insert a new value into the tree.
 *
 * data represents the value to insert.  Its RBNode fields need not
 * be valid, it's the extra data in the larger struct that is of interest.
 *
 * If the value represented by "data" is not present in the tree, then
 * we copy "data" into a new tree entry and return that node, setting *isNew
 * to true.
 *
 * If the value represented by "data" is already present, then we call the
 * combiner function to merge data into the existing node, and return the
 * existing node, setting *isNew to false.
 *
 * "data" is unmodified in either case; it's typically just a local
 * variable in the caller.
 */</comment>
<function><type><name>RBNode</name> <modifier>*</modifier></type>
<name>rb_insert</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RBNode</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>current</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>parent</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

    <comment type="block">/* find where node belongs */</comment>
    <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>parent</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                    <comment type="block">/* just to prevent compiler warning */</comment>

    <while>while <condition>(<expr><name>current</name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name><name>rb</name><operator>-&gt;</operator><name>comparator</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Found node with given key.  Apply combiner.
             */</comment>
            <expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>combiner</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>isNew</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <return>return <expr><name>current</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>parent</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>current</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>current</name><operator>-&gt;</operator><name>left</name></name></expr> </then><else>: <expr><name><name>current</name><operator>-&gt;</operator><name>right</name></name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Value is not present, so create a new node containing data.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>isNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name><name>rb</name><operator>-&gt;</operator><name>allocfunc</name></name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>RBNIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>RBNIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rb_copy_data</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* insert node in tree */</comment>
    <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>rb_insert_fixup</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 *                            Deletion                                  *
 **********************************************************************/</comment>

<comment type="block">/*
 * Maintain Red-Black tree balance after deleting a black node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_delete_fixup</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * x is always a black node.  Initially, it is the former child of the
     * deleted node.  Each iteration of this loop moves it higher up in the
     * tree.
     */</comment>
    <while>while <condition>(<expr><name>x</name> <operator>!=</operator> <name><name>rb</name><operator>-&gt;</operator><name>root</name></name> <operator>&amp;&amp;</operator> <name><name>x</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Left and right cases are symmetric.  Any nodes that are children of
         * x have a black-height one less than the remainder of the nodes in
         * the tree.  We rotate and recolor nodes to move the problem up the
         * tree: at some stage we'll either fix the problem, or reach the root
         * (where the black-height is allowed to decrease).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>w</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBRED</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rb_rotate_left</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>rb_rotate_right</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rb_rotate_left</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>    <comment type="block">/* Arrange for loop to terminate. */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>w</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBRED</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rb_rotate_right</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBRED</name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>rb_rotate_left</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rb_rotate_right</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>    <comment type="block">/* Arrange for loop to terminate. */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name>RBBLACK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete node z from tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_delete_node</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>x</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>z</name> <operator>||</operator> <name>z</name> <operator>==</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * y is the node that will actually be removed from the tree.  This will
     * be z if z has fewer than two children, or the tree successor of z
     * otherwise.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>RBNIL</name> <operator>||</operator> <name><name>z</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>RBNIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* y has a RBNIL node as a child */</comment>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* find tree successor */</comment>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>y</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* x is y's only child */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>y</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>y</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Remove y from the tree. */</comment>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>y</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <name><name>y</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>y</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If we removed the tree successor of z rather than z itself, then move
     * the data for the removed node to the one we were supposed to remove.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>y</name> <operator>!=</operator> <name>z</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>rb_copy_data</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Removing a black node might make some paths from root to leaf contain
     * fewer black nodes than others, or it might make two red nodes adjacent.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>color</name></name> <operator>==</operator> <name>RBBLACK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>rb_delete_fixup</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Now we can recycle the y node */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>freefunc</name></name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rb_delete: remove the given tree entry
 *
 * "node" must have previously been found via rb_find or rb_leftmost.
 * It is caller's responsibility to free any subsidiary data attached
 * to the node before calling rb_delete.  (Do *not* try to push that
 * responsibility off to the freefunc, as some other physical node
 * may be the one actually freed!)
 */</comment>
<function><type><name>void</name></type>
<name>rb_delete</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>rb_delete_node</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 *                          Traverse                                      *
 **********************************************************************/</comment>

<function><type><specifier>static</specifier> <name>RBNode</name> <modifier>*</modifier></type>
<name>rb_left_right_iterator</name><parameter_list>(<parameter><decl><type><name>RBTreeIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt></block_content></block></while>

        <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt></block_content></block></while>

        <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>came_from</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>is_over</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>came_from</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* came from left sub-tree, return current
                                 * node */</comment>

        <comment type="block">/* else - came from right sub-tree, continue to move up */</comment>
    </block_content>}</block></for>

    <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBNode</name> <modifier>*</modifier></type>
<name>rb_right_left_iterator</name><parameter_list>(<parameter><decl><type><name>RBTreeIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt></block_content></block></while>

        <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt></block_content></block></while>

        <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>came_from</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>is_over</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>came_from</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* came from right sub-tree, return current
                                 * node */</comment>

        <comment type="block">/* else - came from left sub-tree, continue to move up */</comment>
    </block_content>}</block></for>

    <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBNode</name> <modifier>*</modifier></type>
<name>rb_direct_iterator</name><parameter_list>(<parameter><decl><type><name>RBTreeIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
        <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
        <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <do>do
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* go up and one step right */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>came_from</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>is_over</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>came_from</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>RBNIL</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
                <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    while <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

    <return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBNode</name> <modifier>*</modifier></type>
<name>rb_inverted_iterator</name><parameter_list>(<parameter><decl><type><name>RBTreeIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>came_from</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RBNode</name>       <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name></expr>;</expr_stmt>

<label><name>loop</name>:</label>
    <switch>switch <condition>(<expr><operator>(</operator><name>InvertedWalkNextStep</name><operator>)</operator> <name><name>iter</name><operator>-&gt;</operator><name>next_step</name></name></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* First call, begin from root */</comment>
        <case>case <expr><name>NextStepBegin</name></expr>:</case>
            <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>rb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next_step</name></name> <operator>=</operator> <name>NextStepLeft</name></expr>;</expr_stmt>
            <goto>goto <name>loop</name>;</goto>

        <case>case <expr><name>NextStepLeft</name></expr>:</case>
            <while>while <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt></block_content></block></while>

            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next_step</name></name> <operator>=</operator> <name>NextStepRight</name></expr>;</expr_stmt>
            <goto>goto <name>loop</name>;</goto>

        <case>case <expr><name>NextStepRight</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>RBNIL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next_step</name></name> <operator>=</operator> <name>NextStepLeft</name></expr>;</expr_stmt>
                <goto>goto <name>loop</name>;</goto>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>                <comment type="block">/* not moved - return current, then go up */</comment>
                <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next_step</name></name> <operator>=</operator> <name>NextStepUp</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <case>case <expr><name>NextStepUp</name></expr>:</case>
            <expr_stmt><expr><name>came_from</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>current</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>is_over</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>            <comment type="block">/* end of iteration */</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>came_from</name> <operator>==</operator> <name><name>current</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* return current, then continue to go up */</comment>
                <break>break;</break>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* otherwise we came from the left */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>came_from</name> <operator>==</operator> <name><name>current</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next_step</name></name> <operator>=</operator> <name>NextStepRight</name></expr>;</expr_stmt>
                <goto>goto <name>loop</name>;</goto>
            </block_content>}</block></else></if_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
    <return>return <expr><name>current</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * rb_begin_iterate: prepare to traverse the tree in any of several orders
 *
 * After calling rb_begin_iterate, call rb_iterate repeatedly until it
 * returns NULL or the traversal stops being of interest.
 *
 * If the tree is changed during traversal, results of further calls to
 * rb_iterate are unspecified.  Multiple concurrent iterators on the same
 * tree are allowed.
 *
 * The iterator state is stored in the 'iter' struct.  The caller should
 * treat it as opaque struct.
 */</comment>
<function><type><name>void</name></type>
<name>rb_begin_iterate</name><parameter_list>(<parameter><decl><type><name>RBTree</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>RBOrderControl</name></type> <name>ctrl</name></decl></parameter>, <parameter><decl><type><name>RBTreeIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Common initialization for all traversal orders */</comment>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>rb</name></name> <operator>=</operator> <name>rb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>last_visited</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>is_over</name></name> <operator>=</operator> <operator>(</operator><name><name>rb</name><operator>-&gt;</operator><name>root</name></name> <operator>==</operator> <name>RBNIL</name><operator>)</operator></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>ctrl</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LeftRightWalk</name></expr>:</case>        <comment type="block">/* visit left, then self, then right */</comment>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>iterate</name></name> <operator>=</operator> <name>rb_left_right_iterator</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RightLeftWalk</name></expr>:</case>        <comment type="block">/* visit right, then self, then left */</comment>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>iterate</name></name> <operator>=</operator> <name>rb_right_left_iterator</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>DirectWalk</name></expr>:</case>        <comment type="block">/* visit self, then left, then right */</comment>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>iterate</name></name> <operator>=</operator> <name>rb_direct_iterator</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>InvertedWalk</name></expr>:</case>        <comment type="block">/* visit left, then right, then self */</comment>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>iterate</name></name> <operator>=</operator> <name>rb_inverted_iterator</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>next_step</name></name> <operator>=</operator> <name>NextStepBegin</name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized rbtree iteration order: %d"</literal></expr></argument>, <argument><expr><name>ctrl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * rb_iterate: return the next node in traversal order, or NULL if no more
 */</comment>
<function><type><name>RBNode</name> <modifier>*</modifier></type>
<name>rb_iterate</name><parameter_list>(<parameter><decl><type><name>RBTreeIterator</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>is_over</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name><name>iter</name><operator>-&gt;</operator><name>iterate</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
