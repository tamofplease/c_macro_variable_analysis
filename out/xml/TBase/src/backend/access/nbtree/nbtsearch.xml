<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/nbtree/nbtsearch.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtsearch.c
 *      Search code for postgres btrees.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/access/nbtree/nbtsearch.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_readpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>,
             <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_saveitem</name><parameter_list>(<parameter><decl><type><name>BTScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>,
             <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_steppage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_readnextpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_parallel_readpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
                      <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>_bt_walk_left</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_endpoint</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_drop_lock_and_maybe_pin</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BTScanPos</name></type> <name>sp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_bt_initialize_more_data</name><parameter_list>(<parameter><decl><type><name>BTScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *    _bt_drop_lock_and_maybe_pin()
 *
 * Unlock the buffer; and if it is safe to release the pin, do that, too.  It
 * is safe if the scan is using an MVCC snapshot and the index is WAL-logged.
 * This will prevent vacuum from stalling in a blocked state trying to read a
 * page when a cursor is sitting on it -- at least in many important cases.
 *
 * Set the buffer to invalid if the pin is released, since the buffer may be
 * re-used.  If we need to go back to this block (for example, to apply
 * LP_DEAD hints) we must get a fresh reference to the buffer.  Hopefully it
 * will remain in shared memory for as long as it takes to scan the index
 * buffer page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_drop_lock_and_maybe_pin</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BTScanPos</name></type> <name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    _bt_search() -- Search the tree for a particular scankey,
 *        or more precisely for the first leaf page it could be on.
 *
 * The passed scankey must be an insertion-type scankey (see nbtree/README),
 * but it can omit the rightmost column(s) of the index.
 *
 * When nextkey is false (the usual case), we are looking for the first
 * item &gt;= scankey.  When nextkey is true, we are looking for the first
 * item strictly greater than scankey.
 *
 * Return value is a stack of parent-page pointers.  *bufP is set to the
 * address of the leaf-page buffer, which is read-locked and pinned.
 * No locks are held on the parent pages, however!
 *
 * If the snapshot parameter is not NULL, "old snapshot" checking will take
 * place during the descent through the tree.  This is not needed when
 * positioning for an insert or delete, so NULL is used for those cases.
 *
 * NOTE that the returned buffer is read-locked regardless of the access
 * parameter.  However, access = BT_WRITE will allow an empty root page
 * to be created and returned.  When access = BT_READ, an empty index
 * will result in *bufP being set to InvalidBuffer.  Also, in BT_WRITE mode,
 * any incomplete splits encountered during the search will be finished.
 */</comment>
<function><type><name>BTStack</name></type>
<name>_bt_search</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nextkey</name></decl></parameter>,
           <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufP</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTStack</name></type>        <name>stack_in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Get the root page to start with */</comment>
    <expr_stmt><expr><operator>*</operator><name>bufP</name> <operator>=</operator> <call><name>_bt_getroot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If index is empty and access = BT_READ, no root page is created. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>bufP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>BTStack</name><operator>)</operator> <name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Loop iterates once per level descended in the tree */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>itemid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>par_blkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BTStack</name></type>        <name>new_stack</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Race -- the page we just grabbed may have split since we read its
         * pointer in the parent (or metapage).  If it has, we may need to
         * move right to its new sibling.  Do that.
         *
         * In write-mode, allow _bt_moveright to finish any incomplete splits
         * along the way.  Strictly speaking, we'd only need to finish an
         * incomplete split on the leaf page we're about to insert to, not on
         * any of the upper levels (they are taken care of in _bt_getstackbuf,
         * if the leaf page is split and we insert to the parent page).  But
         * this is a good opportunity to finish splits of internal pages too.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>bufP</name> <operator>=</operator> <call><name>_bt_moveright</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufP</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>nextkey</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>access</name> <operator>==</operator> <name>BT_WRITE</name><operator>)</operator></expr></argument>, <argument><expr><name>stack_in</name></expr></argument>,
                              <argument><expr><name>BT_READ</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if this is a leaf page, we're done */</comment>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bufP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Find the appropriate item on the internal page, and get the child
         * page that it points to.
         */</comment>
        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_bt_binsrch</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufP</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>nextkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>par_blkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>bufP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We need to save the location of the index entry we chose in the
         * parent page on a stack. In case we split the tree, we'll use the
         * stack to work back up to the parent page.  We also save the actual
         * downlink (TID) to uniquely identify the index entry, in case it
         * moves right while we're working lower in the tree.  See the paper
         * by Lehman and Yao for how this is detected and handled. (We use the
         * child link to disambiguate duplicate keys in the index -- Lehman
         * and Yao disallow duplicate keys.)
         */</comment>
        <expr_stmt><expr><name>new_stack</name> <operator>=</operator> <operator>(</operator><name>BTStack</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTStackData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_stack</name><operator>-&gt;</operator><name>bts_blkno</name></name> <operator>=</operator> <name>par_blkno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_stack</name><operator>-&gt;</operator><name>bts_btentry</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_stack</name><operator>-&gt;</operator><name>bts_parent</name></name> <operator>=</operator> <name>stack_in</name></expr>;</expr_stmt>

        <comment type="block">/* drop the read lock on the parent page, acquire one on the child */</comment>
        <expr_stmt><expr><operator>*</operator><name>bufP</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufP</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* okay, all set to move down a level */</comment>
        <expr_stmt><expr><name>stack_in</name> <operator>=</operator> <name>new_stack</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>stack_in</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_moveright() -- move right in the btree if necessary.
 *
 * When we follow a pointer to reach a page, it is possible that
 * the page has changed in the meanwhile.  If this happens, we're
 * guaranteed that the page has "split right" -- that is, that any
 * data that appeared on the page originally is either on the page
 * or strictly to the right of it.
 *
 * This routine decides whether or not we need to move right in the
 * tree by examining the high key entry on the page.  If that entry
 * is strictly less than the scankey, or &lt;= the scankey in the nextkey=true
 * case, then we followed the wrong link and we need to move right.
 *
 * The passed scankey must be an insertion-type scankey (see nbtree/README),
 * but it can omit the rightmost column(s) of the index.
 *
 * When nextkey is false (the usual case), we are looking for the first
 * item &gt;= scankey.  When nextkey is true, we are looking for the first
 * item strictly greater than scankey.
 *
 * If forupdate is true, we will attempt to finish any incomplete splits
 * that we encounter.  This is required when locking a target page for an
 * insertion, because we don't allow inserting on a page before the split
 * is completed.  'stack' is only used if forupdate is true.
 *
 * On entry, we have the buffer pinned and a lock of the type specified by
 * 'access'.  If we move right, we release the buffer and lock and acquire
 * the same on the right sibling.  Return value is the buffer we stop at.
 *
 * If the snapshot parameter is not NULL, "old snapshot" checking will take
 * place during the descent through the tree.  This is not needed when
 * positioning for an insert or delete, so NULL is used for those cases.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_moveright</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
              <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
              <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>,
              <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>nextkey</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>forupdate</name></decl></parameter>,
              <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
              <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>,
              <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmpval</name></decl>;</decl_stmt>

    <comment type="block">/*
     * When nextkey = false (normal case): if the scan key that brought us to
     * this page is &gt; the high key stored on the page, then the page has split
     * and we need to move right.  (If the scan key is equal to the high key,
     * we might or might not need to move right; have to scan the page first
     * anyway.)
     *
     * When nextkey = true: move right if the scan key is &gt;= page's high key.
     *
     * The page could even have split more than once, so scan as far as
     * needed.
     *
     * We also have to move right if we followed a link that brought us to a
     * dead page.
     */</comment>
    <expr_stmt><expr><name>cmpval</name> <operator>=</operator> <ternary><condition><expr><name>nextkey</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Finish any incomplete splits we encounter along the way.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>forupdate</name> <operator>&amp;&amp;</operator> <call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* upgrade our lock if necessary */</comment>
            <if_stmt><if>if <condition>(<expr><name>access</name> <operator>==</operator> <name>BT_READ</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>_bt_finish_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* re-acquire the lock in the right mode, and re-check */</comment>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>cmpval</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* step right one page */</comment>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fell off the end of index \"%s\""</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_binsrch() -- Do a binary search for a key on a particular page.
 *
 * The passed scankey must be an insertion-type scankey (see nbtree/README),
 * but it can omit the rightmost column(s) of the index.
 *
 * When nextkey is false (the usual case), we are looking for the first
 * item &gt;= scankey.  When nextkey is true, we are looking for the first
 * item strictly greater than scankey.
 *
 * On a leaf page, _bt_binsrch() returns the OffsetNumber of the first
 * key &gt;= given scankey, or &gt; scankey if nextkey is true.  (NOTE: in
 * particular, this means it is possible to return a value 1 greater than the
 * number of keys on the page, if the scankey is &gt; all keys on the page.)
 *
 * On an internal (non-leaf) page, _bt_binsrch() returns the OffsetNumber
 * of the last key &lt; given scankey, or last key &lt;= given scankey if nextkey
 * is true.  (Since _bt_compare treats the first data key of such a page as
 * minus infinity, there will be at least one key &lt; scankey, so the result
 * always points at one of the keys on the page.)  This key indicates the
 * right place to descend to be sure we find all leaf keys &gt;= given scankey
 * (or leaf keys &gt; given scankey when nextkey is true).
 *
 * This procedure is not responsible for walking right, it just examines
 * the given page.  _bt_binsrch() has no lock or refcount side effects
 * on the buffer.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>_bt_binsrch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
            <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>,
            <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>,
            <parameter><decl><type><name>bool</name></type> <name>nextkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>low</name></decl>,
                <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>result</name></decl>,
                <decl><type ref="prev"/><name>cmpval</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>low</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>high</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there are no keys on the page, return the first available slot. Note
     * this covers two cases: the page is really empty (no keys), or it
     * contains only a high key.  The latter case is possible after vacuuming.
     * This can never happen on an internal page, however, since they are
     * never empty (an internal page must have children).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>high</name> <operator>&lt;</operator> <name>low</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>low</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Binary search to find the first key on the page &gt;= scan key, or first
     * key &gt; scankey when nextkey is true.
     *
     * For nextkey=false (cmpval=1), the loop invariant is: all slots before
     * 'low' are &lt; scan key, all slots at or after 'high' are &gt;= scan key.
     *
     * For nextkey=true (cmpval=0), the loop invariant is: all slots before
     * 'low' are &lt;= scan key, all slots at or after 'high' are &gt; scan key.
     *
     * We can fall out when high == low.
     */</comment>
    <expr_stmt><expr><name>high</name><operator>++</operator></expr>;</expr_stmt>                        <comment type="block">/* establish the loop invariant for high */</comment>

    <expr_stmt><expr><name>cmpval</name> <operator>=</operator> <ternary><condition><expr><name>nextkey</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>    <comment type="block">/* select comparison value */</comment>

    <while>while <condition>(<expr><name>high</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>mid</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* We have low &lt;= mid &lt; high, so mid points at a real slot */</comment>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <name>cmpval</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * At this point we have high == low, but be careful: they could point
     * past the last slot on the page.
     *
     * On a leaf page, we always return the first key &gt;= scan key (resp. &gt;
     * scan key), which could be the last slot + 1.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>low</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * On a non-leaf page, return the last key &lt; scan key (resp. &lt;= scan key).
     * There must be one if _bt_compare() is playing by the rules.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>low</name> <operator>&gt;</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>low</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------
 *    _bt_compare() -- Compare scankey to a particular tuple on the page.
 *
 * The passed scankey must be an insertion-type scankey (see nbtree/README),
 * but it can omit the rightmost column(s) of the index.
 *
 *    keysz: number of key conditions to be checked (might be less than the
 *        number of index columns!)
 *    page/offnum: location of btree item to be compared to.
 *
 *        This routine returns:
 *            &lt;0 if scankey &lt; tuple at offnum;
 *             0 if scankey == tuple at offnum;
 *            &gt;0 if scankey &gt; tuple at offnum.
 *        NULLs in the keys are treated as sortable values.  Therefore
 *        "equality" does not necessarily mean that the item should be
 *        returned to the caller as a matching key!
 *
 * CRUCIAL NOTE: on a non-leaf page, the first data key is assumed to be
 * "minus infinity": this routine will always claim it is less than the
 * scankey.  The actual key value stored (if any, which there probably isn't)
 * does not matter.  This convention allows us to implement the Lehman and
 * Yao convention that the first down-link pointer is before the first key.
 * See backend/access/nbtree/README for details.
 *----------
 */</comment>
<function><type><name>int32</name></type>
<name>_bt_compare</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>,
            <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>,
            <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
            <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>itupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Force result "&gt;" if target item is first data item on an internal page
     * --- see NOTE above.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>offnum</name> <operator>==</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The scan key is set up with the attribute number associated with each
     * term in the key.  It is important that, if the index is multi-key, the
     * scan contain the first k key attributes, and that they be in order.  If
     * you think about how multi-key ordering works, you'll understand why
     * this is.
     *
     * We don't test for violation of this condition here, however.  The
     * initial setup for the index scan had better have gotten it right (see
     * _bt_first).
     */</comment>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* see comments about NULLs handling in btbuild */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>    <comment type="block">/* key is NULL */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>        <comment type="block">/* NULL "=" NULL */</comment>
            <if type="elseif">else if <condition>(<expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* NULL "&lt;" NOT_NULL */</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>        <comment type="block">/* NULL "&gt;" NOT_NULL */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>isNull</name></expr>)</condition>        <comment type="block">/* key is NOT_NULL and item is NULL */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>        <comment type="block">/* NOT_NULL "&gt;" NULL */</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* NOT_NULL "&lt;" NULL */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * The sk_func needs to be passed the index value as left arg and
             * the sk_argument as right arg (they might be of different
             * types).  Since it is convenient for callers to think of
             * _bt_compare as comparing the scankey to the index item, we have
             * to flip the sign of the comparison result.  (Unless it's a DESC
             * column, in which case we *don't* flip the sign.)
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
                                                     <argument><expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                                     <argument><expr><name>datum</name></expr></argument>,
                                                     <argument><expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>scankey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>result</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* if the keys are unequal, return the difference */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>scankey</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* if we get here, the keys are equal */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_first() -- Find the first item in a scan.
 *
 *        We need to be clever about the direction of scan, the search
 *        conditions, and the tree ordering.  We find the first item (or,
 *        if backwards scan, the last item) in the tree that satisfies the
 *        qualifications in the scan key.  On success exit, the page containing
 *        the current index tuple is pinned but not locked, and data about
 *        the matching tuple(s) on the page has been loaded into so-&gt;currPos.
 *        scan-&gt;xs_ctup.t_self is set to the heap TID of the current tuple,
 *        and if requested, scan-&gt;xs_itup points to a copy of the index tuple.
 *
 * If there are no matching items in the index, we return FALSE, with no
 * pins or locks held.
 *
 * Note that scan-&gt;keyData[], and the so-&gt;keyData[] scankey built from it,
 * are both search-type scankeys (see nbtree/README for more about this).
 * Within this routine, we build a temporary insertion-type scankey to use
 * in locating the scan start position.
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_first</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTStack</name></type>        <name>stack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>nextkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>goback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name><name>startKeys</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankeys</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>notnullkeys</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>keysCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>status</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strat_total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTScanPosItem</name> <modifier>*</modifier></type><name>currItem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTScanPosIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Examine the scan keys and eliminate any redundant keys; also mark the
     * keys that must be matched to continue the scan.
     */</comment>
    <expr_stmt><expr><call><name>_bt_preprocess_keys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Quit now if _bt_preprocess_keys() discovered that the scan keys can
     * never be satisfied (eg, x == 1 AND x &gt; 2).
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * For parallel scans, get the starting page from shared state. If the
     * scan has not started, proceed to find out first leaf page in the usual
     * way while keeping other participating processes waiting.  If the scan
     * has already begun, use the page number from the shared structure.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>_bt_parallel_seize</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NONE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>_bt_parallel_done</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>blkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_parallel_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <goto>goto <name>readcomplete</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*----------
     * Examine the scan keys to discover where we need to start the scan.
     *
     * We want to identify the keys that can be used as starting boundaries;
     * these are =, &gt;, or &gt;= keys for a forward scan or =, &lt;, &lt;= keys for
     * a backwards scan.  We can use keys for multiple attributes so long as
     * the prior attributes had only =, &gt;= (resp. =, &lt;=) keys.  Once we accept
     * a &gt; or &lt; boundary or find an attribute with no boundary (which can be
     * thought of as the same as "&gt; -infinity"), we can't use keys for any
     * attributes to its right, because it would break our simplistic notion
     * of what initial positioning strategy to use.
     *
     * When the scan keys include cross-type operators, _bt_preprocess_keys
     * may not be able to eliminate redundant keys; in such cases we will
     * arbitrarily pick a usable one for each attribute.  This is correct
     * but possibly not optimal behavior.  (For example, with keys like
     * "x &gt;= 4 AND x &gt;= 5" we would elect to scan starting at x=4 when
     * x=5 would be more efficient.)  Since the situation only arises given
     * a poorly-worded query plus an incomplete opfamily, live with it.
     *
     * When both equality and inequality keys appear for a single attribute
     * (again, only possible when cross-type operators appear), we *must*
     * select one of the equality keys for the starting point, because
     * _bt_checkkeys() will stop the scan as soon as an equality qual fails.
     * For example, if we have keys like "x &gt;= 4 AND x = 10" and we elect to
     * start at x=4, we will fail and stop before reaching x=10.  If multiple
     * equality quals survive preprocessing, however, it doesn't matter which
     * one we use --- by definition, they are either redundant or
     * contradictory.
     *
     * Any regular (not SK_SEARCHNULL) key implies a NOT NULL qualifier.
     * If the index stores nulls at the end of the index we'll be starting
     * from, and we have no boundary key for the column (which means the key
     * we deduced NOT NULL from is an inequality key that constrains the other
     * end of the index), then we cons up an explicit SK_SEARCHNOTNULL key to
     * use as a boundary key.  If we didn't do this, we might find ourselves
     * traversing a lot of null entries at the start of the scan.
     *
     * In this loop, row-comparison keys are treated the same as keys on their
     * first (leftmost) columns.  We'll add on lower-order columns of the row
     * comparison below, if possible.
     *
     * The selected scan keys (at most one per index column) are remembered by
     * storing their addresses into the local startKeys[] array.
     *----------
     */</comment>
    <expr_stmt><expr><name>strat_total</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>curattr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>chosen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>impliesNN</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>cur</name></decl>;</decl_stmt>

        <comment type="block">/*
         * chosen is the so-far-chosen key for the current attribute, if any.
         * We don't cast the decision in stone until we reach keys for the
         * next attribute.
         */</comment>
        <expr_stmt><expr><name>curattr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>chosen</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <comment type="block">/* Also remember any scankey that implies a NOT NULL constraint */</comment>
        <expr_stmt><expr><name>impliesNN</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Loop iterates from 0 to numberOfKeys inclusive; we use the last
         * pass to handle after-last-key processing.  Actual exit from the
         * loop is at one of the "break" statements below.
         */</comment>
        <for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>!=</operator> <name>curattr</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Done looking at keys for curattr.  If we didn't find a
                 * usable boundary key, see if we can deduce a NOT NULL key.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>chosen</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>impliesNN</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                    <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>impliesNN</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator></expr> ?</condition><then>
                     <expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr> </then><else>:
                     <expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Yes, so build the key in notnullkeys[keysCount] */</comment>
                    <expr_stmt><expr><name>chosen</name> <operator>=</operator> <operator>&amp;</operator><name><name>notnullkeys</name><index>[<expr><name>keysCount</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>chosen</name></expr></argument>,
                                           <argument><expr><operator>(</operator><name>SK_SEARCHNOTNULL</name> <operator>|</operator> <name>SK_ISNULL</name> <operator>|</operator>
                                            <operator>(</operator><name><name>impliesNN</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator>
                                             <operator>(</operator><name>SK_BT_DESC</name> <operator>|</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator><operator>)</operator><operator>)</operator></expr></argument>,
                                           <argument><expr><name>curattr</name></expr></argument>,
                                           <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>impliesNN</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator></expr> ?</condition><then>
                                            <expr><name>BTGreaterStrategyNumber</name></expr> </then><else>:
                                            <expr><name>BTLessStrategyNumber</name></expr></else></ternary><operator>)</operator></expr></argument>,
                                           <argument><expr><name>InvalidOid</name></expr></argument>,
                                           <argument><expr><name>InvalidOid</name></expr></argument>,
                                           <argument><expr><name>InvalidOid</name></expr></argument>,
                                           <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * If we still didn't find a usable boundary key, quit; else
                 * save the boundary key pointer in startKeys.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>chosen</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>startKeys</name><index>[<expr><name>keysCount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>chosen</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Adjust strat_total, and quit if we have stored a &gt; or &lt;
                 * key.
                 */</comment>
                <expr_stmt><expr><name>strat</name> <operator>=</operator> <name><name>chosen</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>strat</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>strat_total</name> <operator>=</operator> <name>strat</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>strat</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name> <operator>||</operator>
                        <name>strat</name> <operator>==</operator> <name>BTLessStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Done if that was the last attribute, or if next key is not
                 * in sequence (implying no boundary key is available for the
                 * next attribute).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>||</operator>
                    <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>!=</operator> <name>curattr</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Reset for next attr.
                 */</comment>
                <expr_stmt><expr><name>curattr</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>chosen</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>impliesNN</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Can we use this key as a starting boundary for this attr?
             *
             * If not, does it imply a NOT NULL constraint?  (Because
             * SK_SEARCHNULL keys are always assigned BTEqualStrategyNumber,
             * *any* inequality key works for that; we need not test.)
             */</comment>
            <switch>switch <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
                <case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name>chosen</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>chosen</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>impliesNN</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
                    <comment type="block">/* override any non-equality choice */</comment>
                    <expr_stmt><expr><name>chosen</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
                <case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name>chosen</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>chosen</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>impliesNN</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we found no usable boundary keys, we have to start from one end of
     * the tree.  Walk down that edge to the first or last key, and scan from
     * there.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>keysCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>match</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>_bt_endpoint</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* No match, so mark (parallel) scan finished */</comment>
            <expr_stmt><expr><call><name>_bt_parallel_done</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>match</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We want to start the scan somewhere within the index.  Set up an
     * insertion scankey we can use to search for the boundary point we
     * identified above.  The insertion scankey is built in the local
     * scankeys[] array, using the keys identified by startKeys[].
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysCount</name> <operator>&lt;=</operator> <name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keysCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>cur</name> <init>= <expr><name><name>startKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Row comparison header: look to the first row member instead.
             *
             * The member scankeys are already in insertion format (ie, they
             * have sk_func = 3-way-comparison function), but we have to watch
             * out for nulls, which _bt_preprocess_keys didn't check. A null
             * in the first row member makes the condition unmatchable, just
             * like qual_ok = false.
             */</comment>
            <decl_stmt><decl><type><name>ScanKey</name></type>        <name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>_bt_parallel_done</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scankeys</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>subkey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the row comparison is the last positioning key we accepted,
             * try to add additional keys from the lower-order row members.
             * (If we accepted independent conditions on additional index
             * columns, we use those instead --- doesn't seem worth trying to
             * determine which is more restrictive.)  Note that this is OK
             * even if the row comparison is of "&gt;" or "&lt;" type, because the
             * condition applied to all but the last row member is effectively
             * "&gt;=" or "&lt;=", and so the extra keys don't break the positioning
             * scheme.  But, by the same token, if we aren't able to use all
             * the row members, then the part of the row comparison that we
             * did use has to be treated as just a "&gt;=" or "&lt;=" condition, and
             * so we'd better adjust strat_total accordingly.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>keysCount</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type>        <name>used_all_subkeys</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>subkey</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>!=</operator> <name>keysCount</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* out-of-sequence, can't use it */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>!=</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* wrong direction, can't use it */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* can't use null keys */</comment>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysCount</name> <operator>&lt;</operator> <name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scankeys</name> <operator>+</operator> <name>keysCount</name></expr></argument>, <argument><expr><name>subkey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>keysCount</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>used_all_subkeys</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>used_all_subkeys</name></expr>)</condition>
                <block>{<block_content>
                    <switch>switch <condition>(<expr><name>strat_total</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
                            <expr_stmt><expr><name>strat_total</name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
                            <expr_stmt><expr><name>strat_total</name> <operator>=</operator> <name>BTGreaterEqualStrategyNumber</name></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>            <comment type="block">/* done with outer loop */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Ordinary comparison key.  Transform the search-style scan key
             * to an insertion scan key by replacing the sk_func with the
             * appropriate btree comparison function.
             *
             * If scankey operator is not a cross-type comparison, we can use
             * the cached comparison function; otherwise gotta look it up in
             * the catalogs.  (That can't lead to infinite recursion, since no
             * indexscan initiated by syscache lookup will use cross-data-type
             * operators.)
             *
             * We support the convention that sk_subtype == InvalidOid means
             * the opclass input type; this is a hack to simplify life for
             * ScanKeyInit().
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
                <name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ScanKeyEntryInitializeWithInfo</name><argument_list>(<argument><expr><name>scankeys</name> <operator>+</operator> <name>i</name></expr></argument>,
                                               <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name></expr></argument>,
                                               <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
                                               <argument><expr><name>InvalidStrategy</name></expr></argument>,
                                               <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>,
                                               <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                               <argument><expr><name>procinfo</name></expr></argument>,
                                               <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>RegProcedure</name></type> <name>cmp_proc</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                             <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                             <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>,
                                             <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) for attribute %d of index \"%s\""</literal></expr></argument>,
                         <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>,
                         <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>scankeys</name> <operator>+</operator> <name>i</name></expr></argument>,
                                       <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name></expr></argument>,
                                       <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
                                       <argument><expr><name>InvalidStrategy</name></expr></argument>,
                                       <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>,
                                       <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                       <argument><expr><name>cmp_proc</name></expr></argument>,
                                       <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*----------
     * Examine the selected initial-positioning strategy to determine exactly
     * where we need to start the scan, and set flag variables to control the
     * code below.
     *
     * If nextkey = false, _bt_search and _bt_binsrch will locate the first
     * item &gt;= scan key.  If nextkey = true, they will locate the first
     * item &gt; scan key.
     *
     * If goback = true, we will then step back one item, while if
     * goback = false, we will start the scan on the located item.
     *----------
     */</comment>
    <switch>switch <condition>(<expr><name>strat_total</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>

            <comment type="block">/*
             * Find first item &gt;= scankey, then back up one to arrive at last
             * item &lt; scankey.  (Note: this positioning strategy is only used
             * for a backward scan, so that is always the correct starting
             * position.)
             */</comment>
            <expr_stmt><expr><name>nextkey</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>goback</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>

            <comment type="block">/*
             * Find first item &gt; scankey, then back up one to arrive at last
             * item &lt;= scankey.  (Note: this positioning strategy is only used
             * for a backward scan, so that is always the correct starting
             * position.)
             */</comment>
            <expr_stmt><expr><name>nextkey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>goback</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>

            <comment type="block">/*
             * If a backward scan was specified, need to start with last equal
             * item not first one.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * This is the same as the &lt;= strategy.  We will check at the
                 * end whether the found item is actually =.
                 */</comment>
                <expr_stmt><expr><name>nextkey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>goback</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * This is the same as the &gt;= strategy.  We will check at the
                 * end whether the found item is actually =.
                 */</comment>
                <expr_stmt><expr><name>nextkey</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>goback</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>

        <case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>

            <comment type="block">/*
             * Find first item &gt;= scankey.  (This is only used for forward
             * scans.)
             */</comment>
            <expr_stmt><expr><name>nextkey</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>goback</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>

            <comment type="block">/*
             * Find first item &gt; scankey.  (This is only used for forward
             * scans.)
             */</comment>
            <expr_stmt><expr><name>nextkey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>goback</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* can't get here, but keep compiler quiet */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strat_total: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>strat_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Use the manufactured insertion scan key to descend the tree and
     * position ourselves on the target leaf page.
     */</comment>
    <expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>_bt_search</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keysCount</name></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>, <argument><expr><name>nextkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>,
                       <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* don't need to keep the stack around... */</comment>
    <expr_stmt><expr><call><name>_bt_freestack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We only get here if the index is completely empty. Lock relation
         * because nothing finer to lock exists.
         */</comment>
        <expr_stmt><expr><call><name>PredicateLockRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * mark parallel scan as done, so that all the workers can finish
         * their scan
         */</comment>
        <expr_stmt><expr><call><name>_bt_parallel_done</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>_bt_initialize_more_data</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* position to the precise item on the page */</comment>
    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_bt_binsrch</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>keysCount</name></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>, <argument><expr><name>nextkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If nextkey = false, we are positioned at the first item &gt;= scan key, or
     * possibly at the end of a page on which all the existing items are less
     * than the scan key and we know that everything on later pages is greater
     * than or equal to scan key.
     *
     * If nextkey = true, we are positioned at the first item &gt; scan key, or
     * possibly at the end of a page on which all the existing items are less
     * than or equal to the scan key and we know that everything on later
     * pages is greater than scan key.
     *
     * The actually desired starting point is either this item or the prior
     * one, or in the end-of-page case it's the first item on the next page or
     * the last item on this page.  Adjust the starting offset if needed. (If
     * this results in an offset before the first item or after the last one,
     * _bt_readpage will report no items found, and then we'll step to the
     * next page as needed.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>goback</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* remember which buffer we have pinned, if any */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTScanPosIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Now load data from the first page of the scan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * There's no actually-matching data on this page.  Try to advance to
         * the next page.  Return false if there's no matching data at all.
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_steppage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Drop the lock, and maybe the pin, on the current page */</comment>
        <expr_stmt><expr><call><name>_bt_drop_lock_and_maybe_pin</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<label><name>readcomplete</name>:</label>
    <comment type="block">/* OK, itemIndex says what to return */</comment>
    <expr_stmt><expr><name>currItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itup</name></name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>currTuples</name></name> <operator>+</operator> <name><name>currItem</name><operator>-&gt;</operator><name>tupleOffset</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_next() -- Get the next item in a scan.
 *
 *        On entry, so-&gt;currPos describes the current page, which may be pinned
 *        but is not locked, and so-&gt;currPos.itemIndex identifies which item was
 *        previously returned.
 *
 *        On successful exit, scan-&gt;xs_ctup.t_self is set to the TID of the
 *        next heap tuple, and if requested, scan-&gt;xs_itup points to a copy of
 *        the index tuple.  so-&gt;currPos is updated as needed.
 *
 *        On failure exit (no more tuples), we release pin and set
 *        so-&gt;currPos.buf to InvalidBuffer.
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_next</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTScanPosItem</name> <modifier>*</modifier></type><name>currItem</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Advance to next tuple on current page; or if there's no more, try to
     * step to the next page with data.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>&gt;</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_steppage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_steppage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* OK, itemIndex says what to return */</comment>
    <expr_stmt><expr><name>currItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itup</name></name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>currTuples</name></name> <operator>+</operator> <name><name>currItem</name><operator>-&gt;</operator><name>tupleOffset</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_readpage() -- Load data from current index page into so-&gt;currPos
 *
 * Caller must have pinned and read-locked so-&gt;currPos.buf; the buffer's state
 * is not changed here.  Also, currPos.moreLeft and moreRight must be valid;
 * they are updated as appropriate.  All other fields of so-&gt;currPos are
 * initialized from scratch here.
 *
 * We scan the current page starting at offnum and moving in the indicated
 * direction.  All items matching the scan keys are loaded into currPos.items.
 * moreLeft or moreRight (as appropriate) is cleared if _bt_checkkeys reports
 * that there can be no more matching tuples in the current scan direction.
 *
 * In the case of a parallel scan, caller must have called _bt_parallel_seize
 * prior to calling this function; this function will invoke
 * _bt_parallel_release before returning.
 *
 * Returns true if any matching items found on the page, false if none.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_readpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>minoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>itemIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>continuescan</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We must have the buffer pinned and locked, but the usual macro can't be
     * used here; this function is what makes it good for currPos.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* allow next page be processed by parallel worker */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_bt_parallel_release</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_bt_parallel_release</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We note the buffer's block number so that we can release the pin later.
     * This allows us to re-read the buffer if it is needed again for hinting.
     */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We save the LSN of the page as we read it, so that we know whether it
     * safe to apply LP_DEAD hints to the page later.  This allows us to drop
     * the pin for MVCC scans, which allows vacuum to avoid blocking.
     */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * we must save the page's right-link while scanning it; this tells us
     * where to step right to after we're done with these items.  There is no
     * corresponding need for the left-link, since splits always go right.
     */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextPage</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

    <comment type="block">/* initialize tuple workspace to empty */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextTupleOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Now that the current page has been made consistent, the macro should be
     * good.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTScanPosIsPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* load items[] in ascending order */</comment>
        <expr_stmt><expr><name>itemIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>_bt_checkkeys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>continuescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>itup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* tuple passes all scan key conditions, so remember it */</comment>
                <expr_stmt><expr><call><name>_bt_saveitem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>itemIndex</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>itemIndex</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>continuescan</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* there can't be any more matches, so stop */</comment>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreRight</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&lt;=</operator> <name>MaxIndexTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name> <operator>=</operator> <name>itemIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* load items[] in descending order */</comment>
        <expr_stmt><expr><name>itemIndex</name> <operator>=</operator> <name>MaxIndexTuplesPerPage</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>offnum</name> <operator>&gt;=</operator> <name>minoff</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>_bt_checkkeys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>continuescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>itup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* tuple passes all scan key conditions, so remember it */</comment>
                <expr_stmt><expr><name>itemIndex</name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>_bt_saveitem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>itemIndex</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>continuescan</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* there can't be any more matches, so stop */</comment>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreLeft</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>=</operator> <name>itemIndex</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name> <operator>=</operator> <name>MaxIndexTuplesPerPage</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>=</operator> <name>MaxIndexTuplesPerPage</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>&lt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Save an index item into so-&gt;currPos.items[itemIndex] */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_saveitem</name><parameter_list>(<parameter><decl><type><name>BTScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>,
             <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTScanPosItem</name> <modifier>*</modifier></type><name>currItem</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name>itemIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>currItem</name><operator>-&gt;</operator><name>indexOffset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>currTuples</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Size</name></type>        <name>itupsz</name> <init>= <expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>currItem</name><operator>-&gt;</operator><name>tupleOffset</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextTupleOffset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currTuples</name></name> <operator>+</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextTupleOffset</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextTupleOffset</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_steppage() -- Step to next page containing valid data for scan
 *
 * On entry, if so-&gt;currPos.buf is valid the buffer is pinned but not locked;
 * if pinned, we'll drop the pin before moving to next page.  The buffer is
 * not locked on entry.
 *
 * For success on a scan using a non-MVCC snapshot we hold a pin, but not a
 * read lock, on that page.  If we do not hold the pin, we set so-&gt;currPos.buf
 * to InvalidBuffer.  We return TRUE to indicate success.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_steppage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>status</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTScanPosIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Before leaving current page, deal with any killed items */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_bt_killitems</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Before we modify currPos, make a copy of the page data if there was a
     * mark position that needs it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>markItemIndex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* bump pin on current buffer for assignment to mark buffer */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>BTScanPosIsPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>markPos</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>,
               <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTScanPosData</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
               <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTScanPosItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>markTuples</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>markTuples</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currTuples</name></name></expr></argument>,
                   <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextTupleOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>markPos</name><operator>.</operator><name>itemIndex</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>markItemIndex</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>markItemIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Walk right to the next page with data */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Seize the scan to get the next block number; if the scan has
             * ended already, bail out.
             */</comment>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>_bt_parallel_seize</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* release the previous buffer, if pinned */</comment>
                <expr_stmt><expr><call><name>BTScanPosUnpinIfPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Not parallel, so use the previously-saved nextPage link. */</comment>
            <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextPage</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Remember we left a page with data */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreLeft</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* release the previous buffer, if pinned */</comment>
        <expr_stmt><expr><call><name>BTScanPosUnpinIfPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Remember we left a page with data */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreRight</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Seize the scan to get the current block number; if the scan has
             * ended already, bail out.
             */</comment>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>_bt_parallel_seize</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BTScanPosUnpinIfPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Not parallel, so just use our own notion of the current page */</comment>
            <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_readnextpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Drop the lock, and maybe the pin, on the current page */</comment>
    <expr_stmt><expr><call><name>_bt_drop_lock_and_maybe_pin</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_readnextpage() -- Read next page containing valid data for scan
 *
 * On success exit, so-&gt;currPos is updated to contain data from the next
 * interesting page.  Caller is responsible to release lock and pin on
 * buffer on success.  We return TRUE to indicate success.
 *
 * If there are no more matching records in the given direction, we drop all
 * locks and pins, set so-&gt;currPos.buf to InvalidBuffer, and return FALSE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_readnextpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>status</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <comment type="block">/*
             * if we're at end of scan, give up and mark parallel scan as
             * done, so that all the workers can finish their scan
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NONE</name> <operator>||</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreRight</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>_bt_parallel_done</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* check for interrupts while we're not holding any buffer lock */</comment>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* step right one page */</comment>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* check for deleted page */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* see if there are any matches on this page */</comment>
                <comment type="block">/* note that this will clear moreRight if we can stop */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>_bt_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* nope, keep going */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>_bt_parallel_seize</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Should only happen in parallel cases, when some other backend
         * advanced the scan.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name> <operator>!=</operator> <name>blkno</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>BTScanPosUnpinIfPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Walk left to the next page with data.  This is much more complex
         * than the walk-right case because of the possibility that the page
         * to our left splits while we are in flight to it, plus the
         * possibility that the page we were on gets deleted after we leave
         * it.  See nbtree/README for details.
         *
         * It might be possible to rearrange this code to have less overhead
         * in pinning and locking, but that would require capturing the left
         * pointer when the page is initially read, and using it here, along
         * with big changes to _bt_walk_left() and the code below.  It is not
         * clear whether this would be a win, since if the page immediately to
         * the left splits after we read this page and before we step left, we
         * would need to visit more pages than with the current code.
         *
         * Note that if we change the code so that we drop the pin for a scan
         * which uses a non-MVCC snapshot, we will need to modify the code for
         * walking left, to allow for the possibility that a referenced page
         * has been deleted.  As long as the buffer is pinned or the snapshot
         * is MVCC the page cannot move past the half-dead state to fully
         * deleted.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>BTScanPosIsPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <comment type="block">/* Done if we know there are no matching keys to the left */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreLeft</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>_bt_parallel_done</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Step to next physical page */</comment>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <call><name>_bt_walk_left</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>,
                                            <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* if we're physically at end of index, return failure */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>_bt_parallel_done</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Okay, we managed to move left to a non-deleted page. Done if
             * it's not half-dead and contains matching tuples. Else loop back
             * and do it all again.
             */</comment>
            <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* see if there are any matches on this page */</comment>
                <comment type="block">/* note that this will clear moreLeft if we can stop */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>_bt_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * For parallel scans, get the last page scanned as it is quite
             * possible that by the time we try to seize the scan, some other
             * worker has already advanced the scan to a different page.  We
             * must continue based on the latest page scanned by any worker.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>_bt_parallel_seize</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_parallel_readpage() -- Read current page containing valid data for scan
 *
 * On success, release lock and maybe pin on buffer.  We return TRUE to
 * indicate success.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_parallel_readpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>_bt_initialize_more_data</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_readnextpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Drop the lock, and maybe the pin, on the current page */</comment>
    <expr_stmt><expr><call><name>_bt_drop_lock_and_maybe_pin</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_walk_left() -- step left one page, if possible
 *
 * The given buffer must be pinned and read-locked.  This will be dropped
 * before stepping left.  On return, we have pin and read lock on the
 * returned page, instead.
 *
 * Returns InvalidBuffer if there is no page to the left (no lock is held
 * in that case).
 *
 * When working on a non-leaf level, it is possible for the returned page
 * to be half-dead; the caller should check that condition and step left
 * again if it's important.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>_bt_walk_left</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>obknum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>lblkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>tries</name></decl>;</decl_stmt>

        <comment type="block">/* if we're at end of tree, release buf and return failure */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* remember original page we are stepping left from */</comment>
        <expr_stmt><expr><name>obknum</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* step left */</comment>
        <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>lblkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* check for interrupts while we're not holding any buffer lock */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If this isn't the page we want, walk right till we find what we
         * want --- but go no more than four hops (an arbitrary limit). If we
         * don't find the correct page by then, the most likely bet is that
         * the original page got deleted and isn't in the sibling chain at all
         * anymore, not that its left sibling got split more than four times.
         *
         * Note that it is correct to test P_ISDELETED not P_IGNORE here,
         * because half-dead pages are still in the sibling chain.  Caller
         * must reject half-dead pages if wanted.
         */</comment>
        <expr_stmt><expr><name>tries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>==</operator> <name>obknum</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Found desired page, return it */</comment>
                <return>return <expr><name>buf</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>++</operator><name>tries</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Return to the original page to see what's up */</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>obknum</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * It was deleted.  Move right to first nondeleted page (there
             * must be one); that is the page that has acquired the deleted
             * one's keyspace, so stepping left from it will take us where we
             * want to be.
             */</comment>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fell off the end of index \"%s\""</literal></expr></argument>,
                         <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * Now return to top of loop, resetting obknum to point to this
             * nondeleted page, and try again.
             */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * It wasn't deleted; the explanation had better be that the page
             * to the left got split or deleted. Without this check, we'd go
             * into an infinite loop if there's anything wrong.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>==</operator> <name>lblkno</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find left sibling of block %u in index \"%s\""</literal></expr></argument>,
                     <argument><expr><name>obknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Okay to try again with new lblkno value */</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>InvalidBuffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_get_endpoint() -- Find the first or last page on a given tree level
 *
 * If the index is empty, we will return InvalidBuffer; any other failure
 * condition causes ereport().  We will not return a dead page.
 *
 * The returned buffer is pinned and read-locked.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_get_endpoint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rightmost</name></decl></parameter>,
                 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If we are looking for a leaf page, okay to descend from fast root;
     * otherwise better descend from true root.  (There is no point in being
     * smarter about intermediate levels.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getroot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_gettrueroot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidBuffer</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * If we landed on a deleted page, step right to find a live page
         * (there must be one).  Also, if we want the rightmost page, step
         * right if needed to get to it (this could happen if the page split
         * since we obtained a pointer to it).
         */</comment>
        <while>while <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator>
               <operator>(</operator><name>rightmost</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NONE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fell off the end of index \"%s\""</literal></expr></argument>,
                     <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Done? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>==</operator> <name>level</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>&lt;</operator> <name>level</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btree level %u not found in index \"%s\""</literal></expr></argument>,
                 <argument><expr><name>level</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Descend to leftmost or rightmost child page */</comment>
        <if_stmt><if>if <condition>(<expr><name>rightmost</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _bt_endpoint() -- Find the first or last page in the index, and scan
 * from there to the first key satisfying all the quals.
 *
 * This is used by _bt_first() to set up a scan when we've determined
 * that the scan must start at the beginning or end of the index (for
 * a forward or backward scan respectively).  Exit conditions are the
 * same as for _bt_first().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_endpoint</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTScanPosItem</name> <modifier>*</modifier></type><name>currItem</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Scan down to the leftmost or rightmost leaf page.  This is a simplified
     * version of _bt_search().  We don't maintain a stack since we know we
     * won't need it.
     */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_get_endpoint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Empty index. Lock the whole relation, as nothing finer to lock
         * exists.
         */</comment>
        <expr_stmt><expr><call><name>PredicateLockRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BTScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* There could be dead pages to the left, so not this: */</comment>
        <comment type="block">/* Assert(P_LEFTMOST(opaque)); */</comment>

        <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid scan direction: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* remember which buffer we have pinned */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_initialize_more_data</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now load data from the first page of the scan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * There's no actually-matching data on this page.  Try to advance to
         * the next page.  Return false if there's no matching data at all.
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_steppage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Drop the lock, and maybe the pin, on the current page */</comment>
        <expr_stmt><expr><call><name>_bt_drop_lock_and_maybe_pin</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* OK, itemIndex says what to return */</comment>
    <expr_stmt><expr><name>currItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itup</name></name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>currTuples</name></name> <operator>+</operator> <name><name>currItem</name><operator>-&gt;</operator><name>tupleOffset</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_initialize_more_data() -- initialize moreLeft/moreRight appropriately
 * for scan direction
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>_bt_initialize_more_data</name><parameter_list>(<parameter><decl><type><name>BTScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* initialize moreLeft/moreRight appropriately for scan direction */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreLeft</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreRight</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreLeft</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>moreRight</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* just paranoia */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>markItemIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* ditto */</comment>
</block_content>}</block></function>
</unit>
