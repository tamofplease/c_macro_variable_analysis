<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/nbtree/nbtsort.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtsort.c
 *        Build a btree from sorted input by loading leaf pages sequentially.
 *
 * NOTES
 *
 * We use tuplesort.c to sort the given index tuples into order.
 * Then we scan the index tuples in order and build the btree pages
 * for each level.  We load source tuples into leaf-level pages.
 * Whenever we fill a page at one level, we add a link to it to its
 * parent level (starting a new parent level if necessary).  When
 * done, we write out each final page on each level, adding it to
 * its parent level.  When we have only one page on a level, it must be
 * the root -- it can be attached to the btree metapage and we are done.
 *
 * This code is moderately slow (~10% slower) compared to the regular
 * btree (insertion) build code on sorted or well-clustered data.  On
 * random data, however, the insertion build code is unusable -- the
 * difference on a 60MB heap is a factor of 15 because the random
 * probes into the btree thrash the buffer pool.  (NOTE: the above
 * "10%" estimate is probably obsolete, since it refers to an old and
 * not very good external sort implementation that used to exist in
 * this module.  tuplesort.c is almost certainly faster.)
 *
 * It is not wise to pack the pages entirely full, since then *any*
 * insertion would cause a split (and not only of the leaf page; the need
 * for a split would cascade right up the tree).  The steady-state load
 * factor for btrees is usually estimated at 70%.  We choose to pack leaf
 * pages to the user-controllable fill factor (default 90%) while upper pages
 * are always packed to 70%.  This gives us reasonable density (there aren't
 * many upper pages if the keys are reasonable-size) without risking a lot of
 * cascading splits during early insertions.
 *
 * Formerly the index pages being built were kept in shared buffers, but
 * that is of no value (since other backends have no interest in them yet)
 * and it created locking problems for CHECKPOINT, because the upper-level
 * pages were held exclusive-locked for long periods.  Now we just build
 * the pages in local memory and smgrwrite or smgrextend them as we finish
 * them.  They will need to be re-read into shared buffers on first use after
 * the build finishes.
 *
 * Since the index will never be used unless it is completely built,
 * from a crash-recovery point of view there is no need to WAL-log the
 * steps of the build.  After completing the index build, we can just sync
 * the whole file to disk using smgrimmedsync() before exiting this module.
 * This can be seen to be sufficient for crash recovery by considering that
 * it's effectively equivalent to what would happen if a CHECKPOINT occurred
 * just after the index build.  However, it is clearly not sufficient if the
 * DBA is using the WAL log for PITR or replication purposes, since another
 * machine would not be able to reconstruct the index from WAL.  Therefore,
 * we log the completed index pages to WAL if and only if WAL archiving is
 * active.
 *
 * This code isn't concerned about the FSM at all. The caller is responsible
 * for initializing that.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/access/nbtree/nbtsort.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/relcryptstorage.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Status record for spooling/sorting phase.  (Note we may have two of
 * these due to the special requirements for uniqueness-checking with
 * dead tuples.)
 */</comment>
<struct>struct <name>BTSpool</name>
<block>{
    <decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>sortstate</name></decl>;</decl_stmt>    <comment type="block">/* state data for tuplesort.c */</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>heap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isunique</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Status record for a btree page being built.  We have one of these
 * for each active tree level.
 *
 * The reason we need to store a copy of the minimum key is that we'll
 * need to propagate it to the parent node when this page is linked
 * into its parent.  However, if the page is not a leaf page, the first
 * entry on the page doesn't need to contain a key, so we will not have
 * stored the key itself on the page.  (You might think we could skip
 * copying the minimum key on leaf pages, but actually we must have a
 * writable copy anyway because we'll poke the page's address into it
 * before passing it up to the parent...)
 */</comment>
<typedef>typedef <type><struct>struct <name>BTPageState</name>
<block>{
    <decl_stmt><decl><type><name>Page</name></type>        <name>btps_page</name></decl>;</decl_stmt>        <comment type="block">/* workspace for page building */</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>btps_blkno</name></decl>;</decl_stmt>        <comment type="block">/* block # to write this page at */</comment>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>btps_minkey</name></decl>;</decl_stmt>    <comment type="block">/* copy of minimum key (first item) on page */</comment>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>btps_lastoff</name></decl>;</decl_stmt>    <comment type="block">/* last item offset loaded */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>btps_level</name></decl>;</decl_stmt>        <comment type="block">/* tree level (0 = leaf) */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>btps_full</name></decl>;</decl_stmt>        <comment type="block">/* "full" if less than this much free space */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>BTPageState</name></name> <modifier>*</modifier></type><name>btps_next</name></decl>;</decl_stmt>    <comment type="block">/* link to parent level, if any */</comment>
}</block></struct></type> <name>BTPageState</name>;</typedef>

<comment type="block">/*
 * Overall status record for index writing phase.
 */</comment>
<typedef>typedef <type><struct>struct <name>BTWriteState</name>
<block>{
    <decl_stmt><decl><type><name>Relation</name></type>    <name>heap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>btws_use_wal</name></decl>;</decl_stmt>    <comment type="block">/* dump pages to WAL? */</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>btws_pages_alloced</name></decl>;</decl_stmt> <comment type="block">/* # pages allocated */</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>btws_pages_written</name></decl>;</decl_stmt> <comment type="block">/* # pages written out */</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>btws_zeropage</name></decl>;</decl_stmt>    <comment type="block">/* workspace for filling zeroes */</comment>
}</block></struct></type> <name>BTWriteState</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>Page</name></type> <name>_bt_blnewpage</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BTPageState</name> <modifier>*</modifier></type><name>_bt_pagestate</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_slideleft</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_sortaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>,
               <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_buildadd</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
             <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_uppershutdown</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_load</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>,
         <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Interface routines
 */</comment>


<comment type="block">/*
 * create and initialize a spool structure
 */</comment>
<function><type><name>BTSpool</name> <modifier>*</modifier></type>
<name>_bt_spoolinit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isunique</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>btspool</name> <init>= <expr><operator>(</operator><name>BTSpool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTSpool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>btKbytes</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name>isunique</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We size the sort area as maintenance_work_mem rather than work_mem to
     * speed index creation.  This should be OK since a single backend can't
     * run multiple index creations in parallel.  Note that creation of a
     * unique index actually requires two BTSpool objects.  We expect that the
     * second one (for dead tuples) won't get very full, so we give it only
     * work_mem.
     */</comment>
    <expr_stmt><expr><name>btKbytes</name> <operator>=</operator> <ternary><condition><expr><name>isdead</name></expr> ?</condition><then> <expr><name>work_mem</name></expr> </then><else>: <expr><name>maintenance_work_mem</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <call><name>tuplesort_begin_index_btree</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>isunique</name></expr></argument>,
                                                     <argument><expr><name>btKbytes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>btspool</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clean up a spool structure and its substructures.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_spooldestroy</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>btspool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * spool an index entry into the sort file.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_spool</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>tuplesort_putindextuplevalues</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
                                  <argument><expr><name>self</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * given a spool loaded by successive calls to _bt_spool,
 * create an entire btree.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_leafbuild</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTWriteState</name></type> <name>wstate</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BTREE BUILD (Spool) STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* BTREE_BUILD_STATS */</comment>

    <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>btspool2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to log index creation in WAL iff WAL archiving/streaming is
     * enabled UNLESS the index isn't WAL-logged anyway.
     */</comment>
    <expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_use_wal</name></name> <operator>=</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>wstate</name><operator>.</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* reserve the metapage */</comment>
    <expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_pages_alloced</name></name> <operator>=</operator> <name>BTREE_METAPAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_pages_written</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_zeropage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* until needed */</comment>

    <expr_stmt><expr><call><name>_bt_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wstate</name></expr></argument>, <argument><expr><name>btspool</name></expr></argument>, <argument><expr><name>btspool2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Internal routines.
 */</comment>


<comment type="block">/*
 * allocate workspace for a new, clean btree page, not linked to any siblings.
 */</comment>
<function><type><specifier>static</specifier> <name>Page</name></type>
<name>_bt_blnewpage</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Zero the page and set up standard page header info */</comment>
    <expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize BT opaque state */</comment>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BTP_LEAF</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Make the P_HIKEY line pointer appear allocated */</comment>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * emit a completed btree page, and release the working storage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_blwritepage</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Page</name></type> <name>bufBlockEncrypt</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Ensure rd_smgr is open (could have been closed by relcache flush!) */</comment>
    <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XLOG stuff */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_use_wal</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We use the heap NEWPAGE record type for this */</comment>
        <expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we have to write pages nonsequentially, fill in the space with
     * zeroes until we come back and overwrite.  This is not logically
     * necessary on standard Unix filesystems (unwritten space will read as
     * zeroes anyway), but it should help to avoid fragmentation. The dummy
     * pages aren't WAL-logged though.
     */</comment>
    <while>while <condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>wstate</name><operator>-&gt;</operator><name>btws_zeropage</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_zeropage</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* don't set checksum for all-zero page */</comment>
        <expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
                   <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name><operator>++</operator></expr></argument>,
                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_zeropage</name></name></expr></argument>,
                   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <comment type="block">/*
     * we did crypt on a shadow block, not the orignal one.
     * and, the shadow block dose not need to free, we alloc it once and it resides in top memory context.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>REL_CRYPT_ENTRY_IS_VALID</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_relcrypt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bufBlockEncrypt</name> <operator>=</operator> <call><name>rel_crypt_page_encrypt</name><argument_list>(<argument><expr><operator>(</operator><name>RelCrypt</name><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_relcrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>bufBlockEncrypt</name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Now write the page.  There's no need for smgr to schedule an fsync for
     * this write; we'll do it ourselves before ending the build.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* extending the file... */</comment>
        <expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlockEncrypt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* overwriting a block we zero-filled before */</comment>
        <expr_stmt><expr><call><name>smgrwrite</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
                  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlockEncrypt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * allocate and initialize a new BTPageState.  the returned structure
 * is suitable for immediate use by _bt_buildadd.
 */</comment>
<function><type><specifier>static</specifier> <name>BTPageState</name> <modifier>*</modifier></type>
<name>_bt_pagestate</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>BTPageState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTPageState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* create initial page for level */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_page</name></name> <operator>=</operator> <call><name>_bt_blnewpage</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* and assign it a page position */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_blkno</name></name> <operator>=</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_alloced</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* initialize lastoff so first item goes into P_FIRSTKEY */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_lastoff</name></name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
    <comment type="block">/* set "full" threshold based on level.  See notes at head of file. */</comment>
    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_full</name></name> <operator>=</operator> <operator>(</operator><name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>BTREE_NONLEAF_FILLFACTOR</name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_full</name></name> <operator>=</operator> <call><name>RelationGetTargetPageFreeSpace</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
                                                          <argument><expr><name>BTREE_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <comment type="block">/* no parent level, yet */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * slide an array of ItemIds back one slot (from P_FIRSTKEY to
 * P_HIKEY, overwriting P_HIKEY).  we need to do this when we discover
 * that we have built an ItemId array in what has turned out to be a
 * P_RIGHTMOST page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_slideleft</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemId</name></type>        <name>previi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemId</name></type>        <name>thisii</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>previi</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>P_FIRSTKEY</name></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>thisii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>previi</name> <operator>=</operator> <operator>*</operator><name>thisii</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>previi</name> <operator>=</operator> <name>thisii</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add an item to a page being built.
 *
 * The main difference between this routine and a bare PageAddItem call
 * is that this code knows that the leftmost data item on a non-leaf
 * btree page doesn't need to have a key.  Therefore, it strips such
 * items down to just the item header.
 *
 * This is almost like nbtinsert.c's _bt_pgaddtup(), but we can't use
 * that because it assumes that P_RIGHTMOST() will return the correct
 * answer for the page.  Here, we don't know yet if the page will be
 * rightmost.  Offset P_FIRSTKEY is always the first data key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_sortaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
               <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>,
               <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
               <parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>itup_off</name> <operator>==</operator> <name>P_FIRSTKEY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>trunctuple</name> <operator>=</operator> <operator>*</operator><name>itup</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>&amp;</operator><name>trunctuple</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>itemsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>, <argument><expr><name>itup_off</name></expr></argument>,
                    <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to the index page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * Add an item to a disk page from the sort output.
 *
 * We must be careful to observe the page layout conventions of nbtsearch.c:
 * - rightmost pages start data items at P_HIKEY instead of at P_FIRSTKEY.
 * - on non-leaf pages, the key portion of the first item need not be
 *     stored, we should store only the link.
 *
 * A leaf page being built looks like:
 *
 * +----------------+---------------------------------+
 * | PageHeaderData | linp0 linp1 linp2 ...           |
 * +-----------+----+---------------------------------+
 * | ... linpN |                                      |
 * +-----------+--------------------------------------+
 * |     ^ last                                          |
 * |                                                  |
 * +-------------+------------------------------------+
 * |             | itemN ...                          |
 * +-------------+------------------+-----------------+
 * |          ... item3 item2 item1 | "special space" |
 * +--------------------------------+-----------------+
 *
 * Contrast this with the diagram in bufpage.h; note the mismatch
 * between linps and items.  This is because we reserve linp0 as a
 * placeholder for the pointer to the "high key" item; when we have
 * filled up the page, we will set linp0 to point to itemN and clear
 * linpN.  On the other hand, if we find this is the last (rightmost)
 * page, we leave the items alone and slide the linp array over.
 *
 * 'last' pointer indicates the last offset added to the page.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_buildadd</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>npage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>last_off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>pgspc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>itupsz</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This is a handy place to check for cancel interrupts during the btree
     * load phase of index creation.
     */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>npage</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>btps_page</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nblkno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>btps_blkno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last_off</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>btps_lastoff</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pgspc</name> <operator>=</operator> <call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>itupsz</name> <operator>=</operator> <call><name>IndexTupleDSize</name><argument_list>(<argument><expr><operator>*</operator><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>itupsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check whether the item can fit on a btree page at all. (Eventually, we
     * ought to try to apply TOAST methods if not.) We actually need to be
     * able to fit three items on every page, so restrict any one item to 1/3
     * the per-page available space. Note that at this point, itupsz doesn't
     * include the ItemId.
     *
     * NOTE: similar code appears in _bt_insertonpg() to defend against
     * oversize items being inserted into an already-existing index. But
     * during creation of an index, we don't go through there.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>itupsz</name> <operator>&gt;</operator> <call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
                        <argument><expr><name>itupsz</name></expr></argument>, <argument><expr><call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than 1/3 of a buffer page cannot be indexed.\n"</literal>
                         <literal type="string">"Consider a function index of an MD5 hash of the value, "</literal>
                         <literal type="string">"or use full text indexing."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check to see if page is "full".  It's definitely full if the item won't
     * fit.  Otherwise, compare to the target freespace derived from the
     * fillfactor.  However, we must put at least two items on each page, so
     * disregard fillfactor if we don't have that many.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgspc</name> <operator>&lt;</operator> <name>itupsz</name> <operator>||</operator> <operator>(</operator><name><name>pgspc</name> <argument_list type="generic">&lt; <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_full</name></name> <operator>&amp;&amp;</operator> <name>last_off</name></expr></argument> &gt;</argument_list></name> <name>P_FIRSTKEY</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Finish off the page and write it out.
         */</comment>
        <decl_stmt><decl><type><name>Page</name></type>        <name>opage</name> <init>= <expr><name>npage</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>oblkno</name> <init>= <expr><name>nblkno</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>ii</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>hii</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>oitup</name></decl>;</decl_stmt>

        <comment type="block">/* Create new page of same level */</comment>
        <expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>_bt_blnewpage</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* and assign it a page position */</comment>
        <expr_stmt><expr><name>nblkno</name> <operator>=</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_alloced</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * We copy the last item on the page into the new page, and then
         * rearrange the old page so that the 'last item' becomes its high key
         * rather than a true data item.  There had better be at least two
         * items on the page already, else the page would be empty of useful
         * data.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>last_off</name> <operator>&gt;</operator> <name>P_FIRSTKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>last_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_bt_sortaddtup</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oitup</name></expr></argument>, <argument><expr><name>P_FIRSTKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Move 'last' into the high key position on opage
         */</comment>
        <expr_stmt><expr><name>hii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>hii</name> <operator>=</operator> <operator>*</operator><name>ii</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemIdSetUnused</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* redundant */</comment>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>opage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <comment type="block">/*
         * Link the old page into its parent, using its minimum key. If we
         * don't have a parent, we have to create one; this adds a new btree
         * level.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>=</operator> <call><name>_bt_pagestate</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_level</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><name>oblkno</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Save a copy of the minimum key for the new page.  We have to copy
         * it off the old page, not the new one, in case we are not at leaf
         * level.
         */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>oitup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Set the sibling links for both pages.
         */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>oopaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>nopaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>nblkno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>oblkno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>    <comment type="block">/* redundant */</comment>
        </block_content>}</block>

        <comment type="block">/*
         * Write out the old page.  We never need to touch it again, so we can
         * free the opage workspace too.
         */</comment>
        <expr_stmt><expr><call><name>_bt_blwritepage</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>opage</name></expr></argument>, <argument><expr><name>oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Reset last_off to point to new page
         */</comment>
        <expr_stmt><expr><name>last_off</name> <operator>=</operator> <name>P_FIRSTKEY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the new item is the first for its page, stash a copy for later. Note
     * this will only happen for the first item on a level; on later pages,
     * the first item for a page is copied from the prior page in the code
     * above.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>last_off</name> <operator>==</operator> <name>P_HIKEY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Add the new item into the current page.
     */</comment>
    <expr_stmt><expr><name>last_off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>last_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_bt_sortaddtup</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><name>itupsz</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>last_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_page</name></name> <operator>=</operator> <name>npage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_blkno</name></name> <operator>=</operator> <name>nblkno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_lastoff</name></name> <operator>=</operator> <name>last_off</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish writing out the completed btree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_uppershutdown</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootblkno</name> <init>= <expr><name>P_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>rootlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>metapage</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Each iteration of this loop completes one more level of the tree.
     */</comment>
    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>state</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>btps_next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>btps_blkno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We have to link the last page on this level to somewhere.
         *
         * If we're at the top, it's the root, so attach it to the metapage.
         * Otherwise, add an entry for it to its parent using its minimum key.
         * This may cause the last page of the parent level to split, but
         * that's not a problem -- we haven't gotten to it yet.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_ROOT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rootlevel</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>btps_level</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_next</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * This is the rightmost page, so the ItemId array needs to be slid
         * back one slot.  Then we can dump out the page.
         */</comment>
        <expr_stmt><expr><call><name>_bt_slideleft</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_bt_blwritepage</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* writepage freed the workspace */</comment>
    </block_content>}</block></for>

    <comment type="block">/*
     * As the last step in the process, construct the metapage and make it
     * point to the new root (unless we had no data at all, in which case it's
     * set to point to "P_NONE").  This changes the index to the "valid" state
     * by filling in a valid magic number in the metapage.
     */</comment>
    <expr_stmt><expr><name>metapage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_bt_initmetapage</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>rootblkno</name></expr></argument>, <argument><expr><name>rootlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_bt_blwritepage</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read tuples in correct sort order from tuplesort, and load them into
 * btree leaves.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_load</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>merge</name> <init>= <expr><operator>(</operator><name>btspool2</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>,
                <decl><type ref="prev"/><name>itup2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>load1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdes</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>keysz</name> <init>= <expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>indexScanKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKeys</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>merge</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Another BTSpool for dead tuples exists. Now we have to merge
         * btspool and btspool2.
         */</comment>

        <comment type="block">/* the preparation of merge */</comment>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup2</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexScanKey</name> <operator>=</operator> <call><name>_bt_mkscankey_nodata</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Prepare SortSupport data for each column */</comment>
        <expr_stmt><expr><name>sortKeys</name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>keysz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name>sortKeys</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ScanKey</name></type>        <name>scanKey</name> <init>= <expr><name>indexScanKey</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int16</name></type>        <name>strategy</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator>
                <operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
            <comment type="block">/* Abbreviation is not supported here */</comment>
            <expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>strategy</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then>
                <expr><name>BTGreaterStrategyNumber</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PrepareSortSupportFromIndexRel</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>_bt_freeskey</name><argument_list>(<argument><expr><name>indexScanKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>load1</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* load BTSpool next ? */</comment>
            <if_stmt><if>if <condition>(<expr><name>itup2</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>itup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>itup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>SortSupport</name></type> <name>entry</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Datum</name></type>        <name>attrDatum1</name></decl>,
                                <decl><type ref="prev"/><name>attrDatum2</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>isNull1</name></decl>,
                                <decl><type ref="prev"/><name>isNull2</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>        <name>compare</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>entry</name> <operator>=</operator> <name>sortKeys</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>attrDatum1</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tupdes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>attrDatum2</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tupdes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>attrDatum1</name></expr></argument>, <argument><expr><name>isNull1</name></expr></argument>,
                                                  <argument><expr><name>attrDatum2</name></expr></argument>, <argument><expr><name>isNull2</name></expr></argument>,
                                                  <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>compare</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>load1</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>compare</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>load1</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* When we see first tuple, create first index page */</comment>
            <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>_bt_pagestate</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>load1</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>itup2</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sortKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* merge is unnecessary */</comment>
        <while>while <condition>(<expr><operator>(</operator><name>itup</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>,
                                               <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* When we see first tuple, create first index page */</comment>
            <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>_bt_pagestate</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Close down final pages and write the metapage */</comment>
    <expr_stmt><expr><call><name>_bt_uppershutdown</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the index is WAL-logged, we must fsync it down to disk before it's
     * safe to commit the transaction.  (For a non-WAL-logged index we don't
     * care since the index will be uninteresting after a crash anyway.)
     *
     * It's obvious that we must do this when not WAL-logging the build. It's
     * less obvious that we have to do it even if we did WAL-log the index
     * pages.  The reason is that since we're building outside shared buffers,
     * a CHECKPOINT occurring during the build has no way to flush the
     * previously written data to disk (indeed it won't know the index even
     * exists).  A crash later on would replay WAL from the checkpoint,
     * therefore it wouldn't replay our earlier WAL entries. If we do not
     * fsync those pages here, they might still not be on disk when the crash
     * occurs.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
