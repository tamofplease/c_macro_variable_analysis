<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/nbtree/nbtxlog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtxlog.c
 *      WAL replay logic for btrees.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/access/nbtree/nbtxlog.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * _bt_restore_page -- re-enter all the index tuples on a page
 *
 * The page is freshly init'd, and *from (length len) is a copy of what
 * had been its upper part (pd_upper to pd_special).  We assume that the
 * tuples had been added to the page in item-number order, and therefore
 * the one with highest item number appears first (lowest on the page).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_restore_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexTupleData</name></type> <name>itupdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>itemsz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end</name> <init>= <expr><name>from</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Item</name></type>        <name><name>items</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name><name>itemsizes</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nitems</name></decl>;</decl_stmt>

    <comment type="block">/*
     * To get the items back in the original order, we add them to the page in
     * reverse.  To figure out where one tuple ends and another begins, we
     * have to scan them in forward order first.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>from</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Need to copy tuple header due to alignment considerations */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itupdata</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleDSize</name><argument_list>(<argument><expr><name>itupdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Item</name><operator>)</operator> <name>from</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>itemsizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>itemsz</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>from</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>nitems</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nitems</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>itemsizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nitems</name> <operator>-</operator> <name>i</name></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"_bt_restore_page: cannot add item to page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>from</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_restore_meta</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>metabuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>metapg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>md</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_btree_metadata</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BTREE_METAPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_btree_metadata</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>md</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>=</operator> <name>BTREE_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>=</operator> <name>BTREE_VERSION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_level</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>fastroot</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>fastlevel</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_META</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Set pd_lower just past the end of the metadata.  This is not essential
     * but it makes the page look compressible to xlog.c.
     */</comment>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>metapg</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
        <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>md</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metapg</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_clear_incomplete_split -- clear INCOMPLETE_SPLIT flag on a page
 *
 * This is a common subroutine of the redo functions of all the WAL record
 * types that can insert a downlink: insert, split, and newroot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_clear_incomplete_split</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;</operator> <name>BTP_INCOMPLETE_SPLIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_insert</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isleaf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ismeta</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_btree_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Insertion to an internal page finishes an incomplete split at the child
     * level.  Clear the incomplete-split flag in the child.  Note: during
     * normal operation, the child and parent pages are locked at the same
     * time, so that clearing the flag and inserting the downlink appear
     * atomic to other backends.  We don't bother with that during replay,
     * because readers don't care about the incomplete-split flag and there
     * cannot be updates happening.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_bt_clear_incomplete_split</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>datapos</name> <init>= <expr><call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>datapos</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"btree_insert_redo: failed to add item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Note: in normal operation, we'd update the metapage while still holding
     * lock on the page we inserted into.  But during replay it's not
     * necessary to hold that lock, since no other index updates can be
     * happening concurrently, and readers will cope fine with following an
     * obsolete link from the metapage.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ismeta</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_bt_restore_meta</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_split</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onleft</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isroot</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_btree_split</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_split</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isleaf</name> <init>= <expr><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>lbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>rbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>rpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>ropaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>datapos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Item</name></type>        <name>left_hikey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>left_hikeysz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftsib</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightsib</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>rnext</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftsib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightsib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rnext</name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Clear the incomplete split flag on the left sibling of the child page
     * this is a downlink for.  (Like in btree_xlog_insert, this can be done
     * before locking the other pages)
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_bt_clear_incomplete_split</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Reconstruct right (new) sibling page from scratch */</comment>
    <expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>datapos</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rpage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ropaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rnext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <ternary><condition><expr><name>isleaf</name></expr> ?</condition><then> <expr><name>BTP_LEAF</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_restore_page</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>datapos</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * On leaf level, the high key of the left page is equal to the first key
     * on the right page.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isleaf</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>hiItemId</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>ropaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>left_hikey</name> <operator>=</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>hiItemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>left_hikeysz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>hiItemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* don't release the buffer yet; we touch right page's first item below */</comment>

    <comment type="block">/* Now reconstruct left (original) sibling page */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * To retain the same physical order of the tuples that they had, we
         * initialize a temporary empty page for the left page and add all the
         * items to that in item number order.  This mirrors how _bt_split()
         * works.  It's not strictly required to retain the same physical
         * order, as long as the items are in the correct item number order,
         * but it helps debugging.  See also _bt_restore_page(), which does
         * the same for the right page.
         */</comment>
        <decl_stmt><decl><type><name>Page</name></type>        <name>lpage</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lopaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Item</name></type>        <name>newitem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>newitemsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Page</name></type>        <name>newlpage</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>leftoff</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>datapos</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>onleft</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>newitem</name> <operator>=</operator> <operator>(</operator><name>Item</name><operator>)</operator> <name>datapos</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>newitemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>datapos</name> <operator>+=</operator> <name>newitemsz</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>datalen</name> <operator>-=</operator> <name>newitemsz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Extract left hikey and its size (assuming 16-bit alignment) */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>left_hikey</name> <operator>=</operator> <operator>(</operator><name>Item</name><operator>)</operator> <name>datapos</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>left_hikeysz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>left_hikey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>datapos</name> <operator>+=</operator> <name>left_hikeysz</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>datalen</name> <operator>-=</operator> <name>left_hikeysz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datalen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newlpage</name> <operator>=</operator> <call><name>PageGetTempPageCopySpecial</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set high key */</comment>
        <expr_stmt><expr><name>leftoff</name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>left_hikey</name></expr></argument>, <argument><expr><name>left_hikeysz</name></expr></argument>,
                        <argument><expr><name>P_HIKEY</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add high key to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>lopaque</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>firstright</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ItemId</name></type>        <name>itemid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Size</name></type>        <name>itemsz</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Item</name></type>        <name>item</name></decl>;</decl_stmt>

            <comment type="block">/* add the new item if it was inserted on left page */</comment>
            <if_stmt><if>if <condition>(<expr><name>onleft</name> <operator>&amp;&amp;</operator> <name>off</name> <operator>==</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>newitemoff</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add old item to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* cope with possibility that newitem goes at the end */</comment>
        <if_stmt><if>if <condition>(<expr><name>onleft</name> <operator>&amp;&amp;</operator> <name>off</name> <operator>==</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>newitemoff</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Fix opaque fields */</comment>
        <expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_LEAF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We no longer need the buffers */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Fix left-link of the page to the right of the new right sibling.
     *
     * Note: in normal operation, we do this while still holding lock on the
     * two split pages.  However, that's not necessary for correctness in WAL
     * replay, because no other index update can be in progress, and readers
     * will cope properly when following an obsolete left-link.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>rnext</name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_vacuum</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNUSED</name></cpp:ifdef>
    <decl_stmt><decl><type><name>xl_btree_vacuum</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_vacuum</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * This section of code is thought to be no longer needed, after analysis
     * of the calling paths. It is retained to allow the code to be reinstated
     * if a flaw is revealed in that thinking.
     *
     * If we are running non-MVCC scans using this index we need to do some
     * additional work to ensure correctness, which is known as a "pin scan"
     * described in more detail in next paragraphs. We used to do the extra
     * work in all cases, whereas we now avoid that work in most cases. If
     * lastBlockVacuumed is set to InvalidBlockNumber then we skip the
     * additional work required for the pin scan.
     *
     * Avoiding this extra work is important since it requires us to touch
     * every page in the index, so is an O(N) operation. Worse, it is an
     * operation performed in the foreground during redo, so it delays
     * replication directly.
     *
     * If queries might be active then we need to ensure every leaf page is
     * unpinned between the lastBlockVacuumed and the current block, if there
     * are any.  This prevents replay of the VACUUM from reaching the stage of
     * removing heap tuples while there could still be indexscans "in flight"
     * to those particular tuples for those scans which could be confused by
     * finding new tuples at the old TID locations (see nbtree/README).
     *
     * It might be worth checking if there are actually any backends running;
     * if not, we could just skip this.
     *
     * Since VACUUM can visit leaf pages out-of-order, it might issue records
     * with lastBlockVacuumed &gt;= block; that's not an error, it just means
     * nothing to do now.
     *
     * Note: since we touch all pages in the range, we will lock non-leaf
     * pages, and also any empty (all-zero) pages that may be in the index. It
     * doesn't seem worth the complexity to avoid that.  But it's important
     * that HotStandbyActiveInReplay() will not return true if the database
     * isn't yet consistent; so we need not fear reading still-corrupt blocks
     * here during crash recovery.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HotStandbyActiveInReplay</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>lastBlockVacuumed</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RelFileNode</name></type> <name>thisrnode</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>thisblkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>thisrnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thisblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>blkno</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>lastBlockVacuumed</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>thisblkno</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/*
             * We use RBM_NORMAL_NO_LOG mode because it's not an error
             * condition to see all-zero pages.  The original btvacuumpage
             * scan would have skipped over all-zero pages, noting them in FSM
             * but not bothering to initialize them just yet; so we mustn't
             * throw an error here.  (We could skip acquiring the cleanup lock
             * if PageIsNew, but it's probably not worth the cycles to test.)
             *
             * XXX we don't actually need to read the block, we just need to
             * confirm it is unpinned. If we had a special call into the
             * buffer manager we could optimise this so that if the block is
             * not in shared_buffers we confirm it as unpinned. Optimizing
             * this is now moot, since in most cases we avoid the scan.
             */</comment>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name>thisrnode</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
                                            <argument><expr><name>RBM_NORMAL_NO_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LockBufferForCleanup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Like in btvacuumpage(), we need to take a cleanup lock on every leaf
     * page. See nbtree/README for details.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call>
        <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unend</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>unend</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unend</name> <operator>-</operator> <name>unused</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name>unend</name> <operator>-</operator> <name>unused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Mark the page as not containing any LP_DEAD items --- see comments
         * in _bt_delitems_vacuum().
         */</comment>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the latestRemovedXid from the heap pages pointed at by the index
 * tuples being deleted. This puts the work for calculating latestRemovedXid
 * into the recovery path rather than the primary path.
 *
 * It's possible that this generates a fair amount of I/O, since an index
 * block may have hundreds of tuples being deleted. Repeat accesses to the
 * same heap blocks are common, though are not yet optimised.
 *
 * XXX optimise later with something like XLogPrefetchBuffer()
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>btree_xlog_delete_get_latestRemovedXid</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>xl_btree_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>ibuffer</name></decl>,
                <decl><type ref="prev"/><name>hbuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>ipage</name></decl>,
                <decl><type ref="prev"/><name>hpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemId</name></type>        <name>iitemid</name></decl>,
                <decl><type ref="prev"/><name>hitemid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htuphdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>hblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>hoffnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If there's nothing running on the standby we don't need to derive a
     * full latestRemovedXid value, so use a fast path out of here.  This
     * returns InvalidTransactionId, and so will conflict with all HS
     * transactions; but since we just worked out that that's zero people,
     * it's OK.
     *
     * XXX There is a race condition here, which is that a new backend might
     * start just after we look.  If so, it cannot need to conflict, but this
     * coding will result in throwing a conflict anyway.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>CountDBBackends</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>latestRemovedXid</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * In what follows, we have to examine the previous state of the index
     * page, as well as the heap page(s) it points to.  This is only valid if
     * WAL replay has reached a consistent database state; which means that
     * the preceding check is not just an optimization, but is *necessary*. We
     * won't have let in any user sessions before we reach consistency.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>reachedConsistency</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"btree_xlog_delete_get_latestRemovedXid: cannot operate with inconsistent data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Get index page.  If the DB is consistent, this should not fail, nor
     * should any of the heap page fetches below.  If one does, we return
     * InvalidTransactionId to cancel all HS transactions.  That's probably
     * overkill, but it's safe, and certainly better than panicking here.
     */</comment>
    <expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ibuffer</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ibuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidTransactionId</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ibuffer</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ipage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ibuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop through the deleted index items to obtain the TransactionId from
     * the heap items they point to.
     */</comment>
    <expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlrec</name> <operator>+</operator> <name>SizeOfBtreeDelete</name><operator>)</operator></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Identify the index tuple about to be deleted
         */</comment>
        <expr_stmt><expr><name>iitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>ipage</name></expr></argument>, <argument><expr><name><name>unused</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>ipage</name></expr></argument>, <argument><expr><name>iitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Locate the heap page that the index tuple points at
         */</comment>
        <expr_stmt><expr><name>hblkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hbuffer</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>hnode</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>hblkno</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>hbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ibuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidTransactionId</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>hbuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hpage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>hbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Look up the heap tuple header that the index tuple points at by
         * using the heap node supplied with the xlrec. We can't use
         * heap_fetch, since it uses ReadBuffer rather than XLogReadBuffer.
         * Note that we are not looking at tuple data here, just headers.
         */</comment>
        <expr_stmt><expr><name>hoffnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>hpage</name></expr></argument>, <argument><expr><name>hoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Follow any redirections until we find something useful.
         */</comment>
        <while>while <condition>(<expr><call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hoffnum</name> <operator>=</operator> <call><name>ItemIdGetRedirect</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>hpage</name></expr></argument>, <argument><expr><name>hoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/*
         * If the heap item has storage, then read the header and use that to
         * set latestRemovedXid.
         *
         * Some LP_DEAD items may not be accessible, so we ignore them.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>htuphdr</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>hpage</name></expr></argument>, <argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>HeapTupleHeaderAdvanceLatestRemovedXid</name><argument_list>(<argument><expr><name>htuphdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>latestRemovedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Conjecture: if hitemid is dead then it had xids before the xids
             * marked on LP_NORMAL items. So we just ignore this item and move
             * onto the next, for the purposes of calculating
             * latestRemovedxids.
             */</comment>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>hbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ibuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If all heap tuples were LP_DEAD then we will be returning
     * InvalidTransactionId here, which avoids conflicts. This matches
     * existing logic which assumes that LP_DEAD tuples must already be older
     * than the latestRemovedXid on the cleanup record that set them as
     * LP_DEAD, hence must already have generated a conflict.
     */</comment>
    <return>return <expr><name>latestRemovedXid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_delete</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_btree_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If we have any conflict processing to do, it must happen before we
     * update the page.
     *
     * Btree delete records can conflict with standby queries.  You might
     * think that vacuum records would conflict as well, but we've handled
     * that already.  XLOG_HEAP2_CLEANUP_INFO records provide the highest xid
     * cleaned by the vacuum of the heap and so we can resolve any conflicts
     * just once when that arrives.  After that we know that no conflicts
     * exist from individual btree vacuum records on that index.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><call><name>btree_xlog_delete_get_latestRemovedXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name>latestRemovedXid</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We don't need to take a cleanup lock to apply these changes. See
     * nbtree/README for details.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>SizeOfBtreeDelete</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlrec</name> <operator>+</operator> <name>SizeOfBtreeDelete</name><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Mark the page as not containing any LP_DEAD items --- see comments
         * in _bt_delitems_delete().
         */</comment>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_mark_page_halfdead</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_btree_mark_page_halfdead</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_mark_page_halfdead</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

    <comment type="block">/*
     * In normal operation, we would lock all the pages this WAL record
     * touches before changing any of them.  In WAL replay, it should be okay
     * to lock just one page at a time, since no concurrent index updates can
     * be happening, and readers should not care whether they arrive at the
     * target page or not (since it's surely empty).
     */</comment>

    <comment type="block">/* parent page */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>poffset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>itemid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nextoffset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightsib</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>poffset</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>poffset</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>nextoffset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nextoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rightsib</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rightsib</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nextoffset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nextoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Rewrite the leaf page as a halfdead page */</comment>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leftblk</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>rightblk</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_HALF_DEAD</name> <operator>|</operator> <name>BTP_LEAF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct a dummy hikey item that points to the next parent to be
     * deleted (if any).
     */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>topparent</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trunctuple</name><operator>.</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>topparent</name></name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trunctuple</name><operator>.</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
                    <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not add dummy high key to half-dead page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_unlink_page</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_btree_unlink_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_unlink_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftsib</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightsib</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>leftsib</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leftsib</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rightsib</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>rightsib</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * In normal operation, we would lock all the pages this WAL record
     * touches before changing any of them.  In WAL replay, it should be okay
     * to lock just one page at a time, since no concurrent index updates can
     * be happening, and readers should not care whether they arrive at the
     * target page or not (since it's surely empty).
     */</comment>

    <comment type="block">/* Fix left-link of right sibling */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Fix right-link of left sibling, if any */</comment>
    <if_stmt><if>if <condition>(<expr><name>leftsib</name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Rewrite target page as empty deleted page */</comment>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>btpo_xact</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_DELETED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we deleted a parent of the targeted leaf page, instead of the leaf
     * itself, update the leaf to point to the next remaining child in the
     * branch.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * There is no real data on the page, so we just re-create it from
         * scratch using the information from the WAL record.
         */</comment>
        <decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_HALF_DEAD</name> <operator>|</operator> <name>BTP_LEAF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leafleftsib</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leafrightsib</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Add a dummy hikey item */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>topparent</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trunctuple</name><operator>.</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>topparent</name></name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trunctuple</name><operator>.</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not add dummy high key to half-dead page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Update metapage if needed */</comment>
    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_bt_restore_meta</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_newroot</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_btree_newroot</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_newroot</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_ROOT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_LEAF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_bt_restore_page</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear the incomplete-split flag in left child */</comment>
        <expr_stmt><expr><call><name>_bt_clear_incomplete_split</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_bt_restore_meta</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>btree_xlog_reuse_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>xl_btree_reuse_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_reuse_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Btree reuse_page records exist to provide a conflict point when we
     * reuse pages in the index via the FSM.  That's all they do though.
     *
     * latestRemovedXid was the page's btpo.xact.  The btpo.xact &lt;
     * RecentGlobalXmin test in _bt_page_recyclable() conceptually mirrors the
     * pgxact-&gt;xmin &gt; limitXmin test in GetConflictingVirtualXIDs().
     * Consequently, one XID value achieves the same exclusion effect on
     * master and standby.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>,
                                            <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>btree_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>uint8</name></type>        <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>info</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>XLOG_BTREE_INSERT_LEAF</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_insert</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_INSERT_UPPER</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_insert</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_INSERT_META</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_insert</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_SPLIT_L</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_split</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_SPLIT_R</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_split</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_SPLIT_L_ROOT</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_split</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_SPLIT_R_ROOT</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_split</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_VACUUM</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_vacuum</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_DELETE</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_delete</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_MARK_PAGE_HALFDEAD</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_mark_page_halfdead</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_UNLINK_PAGE</name></expr>:</case>
        <case>case <expr><name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_unlink_page</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_NEWROOT</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_newroot</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>XLOG_BTREE_REUSE_PAGE</name></expr>:</case>
            <expr_stmt><expr><call><name>btree_xlog_reuse_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"btree_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Mask a btree page before performing consistency checks on it.
 */</comment>
<function><type><name>void</name></type>
<name>btree_mask</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pagedata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <name>pagedata</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>maskopaq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mask_page_lsn</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mask_page_hint_bits</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mask_unused_space</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>maskopaq</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>maskopaq</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Mask page content on a DELETED page since it will be re-initialized
         * during replay. See btree_xlog_unlink_page() for details.
         */</comment>
        <expr_stmt><expr><call><name>mask_page_content</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>maskopaq</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In btree leaf pages, it is possible to modify the LP_FLAGS without
         * emitting any WAL record. Hence, mask the line pointer flags. See
         * _bt_killitems(), _bt_check_unique() for details.
         */</comment>
        <expr_stmt><expr><call><name>mask_lp_flags</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * BTP_HAS_GARBAGE is just an un-logged hint bit. So, mask it. See
     * _bt_killitems(), _bt_check_unique() for details.
     */</comment>
    <expr_stmt><expr><name><name>maskopaq</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * During replay of a btree page split, we don't set the BTP_SPLIT_END
     * flag of the right sibling and initialize the cycle_id to 0 for the same
     * page. See btree_xlog_split() for details.
     */</comment>
    <expr_stmt><expr><name><name>maskopaq</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_SPLIT_END</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>maskopaq</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
