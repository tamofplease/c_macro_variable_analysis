<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/nbtree/nbtutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtutils.c
 *      Utility code for Postgres btree implementation.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/access/nbtree/nbtutils.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>BTSortArrayContext</name>
<block>{
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>flinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>collation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>reverse</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTSortArrayContext</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>_bt_find_extreme_element</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
                         <parameter><decl><type><name>StrategyNumber</name></type> <name>strat</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_bt_sort_array_elements</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>reverse</name></decl></parameter>,
                        <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>_bt_compare_array_elements</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_compare_scankey_args</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>op</name></decl></parameter>,
                         <parameter><decl><type><name>ScanKey</name></type> <name>leftarg</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>rightarg</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_fix_scankey_strategy</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>indoption</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_mark_scankey_required</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_check_rowcompare</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
                     <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
                     <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>continuescan</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * _bt_mkscankey
 *        Build an insertion scan key that contains comparison data from itup
 *        as well as comparator routines appropriate to the key datatypes.
 *
 *        The result is intended for use with _bt_compare().
 */</comment>
<function><type><name>ScanKey</name></type>
<name>_bt_mkscankey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>itupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>       <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>itupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>indoption</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>skey</name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>null</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>flags</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We can use the cached (default) support procs since no cross-type
         * comparison can be needed.
         */</comment>
        <expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>null</name></expr> ?</condition><then> <expr><name>SK_ISNULL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <name>SK_BT_INDOPTION_SHIFT</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ScanKeyEntryInitializeWithInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name>flags</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
                                       <argument><expr><name>InvalidStrategy</name></expr></argument>,
                                       <argument><expr><name>InvalidOid</name></expr></argument>,
                                       <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name>procinfo</name></expr></argument>,
                                       <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>skey</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_mkscankey_nodata
 *        Build an insertion scan key that contains 3-way comparator routines
 *        appropriate to the key datatypes, but no comparison data.  The
 *        comparison data ultimately used must match the key datatypes.
 *
 *        The result cannot be used with _bt_compare(), unless comparison
 *        data is first stored into the key entries.  Currently this
 *        routine is only called by nbtsort.c and tuplesort.c, which have
 *        their own comparison routines.
 */</comment>
<function><type><name>ScanKey</name></type>
<name>_bt_mkscankey_nodata</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>       <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>indoption</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>skey</name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>flags</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We can use the cached (default) support procs since no cross-type
         * comparison can be needed.
         */</comment>
        <expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>SK_ISNULL</name> <operator>|</operator> <operator>(</operator><name><name>indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <name>SK_BT_INDOPTION_SHIFT</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ScanKeyEntryInitializeWithInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name>flags</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
                                       <argument><expr><name>InvalidStrategy</name></expr></argument>,
                                       <argument><expr><name>InvalidOid</name></expr></argument>,
                                       <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name>procinfo</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>skey</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * free a scan key made by either _bt_mkscankey or _bt_mkscankey_nodata.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_freeskey</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * free a retracement stack made by _bt_search.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_freestack</name><parameter_list>(<parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTStack</name></type>        <name>ostack</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ostack</name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ostack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 *    _bt_preprocess_array_keys() -- Preprocess SK_SEARCHARRAY scan keys
 *
 * If there are any SK_SEARCHARRAY scan keys, deconstruct the array(s) and
 * set up BTArrayKeyInfo info for each one that is an equality-type key.
 * Prepare modified scan keys in so-&gt;arrayKeyData, which will hold the current
 * array elements during each primitive indexscan operation.  For inequality
 * array keys, it's sufficient to find the extreme element value and replace
 * the whole array with that scalar value.
 *
 * Note: the reason we need so-&gt;arrayKeyData, rather than just scribbling
 * on scan-&gt;keyData, is that callers are permitted to call btrescan without
 * supplying a new set of scankey data.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_preprocess_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfKeys</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>       <modifier>*</modifier></type><name>indoption</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numArrayKeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

    <comment type="block">/* Quick check to see if there are any array keys */</comment>
    <expr_stmt><expr><name>numArrayKeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHARRAY</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>numArrayKeys</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_ROW_HEADER</name> <operator>|</operator> <name>SK_SEARCHNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* If any arrays are null as a whole, we can quit right now. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Quit if nothing to do. */</comment>
    <if_stmt><if>if <condition>(<expr><name>numArrayKeys</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Make a scan-lifespan context to hold array-associated data, or reset it
     * if we already have one from a previous rescan cycle.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                                 <argument><expr><literal type="string">"BTree array context"</literal></expr></argument>,
                                                 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create modifiable copy of scan-&gt;keyData in the workspace context */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name></expr></argument>,
           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>,
           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate space for per-array data in the workspace context */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name></name> <operator>=</operator> <operator>(</operator><name>BTArrayKeyInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numArrayKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTArrayKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now process each array key */</comment>
    <expr_stmt><expr><name>numArrayKeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>elmlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>elmbyval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name>elmalign</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>num_elems</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>num_nonnulls</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHARRAY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * First, deconstruct the array into elements.  Anything allocated
         * here (including a possibly detoasted array value) is in the
         * workspace context.
         */</comment>
        <expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We could cache this data, but not clear it's worth it */</comment>
        <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>,
                          <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Compress out any null elements.  We can ignore them since we assume
         * all btree operators are strict.
         */</comment>
        <expr_stmt><expr><name>num_nonnulls</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elem_nulls</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>elem_values</name><index>[<expr><name>num_nonnulls</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>elem_values</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* We could pfree(elem_nulls) now, but not worth the cycles */</comment>

        <comment type="block">/* If there's no non-nulls, the scan qual is unsatisfiable */</comment>
        <if_stmt><if>if <condition>(<expr><name>num_nonnulls</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>numArrayKeys</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the comparison operator is not equality, then the array qual
         * degenerates to a simple comparison against the smallest or largest
         * non-null array element, as appropriate.
         */</comment>
        <switch>switch <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
            <case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
                <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator>
                    <call><name>_bt_find_extreme_element</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>,
                                             <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>,
                                             <argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>num_nonnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            <case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
                <comment type="block">/* proceed with rest of loop */</comment>
                <break>break;</break>
            <case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
            <case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
                <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator>
                    <call><name>_bt_find_extreme_element</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>,
                                             <argument><expr><name>BTLessStrategyNumber</name></expr></argument>,
                                             <argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>num_nonnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized StrategyNumber: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/*
         * Sort the non-null elements and eliminate any duplicates.  We must
         * sort in the same ordering used by the index column, so that the
         * successive primitive indexscans produce data in index order.
         */</comment>
        <expr_stmt><expr><name>num_elems</name> <operator>=</operator> <call><name>_bt_sort_array_elements</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>,
                                            <argument><expr><operator>(</operator><name><name>indoption</name><index>[<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>INDOPTION_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
                                            <argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>num_nonnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * And set up the BTArrayKeyInfo data.
         */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>numArrayKeys</name></expr>]</index></name><operator>.</operator><name>scan_key</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>numArrayKeys</name></expr>]</index></name><operator>.</operator><name>num_elems</name> <operator>=</operator> <name>num_elems</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>numArrayKeys</name></expr>]</index></name><operator>.</operator><name>elem_values</name> <operator>=</operator> <name>elem_values</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numArrayKeys</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>=</operator> <name>numArrayKeys</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_find_extreme_element() -- get least or greatest array element
 *
 * scan and skey identify the index column, whose opfamily determines the
 * comparison semantics.  strat should be BTLessStrategyNumber to get the
 * least element, or BTGreaterStrategyNumber to get the greatest.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>_bt_find_extreme_element</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
                         <parameter><decl><type><name>StrategyNumber</name></type> <name>strat</name></decl></parameter>,
                         <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>elemtype</name></decl>,
                <decl><type ref="prev"/><name>cmp_op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegProcedure</name></type> <name>cmp_proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name></type>    <name>flinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Determine the nominal datatype of the array elements.  We have to
     * support the convention that sk_subtype == InvalidOid means the opclass
     * input type; this is a hack to simplify life for ScanKeyInit().
     */</comment>
    <expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Look up the appropriate comparison operator in the opfamily.
     *
     * Note: it's possible that this would fail, if the opfamily is
     * incomplete, but it seems quite unlikely that an opfamily would omit
     * non-cross-type comparison operators for any datatype that it supports
     * at all.
     */</comment>
    <expr_stmt><expr><name>cmp_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                 <argument><expr><name>elemtype</name></expr></argument>,
                                 <argument><expr><name>elemtype</name></expr></argument>,
                                 <argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
             <argument><expr><name>strat</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>,
             <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing oprcode for operator %u"</literal></expr></argument>, <argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>,
                                           <argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                           <argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_sort_array_elements() -- sort and de-dup array elements
 *
 * The array elements are sorted in-place, and the new number of elements
 * after duplicate removal is returned.
 *
 * scan and skey identify the index column, whose opfamily determines the
 * comparison semantics.  If reverse is true, we sort in descending order.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bt_sort_array_elements</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>reverse</name></decl></parameter>,
                        <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>elemtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegProcedure</name></type> <name>cmp_proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTSortArrayContext</name></type> <name>cxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>last_non_dup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>nelems</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* no work to do */</comment>

    <comment type="block">/*
     * Determine the nominal datatype of the array elements.  We have to
     * support the convention that sk_subtype == InvalidOid means the opclass
     * input type; this is a hack to simplify life for ScanKeyInit().
     */</comment>
    <expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Look up the appropriate comparison function in the opfamily.
     *
     * Note: it's possible that this would fail, if the opfamily is
     * incomplete, but it seems quite unlikely that an opfamily would omit
     * non-cross-type support functions for any datatype that it supports at
     * all.
     */</comment>
    <expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                 <argument><expr><name>elemtype</name></expr></argument>,
                                 <argument><expr><name>elemtype</name></expr></argument>,
                                 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
             <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>,
             <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Sort the array elements */</comment>
    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>.</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>reverse</name></name> <operator>=</operator> <name>reverse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>elems</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>_bt_compare_array_elements</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now scan the sorted elements and remove duplicates */</comment>
    <expr_stmt><expr><name>last_non_dup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>        <name>compare</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>.</operator><name>flinfo</name></name></expr></argument>,
                                                  <argument><expr><name><name>cxt</name><operator>.</operator><name>collation</name></name></expr></argument>,
                                                  <argument><expr><name><name>elems</name><index>[<expr><name>last_non_dup</name></expr>]</index></name></expr></argument>,
                                                  <argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>elems</name><index>[<expr><operator>++</operator><name>last_non_dup</name></expr>]</index></name> <operator>=</operator> <name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>last_non_dup</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_arg comparator for sorting array elements
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bt_compare_array_elements</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>da</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>db</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTSortArrayContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><operator>(</operator><name>BTSortArrayContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>compare</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
                                              <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>,
                                              <argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>compare</name> <operator>=</operator> <operator>-</operator><name>compare</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>compare</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_start_array_keys() -- Initialize array keys at start of a scan
 *
 * Set up the cur_elem counters and fill in the first sk_argument value for
 * each array scankey.  We can't do this until we know the scan direction.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_start_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>scan_key</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>elem_values</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_advance_array_keys() -- Advance to next set of array elements
 *
 * Returns TRUE if there is another set of values to consider, FALSE if not.
 * On TRUE result, the scankeys are initialized with the next set of values.
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_advance_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We must advance the last array key most quickly, since it will
     * correspond to the lowest-order index column among the available
     * qualifications. This is necessary to ensure correct ordering of output
     * when there are multiple array keys.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>scan_key</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>cur_elem</name> <init>= <expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>num_elems</name> <init>= <expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>num_elems</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>--</operator><name>cur_elem</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>cur_elem</name> <operator>=</operator> <name>num_elems</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* need to advance next array key */</comment>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>cur_elem</name> <operator>&gt;=</operator> <name>num_elems</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>cur_elem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* need to advance next array key */</comment>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <name>cur_elem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>elem_values</name><index>[<expr><name>cur_elem</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* advance parallel scan */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_bt_parallel_advance_array_keys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_mark_array_keys() -- Handle array keys during btmarkpos
 *
 * Save the current state of the array keys as the "mark" position.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_mark_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>mark_elem</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_restore_array_keys() -- Handle array keys during btrestrpos
 *
 * Restore the array keys to where they were when the mark was set.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_restore_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Restore each array key to its position when the mark was set */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>scan_key</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>mark_elem</name> <init>= <expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>mark_elem</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>!=</operator> <name>mark_elem</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <name>mark_elem</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>elem_values</name><index>[<expr><name>mark_elem</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If we changed any keys, we must redo _bt_preprocess_keys.  That might
     * sound like overkill, but in cases with multiple keys per index column
     * it seems necessary to do the full set of pushups.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>_bt_preprocess_keys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The mark should have been set on a consistent set of keys... */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    _bt_preprocess_keys() -- Preprocess scan keys
 *
 * The given search-type keys (in scan-&gt;keyData[] or so-&gt;arrayKeyData[])
 * are copied to so-&gt;keyData[] with possible transformation.
 * scan-&gt;numberOfKeys is the number of input keys, so-&gt;numberOfKeys gets
 * the number of output keys (possibly less, never greater).
 *
 * The output keys are marked with additional sk_flag bits beyond the
 * system-standard bits supplied by the caller.  The DESC and NULLS_FIRST
 * indoption bits for the relevant index attribute are copied into the flags.
 * Also, for a DESC column, we commute (flip) all the sk_strategy numbers
 * so that the index sorts in the desired direction.
 *
 * One key purpose of this routine is to discover which scan keys must be
 * satisfied to continue the scan.  It also attempts to eliminate redundant
 * keys and detect contradictory keys.  (If the index opfamily provides
 * incomplete sets of cross-type operators, we may fail to detect redundant
 * or contradictory keys, but we can survive that.)
 *
 * The output keys must be sorted by index attribute.  Presently we expect
 * (but verify) that the input keys are already so sorted --- this is done
 * by match_clauses_to_index() in indxpath.c.  Some reordering of the keys
 * within each attribute may be done as a byproduct of the processing here,
 * but no other code depends on that.
 *
 * The output keys are marked with flags SK_BT_REQFWD and/or SK_BT_REQBKWD
 * if they must be satisfied in order to continue the scan forward or backward
 * respectively.  _bt_checkkeys uses these flags.  For example, if the quals
 * are "x = 1 AND y &lt; 4 AND z &lt; 5", then _bt_checkkeys will reject a tuple
 * (1,2,7), but we must continue the scan in case there are tuples (1,3,z).
 * But once we reach tuples like (1,4,z) we can stop scanning because no
 * later tuples could match.  This is reflected by marking the x and y keys,
 * but not the z key, with SK_BT_REQFWD.  In general, the keys for leading
 * attributes with "=" keys are marked both SK_BT_REQFWD and SK_BT_REQBKWD.
 * For the first attribute without an "=" key, any "&lt;" and "&lt;=" keys are
 * marked SK_BT_REQFWD while any "&gt;" and "&gt;=" keys are marked SK_BT_REQBKWD.
 * This can be seen to be correct by considering the above example.  Note
 * in particular that if there are no keys for a given attribute, the keys for
 * subsequent attributes can never be required; for instance "WHERE y = 4"
 * requires a full-index scan.
 *
 * If possible, redundant keys are eliminated: we keep only the tightest
 * &gt;/&gt;= bound and the tightest &lt;/&lt;= bound, and if there's an = key then
 * that's the only one returned.  (So, we return either a single = key,
 * or one or two boundary-condition keys for each attr.)  However, if we
 * cannot compare two keys for lack of a suitable cross-type operator,
 * we cannot eliminate either.  If there are two such keys of the same
 * operator strategy, the second one is just pushed into the output array
 * without further processing here.  We may also emit both &gt;/&gt;= or both
 * &lt;/&lt;= keys if we can't compare them.  The logic about required keys still
 * works if we don't eliminate redundant keys.
 *
 * Note that one reason we need direction-sensitive required-key flags is
 * precisely that we may not be able to eliminate redundant keys.  Suppose
 * we have "x &gt; 4::int AND x &gt; 10::bigint", and we are unable to determine
 * which key is more restrictive for lack of a suitable cross-type operator.
 * _bt_first will arbitrarily pick one of the keys to do the initial
 * positioning with.  If it picks x &gt; 4, then the x &gt; 10 condition will fail
 * until we reach index entries &gt; 10; but we can't stop the scan just because
 * x &gt; 10 is failing.  On the other hand, if we are scanning backwards, then
 * failure of either key is indeed enough to stop the scan.  (In general, when
 * inequality keys are present, the initial-positioning code only promises to
 * position before the first possible match, not exactly at the first match,
 * for a forward scan; or after the last match for a backward scan.)
 *
 * As a byproduct of this work, we can detect contradictory quals such
 * as "x = 1 AND x &gt; 2".  If we see that, we return so-&gt;qual_ok = FALSE,
 * indicating the scan need not be run at all since no tuples can match.
 * (In this case we do not bother completing the output key array!)
 * Again, missing cross-type operators might cause us to fail to prove the
 * quals contradictory when they really are, but the scan will work correctly.
 *
 * Row comparison keys are currently also treated without any smarts:
 * we just transfer them into the preprocessed array without any
 * editorialization.  We can treat them the same as an ordinary inequality
 * comparison on the row's first index column, for the purposes of the logic
 * about required keys.
 *
 * Note: the reason we have to copy the preprocessed scan keys into private
 * storage is that we are modifying the array based on comparisons of the
 * key argument values, which could change on a rescan or after moving to
 * new elements of array keys.  Therefore we can't overwrite the source data.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_preprocess_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfKeys</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>       <modifier>*</modifier></type><name>indoption</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>new_numberOfKeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfEqualCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>inkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>outkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name><name>xform</name><index>[<expr><name>BTMaxStrategyNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>test_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attno</name></decl>;</decl_stmt>

    <comment type="block">/* initialize result variables */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numberOfKeys</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* done if qual-less scan */</comment>

    <comment type="block">/*
     * Read so-&gt;arrayKeyData if array keys are present, else scan-&gt;keyData
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>inkeys</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>inkeys</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>outkeys</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>inkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <comment type="block">/* we check that input keys are correctly ordered */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btree index keys must be ordered by attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We can short-circuit most of the work if there's just one key */</comment>
    <if_stmt><if>if <condition>(<expr><name>numberOfKeys</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Apply indoption to scankey (might change sk_strategy!) */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_fix_scankey_strategy</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>indoption</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkeys</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <comment type="block">/* We can mark the qual as required if it's for first index col */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Otherwise, do the full set of pushups.
     */</comment>
    <expr_stmt><expr><name>new_numberOfKeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>numberOfEqualCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize for processing of keys for attr 1.
     *
     * xform[i] points to the currently best scan key of strategy type i+1; it
     * is NULL if we haven't yet found such a key for this attr.
     */</comment>
    <expr_stmt><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>xform</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xform</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop iterates from 0 to numberOfKeys inclusive; we use the last pass to
     * handle after-last-key processing.  Actual exit from the loop is at the
     * "break" statement below.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Apply indoption to scankey (might change sk_strategy!) */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_fix_scankey_strategy</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>indoption</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* NULL can't be matched, so give up */</comment>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we are at the end of the keys for a particular attr, finish up
         * processing and emit the cleaned-up keys.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>numberOfKeys</name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>!=</operator> <name>attno</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>priorNumberOfEqualCols</name> <init>= <expr><name>numberOfEqualCols</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* check input keys are correctly ordered */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name> <operator>&amp;&amp;</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>&lt;</operator> <name>attno</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btree index keys must be ordered by attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If = has been specified, all other keys can be eliminated as
             * redundant.  If we have a case like key = 1 AND key &gt; 2, we can
             * set qual_ok to false and abandon further processing.
             *
             * We also have to deal with the case of "key IS NULL", which is
             * unsatisfiable in combination with any other index condition. By
             * the time we get here, that's been classified as an equality
             * check, and we've rejected any combination of it with a regular
             * equality condition; but not with other types of conditions.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ScanKey</name></type>        <name>eq</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>BTMaxStrategyNumber</name></expr>;</init> <condition><expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>chk</name> <init>= <expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>chk</name> <operator>||</operator> <name>j</name> <operator>==</operator> <operator>(</operator><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>eq</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* IS NULL is contradictory to anything else */</comment>
                        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        <return>return;</return>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>chk</name></expr></argument>, <argument><expr><name>eq</name></expr></argument>, <argument><expr><name>chk</name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>test_result</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* keys proven mutually contradictory */</comment>
                            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            <return>return;</return>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/* else discard the redundant non-equality key */</comment>
                        <expr_stmt><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* else, cannot determine redundancy, keep both keys */</comment>
                </block_content>}</block></for>
                <comment type="block">/* track number of attrs for which we have "=" keys */</comment>
                <expr_stmt><expr><name>numberOfEqualCols</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* try to keep only one of &lt;, &lt;= */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>BTLessStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
                <operator>&amp;&amp;</operator> <name><name>xform</name><index>[<expr><name>BTLessEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ScanKey</name></type>        <name>lt</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTLessStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ScanKey</name></type>        <name>le</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTLessEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>le</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>, <argument><expr><name>le</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>test_result</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTLessEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTLessStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* try to keep only one of &gt;, &gt;= */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>BTGreaterStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
                <operator>&amp;&amp;</operator> <name><name>xform</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ScanKey</name></type>        <name>gt</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTGreaterStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ScanKey</name></type>        <name>ge</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ge</name></expr></argument>, <argument><expr><name>gt</name></expr></argument>, <argument><expr><name>ge</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>test_result</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTGreaterStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Emit the cleaned-up keys into the outkeys[] array, and then
             * mark them if they are required.  They are required (possibly
             * only in one direction) if all attrs before this one had "=".
             */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>BTMaxStrategyNumber</name></expr>;</init> <condition><expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>outkey</name> <init>= <expr><operator>&amp;</operator><name><name>outkeys</name><index>[<expr><name>new_numberOfKeys</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>, <argument><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>priorNumberOfEqualCols</name> <operator>==</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * Exit loop here if done.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>numberOfKeys</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* Re-initialize for new attno */</comment>
            <expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>xform</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xform</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* check strategy this key's operator corresponds to */</comment>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* if row comparison, push it directly to the output array */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ScanKey</name></type>        <name>outkey</name> <init>= <expr><operator>&amp;</operator><name><name>outkeys</name><index>[<expr><name>new_numberOfKeys</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>numberOfEqualCols</name> <operator>==</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We don't support RowCompare using equality; such a qual would
             * mess up the numberOfEqualCols tracking.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>!=</operator> <operator>(</operator><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* have we seen one of these before? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* nope, so remember this scankey */</comment>
            <expr_stmt><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* yup, keep only the more restrictive key */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>test_result</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>j</name> <operator>==</operator> <operator>(</operator><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* key == a &amp;&amp; key == b, but a != b */</comment>
                    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* else old key is more restrictive, keep it */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * We can't determine which key is more restrictive.  Keep the
                 * previous one in xform[j] and push this one directly to the
                 * output array.
                 */</comment>
                <decl_stmt><decl><type><name>ScanKey</name></type>        <name>outkey</name> <init>= <expr><operator>&amp;</operator><name><name>outkeys</name><index>[<expr><name>new_numberOfKeys</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>numberOfEqualCols</name> <operator>==</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <name>new_numberOfKeys</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two scankey values using a specified operator.
 *
 * The test we want to perform is logically "leftarg op rightarg", where
 * leftarg and rightarg are the sk_argument values in those ScanKeys, and
 * the comparison operator is the one in the op ScanKey.  However, in
 * cross-data-type situations we may need to look up the correct operator in
 * the index's opfamily: it is the one having amopstrategy = op-&gt;sk_strategy
 * and amoplefttype/amoprighttype equal to the two argument datatypes.
 *
 * If the opfamily doesn't supply a complete set of cross-type operators we
 * may not be able to make the comparison.  If we can make the comparison
 * we store the operator result in *result and return TRUE.  We return FALSE
 * if the comparison could not be made.
 *
 * Note: op always points at the same ScanKey as either leftarg or rightarg.
 * Since we don't scribble on the scankeys, this aliasing should cause no
 * trouble.
 *
 * Note: this routine needs to be insensitive to any DESC option applied
 * to the index column.  For example, "x &lt; 4" is a tighter constraint than
 * "x &lt; 5" regardless of which way the index is sorted.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_compare_scankey_args</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>op</name></decl></parameter>,
                         <parameter><decl><type><name>ScanKey</name></type> <name>leftarg</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>rightarg</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>lefttype</name></decl>,
                <decl><type ref="prev"/><name>righttype</name></decl>,
                <decl><type ref="prev"/><name>optype</name></decl>,
                <decl><type ref="prev"/><name>opcintype</name></decl>,
                <decl><type ref="prev"/><name>cmp_op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strat</name></decl>;</decl_stmt>

    <comment type="block">/*
     * First, deal with cases where one or both args are NULL.  This should
     * only happen when the scankeys represent IS NULL/NOT NULL conditions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>leftarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|</operator> <name><name>rightarg</name><operator>-&gt;</operator><name>sk_flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>leftnull</name></decl>,
                    <decl><type ref="prev"/><name>rightnull</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_SEARCHNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>leftnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>leftnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_SEARCHNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rightnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>rightnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * We treat NULL as either greater than or less than all other values.
         * Since true &gt; false, the tests below work correctly for NULLS LAST
         * logic.  If the index is NULLS FIRST, we need to flip the strategy.
         */</comment>
        <expr_stmt><expr><name>strat</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>strat</name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><name>strat</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&lt;</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&lt;=</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>==</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&gt;=</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&gt;</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized StrategyNumber: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The opfamily we need to worry about is identified by the index column.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <name><name>rightarg</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>opcintype</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the actual datatypes of the ScanKey arguments.  We have to
     * support the convention that sk_subtype == InvalidOid means the opclass
     * input type; this is a hack to simplify life for ScanKeyInit().
     */</comment>
    <expr_stmt><expr><name>lefttype</name> <operator>=</operator> <name><name>leftarg</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lefttype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lefttype</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>righttype</name> <operator>=</operator> <name><name>rightarg</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>righttype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>righttype</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>optype</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>optype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>optype</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If leftarg and rightarg match the types expected for the "op" scankey,
     * we can use its already-looked-up comparison function.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>lefttype</name> <operator>==</operator> <name>opcintype</name> <operator>&amp;&amp;</operator> <name>righttype</name> <operator>==</operator> <name>optype</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
                                                 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                                 <argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
                                                 <argument><expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Otherwise, we need to go to the syscache to find the appropriate
     * operator.  (This cannot result in infinite recursion, since no
     * indexscan initiated by syscache lookup will use cross-data-type
     * operators.)
     *
     * If the sk_strategy was flipped by _bt_fix_scankey_strategy, we have to
     * un-flip it to get the correct opfamily member.
     */</comment>
    <expr_stmt><expr><name>strat</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>strat</name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cmp_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                 <argument><expr><name>lefttype</name></expr></argument>,
                                 <argument><expr><name>righttype</name></expr></argument>,
                                 <argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RegProcedure</name></type> <name>cmp_proc</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>,
                                                        <argument><expr><name><name>op</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                                        <argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
                                                        <argument><expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Can't make the comparison */</comment>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>            <comment type="block">/* suppress compiler warnings */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust a scankey's strategy and flags setting as needed for indoptions.
 *
 * We copy the appropriate indoption value into the scankey sk_flags
 * (shifting to avoid clobbering system-defined flag bits).  Also, if
 * the DESC option is set, commute (flip) the operator strategy number.
 *
 * A secondary purpose is to check for IS NULL/NOT NULL scankeys and set up
 * the strategy field correctly for them.
 *
 * Lastly, for ordinary scankeys (not IS NULL/NOT NULL), we check for a
 * NULL comparison value.  Since all btree operators are assumed strict,
 * a NULL means that the qual cannot be satisfied.  We return TRUE if the
 * comparison value isn't NULL, or FALSE if the scan should be abandoned.
 *
 * This function is applied to the *input* scankey structure; therefore
 * on a rescan we will be looking at already-processed scankeys.  Hence
 * we have to be careful not to re-commute the strategy if we already did it.
 * It's a bit ugly to modify the caller's copy of the scankey but in practice
 * there shouldn't be any problem, since the index's indoptions are certainly
 * not going to change while the scankey survives.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_fix_scankey_strategy</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>indoption</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>addflags</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addflags</name> <operator>=</operator> <name><name>indoption</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>SK_BT_INDOPTION_SHIFT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We treat all btree operators as strict (even if they're not so marked
     * in pg_proc). This means that it is impossible for an operator condition
     * with a NULL comparison constant to succeed, and we can reject it right
     * away.
     *
     * However, we now also support "x IS NULL" clauses as search conditions,
     * so in that case keep going. The planner has not filled in any
     * particular strategy in this case, so set it to BTEqualStrategyNumber
     * --- we can treat IS NULL as an equality operator for purposes of search
     * strategy.
     *
     * Likewise, "x IS NOT NULL" is supported.  We treat that as either "less
     * than NULL" in a NULLS LAST index, or "greater than NULL" in a NULLS
     * FIRST index.
     *
     * Note: someday we might have to fill in sk_collation from the index
     * column's collation.  At the moment this is a non-issue because we'll
     * never actually call the comparison operator on a NULL.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* SK_ISNULL shouldn't be set in a row header scankey */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set indoption flags in scankey (might be done already) */</comment>
        <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>

        <comment type="block">/* Set correct strategy for IS NULL or NOT NULL search */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name>BTGreaterStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name>BTLessStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* regular qual, so it cannot be satisfied */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Needn't do the rest */</comment>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Adjust strategy for DESC, if we didn't already */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>addflags</name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>

    <comment type="block">/* If it's a row header, fix row member flags and strategies similarly */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>addflags</name> <operator>=</operator> <name><name>indoption</name><index>[<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>SK_BT_INDOPTION_SHIFT</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>addflags</name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>subkey</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a scankey as "required to continue the scan".
 *
 * Depending on the operator type, the key may be required for both scan
 * directions or just one.  Also, if the key is a row comparison header,
 * we have to mark its first subsidiary ScanKey as required.  (Subsequent
 * subsidiary ScanKeys are normally for lower-order columns, and thus
 * cannot be required, since they're after the first non-equality scankey.)
 *
 * Note: when we set required-key flag bits in a subsidiary scankey, we are
 * scribbling on a data structure belonging to the index AM's caller, not on
 * our private copy.  This should be OK because the marking will not change
 * from scan to scan within a query, and so we'd just re-mark the same way
 * anyway on a rescan.  Something to keep an eye on though.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_mark_scankey_required</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>addflags</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
        <case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>addflags</name> <operator>=</operator> <name>SK_BT_REQFWD</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>addflags</name> <operator>=</operator> <name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
        <case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>addflags</name> <operator>=</operator> <name>SK_BT_REQBKWD</name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized StrategyNumber: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>addflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* First subkey should be same column/operator as the header */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether an indextuple satisfies all the scankey conditions.
 *
 * If so, return the address of the index tuple on the index page.
 * If not, return NULL.
 *
 * If the tuple fails to pass the qual, we also determine whether there's
 * any need to continue the scan beyond this tuple, and set *continuescan
 * accordingly.  See comments for _bt_preprocess_keys(), above, about how
 * this is done.
 *
 * scan: index scan descriptor (containing a search-type scankey)
 * page: buffer page containing index tuple
 * offnum: offset number of index tuple (must be a valid item!)
 * dir: direction we are scanning in
 * continuescan: output parameter (will be set correctly in all cases)
 *
 * Caller must hold pin and lock on the index page.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>_bt_checkkeys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
              <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>,
              <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>continuescan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ItemId</name></type>        <name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>tuple_alive</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>keysz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ikey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>key</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* default assumption */</comment>

    <comment type="block">/*
     * If the scan specifies not to return killed tuples, then we treat a
     * killed tuple as not passing the qual.  Most of the time, it's a win to
     * not bother examining the tuple's index keys, but just return
     * immediately with continuescan = true to proceed to the next tuple.
     * However, if this is the last tuple on the page, we should check the
     * index keys to prevent uselessly advancing to the next page.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>ignore_killed_tuples</name></name> <operator>&amp;&amp;</operator> <call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* return immediately if there are more tuples on the page */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&lt;</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&gt;</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * OK, we want to check the keys so we can set continuescan correctly,
         * but we'll return NULL even if the tuple passes the key tests.
         */</comment>
        <expr_stmt><expr><name>tuple_alive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>tuple_alive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>keysz</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>key</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr><operator>,</operator> <expr><name>ikey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ikey</name> <operator>&lt;</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>key</name><operator>++</operator></expr><operator>,</operator> <expr><name>ikey</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>test</name></decl>;</decl_stmt>

        <comment type="block">/* row-comparison keys need special processing */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>_bt_check_rowcompare</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>continuescan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
                              <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
                              <argument><expr><name>tupdesc</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Handle IS NULL/NOT NULL tests */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* tuple satisfies this qual */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* tuple satisfies this qual */</comment>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Tuple fails this qual.  If it's a required qual for the current
             * scan direction, then we can conclude no further tuples will
             * pass, either.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
                     <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * In any case, this indextuple doesn't match the qual.
             */</comment>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Since NULLs are sorted before non-NULLs, we know we have
                 * reached the lower limit of the range of values for this
                 * index attr.  On a backward scan, we can stop if this qual
                 * is one of the "must match" subset.  We can stop regardless
                 * of whether the qual is &gt; or &lt;, so long as it's required,
                 * because it's not possible for any future tuples to pass. On
                 * a forward scan, however, we must keep going, because we may
                 * have initially positioned to the start of the index.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
                    <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Since NULLs are sorted after non-NULLs, we know we have
                 * reached the upper limit of the range of values for this
                 * index attr.  On a forward scan, we can stop if this qual is
                 * one of the "must match" subset.  We can stop regardless of
                 * whether the qual is &gt; or &lt;, so long as it's required,
                 * because it's not possible for any future tuples to pass. On
                 * a backward scan, however, we must keep going, because we
                 * may have initially positioned to the end of the index.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
                    <call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * In any case, this indextuple doesn't match the qual.
             */</comment>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                 <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Tuple fails this qual.  If it's a required qual for the current
             * scan direction, then we can conclude no further tuples will
             * pass, either.
             *
             * Note: because we stop the scan as soon as any required equality
             * qual fails, it is critical that equality quals be used for the
             * initial positioning in _bt_first() when they are available. See
             * comments in _bt_first().
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
                     <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * In any case, this indextuple doesn't match the qual.
             */</comment>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Check for failure due to it being a killed tuple. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple_alive</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we get here, the tuple passes all index quals. */</comment>
    <return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether an indextuple satisfies a row-comparison scan condition.
 *
 * Return true if so, false if not.  If not, also clear *continuescan if
 * it's not possible for any future tuples in the current scan direction
 * to pass the qual.
 *
 * This is a subroutine for _bt_checkkeys, which see for more info.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_check_rowcompare</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
                     <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>continuescan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmpresult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* First subkey should be same as the header says */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Loop over columns of the row condition */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
                              <argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
                              <argument><expr><name>tupdesc</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Since NULLs are sorted before non-NULLs, we know we have
                 * reached the lower limit of the range of values for this
                 * index attr.  On a backward scan, we can stop if this qual
                 * is one of the "must match" subset.  We can stop regardless
                 * of whether the qual is &gt; or &lt;, so long as it's required,
                 * because it's not possible for any future tuples to pass. On
                 * a forward scan, however, we must keep going, because we may
                 * have initially positioned to the start of the index.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
                    <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Since NULLs are sorted after non-NULLs, we know we have
                 * reached the upper limit of the range of values for this
                 * index attr.  On a forward scan, we can stop if this qual is
                 * one of the "must match" subset.  We can stop regardless of
                 * whether the qual is &gt; or &lt;, so long as it's required,
                 * because it's not possible for any future tuples to pass. On
                 * a backward scan, however, we must keep going, because we
                 * may have initially positioned to the end of the index.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
                    <call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * In any case, this indextuple doesn't match the qual.
             */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Unlike the simple-scankey case, this isn't a disallowed case.
             * But it can never match.  If all the earlier row comparison
             * columns are required for the scan direction, we can stop the
             * scan, because there can't be another tuple that will succeed.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>subkey</name> <operator>!=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>subkey</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
                <call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
                     <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Perform the test --- three-way comparison not bool operator */</comment>
        <expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
                                                    <argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
                                                    <argument><expr><name>datum</name></expr></argument>,
                                                    <argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <operator>-</operator><name>cmpresult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Done comparing if unequal, else advance to next column */</comment>
        <if_stmt><if>if <condition>(<expr><name>cmpresult</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>subkey</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * At this point cmpresult indicates the overall result of the row
     * comparison, and subkey points to the deciding column (or the last
     * column if the result is "=").
     */</comment>
    <switch>switch <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* EQ and NE cases aren't allowed here */</comment>
        <case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RowCompareType: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Tuple fails this qual.  If it's a required qual for the current
         * scan direction, then we can conclude no further tuples will pass,
         * either.  Note we have to look at the deciding column, not
         * necessarily the first or last column of the row condition.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
                 <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_killitems - set LP_DEAD state for items an indexscan caller has
 * told us were killed
 *
 * scan-&gt;opaque, referenced locally through so, contains information about the
 * current page and killed tuples thereon (generally, this should only be
 * called if so-&gt;numKilled &gt; 0).
 *
 * The caller does not have a lock on the page and may or may not have the
 * page pinned in a buffer.  Note that read-lock is sufficient for setting
 * LP_DEAD status (which is only a hint).
 *
 * We match items by heap TID before assuming they are the right ones to
 * delete.  We cope with cases where items have moved right due to insertions.
 * If an item has moved off the current page due to a split, we'll fail to
 * find it and do nothing (this is not an error case --- we assume the item
 * will eventually get marked in a future indexscan).
 *
 * Note that if we hold a pin on the target page continuously from initially
 * reading the items until applying this function, VACUUM cannot have deleted
 * any items from the page, and so there is no need to search left from the
 * recorded offset.  (This observation also guarantees that the item is still
 * the right one to delete, which might otherwise be questionable since heap
 * TIDs can get recycled.)    This holds true even if the page has been modified
 * by inserts and page splits, so there is no need to consult the LSN.
 *
 * If the pin was released after reading the page, then we re-read it.  If it
 * has been modified since we read it (as determined by the LSN), we dare not
 * flag any entries because it is possible that the old entry was vacuumed
 * away and the TID was re-used by a completely different heap tuple.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_killitems</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>minoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numKilled</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>killedsomething</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTScanPosIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Always reset the scan state, so we don't look for same items on other
     * pages.
     */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>BTScanPosIsPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have held the pin on this page since we read the index tuples,
         * so all we need to do is lock it.  The pin will have prevented
         * re-use of any TID on the page, so there is no need to check the
         * LSN.
         */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_buffer_mprotect</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>

        <comment type="block">/* Attempt to re-read the buffer, getting pin and lock. */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_buffer_mprotect</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <comment type="block">/* It might not exist anymore; in which case we can't hint it. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Modified while not pinned means hinting is not safe. */</comment>
            <expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numKilled</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>itemIndex</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BTScanPosItem</name> <modifier>*</modifier></type><name>kitem</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name>itemIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name> <init>= <expr><name><name>kitem</name><operator>-&gt;</operator><name>indexOffset</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>&amp;&amp;</operator>
               <name>itemIndex</name> <operator>&lt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&lt;</operator> <name>minoff</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* pure paranoia */</comment>
        <while>while <condition>(<expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ItemId</name></type>        <name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>ituple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ituple</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>kitem</name><operator>-&gt;</operator><name>heapTid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* found the item */</comment>
                <expr_stmt><expr><call><name>ItemIdMarkDead</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>killedsomething</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>            <comment type="block">/* out of inner search loop */</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <comment type="block">/*
     * Since this can be redone later if needed, mark as dirty hint.
     *
     * Whenever we mark anything LP_DEAD, we also set the page's
     * BTP_HAS_GARBAGE flag, which is likewise just a hint.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>killedsomething</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * The following routines manage a shared-memory area in which we track
 * assignment of "vacuum cycle IDs" to currently-active btree vacuuming
 * operations.  There is a single counter which increments each time we
 * start a vacuum to assign it a cycle ID.  Since multiple vacuums could
 * be active concurrently, we have to track the cycle ID for each active
 * vacuum; this requires at most MaxBackends entries (usually far fewer).
 * We assume at most one vacuum can be active for a given index.
 *
 * Access to the shared memory area is controlled by BtreeVacuumLock.
 * In principle we could use a separate lmgr locktag for each index,
 * but a single LWLock is much cheaper, and given the short time that
 * the lock is ever held, the concurrency hit should be minimal.
 */</comment>

<typedef>typedef <type><struct>struct <name>BTOneVacInfo</name>
<block>{
    <decl_stmt><decl><type><name>LockRelId</name></type>    <name>relid</name></decl>;</decl_stmt>            <comment type="block">/* global identifier of an index */</comment>
    <decl_stmt><decl><type><name>BTCycleId</name></type>    <name>cycleid</name></decl>;</decl_stmt>        <comment type="block">/* cycle ID for its active VACUUM */</comment>
}</block></struct></type> <name>BTOneVacInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BTVacInfo</name>
<block>{
    <decl_stmt><decl><type><name>BTCycleId</name></type>    <name>cycle_ctr</name></decl>;</decl_stmt>        <comment type="block">/* cycle ID most recently assigned */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_vacuums</name></decl>;</decl_stmt>    <comment type="block">/* number of currently active VACUUMs */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>max_vacuums</name></decl>;</decl_stmt>    <comment type="block">/* allocated length of vacuums[] array */</comment>
    <decl_stmt><decl><type><name>BTOneVacInfo</name></type> <name><name>vacuums</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BTVacInfo</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>BTVacInfo</name> <modifier>*</modifier></type><name>btvacinfo</name></decl>;</decl_stmt>


<comment type="block">/*
 * _bt_vacuum_cycleid --- get the active vacuum cycle ID for an index,
 *        or zero if there is no active VACUUM
 *
 * Note: for correct interlocking, the caller must already hold pin and
 * exclusive lock on each buffer it will store the cycle ID into.  This
 * ensures that even if a VACUUM starts immediately afterwards, it cannot
 * process those pages until the page split is complete.
 */</comment>
<function><type><name>BTCycleId</name></type>
<name>_bt_vacuum_cycleid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTCycleId</name></type>    <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Share lock is enough since this is a read-only operation */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BTOneVacInfo</name> <modifier>*</modifier></type><name>vac</name> <init>= <expr><operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>relId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>&amp;&amp;</operator>
            <name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>dbId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>vac</name><operator>-&gt;</operator><name>cycleid</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_start_vacuum --- assign a cycle ID to a just-starting VACUUM operation
 *
 * Note: the caller must guarantee that it will eventually call
 * _bt_end_vacuum, else we'll permanently leak an array slot.  To ensure
 * that this happens even in elog(FATAL) scenarios, the appropriate coding
 * is not just a PG_TRY, but
 *        PG_ENSURE_ERROR_CLEANUP(_bt_end_vacuum_callback, PointerGetDatum(rel))
 */</comment>
<function><type><name>BTCycleId</name></type>
<name>_bt_start_vacuum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BTCycleId</name></type>    <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BTOneVacInfo</name> <modifier>*</modifier></type><name>vac</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Assign the next cycle ID, being careful to avoid zero as well as the
     * reserved high values.
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>cycle_ctr</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>result</name> <operator>&gt;</operator> <name>MAX_BT_CYCLE_ID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Let's just make sure there's no entry already for this index */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>vac</name> <operator>=</operator> <operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>relId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>&amp;&amp;</operator>
            <name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>dbId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Unlike most places in the backend, we have to explicitly
             * release our LWLock before throwing an error.  This is because
             * we expect _bt_end_vacuum() to be called before transaction
             * abort cleanup can run to release LWLocks.
             */</comment>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"multiple active vacuums for index \"%s\""</literal></expr></argument>,
                 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* OK, add an entry */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name> <operator>&gt;=</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>max_vacuums</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of btvacinfo slots"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>vac</name> <operator>=</operator> <operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vac</name><operator>-&gt;</operator><name>cycleid</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_end_vacuum --- mark a btree VACUUM operation as done
 *
 * Note: this is deliberately coded not to complain if no entry is found;
 * this allows the caller to put PG_TRY around the start_vacuum operation.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_end_vacuum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find the array entry */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BTOneVacInfo</name> <modifier>*</modifier></type><name>vac</name> <init>= <expr><operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>relId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>&amp;&amp;</operator>
            <name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>dbId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Remove it by shifting down the last entry */</comment>
            <expr_stmt><expr><operator>*</operator><name>vac</name> <operator>=</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name><operator>--</operator></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_end_vacuum wrapped as an on_shmem_exit callback function
 */</comment>
<function><type><name>void</name></type>
<name>_bt_end_vacuum_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>_bt_end_vacuum</name><argument_list>(<argument><expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BTreeShmemSize --- report amount of shared memory space needed
 */</comment>
<function><type><name>Size</name></type>
<name>BTreeShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTVacInfo</name></expr></argument>, <argument><expr><name>vacuums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MaxBackends</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTOneVacInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BTreeShmemInit --- initialize this module's shared memory
 */</comment>
<function><type><name>void</name></type>
<name>BTreeShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>btvacinfo</name> <operator>=</operator> <operator>(</operator><name>BTVacInfo</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"BTree Vacuum State"</literal></expr></argument>,
                                              <argument><expr><call><name>BTreeShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Initialize shared memory area */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * It doesn't really matter what the cycle counter starts at, but
         * having it always start the same doesn't seem good.  Seed with
         * low-order bits of time() instead.
         */</comment>
        <expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <operator>(</operator><name>BTCycleId</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>max_vacuums</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>btoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_BTREE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    btproperty() -- Check boolean properties of indexes.
 *
 * This is optional, but handling AMPROP_RETURNABLE here saves opening the rel
 * to call btcanreturn.
 */</comment>
<function><type><name>bool</name></type>
<name>btproperty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>,
           <parameter><decl><type><name>IndexAMProperty</name></type> <name>prop</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>propname</name></decl></parameter>,
           <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>prop</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>AMPROP_RETURNABLE</name></expr>:</case>
            <comment type="block">/* answer only for columns, not AM or whole index */</comment>
            <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <comment type="block">/* otherwise, btree can always return data */</comment>
            <expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>

        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>        <comment type="block">/* punt to generic code */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>
</unit>
