<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/gin/ginscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ginscan.c
 *      routines to manage scans of inverted index relations
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *            src/backend/access/gin/ginscan.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<function><type><name>IndexScanDesc</name></type>
<name>ginbeginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name></decl>;</decl_stmt>

    <comment type="block">/* no order by operators allowed */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>norderbys</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>RelationGetIndexScan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>norderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* allocate private workspace */</comment>
    <expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinScanOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                        <argument><expr><literal type="string">"Gin scan temporary context"</literal></expr></argument>,
                                        <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                       <argument><expr><literal type="string">"Gin scan key context"</literal></expr></argument>,
                                       <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initGinState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>so</name></expr>;</expr_stmt>

    <return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new GinScanEntry, unless an equivalent one already exists,
 * in which case just return it
 */</comment>
<function><type><specifier>static</specifier> <name>GinScanEntry</name></type>
<name>ginFillScanEntry</name><parameter_list>(<parameter><decl><type><name>GinScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
                 <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>searchMode</name></decl></parameter>,
                 <parameter><decl><type><name>Datum</name></type> <name>queryKey</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name></type> <name>queryCategory</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>isPartialMatch</name></decl></parameter>, <parameter><decl><type><name>Pointer</name></type> <name>extra_data</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GinState</name>   <modifier>*</modifier></type><name>ginstate</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinScanEntry</name></type> <name>scanEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Look for an existing equivalent entry.
     *
     * Entries with non-null extra_data are never considered identical, since
     * we can't know exactly what the opclass might be doing with that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>GinScanEntry</name></type> <name>prevEntry</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>prevEntry</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <name><name>prevEntry</name><operator>-&gt;</operator><name>isPartialMatch</name></name> <operator>==</operator> <name>isPartialMatch</name> <operator>&amp;&amp;</operator>
                <name><name>prevEntry</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>strategy</name> <operator>&amp;&amp;</operator>
                <name><name>prevEntry</name><operator>-&gt;</operator><name>searchMode</name></name> <operator>==</operator> <name>searchMode</name> <operator>&amp;&amp;</operator>
                <name><name>prevEntry</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name>attnum</name> <operator>&amp;&amp;</operator>
                <call><name>ginCompareEntries</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
                                  <argument><expr><name><name>prevEntry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>,
                                  <argument><expr><name><name>prevEntry</name><operator>-&gt;</operator><name>queryCategory</name></name></expr></argument>,
                                  <argument><expr><name>queryKey</name></expr></argument>,
                                  <argument><expr><name>queryCategory</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Successful match */</comment>
                <return>return <expr><name>prevEntry</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Nope, create a new entry */</comment>
    <expr_stmt><expr><name>scanEntry</name> <operator>=</operator> <operator>(</operator><name>GinScanEntry</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntryData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>queryKey</name></name> <operator>=</operator> <name>queryKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>queryCategory</name></name> <operator>=</operator> <name>queryCategory</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>isPartialMatch</name></name> <operator>=</operator> <name>isPartialMatch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>extra_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>searchMode</name></name> <operator>=</operator> <name>searchMode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanEntry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>matchBitmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>matchIterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>matchResult</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>nlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>reduceResult</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Add it to so's array */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name> <operator>&gt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>allocentries</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>allocentries</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <operator>(</operator><name>GinScanEntry</name> <operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>allocentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>scanEntry</name></expr>;</expr_stmt>

    <return>return <expr><name>scanEntry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the next GinScanKey using the output from the extractQueryFn
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginFillScanKey</name><parameter_list>(<parameter><decl><type><name>GinScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
               <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>searchMode</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nQueryValues</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>queryValues</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name> <modifier>*</modifier></type><name>queryCategories</name></decl></parameter>,
               <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>partial_matches</name></decl></parameter>, <parameter><decl><type><name>Pointer</name> <modifier>*</modifier></type><name>extra_data</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GinScanKey</name></type>    <name>key</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name><operator>++</operator></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinState</name>   <modifier>*</modifier></type><name>ginstate</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>nUserQueryValues</name> <init>= <expr><name>nQueryValues</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Non-default search modes add one "hidden" entry to each key */</comment>
    <if_stmt><if>if <condition>(<expr><name>searchMode</name> <operator>!=</operator> <name>GIN_SEARCH_MODE_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nQueryValues</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nentries</name></name> <operator>=</operator> <name>nQueryValues</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nuserentries</name></name> <operator>=</operator> <name>nUserQueryValues</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>scanEntry</name></name> <operator>=</operator> <operator>(</operator><name>GinScanEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nQueryValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name></name> <operator>=</operator> <operator>(</operator><name>GinTernaryValue</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinTernaryValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nQueryValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>queryValues</name></name> <operator>=</operator> <name>queryValues</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>queryCategories</name></name> <operator>=</operator> <name>queryCategories</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>extra_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>searchMode</name></name> <operator>=</operator> <name>searchMode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>additionalEntries</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ginInitConsistentFunction</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nQueryValues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>queryKey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GinNullCategory</name></type> <name>queryCategory</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isPartialMatch</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Pointer</name></type>        <name>this_extra</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nUserQueryValues</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* set up normal entry using extractQueryFn's outputs */</comment>
            <expr_stmt><expr><name>queryKey</name> <operator>=</operator> <name><name>queryValues</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>queryCategory</name> <operator>=</operator> <name><name>queryCategories</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>isPartialMatch</name> <operator>=</operator>
                <ternary><condition><expr><operator>(</operator><name><name>ginstate</name><operator>-&gt;</operator><name>canPartialMatch</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>partial_matches</name><operator>)</operator></expr>
                ?</condition><then> <expr><name><name>partial_matches</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>this_extra</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>extra_data</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>extra_data</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* set up hidden entry */</comment>
            <expr_stmt><expr><name>queryKey</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>searchMode</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>GIN_SEARCH_MODE_INCLUDE_EMPTY</name></expr>:</case>
                    <expr_stmt><expr><name>queryCategory</name> <operator>=</operator> <name>GIN_CAT_EMPTY_ITEM</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>GIN_SEARCH_MODE_ALL</name></expr>:</case>
                    <expr_stmt><expr><name>queryCategory</name> <operator>=</operator> <name>GIN_CAT_EMPTY_QUERY</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>GIN_SEARCH_MODE_EVERYTHING</name></expr>:</case>
                    <expr_stmt><expr><name>queryCategory</name> <operator>=</operator> <name>GIN_CAT_EMPTY_QUERY</name></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected searchMode: %d"</literal></expr></argument>, <argument><expr><name>searchMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>queryCategory</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* keep compiler quiet */</comment>
                    <break>break;</break>
            </block_content>}</block></switch>
            <expr_stmt><expr><name>isPartialMatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>this_extra</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <comment type="block">/*
             * We set the strategy to a fixed value so that ginFillScanEntry
             * can combine these entries for different scan keys.  This is
             * safe because the strategy value in the entry struct is only
             * used for partial-match cases.  It's OK to overwrite our local
             * variable here because this is the last loop iteration.
             */</comment>
            <expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ginFillScanEntry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
                                             <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>searchMode</name></expr></argument>,
                                             <argument><expr><name>queryKey</name></expr></argument>, <argument><expr><name>queryCategory</name></expr></argument>,
                                             <argument><expr><name>isPartialMatch</name></expr></argument>, <argument><expr><name>this_extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Release current scan keys, if any.
 */</comment>
<function><type><name>void</name></type>
<name>ginFreeScanKeys</name><parameter_list>(<parameter><decl><type><name>GinScanOpaque</name></type> <name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GinScanEntry</name></type> <name>entry</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>tbm_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ginNewScanKey</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>scankey</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasNullQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Allocate all the scan key information in the key context. (If
     * extractQuery leaks anything there, it won't be reset until the end of
     * scan or rescan, but that's OK.)
     */</comment>
    <expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if no scan keys provided, allocate extra EVERYTHING GinScanKey */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <operator>(</operator><name>GinScanKey</name><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* initialize expansible array of GinScanEntry pointers */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>allocentries</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <operator>(</operator><name>GinScanEntry</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>allocentries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>isVoidRes</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>queryValues</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>nQueryValues</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>partial_matches</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Pointer</name>    <modifier>*</modifier></type><name>extra_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullFlags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>searchMode</name> <init>= <expr><name>GIN_SEARCH_MODE_DEFAULT</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We assume that GIN-indexable operators are strict, so a null query
         * argument means an unsatisfiable query.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>isVoidRes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* OK to call the extractQueryFn */</comment>
        <expr_stmt><expr><name>queryValues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
            <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>FunctionCall7Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name><operator>.</operator><name>extractQueryFn</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>so</name><operator>-&gt;</operator><name>ginstate</name><operator>.</operator><name>supportCollation</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nQueryValues</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partial_matches</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_data</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nullFlags</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>searchMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If bogus searchMode is returned, treat as GIN_SEARCH_MODE_ALL; note
         * in particular we don't allow extractQueryFn to select
         * GIN_SEARCH_MODE_EVERYTHING.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>searchMode</name> <argument_list type="generic">&lt; <argument><expr><name>GIN_SEARCH_MODE_DEFAULT</name> <operator>||</operator>
            <name>searchMode</name></expr></argument> &gt;</argument_list></name> <name>GIN_SEARCH_MODE_ALL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>searchMode</name> <operator>=</operator> <name>GIN_SEARCH_MODE_ALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Non-default modes require the index to have placeholders */</comment>
        <if_stmt><if>if <condition>(<expr><name>searchMode</name> <operator>!=</operator> <name>GIN_SEARCH_MODE_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hasNullQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * In default mode, no keys means an unsatisfiable query.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>queryValues</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nQueryValues</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>searchMode</name> <operator>==</operator> <name>GIN_SEARCH_MODE_DEFAULT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>isVoidRes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>nQueryValues</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* ensure sane value */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the extractQueryFn didn't create a nullFlags array, create one,
         * assuming that everything's non-null.  Otherwise, run through the
         * array and make sure each value is exactly 0 or 1; this ensures
         * binary compatibility with the GinNullCategory representation. While
         * at it, detect whether any null keys are present.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>nullFlags</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nullFlags</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nQueryValues</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>int32</name></type>        <name>j</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nQueryValues</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>nullFlags</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>nullFlags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>    <comment type="block">/* not any other nonzero value */</comment>
                    <expr_stmt><expr><name>hasNullQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* now we can use the nullFlags as category codes */</comment>

        <expr_stmt><expr><call><name>ginFillScanKey</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
                       <argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>, <argument><expr><name>searchMode</name></expr></argument>,
                       <argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>, <argument><expr><name>nQueryValues</name></expr></argument>,
                       <argument><expr><name>queryValues</name></expr></argument>, <argument><expr><operator>(</operator><name>GinNullCategory</name> <operator>*</operator><operator>)</operator> <name>nullFlags</name></expr></argument>,
                       <argument><expr><name>partial_matches</name></expr></argument>, <argument><expr><name>extra_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If there are no regular scan keys, generate an EVERYTHING scankey to
     * drive a full-index scan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>isVoidRes</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>hasNullQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ginFillScanKey</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>,
                       <argument><expr><name>InvalidStrategy</name></expr></argument>, <argument><expr><name>GIN_SEARCH_MODE_EVERYTHING</name></expr></argument>,
                       <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the index is version 0, it may be missing null and placeholder
     * entries, which would render searches for nulls and full-index scans
     * unreliable.  Throw an error if so.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>hasNullQuery</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>isVoidRes</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GinStatsData</name></type> <name>ginStats</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ginGetStats</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ginStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ginStats</name><operator>.</operator><name>ginVersion</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"old GIN indexes do not support whole-index scans nor searches for nulls"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To fix this, do REINDEX INDEX \"%s\"."</literal></expr></argument>,
                             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ginrescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nscankeys</name></decl></parameter>,
          <parameter><decl><type><name>ScanKey</name></type> <name>orderbys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ginFreeScanKeys</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>scankey</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>,
                <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ginendscan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ginFreeScanKeys</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
