<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/gin/ginget.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ginget.c
 *      fetch tuples from a GIN scan.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *            src/backend/access/gin/ginget.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/* GUC parameter */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>GinFuzzySearchLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>pendingPosition</name>
<block>{
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>pendingBuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>firstOffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>lastOffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>hasMatchKey</name></decl>;</decl_stmt>
}</block></struct></type> <name>pendingPosition</name>;</typedef>


<comment type="block">/*
 * Goes to the next page if current offset is outside of bounds
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>moveRightIfItNeeded</name><parameter_list>(<parameter><decl><type><name>GinBtreeData</name> <modifier>*</modifier></type><name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>&gt;</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We scanned the whole page, so we should take right page
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* no more pages */</comment>

        <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ginStepRight</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan all pages of a posting tree and save all its heap ItemPointers
 * in scanEntry-&gt;matchBitmap
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>scanPostingTree</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>GinScanEntry</name></type> <name>scanEntry</name></decl></parameter>,
                <parameter><decl><type><name>BlockNumber</name></type> <name>rootPostingTree</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GinBtreeData</name></type> <name>btree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>

    <comment type="block">/* Descend to the leftmost leaf page */</comment>
    <expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>ginScanBeginPostingTree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>rootPostingTree</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* prevent unpin in freeGinBtreeStack */</comment>

    <expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop iterates through all leaf pages of posting tree
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>GIN_DELETED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>n</name> <init>= <expr><call><name>GinDataLeafPageGetItemsToTbm</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>predictNumberResult</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* no more pages */</comment>

        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ginStepRight</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collects TIDs into scanEntry-&gt;matchBitmap for all heap tuples that
 * match the search entry.  This supports three different match modes:
 *
 * 1. Partial-match support: scan from current point until the
 *      comparePartialFn says we're done.
 * 2. SEARCH_MODE_ALL: scan from current point (which should be first
 *      key for the current attnum) until we hit null items or end of attnum
 * 3. SEARCH_MODE_EVERYTHING: scan from current point (which should be first
 *      key for the current attnum) until we hit end of attnum
 *
 * Returns true if done, false if it's necessary to restart scan from scratch
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>collectMatchBitmap</name><parameter_list>(<parameter><decl><type><name>GinBtreeData</name> <modifier>*</modifier></type><name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
                   <parameter><decl><type><name>GinScanEntry</name></type> <name>scanEntry</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

    <comment type="block">/* Initialize empty bitmap result */</comment>
    <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>matchBitmap</name></name> <operator>=</operator> <call><name>tbm_create</name><argument_list>(<argument><expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Null query cannot partial-match anything */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scanEntry</name><operator>-&gt;</operator><name>isPartialMatch</name></name> <operator>&amp;&amp;</operator>
        <name><name>scanEntry</name><operator>-&gt;</operator><name>queryCategory</name></name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Locate tupdesc entry for key column (for attbyval/attlen data) */</comment>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>scanEntry</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>btree</name><operator>-&gt;</operator><name>ginstate</name><operator>-&gt;</operator><name>origTupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>idatum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GinNullCategory</name></type> <name>icategory</name></decl>;</decl_stmt>

        <comment type="block">/*
         * stack-&gt;off points to the interested entry, buffer is already locked
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>moveRightIfItNeeded</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If tuple stores another attribute then stop scan
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Safe to fetch attribute value */</comment>
        <expr_stmt><expr><name>idatum</name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>icategory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check for appropriate scan stop conditions
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scanEntry</name><operator>-&gt;</operator><name>isPartialMatch</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int32</name></type>        <name>cmp</name></decl>;</decl_stmt>

            <comment type="block">/*
             * In partial match, stop scan at any null (including
             * placeholders); partial matches never match nulls
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>icategory</name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*----------
             * Check of partial match.
             * case cmp == 0 =&gt; match
             * case cmp &gt; 0 =&gt; not match and finish scan
             * case cmp &lt; 0 =&gt; not match and continue scan
             *----------
             */</comment>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name><operator>-&gt;</operator><name>comparePartialFn</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                                  <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                                  <argument><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>,
                                                  <argument><expr><name>idatum</name></expr></argument>,
                                                  <argument><expr><call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>extra_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name><operator>++</operator></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>scanEntry</name><operator>-&gt;</operator><name>searchMode</name></name> <operator>==</operator> <name>GIN_SEARCH_MODE_ALL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * In ALL mode, we are not interested in null items, so we can
             * stop if we get to a null-item placeholder (which will be the
             * last entry for a given attnum).  We do want to include NULL_KEY
             * and EMPTY_ITEM entries, though.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>icategory</name> <operator>==</operator> <name>GIN_CAT_NULL_ITEM</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * OK, we want to return the TIDs listed in this entry.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>GinIsPostingTree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootPostingTree</name> <init>= <expr><call><name>GinGetPostingTree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * We should unlock current page (but not unpin) during tree scan
             * to prevent deadlock with vacuum processes.
             *
             * We save current entry value (idatum) to be able to re-find our
             * tuple after re-locking
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>icategory</name> <operator>==</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>idatum</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>idatum</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Collect all the TIDs in this entry's posting tree */</comment>
            <expr_stmt><expr><call><name>scanPostingTree</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>scanEntry</name></expr></argument>, <argument><expr><name>rootPostingTree</name></expr></argument>,
                            <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * We lock again the entry page and while it was unlocked insert
             * might have occurred, so we need to re-find our position.
             */</comment>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Root page becomes non-leaf while we unlock it. We will
                 * start again, this situation doesn't occur often - root can
                 * became a non-leaf only once per life of index.
                 */</comment>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Search forward to re-find idatum */</comment>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Datum</name></type>        <name>newDatum</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>GinNullCategory</name></type> <name>newCategory</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>moveRightIfItNeeded</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"lost saved point in index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* must not happen !!! */</comment>

                <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"lost saved point in index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* must not happen !!! */</comment>
                <expr_stmt><expr><name>newDatum</name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>newCategory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>ginCompareEntries</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
                                      <argument><expr><name>newDatum</name></expr></argument>, <argument><expr><name>newCategory</name></expr></argument>,
                                      <argument><expr><name>idatum</name></expr></argument>, <argument><expr><name>icategory</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>        <comment type="block">/* Found! */</comment>

                <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>icategory</name> <operator>==</operator> <name>GIN_CAT_NORM_KEY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>idatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>ItemPointer</name></type> <name>ipd</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>nipd</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>ipd</name> <operator>=</operator> <call><name>ginReadTuple</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nipd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr></argument>, <argument><expr><name>ipd</name></expr></argument>, <argument><expr><name>nipd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scanEntry</name><operator>-&gt;</operator><name>predictNumberResult</name></name> <operator>+=</operator> <call><name>GinGetNPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ipd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Done with this entry, go to the next
         */</comment>
        <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Start* functions setup beginning state of searches: finds correct buffer and pins it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>startScanEntry</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GinBtreeData</name></type> <name>btreeEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stackEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>needUnlock</name></decl>;</decl_stmt>

<label><name>restartScanEntry</name>:</label>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>reduceResult</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>predictNumberResult</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * we should find entry, and begin scan of posting tree or just store
     * posting list in memory
     */</comment>
    <expr_stmt><expr><call><name>ginPrepareEntryScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btreeEntry</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
                        <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryCategory</name></name></expr></argument>,
                        <argument><expr><name>ginstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stackEntry</name> <operator>=</operator> <call><name>ginFindLeafPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btreeEntry</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ginFindLeafPage() will have already checked snapshot age. */</comment>
    <expr_stmt><expr><name>needUnlock</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isPartialMatch</name></name> <operator>||</operator>
        <name><name>entry</name><operator>-&gt;</operator><name>queryCategory</name></name> <operator>==</operator> <name>GIN_CAT_EMPTY_QUERY</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * btreeEntry.findItem locates the first item &gt;= given search key.
         * (For GIN_CAT_EMPTY_QUERY, it will find the leftmost index item
         * because of the way the GIN_CAT_EMPTY_QUERY category code is
         * assigned.)  We scan forward from there and collect all TIDs needed
         * for the entry type.
         */</comment>
        <expr_stmt><expr><call><name><name>btreeEntry</name><operator>.</operator><name>findItem</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>btreeEntry</name></expr></argument>, <argument><expr><name>stackEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>collectMatchBitmap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btreeEntry</name></expr></argument>, <argument><expr><name>stackEntry</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call>
            <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * GIN tree was seriously restructured, so we will cleanup all
             * found data and rescan. See comments near 'return false' in
             * collectMatchBitmap()
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>tbm_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stackEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>restartScanEntry</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tbm_is_empty</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name> <operator>=</operator> <call><name>tbm_begin_iterate</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name><name>btreeEntry</name><operator>.</operator><name>findItem</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>btreeEntry</name></expr></argument>, <argument><expr><name>stackEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GinIsPostingTree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootPostingTree</name> <init>= <expr><call><name>GinGetPostingTree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>minItem</name></decl>;</decl_stmt>

            <comment type="block">/*
             * We should unlock entry page before touching posting tree to
             * prevent deadlocks with vacuum processes. Because entry is never
             * deleted from page and posting tree is never reduced to the
             * posting list, we can unlock page after getting BlockNumber of
             * root of posting tree.
             */</comment>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needUnlock</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>ginScanBeginPostingTree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>btree</name></name></expr></argument>, <argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
                                            <argument><expr><name>rootPostingTree</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * We keep buffer pinned because we need to prevent deletion of
             * page during scan. See GIN's vacuum implementation. RefCount is
             * increased to keep buffer pinned after freeGinBtreeStack() call.
             */</comment>
            <expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Load the first page into memory.
             */</comment>
            <expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>GinDataLeafPageGetItems</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr></argument>, <argument><expr><name>minItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>predictNumberResult</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>predictNumber</name></name> <operator>*</operator> <name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>GinGetNPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>ginReadTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>predictNumberResult</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>needUnlock</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stackEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for scan entry indexes. Sorts by predictNumberResult,
 * least frequent items first.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>entryIndexByFrequencyCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>GinScanKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>GinScanKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>a1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>a2</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n1</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>i1</name></expr>]</index></name><operator>-&gt;</operator><name>predictNumberResult</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n2</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>i2</name></expr>]</index></name><operator>-&gt;</operator><name>predictNumberResult</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>n1</name> <operator>&lt;</operator> <name>n2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>n1</name> <operator>==</operator> <name>n2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>startScanKey</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>GinScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>GinScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>entryIndexes</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Divide the entries into two distinct sets: required and additional.
     * Additional entries are not enough for a match alone, without any items
     * from the required set, but are needed by the consistent function to
     * decide if an item matches. When scanning, we can skip over items from
     * additional entries that have no corresponding matches in any of the
     * required entries. That speeds up queries like "frequent &amp; rare"
     * considerably, if the frequent term can be put in the additional set.
     *
     * There can be many legal ways to divide them entries into these two
     * sets. A conservative division is to just put everything in the required
     * set, but the more you can put in the additional set, the more you can
     * skip during the scan. To maximize skipping, we try to put as many
     * frequent items as possible into additional, and less frequent ones into
     * required. To do that, sort the entries by frequency
     * (predictNumberResult), and put entries into the required set in that
     * order, until the consistent function says that none of the remaining
     * entries can form a match, without any items from the required set. The
     * rest go to the additional set.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>entryIndexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>entryIndexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>entryIndexes</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                  <argument><expr><name>entryIndexByFrequencyCmp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Pass all entries &lt;= i as FALSE, and the rest as MAYBE */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>GIN_FALSE</name></expr>;</expr_stmt></block_content></block></for>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>GIN_MAYBE</name></expr>;</expr_stmt></block_content></block></for>

            <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>-&gt;</operator><name>triConsistentFn</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIN_FALSE</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="block">/* i is now the last required entry. */</comment>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name> <operator>-</operator> <name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>additionalEntries</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>additionalEntries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

        <comment type="block">/* clean up after consistentFn calls (also frees entryIndexes) */</comment>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>startScan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinState</name>   <modifier>*</modifier></type><name>ginstate</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>startScanEntry</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>GinFuzzySearchLimit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If all of keys more than threshold we will try to reduce result, we
         * hope (and only hope, for intersection operation of array our
         * supposition isn't true), that total result will not more than
         * minimal predictNumberResult.
         */</comment>
        <decl_stmt><decl><type><name>bool</name></type>        <name>reduce</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>predictNumberResult</name> <operator>&lt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name> <operator>*</operator> <name>GinFuzzySearchLimit</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>reduce</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>reduce</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>predictNumberResult</name> <operator>/=</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>reduceResult</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now that we have the estimates for the entry frequencies, finish
     * initializing the scan keys.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>startScanKey</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Load the next batch of item pointers from a posting tree.
 *
 * Note that we copy the page into GinScanEntry-&gt;list array and unlock it, but
 * keep it pinned to prevent interference with vacuum.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>entryLoadMoreItems</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl></parameter>,
                   <parameter><decl><type><name>ItemPointerData</name></type> <name>advancePast</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>stepright</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We have two strategies for finding the correct page: step right from
     * the current page, or descend the tree again from the root. If
     * advancePast equals the current item, the next matching item should be
     * on the next page, so we step right. Otherwise, descend from root.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>stepright</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Set the search key, and find the correct leaf page.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>btree</name><operator>.</operator><name>itemptr</name></name></expr></argument>,
                           <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                           <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>btree</name><operator>.</operator><name>itemptr</name></name></expr></argument>,
                           <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>btree</name><operator>.</operator><name>fullScan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>ginFindLeafPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>btree</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* we don't need the stack, just the buffer. */</comment>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stepright</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"entryLoadMoreItems, %u/%u, skip: %d"</literal></expr></argument>,
         <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><operator>!</operator><name>stepright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>stepright</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We've processed all the entries on this page. If it was the
             * last page in the tree, we're done.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Step to next page, following the right link. then find the
             * first ItemPointer greater than advancePast.
             */</comment>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ginStepRight</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
                                         <argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
                                         <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>stepright</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>GIN_DELETED</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* page was deleted by concurrent vacuum */</comment>

        <comment type="block">/*
         * The first item &gt; advancePast might not be on this page, but
         * somewhere to the right, if the page was split, or a non-match from
         * another key in the query allowed us to skip some items from this
         * entry. Keep following the right-links until we re-find the correct
         * page.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>, <argument><expr><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * the item we're looking is &gt; the right bound of the page, so it
             * can't be on this page.
             */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>GinDataLeafPageGetItems</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr></argument>, <argument><expr><name>advancePast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* after processing the copied items, we're done. */</comment>
                    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gin_rand</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(((double) random()) / ((double) MAX_RANDOM_VALUE))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dropItem</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( gin_rand() &gt; ((double)GinFuzzySearchLimit)/((double)((e)-&gt;predictNumberResult)) )</cpp:value></cpp:define>

<comment type="block">/*
 * Sets entry-&gt;curItem to next heap item pointer &gt; advancePast, for one entry
 * of one scan key, or sets entry-&gt;isFinished to TRUE if there are no more.
 *
 * Item pointers are returned in ascending order.
 *
 * Note: this can return a "lossy page" item pointer, indicating that the
 * entry potentially matches all items on that heap page.  However, it is
 * not allowed to return both a lossy page pointer and exact (regular)
 * item pointers for the same page.  (Doing so would break the key-combination
 * logic in keyGetItem and scanGetItem; see comment in scanGetItem.)  In the
 * current implementation this is guaranteed by the behavior of tidbitmaps.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>entryGetItem</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl></parameter>,
             <parameter><decl><type><name>ItemPointerData</name></type> <name>advancePast</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
           <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* A bitmap result */</comment>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>advancePastBlk</name> <init>= <expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>advancePastOff</name> <init>= <expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>gotitem</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <comment type="block">/*
             * If we've exhausted all items on this block, move to next block
             * in the bitmap.
             */</comment>
            <while>while <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                   <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                    <name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;=</operator> <name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>ntuples</name></name><operator>)</operator> <operator>||</operator>
                   <name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>blockno</name></name> <operator>&lt;</operator> <name>advancePastBlk</name> <operator>||</operator>
                   <operator>(</operator><call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>blockno</name></name> <operator>==</operator> <name>advancePastBlk</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name></name> <operator>=</operator> <call><name>tbm_iterate</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchIterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Reset counter to the beginning of entry-&gt;matchResult. Note:
                 * entry-&gt;offset is still greater than matchResult-&gt;ntuples if
                 * matchResult is lossy.  So, on next call we will get next
                 * result from TIDBitmap.
                 */</comment>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We're now on the first page after advancePast which has any
             * items on it. If it's a lossy result, return that.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ItemPointerSetLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>,
                                        <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * We might as well fall out of the loop; we could not
                 * estimate number of results on this page to support correct
                 * reducing of result even if it's enabled.
                 */</comment>
                <expr_stmt><expr><name>gotitem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Not a lossy page. Skip over any offsets &lt;= advancePast, and
             * return that.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>blockno</name></name> <operator>==</operator> <name>advancePastBlk</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * First, do a quick check against the last offset on the
                 * page. If that's &gt; advancePast, so are all the other
                 * offsets.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <name>advancePastOff</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Otherwise scan to find the first item &gt; advancePast */</comment>
                <while>while <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr>]</index></name> <operator>&lt;=</operator> <name>advancePastOff</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>,
                           <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>,
                           <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>gotitem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><operator>!</operator><name>gotitem</name> <operator>||</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>reduceResult</name></name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <call><name>dropItem</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * A posting list from an entry tuple, or the last page of a posting
         * tree.
         */</comment>
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
        <comment type="block">/* XXX: shouldn't we apply the fuzzy search limit here? */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* A posting tree */</comment>
        <do>do
        <block>{<block_content>
            <comment type="block">/* If we've processed the current batch, load more items */</comment>
            <while>while <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>entryLoadMoreItems</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>advancePast</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

        </block_content>}</block> while <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
                 <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>reduceResult</name></name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator> <call><name>dropItem</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Identify the "current" item among the input entry streams for this scan key
 * that is greater than advancePast, and test whether it passes the scan key
 * qual condition.
 *
 * The current item is the smallest curItem among the inputs.  key-&gt;curItem
 * is set to that value.  key-&gt;curItemMatches is set to indicate whether that
 * TID passes the consistentFn test.  If so, key-&gt;recheckCurItem is set true
 * iff recheck is needed for this item pointer (including the case where the
 * item pointer is a lossy page pointer).
 *
 * If all entry streams are exhausted, sets key-&gt;isFinished to TRUE.
 *
 * Item pointers must be returned in ascending order.
 *
 * Note: this can return a "lossy page" item pointer, indicating that the
 * key potentially matches all items on that heap page.  However, it is
 * not allowed to return both a lossy page pointer and exact (regular)
 * item pointers for the same page.  (Doing so would break the key-combination
 * logic in scanGetItem.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>keyGetItem</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tempCtx</name></decl></parameter>, <parameter><decl><type><name>GinScanKey</name></type> <name>key</name></decl></parameter>,
           <parameter><decl><type><name>ItemPointerData</name></type> <name>advancePast</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>minItem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>curPageLossy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>haveLossyEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinTernaryValue</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>allFinished</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>isFinished</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We might have already tested this item; if so, no need to repeat work.
     * (Note: the "&gt;" case can happen, if advancePast is exact but we
     * previously had to set curItem to a lossy-page pointer.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Find the minimum item &gt; advancePast among the active entry streams.
     *
     * Note: a lossy-page entry is encoded by a ItemPointer with max value for
     * offset (0xffff), so that it will sort after any exact entries for the
     * same page.  So we'll prefer to return exact pointers not lossy
     * pointers, which is good.
     */</comment>
    <expr_stmt><expr><call><name>ItemPointerSetMax</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>allFinished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Advance this stream if necessary.
         *
         * In particular, since entry-&gt;curItem was initialized with
         * ItemPointerSetMin, this ensures we fetch the first item for each
         * entry on the first call.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>entryGetItem</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>advancePast</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>allFinished</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>minItem</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>allFinished</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* all entries are finished */</comment>
        <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Ok, we now know that there are no matches &lt; minItem.
     *
     * If minItem is lossy, it means that there were no exact items on the
     * page among requiredEntries, because lossy pointers sort after exact
     * items. However, there might be exact items for the same page among
     * additionalEntries, so we mustn't advance past them.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
            <call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>,
                           <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>,
                       <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We might not have loaded all the entry streams for this TID yet. We
     * could call the consistent function, passing MAYBE for those entries, to
     * see if it can decide if this TID matches based on the information we
     * have. But if the consistent-function is expensive, and cannot in fact
     * decide with partial information, that could be a big loss. So, load all
     * the additional entries, before calling the consistent function.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>additionalEntries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>entryGetItem</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>advancePast</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Normally, none of the items in additionalEntries can have a curItem
         * larger than minItem. But if minItem is a lossy page, then there
         * might be exact items on the same page among additionalEntries.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>minItem</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Ok, we've advanced all the entries up to minItem now. Set key-&gt;curItem,
     * and perform consistentFn test.
     *
     * Lossy-page entries pose a problem, since we don't know the correct
     * entryRes state to pass to the consistentFn, and we also don't know what
     * its combining logic will be (could be AND, OR, or even NOT). If the
     * logic is OR then the consistentFn might succeed for all items in the
     * lossy page even when none of the other entries match.
     *
     * Our strategy is to call the tri-state consistent function, with the
     * lossy-page entries set to MAYBE, and all the other entries FALSE. If it
     * returns FALSE, none of the lossy items alone are enough for a match, so
     * we don't need to return a lossy-page pointer. Otherwise, return a
     * lossy-page pointer to indicate that the whole heap page must be
     * checked.  (On subsequent calls, we'll do nothing until minItem is past
     * the page altogether, thus ensuring that we never return both regular
     * and lossy pointers for the same page.)
     *
     * An exception is that it doesn't matter what we pass for lossy pointers
     * in "hidden" entries, because the consistentFn's result can't depend on
     * them. We could pass them as MAYBE as well, but if we're using the
     * "shim" implementation of a tri-state consistent function (see
     * ginlogic.c), it's better to pass as few MAYBEs as possible. So pass
     * them as TRUE.
     *
     * Note that only lossy-page entries pointing to the current item's page
     * should trigger this processing; we might have future lossy pages in the
     * entry array, but they aren't relevant yet.
     */</comment>
    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name> <operator>=</operator> <name>minItem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curPageLossy</name></expr></argument>,
                            <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>haveLossyEntry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>
            <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curPageLossy</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nuserentries</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GIN_MAYBE</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GIN_TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name>haveLossyEntry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GIN_FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* prepare for calling consistentFn in temp context */</comment>
    <expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tempCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>haveLossyEntry</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Have lossy-page entries, so see if whole page matches */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>key</name><operator>-&gt;</operator><name>triConsistentFn</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>GIN_TRUE</name> <operator>||</operator> <name>res</name> <operator>==</operator> <name>GIN_MAYBE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Yes, so clean up ... */</comment>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tempCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* and return lossy pointer for whole page */</comment>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name> <operator>=</operator> <name>curPageLossy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * At this point we know that we don't need to return a lossy whole-page
     * pointer, but we might have matches for individual exact item pointers,
     * possibly in combination with a lossy pointer. Pass lossy pointers as
     * MAYBE to the ternary consistent function, to let it decide if this
     * tuple satisfies the overall key, even though we don't know if the lossy
     * entries match.
     *
     * Prepare entryRes array to be passed to consistentFn.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GIN_FALSE</name></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

        <comment type="block">/*
         * This case can't currently happen, because we loaded all the entries
         * for this item earlier.
         */</comment>
        else if (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) &lt;= 0)
            key-&gt;entryRes[i] = GIN_MAYBE;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if type="elseif">else if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curPageLossy</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GIN_MAYBE</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minItem</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GIN_TRUE</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>GIN_FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>key</name><operator>-&gt;</operator><name>triConsistentFn</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>res</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GIN_TRUE</name></expr>:</case>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <comment type="block">/* triConsistentFn set recheckCurItem */</comment>
            <break>break;</break>

        <case>case <expr><name>GIN_FALSE</name></expr>:</case>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>GIN_MAYBE</name></expr>:</case>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>

            <comment type="block">/*
             * the 'default' case shouldn't happen, but if the consistent
             * function returns something bogus, this is the safe result
             */</comment>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * We have a tuple, and we know if it matches or not. If it's a non-match,
     * we could continue to find the next matching tuple, but let's break out
     * and give scanGetItem a chance to advance the other keys. They might be
     * able to skip past to a much higher TID, allowing us to save work.
     */</comment>

    <comment type="block">/* clean up after consistentFn calls */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tempCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get next heap item pointer (after advancePast) from scan.
 * Returns true if anything found.
 * On success, *item and *recheck are set.
 *
 * Note: this is very nearly the same logic as in keyGetItem(), except
 * that we know the keys are to be combined with AND logic, whereas in
 * keyGetItem() the combination logic is known only to the consistentFn.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>scanGetItem</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name></type> <name>advancePast</name></decl></parameter>,
            <parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>match</name></decl>;</decl_stmt>

    <comment type="block">/*----------
     * Advance the scan keys in lock-step, until we find an item that matches
     * all the keys. If any key reports isFinished, meaning its subset of the
     * entries is exhausted, we can stop.  Otherwise, set *item to the next
     * matching item.
     *
     * This logic works only if a keyGetItem stream can never contain both
     * exact and lossy pointers for the same page.  Else we could have a
     * case like
     *
     *        stream 1        stream 2
     *        ...             ...
     *        42/6            42/7
     *        50/1            42/0xffff
     *        ...             ...
     *
     * We would conclude that 42/6 is not a match and advance stream 1,
     * thus never detecting the match to the lossy pointer in stream 2.
     * (keyGetItem has a similar problem versus entryGetItem.)
     *----------
     */</comment>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>&amp;&amp;</operator> <name>match</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>GinScanKey</name></type>    <name>key</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Fetch the next item for this key that is &gt; advancePast. */</comment>
            <expr_stmt><expr><call><name>keyGetItem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>advancePast</name></expr></argument>,
                       <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If it's not a match, we can immediately conclude that nothing
             * &lt;= this item matches, without checking the rest of the keys.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>advancePast</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * It's a match. We can conclude that nothing &lt; matches, so the
             * other key streams can skip to this item.
             *
             * Beware of lossy pointers, though; from a lossy pointer, we can
             * only conclude that nothing smaller than this *block* matches.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
                    <call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>,
                                   <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>,
                               <argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * If this is the first key, remember this location as a potential
             * match, and proceed to check the rest of the keys.
             *
             * Otherwise, check if this is the same item that we checked the
             * previous keys for (or a lossy pointer for the same page). If
             * not, loop back to check the previous keys for this item (we
             * will check this key again too, but keyGetItem returns quickly
             * for that)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>item</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <operator>(</operator><call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
                             <call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>match</name> <operator>=</operator> <operator>(</operator><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerIsMin</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now *item contains the first ItemPointer after previous result that
     * satisfied all the keys for that exact TID, or a lossy reference to the
     * same page.
     *
     * We must return recheck = true if any of the keys are marked recheck.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GinScanKey</name></type>    <name>key</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Functions for scanning the pending list
 */</comment>


<comment type="block">/*
 * Get ItemPointer of next heap row to be checked from pending list.
 * Returns false if there are no more. On pages with several heap rows
 * it returns each row separately, on page with part of heap row returns
 * per page data.  pos-&gt;firstOffset and pos-&gt;lastOffset are set to identify
 * the range of pending-list tuples belonging to this heap row.
 *
 * The pendingBuffer is presumed pinned and share-locked on entry, and is
 * pinned and share-locked on success exit.  On failure exit it's released.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>scanGetCandidate</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>pendingPosition</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pos</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>pendingBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name> <operator>&gt;</operator> <name>maxoff</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>pendingBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>pendingBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Here we must prevent deletion of next page by insertcleanup
                 * process, which may be trying to obtain exclusive lock on
                 * current page.  So, we lock next page before releasing the
                 * current one
                 */</comment>
                <decl_stmt><decl><type><name>Buffer</name></type>        <name>tmpbuf</name> <init>= <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>pendingBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>pendingBuffer</name></name> <operator>=</operator> <name>tmpbuf</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>GinPageHasFullRow</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * find itempointer to the next row
                 */</comment>
                <for>for <control>(<init><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pos</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * All itempointers are the same on this page
                 */</comment>
                <expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name> <operator>=</operator> <name>maxoff</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Now pos-&gt;firstOffset points to the first tuple of current heap
             * row, pos-&gt;lastOffset points to the first tuple of next heap row
             * (or to the end of page)
             */</comment>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan pending-list page from current tuple (off) up till the first of:
 * - match is found (then returns true)
 * - no later match is possible
 * - tuple's attribute number is not equal to entry's attrnum
 * - reach end of page
 *
 * datum[]/category[]/datumExtracted[] arrays are used to cache the results
 * of gintuple_get_key() on the current page.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>matchPartialInPendingList</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
                          <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl></parameter>,
                          <parameter><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl></parameter>,
                          <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name> <modifier>*</modifier></type><name>category</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>datumExtracted</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>cmp</name></decl>;</decl_stmt>

    <comment type="block">/* Partial match to a null is not possible */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>queryCategory</name></name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <name>maxoff</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>attnum</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>datumExtracted</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>datum</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name><name>category</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>datumExtracted</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Once we hit nulls, no further match is possible */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>category</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/*----------
         * Check partial match.
         * case cmp == 0 =&gt; match
         * case cmp &gt; 0 =&gt; not match and end scan (no later match possible)
         * case cmp &lt; 0 =&gt; not match and continue scan
         *----------
         */</comment>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ginstate</name><operator>-&gt;</operator><name>comparePartialFn</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>,
                                              <argument><expr><name><name>datum</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                              <argument><expr><call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>extra_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the entryRes array for each key by looking at
 * every entry for current heap row in pending list.
 *
 * Returns true if each scan key has at least one entryRes match.
 * This corresponds to the situations where the normal index search will
 * try to apply the key's consistentFn.  (A tuple not meeting that requirement
 * cannot be returned by the normal search since no entry stream will
 * source its TID.)
 *
 * The pendingBuffer is presumed pinned and share-locked on entry.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>collectMatchesForHeapRow</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>pendingPosition</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attrnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Reset all entryRes and hasMatchKey flags
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GinScanKey</name></type>    <name>key</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name></name></expr></argument>, <argument><expr><name>GIN_FALSE</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>hasMatchKey</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Outer loop iterates over multiple pending-list pages when a single heap
     * row has entries spanning those pages.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>datum</name><index>[<expr><name>BLCKSZ</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GinNullCategory</name></type> <name><name>category</name><index>[<expr><name>BLCKSZ</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>datumExtracted</name><index>[<expr><name>BLCKSZ</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name> <operator>&gt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>datumExtracted</name> <operator>+</operator> <name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name> <operator>-</operator> <name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>pendingBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>GinScanKey</name></type>    <name>key</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GinScanEntry</name></type> <name>entry</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>StopLow</name> <init>= <expr><name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name></expr></init></decl>,
                            <decl><type ref="prev"/><name>StopHigh</name> <init>= <expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name></expr></init></decl>,
                            <decl><type ref="prev"/><name>StopMiddle</name></decl>;</decl_stmt>

                <comment type="block">/* If already matched on earlier page, do no extra work */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Interesting tuples are from pos-&gt;firstOffset to
                 * pos-&gt;lastOffset and they are ordered by (attnum, Datum) as
                 * it's done in entry tree.  So we can use binary search to
                 * avoid linear scanning.
                 */</comment>
                <while>while <condition>(<expr><name>StopLow</name> <operator>&lt;</operator> <name>StopHigh</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>res</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>StopMiddle</name> <operator>=</operator> <name>StopLow</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>StopHigh</name> <operator>-</operator> <name>StopLow</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>StopMiddle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>attrnum</name> <operator>=</operator> <call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;</operator> <name>attrnum</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name>StopMiddle</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&gt;</operator> <name>attrnum</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name>StopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>datumExtracted</name><index>[<expr><name>StopMiddle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>datum</name><index>[<expr><name>StopMiddle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
                            <call><name>gintuple_get_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name><name>category</name><index>[<expr><name>StopMiddle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>datumExtracted</name><index>[<expr><name>StopMiddle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>queryCategory</name></name> <operator>==</operator> <name>GIN_CAT_EMPTY_QUERY</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* special behavior depending on searchMode */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>searchMode</name></name> <operator>==</operator> <name>GIN_SEARCH_MODE_ALL</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* match anything except NULL_ITEM */</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>category</name><index>[<expr><name>StopMiddle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>GIN_CAT_NULL_ITEM</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* match everything */</comment>
                            <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ginCompareEntries</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>,
                                                <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
                                                <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>,
                                                <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryCategory</name></name></expr></argument>,
                                                <argument><expr><name><name>datum</name><index>[<expr><name>StopMiddle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                                <argument><expr><name><name>category</name><index>[<expr><name>StopMiddle</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Found exact match (there can be only one, except in
                         * EMPTY_QUERY mode).
                         *
                         * If doing partial match, scan forward from here to
                         * end of page to check for matches.
                         *
                         * See comment above about tuple's ordering.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isPartialMatch</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
                                <call><name>matchPartialInPendingList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>,
                                                          <argument><expr><name>page</name></expr></argument>,
                                                          <argument><expr><name>StopMiddle</name></expr></argument>,
                                                          <argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name></expr></argument>,
                                                          <argument><expr><name>entry</name></expr></argument>,
                                                          <argument><expr><name>datum</name></expr></argument>,
                                                          <argument><expr><name>category</name></expr></argument>,
                                                          <argument><expr><name>datumExtracted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                        <comment type="block">/* done with binary search */</comment>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>StopHigh</name> <operator>=</operator> <name>StopMiddle</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>StopLow</name> <operator>=</operator> <name>StopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></while>

                <if_stmt><if>if <condition>(<expr><name>StopLow</name> <operator>&gt;=</operator> <name>StopHigh</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>isPartialMatch</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * No exact match on this page.  If doing partial match,
                     * scan from the first tuple greater than target value to
                     * end of page.  Note that since we don't remember whether
                     * the comparePartialFn told us to stop early on a
                     * previous page, we will uselessly apply comparePartialFn
                     * to the first tuple on each subsequent page.
                     */</comment>
                    <expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
                        <call><name>matchPartialInPendingList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>,
                                                  <argument><expr><name>page</name></expr></argument>,
                                                  <argument><expr><name>StopHigh</name></expr></argument>,
                                                  <argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name></expr></argument>,
                                                  <argument><expr><name>entry</name></expr></argument>,
                                                  <argument><expr><name>datum</name></expr></argument>,
                                                  <argument><expr><name>category</name></expr></argument>,
                                                  <argument><expr><name>datumExtracted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>hasMatchKey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="block">/* Advance firstOffset over the scanned tuples */</comment>
        <expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>firstOffset</name></name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>lastOffset</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GinPageHasFullRow</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We have examined all pending entries for the current heap row.
             * Break out of loop over pages.
             */</comment>
            <break>break;</break>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Advance to next page of pending entries for the current heap
             * row.  Complain if there isn't one.
             */</comment>
            <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>item</name> <init>= <expr><name><name>pos</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>scanGetCandidate</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name> <operator>||</operator>
                <operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pos</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find additional pending pages for same heap tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Now return "true" if all scan keys have at least one matching datum
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>hasMatchKey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Collect all matched rows from pending list into bitmap
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>scanPendingInsert</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>ntids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>recheck</name></decl>,
                <decl><type ref="prev"/><name>match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pendingPosition</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>metabuffer</name> <init>= <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>GIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>ntids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>GinPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name></expr>;</expr_stmt>

    <comment type="block">/*
     * fetch head of list before unlocking metapage. head page must be pinned
     * to prevent deletion by vacuum process
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* No pending list, so proceed with normal scan */</comment>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pos</name><operator>.</operator><name>pendingBuffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>pos</name><operator>.</operator><name>pendingBuffer</name></name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pos</name><operator>.</operator><name>firstOffset</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pos</name><operator>.</operator><name>hasMatchKey</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * loop for each heap row. scanGetCandidate returns full row or row's
     * tuples from first page.
     */</comment>
    <while>while <condition>(<expr><call><name>scanGetCandidate</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Check entries in tuple and set up entryRes array.
         *
         * If pending tuples belonging to the current heap row are spread
         * across several pages, collectMatchesForHeapRow will read all of
         * those pages.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>collectMatchesForHeapRow</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Matching of entries of one row is finished, so check row using
         * consistent functions.
         */</comment>
        <expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>GinScanKey</name></type>    <name>key</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>-&gt;</operator><name>boolConsistentFn</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>recheck</name> <operator>|=</operator> <name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pos</name><operator>.</operator><name>item</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ntids</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pos</name><operator>.</operator><name>hasMatchKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GinIsVoidRes</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>( ((GinScanOpaque) scan-&gt;opaque)-&gt;isVoidRes )</cpp:value></cpp:define>

<function><type><name>int64</name></type>
<name>gingetbitmap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>ntids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>iptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>recheck</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Set up the scan keys, and check for unsatisfiable query.
     */</comment>
    <expr_stmt><expr><call><name>ginFreeScanKeys</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* there should be no keys yet, but just to be
                                 * sure */</comment>
    <expr_stmt><expr><call><name>ginNewScanKey</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>GinIsVoidRes</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ntids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * First, scan the pending list and collect any matching entries into the
     * bitmap.  After we scan a pending item, some other backend could post it
     * into the main index, and so we might visit it a second time during the
     * main scan.  This is okay because we'll just re-set the same bit in the
     * bitmap.  (The possibility of duplicate visits is a major reason why GIN
     * can't support the amgettuple API, however.) Note that it would not do
     * to scan the main index before the pending list, since concurrent
     * cleanup could then make us miss entries entirely.
     */</comment>
    <expr_stmt><expr><call><name>scanPendingInsert</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>tbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now scan the main index.
     */</comment>
    <expr_stmt><expr><call><name>startScan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanGetItem</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>iptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsLossyPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>tbm_add_page</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>ntids</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>ntids</name></expr>;</return>
</block_content>}</block></function>
</unit>
