<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/gist/gistutil.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gistutil.c
 *      utilities routines for the postgres GiST index access method.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *            src/backend/access/gist/gistutil.c
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Write itup vector to page, has no control of free space.
 */</comment>
<function><type><name>void</name></type>
<name>gistfillbuffer</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>l</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>off</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>FirstOffsetNumber</name></expr> </then><else>:
            <expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Size</name></type>        <name>sz</name> <init>= <expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>itup</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>itup</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to GiST index page, item %d out of %d, size %d bytes"</literal></expr></argument>,
                 <argument><expr><name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check space for itup vector on page
 */</comment>
<function><type><name>bool</name></type>
<name>gistnospace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>todelete</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><name>freespace</name></expr></init></decl>,
                <decl><type ref="prev"/><name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>itvec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>todelete</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>todelete</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><operator>(</operator><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>deleted</name> <operator>&lt;</operator> <name>size</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>gistfitpage</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>itvec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* TODO: Consider fillfactor */</comment>
    <return>return <expr><operator>(</operator><name>size</name> <operator>&lt;=</operator> <name>GiSTPageSize</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read buffer into itup vector
 */</comment>
<function><type><name>IndexTuple</name> <modifier>*</modifier></type>
<name>gistextractpage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter> <comment type="block">/* out */</comment> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>maxoff</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>itvec</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>itvec</name><index>[<expr><name>i</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>itvec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * join two vectors into one
 */</comment>
<function><type><name>IndexTuple</name> <modifier>*</modifier></type>
<name>gistjoinvector</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>additvec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>itvec</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>itvec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>len</name><operator>)</operator> <operator>+</operator> <name>addlen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itvec</name><index>[<expr><operator>*</operator><name>len</name></expr>]</index></name></expr></argument>, <argument><expr><name>additvec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>addlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>+=</operator> <name>addlen</name></expr>;</expr_stmt>
    <return>return <expr><name>itvec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make plain IndexTupleVector
 */</comment>

<function><type><name>IndexTupleData</name> <modifier>*</modifier></type>
<name>gistfillitupvec</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>veclen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>memlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>memlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>veclen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>memlen</name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>ret</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>memlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>veclen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>(</operator><name>IndexTupleData</name> <operator>*</operator><operator>)</operator> <name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make unions of keys in IndexTuple vector (one union datum per index column).
 * Union Datums are returned into the attr/isnull arrays.
 * Resulting Datums aren't compressed.
 */</comment>
<function><type><name>void</name></type>
<name>gistMakeUnionItVec</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
                   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>evec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attrsize</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>evec</name> <operator>=</operator> <operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>GEVHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

        <comment type="block">/* Collect non-null datums for this column */</comment>
        <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>IsNull</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name><name>itvec</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>IsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>IsNull</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>gistdentryinit</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                           <argument><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name></name> <operator>+</operator> <name><name>evec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>,
                           <argument><expr><name>datum</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>IsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* If this column was all NULLs, the union is NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* unionFn may expect at least two inputs */</comment>
                <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Make union and store in attr array */</comment>
            <expr_stmt><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>unionFn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>evec</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attrsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Return an IndexTuple containing the result of applying the "union"
 * method to the specified IndexTuple vector.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>gistunion</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>attr</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gistMakeUnionItVec</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>itvec</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>gistFormTuple</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makes union of two key
 */</comment>
<function><type><name>void</name></type>
<name>gistMakeUnionKey</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>,
                 <parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>entry1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull1</name></decl></parameter>,
                 <parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>entry2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull2</name></decl></parameter>,
                 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>dstisnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* we need a GistEntryVector with room for exactly 2 elements */</comment>
    <union>union
    <block>{
        <decl_stmt><decl><type><name>GistEntryVector</name></type> <name>gev</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>padding</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>GEVHDRSZ</name></expr>]</index></name></decl>;</decl_stmt>
    }</block>            <decl><name>storage</name></decl>;</union>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>evec</name> <init>= <expr><operator>&amp;</operator><name><name>storage</name><operator>.</operator><name>gev</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dstsize</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isnull1</name> <operator>&amp;&amp;</operator> <name>isnull2</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>dstisnull</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>isnull1</name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator> <name>isnull2</name> <operator>==</operator> <name>FALSE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>entry1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>entry2</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>isnull1</name> <operator>==</operator> <name>FALSE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>entry1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>entry1</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>entry2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>entry2</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>dstisnull</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>unionFn</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                                 <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                                 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>evec</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dstsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>gistKeyIsEQ</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FunctionCall3Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>equalFn</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decompress all keys in tuple
 */</comment>
<function><type><name>void</name></type>
<name>gistDeCompressAtt</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>,
                  <parameter><decl><type><name>OffsetNumber</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>attdata</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistdentryinit</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attdata</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                       <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>o</name></expr></argument>,
                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Forms union of oldtup and addtup, if union == oldtup then return NULL
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>gistgetadjusted</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>oldtup</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>addtup</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>neednew</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name><name>oldentries</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>,
                <decl><type ref="prev"/><name><name>addentries</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>oldisnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>,
                <decl><type ref="prev"/><name><name>addisnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>attr</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>newtup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gistDeCompressAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                      <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>oldentries</name></expr></argument>, <argument><expr><name>oldisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>gistDeCompressAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>addtup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                      <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>addentries</name></expr></argument>, <argument><expr><name>addisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>gistMakeUnionKey</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                         <argument><expr><name>oldentries</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>oldisnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                         <argument><expr><name>addentries</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>addisnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                         <argument><expr><name>attr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>isnull</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>neednew</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* we already need new key, so we can skip check */</comment>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* union of key may be NULL if and only if both keys are NULL */</comment>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>addisnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>oldisnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
                <operator>!</operator><call><name>gistKeyIsEQ</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>oldentries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>, <argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>neednew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>neednew</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* need to update key */</comment>
        <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>gistFormTuple</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <name><name>oldtup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>newtup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search an upper index page for the entry with lowest penalty for insertion
 * of the new index key contained in "it".
 *
 * Returns the index of the page entry to insert into.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>gistchoose</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>it</name></decl></parameter>,    <comment type="block">/* it has compressed entry */</comment>
           <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type>        <name><name>best_penalty</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name>entry</name></decl>,
                <decl><type ref="prev"/><name><name>identry</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>keep_current_best</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>gistDeCompressAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
                      <argument><expr><name>it</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                      <argument><expr><name>identry</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we'll return FirstOffsetNumber if page is empty (shouldn't happen) */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The index may have multiple columns, and there's a penalty value for
     * each column.  The penalty associated with a column that appears earlier
     * in the index definition is strictly more important than the penalty of
     * a column that appears later in the index definition.
     *
     * best_penalty[j] is the best penalty we have seen so far for column j,
     * or -1 when we haven't yet examined column j.  Array entries to the
     * right of the first -1 are undefined.
     */</comment>
    <expr_stmt><expr><name><name>best_penalty</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * If we find a tuple that's exactly as good as the currently best one, we
     * could use either one.  When inserting a lot of tuples with the same or
     * similar keys, it's preferable to descend down the same path when
     * possible, as that's more cache-friendly.  On the other hand, if all
     * inserts land on the same leaf page after a split, we're never going to
     * insert anything to the other half of the split, and will end up using
     * only 50% of the available space.  Distributing the inserts evenly would
     * lead to better space usage, but that hurts cache-locality during
     * insertion.  To get the best of both worlds, when we find a tuple that's
     * exactly as good as the previous best, choose randomly whether to stick
     * to the old best, or use the new one.  Once we decide to stick to the
     * old best, we keep sticking to it for any subsequent equally good tuples
     * we might find.  This favors tuples with low offsets, but still allows
     * some inserts to go to other equally-good subtrees.
     *
     * keep_current_best is -1 if we haven't yet had to make a random choice
     * whether to keep the current best tuple.  If we have done so, and
     * decided to keep it, keep_current_best is 1; if we've decided to
     * replace, keep_current_best is 0.  (This state will be reset to -1 as
     * soon as we've made the replacement, but sometimes we make the choice in
     * advance of actually finding a replacement best tuple.)
     */</comment>
    <expr_stmt><expr><name>keep_current_best</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop over tuples on page.
     */</comment>
    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxoff</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>zero_penalty</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>zero_penalty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* Loop over index attributes. */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type>        <name>usize</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>IsNull</name></decl>;</decl_stmt>

            <comment type="block">/* Compute penalty for this column. */</comment>
            <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>IsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>gistdentryinit</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>IsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>IsNull</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name><name>identry</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>zero_penalty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>usize</name> <operator>&lt;</operator> <name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * New best penalty for column.  Tentatively select this tuple
                 * as the target, and record the best penalty.  Then reset the
                 * next column's penalty to "unknown" (and indirectly, the
                 * same for all the ones to its right).  This will force us to
                 * adopt this tuple's penalty values as the best for all the
                 * remaining columns during subsequent loop iterations.
                 */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>usize</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>best_penalty</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/* we have new best, so reset keep-it decision */</comment>
                <expr_stmt><expr><name>keep_current_best</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>usize</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * The current tuple is exactly as good for this column as the
                 * best tuple seen so far.  The next iteration of this loop
                 * will compare the next column.
                 */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * The current tuple is worse for this column than the best
                 * tuple seen so far.  Skip the remaining columns and move on
                 * to the next tuple, if any.
                 */</comment>
                <expr_stmt><expr><name>zero_penalty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* so outer loop won't exit */</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * If we looped past the last column, and did not update "result",
         * then this tuple is exactly as good as the prior best tuple.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <name>i</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>keep_current_best</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* we didn't make the random choice yet for this old best */</comment>
                <expr_stmt><expr><name>keep_current_best</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>random</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>MAX_RANDOM_VALUE</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>keep_current_best</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* we choose to use the new tuple */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <comment type="block">/* choose again if there are even more exactly-as-good ones */</comment>
                <expr_stmt><expr><name>keep_current_best</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we find a tuple with zero penalty for all columns, and we've
         * decided we don't want to search for another tuple with equal
         * penalty, there's no need to examine remaining tuples; just break
         * out of the loop and return it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>zero_penalty</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>keep_current_best</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* we didn't make the random choice yet for this old best */</comment>
                <expr_stmt><expr><name>keep_current_best</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>random</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>MAX_RANDOM_VALUE</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>keep_current_best</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * initialize a GiST entry with a decompressed version of key
 */</comment>
<function><type><name>void</name></type>
<name>gistdentryinit</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkey</name></decl></parameter>, <parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>e</name></decl></parameter>,
               <parameter><decl><type><name>Datum</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>o</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>dep</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>e</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dep</name> <operator>=</operator> <operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator>
            <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>decompressFn</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* decompressFn may just return the given pointer */</comment>
        <if_stmt><if>if <condition>(<expr><name>dep</name> <operator>!=</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>e</name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,
                          <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>leafkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>e</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>IndexTuple</name></type>
<name>gistFormTuple</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>,
              <parameter><decl><type><name>Datum</name></type> <name><name>attdata</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name><name>isnull</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isleaf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>compatt</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>res</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Call the compress method on each attribute.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>compatt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name>centry</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>cep</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>centry</name></expr></argument>, <argument><expr><name><name>attdata</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                          <argument><expr><name>isleaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cep</name> <operator>=</operator> <operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator>
                <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>compressFn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                  <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>centry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>compatt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cep</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>compatt</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The offset number on tuples on internal pages is unused. For historical
     * reasons, it is set to 0xffff.
     */</comment>
    <expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0xffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * initialize a GiST entry with fetched value in key field
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>gistFetchAtt</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkey</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name>fentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>fep</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>fentry</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fep</name> <operator>=</operator> <operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator>
        <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>fetchFn</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
                                          <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
                                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fentry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* fetchFn set 'key', return it to the caller */</comment>
    <return>return <expr><name><name>fep</name><operator>-&gt;</operator><name>key</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch all keys in tuple.
 * Returns a new HeapTuple containing the originally-indexed data.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>gistFetchTuple</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>fetchatt</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>giststate</name><operator>-&gt;</operator><name>fetchFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>fetchatt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>gistFetchAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>fetchatt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Index-only scans not supported for this column. Since the
             * planner chose an index-only scan anyway, it is not interested
             * in this column, and we can replace it with a NULL.
             */</comment>
            <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fetchatt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>fetchTupdesc</name></name></expr></argument>, <argument><expr><name>fetchatt</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>float</name></type>
<name>gistpenalty</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>,
            <parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNullOrig</name></decl></parameter>,
            <parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>add</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNullAdd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>float</name></type>        <name>penalty</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>giststate</name><operator>-&gt;</operator><name>penaltyFn</name><index>[<expr><name>attno</name></expr>]</index></name><operator>.</operator><name>fn_strict</name> <operator>==</operator> <name>FALSE</name> <operator>||</operator>
        <operator>(</operator><name>isNullOrig</name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator> <name>isNullAdd</name> <operator>==</operator> <name>FALSE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FunctionCall3Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>penaltyFn</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                          <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>add</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>penalty</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* disallow negative or NaN penalty */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>penalty</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>penalty</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>isNullOrig</name> <operator>&amp;&amp;</operator> <name>isNullAdd</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* try to prevent mixing null and non-null values */</comment>
        <expr_stmt><expr><name>penalty</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>penalty</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a new index page
 */</comment>
<function><type><name>void</name></type>
<name>GISTInitBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>pageSize</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pageSize</name> <operator>=</operator> <call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* page was already zeroed by PageInit, so this is not needed: */</comment>
    <comment type="block">/* memset(&amp;(opaque-&gt;nsn), 0, sizeof(GistNSN)); */</comment>
    <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>rightlink</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>gist_page_id</name></name> <operator>=</operator> <name>GIST_PAGE_ID</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that a freshly-read page looks sane.
 */</comment>
<function><type><name>void</name></type>
<name>gistcheckpage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * ReadBuffer verifies that every newly-read page passes
     * PageHeaderIsValid, which means it either contains a reasonably sane
     * page header or is all-zero.  We have to defend against the all-zero
     * case, however.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains unexpected zero page at block %u"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Additionally check that the special area looks sane.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PageGetSpecialSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains corrupted page at block %u"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Allocate a new page (either by recycling, or by extending the index file)
 *
 * The returned buffer is already pinned and exclusive-locked
 *
 * Caller is responsible for initializing the page by calling GISTInitBuffer
 */</comment>
<function><type><name>Buffer</name></type>
<name>gistNewBuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>needLock</name></decl>;</decl_stmt>

    <comment type="block">/* First, try to get a page from FSM */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>GetFreeIndexPage</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* nothing left in FSM */</comment>

        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We have to guard against the possibility that someone else already
         * recycled this page; the buffer may be locked if so.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>buffer</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* OK to use, if never initialized */</comment>

            <expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>GistPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>buffer</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* OK to use */</comment>

            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Can't use it, so release buffer and try again */</comment>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Must extend the file */</comment>
    <expr_stmt><expr><name>needLock</name> <operator>=</operator> <operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>gistoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GiSTOptions</name> <modifier>*</modifier></type><name>rdopts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numoptions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>relopt_parse_elt</name></type> <name><name>tab</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{<expr><literal type="string">"fillfactor"</literal></expr>, <expr><name>RELOPT_TYPE_INT</name></expr>, <macro><name>offsetof</name><argument_list>(<argument>GiSTOptions</argument>, <argument>fillfactor</argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><literal type="string">"buffering"</literal></expr>, <expr><name>RELOPT_TYPE_STRING</name></expr>, <macro><name>offsetof</name><argument_list>(<argument>GiSTOptions</argument>, <argument>bufferingModeOffset</argument>)</argument_list></macro>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>parseRelOptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_GIST</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>numoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if none set, we're done */</comment>
    <if_stmt><if>if <condition>(<expr><name>numoptions</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rdopts</name> <operator>=</operator> <call><name>allocateReloptStruct</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GiSTOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>numoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fillRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rdopts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GiSTOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>numoptions</name></expr></argument>,
                   <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <name>rdopts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    gistproperty() -- Check boolean properties of indexes.
 *
 * This is optional for most AMs, but is required for GiST because the core
 * property code doesn't support AMPROP_DISTANCE_ORDERABLE.  We also handle
 * AMPROP_RETURNABLE here to save opening the rel to call gistcanreturn.
 */</comment>
<function><type><name>bool</name></type>
<name>gistproperty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>,
             <parameter><decl><type><name>IndexAMProperty</name></type> <name>prop</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>propname</name></decl></parameter>,
             <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_index</name> <name>rd_index</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>rd_opclass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>disnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>opclass</name></decl>,
                <decl><type ref="prev"/><name>opfamily</name></decl>,
                <decl><type ref="prev"/><name>opcintype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>procno</name></decl>;</decl_stmt>

    <comment type="block">/* Only answer column-level inquiries */</comment>
    <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Currently, GiST distance-ordered scans require that there be a distance
     * function in the opclass with the default types (i.e. the one loaded
     * into the relcache entry, see initGISTstate).  So we assume that if such
     * a function exists, then there's a reason for it (rather than grubbing
     * through all the opfamily's operators to find an ordered one).
     *
     * Essentially the same code can test whether we support returning the
     * column data, since that's true if the opclass provides a fetch proc.
     */</comment>

    <switch>switch <condition>(<expr><name>prop</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>AMPROP_DISTANCE_ORDERABLE</name></expr>:</case>
            <expr_stmt><expr><name>procno</name> <operator>=</operator> <name>GIST_DISTANCE_PROC</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AMPROP_RETURNABLE</name></expr>:</case>
            <expr_stmt><expr><name>procno</name> <operator>=</operator> <name>GIST_FETCH_PROC</name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></switch>

    <comment type="block">/* First we need to know the column's opclass. */</comment>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rd_index</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* caller is supposed to guarantee this */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attno</name> <operator>&lt;=</operator> <name><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                            <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>disnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>disnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>opclass</name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now look up the opclass family and input datatype. */</comment>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rd_opclass</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>rd_opclass</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>opcintype</name> <operator>=</operator> <name><name>rd_opclass</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And now we can check whether the function is provided. */</comment>

    <expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <call><name>SearchSysCacheExists4</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>procno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Temporary and unlogged GiST indexes are not WAL-logged, but we need LSNs
 * to detect concurrent page splits anyway. This function provides a fake
 * sequence of LSNs for that purpose.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>gistGetFakeLSN</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>counter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Temporary relations are only accessible in our session, so a simple
         * backend-local counter will do.
         */</comment>
        <return>return <expr><name>counter</name><operator>++</operator></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Unlogged relations are accessible from other backends, and survive
         * (clean) restarts. GetFakeLSNForUnloggedRel() handles that for us.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>GetFakeLSNForUnloggedRel</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
