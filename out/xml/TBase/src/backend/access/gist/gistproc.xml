<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/gist/gistproc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gistproc.c
 *      Support procedures for GiSTs over 2-D objects (boxes, polygons, circles,
 *      points).
 *
 * This gives R-tree behavior, with Guttman's poly-time split algorithm.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *    src/backend/access/gist/gistproc.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/geo_decls.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gist_box_leaf_consistent</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                         <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>rtree_internal_consistent</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                          <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Minimum accepted ratio of split */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIMIT_RATIO</name></cpp:macro> <cpp:value>0.3</cpp:value></cpp:define>

<comment type="block">/* Convenience macros for NaN-aware comparisons */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT8_EQ</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(float8_cmp_internal(a, b) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT8_LT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(float8_cmp_internal(a, b) &lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT8_LE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(float8_cmp_internal(a, b) &lt;= 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT8_GT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(float8_cmp_internal(a, b) &gt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT8_GE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(float8_cmp_internal(a, b) &gt;= 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT8_MAX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(FLOAT8_GT(a, b) ? (a) : (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT8_MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(FLOAT8_LT(a, b) ? (a) : (b))</cpp:value></cpp:define>


<comment type="block" format="doxygen">/**************************************************
 * Box ops
 **************************************************/</comment>

<comment type="block">/*
 * Calculates union of two boxes, a and b. The result is stored in *n.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rt_box_union</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BOX</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>FLOAT8_MAX</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>FLOAT8_MAX</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>FLOAT8_MIN</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>FLOAT8_MIN</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Size of a BOX for penalty-calculation purposes.
 * The result can be +Infinity, but not NaN.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>size_box</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Check for zero-width cases.  Note that we define the size of a zero-
     * by-infinity box as zero.  It's important to special-case this somehow,
     * as naively multiplying infinity by zero will produce NaN.
     *
     * The less-than cases should not happen, but if they do, say "zero".
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_LE</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>FLOAT8_LE</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We treat NaN as larger than +Infinity, so any distance involving a NaN
     * and a non-NaN is infinite.  Note the previous check eliminated the
     * possibility that the low fields are NaNs.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return amount by which the union of the two boxes is larger than
 * the original BOX's area.  The result can be +Infinity, but not NaN.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>box_penalty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BOX</name> <modifier>*</modifier></type><name>original</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BOX</name> <modifier>*</modifier></type><name>new</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name></type>            <name>unionbox</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>rt_box_union</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unionbox</name></expr></argument>, <argument><expr><name>original</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>size_box</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unionbox</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>size_box</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST Consistent method for boxes
 *
 * Should return false if for all data items x below entry,
 * the predicate x op query must be FALSE, where op is the oper
 * corresponding to strategy in the pg_amop table.
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Oid        subtype = PG_GETARG_OID(3); */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* All cases served by this function are exact */</comment>
    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * if entry is not leaf, use rtree_internal_consistent, else use
     * gist_box_leaf_consistent
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>gist_box_leaf_consistent</name><argument_list>(<argument><expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>query</name></expr></argument>,
                                                <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>rtree_internal_consistent</name><argument_list>(<argument><expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name>query</name></expr></argument>,
                                                 <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Increase BOX b to include addon.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjustBox</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BOX</name> <modifier>*</modifier></type><name>addon</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_LT</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>addon</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>addon</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_GT</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>addon</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>addon</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_LT</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>addon</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>addon</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_GT</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>addon</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>addon</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST Union method for boxes
 *
 * returns the minimal bounding box that encloses all the entries in entryvec
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_union</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>sizep</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numranges</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>cur</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>pageunion</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>numranges</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pageunion</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pageunion</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numranges</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>adjustBox</name><argument_list>(<argument><expr><name>pageunion</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>pageunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GiST Compress methods for boxes
 *
 * do not do anything.
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_compress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GiST DeCompress method for boxes (also used for points, polygons
 * and circles)
 *
 * do not do anything --- we just use the stored box as is.
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_decompress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GiST Fetch method for boxes
 * do not do anything --- we just return the stored box as is.
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_fetch</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST Penalty method for boxes (also used for points)
 *
 * As in the R-tree paper, we use change in area as our penalty metric
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_penalty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>origentry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>newentry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>origbox</name> <init>= <expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>origentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>newbox</name> <init>= <expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>newentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <call><name>box_penalty</name><argument_list>(<argument><expr><name>origbox</name></expr></argument>, <argument><expr><name>newbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Trivial split: half of entries will be placed on one page
 * and another half - to another
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fallbackSplit</name><parameter_list>(<parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>, <parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>unionL</name> <init>= <expr><name>NULL</name></expr></init></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>unionR</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbytes</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>maxoff</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>cur</name> <init>= <expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <operator>(</operator><name>maxoff</name> <operator>-</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>unionL</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>unionL</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>unionL</name> <operator>=</operator> <operator>*</operator><name>cur</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>adjustBox</name><argument_list>(<argument><expr><name>unionL</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>unionR</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>unionR</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>unionR</name> <operator>=</operator> <operator>*</operator><name>cur</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>adjustBox</name><argument_list>(<argument><expr><name>unionR</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>unionL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>unionR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Represents information about an entry that can be placed to either group
 * without affecting overlap over selected axis ("common entry").
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <comment type="block">/* Index of entry in the initial array */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>index</name></decl>;</decl_stmt>
    <comment type="block">/* Delta between penalties of entry insertion into different groups */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>delta</name></decl>;</decl_stmt>
}</block></struct></type> <name>CommonEntry</name>;</typedef>

<comment type="block">/*
 * Context for g_box_consider_split. Contains information about currently
 * selected split and some general information.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>entriesCount</name></decl>;</decl_stmt>    <comment type="block">/* total number of entries being split */</comment>
    <decl_stmt><decl><type><name>BOX</name></type>            <name>boundingBox</name></decl>;</decl_stmt>    <comment type="block">/* minimum bounding box across all entries */</comment>

    <comment type="block">/* Information about currently selected split follows */</comment>

    <decl_stmt><decl><type><name>bool</name></type>        <name>first</name></decl>;</decl_stmt>            <comment type="block">/* true if no split was selected yet */</comment>

    <decl_stmt><decl><type><name>double</name></type>        <name>leftUpper</name></decl>;</decl_stmt>        <comment type="block">/* upper bound of left interval */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>rightLower</name></decl>;</decl_stmt>        <comment type="block">/* lower bound of right interval */</comment>

    <decl_stmt><decl><type><name>float4</name></type>        <name>ratio</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float4</name></type>        <name>overlap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name></decl>;</decl_stmt>            <comment type="block">/* axis of this split */</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>range</name></decl>;</decl_stmt>            <comment type="block">/* width of general MBR projection to the
                                 * selected axis */</comment>
}</block></struct></type> <name>ConsiderSplitContext</name>;</typedef>

<comment type="block">/*
 * Interval represents projection of box to axis.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>double</name></type>        <name>lower</name></decl>,
                <name>upper</name>;</decl_stmt>
}</block></struct></type> <name>SplitInterval</name>;</typedef>

<comment type="block">/*
 * Interval comparison function by lower bound of the interval;
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interval_cmp_lower</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>lower1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SplitInterval</name> <operator>*</operator><operator>)</operator> <name>i1</name><operator>)</operator><operator>-&gt;</operator><name>lower</name></expr></init></decl>,
                <decl><type ref="prev"/><name>lower2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SplitInterval</name> <operator>*</operator><operator>)</operator> <name>i2</name><operator>)</operator><operator>-&gt;</operator><name>lower</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>lower1</name></expr></argument>, <argument><expr><name>lower2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Interval comparison function by upper bound of the interval;
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interval_cmp_upper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>upper1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SplitInterval</name> <operator>*</operator><operator>)</operator> <name>i1</name><operator>)</operator><operator>-&gt;</operator><name>upper</name></expr></init></decl>,
                <decl><type ref="prev"/><name>upper2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SplitInterval</name> <operator>*</operator><operator>)</operator> <name>i2</name><operator>)</operator><operator>-&gt;</operator><name>upper</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>upper1</name></expr></argument>, <argument><expr><name>upper2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace negative (or NaN) value with zero.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type>
<name>non_negative</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;=</operator> <literal type="number">0.0f</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>val</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0.0f</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Consider replacement of currently selected split with the better one.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>g_box_consider_split</name><parameter_list>(<parameter><decl><type><name>ConsiderSplitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dimNum</name></decl></parameter>,
                     <parameter><decl><type><name>double</name></type> <name>rightLower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minLeftCount</name></decl></parameter>,
                     <parameter><decl><type><name>double</name></type> <name>leftUpper</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxLeftCount</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>leftCount</name></decl>,
                <decl><type ref="prev"/><name>rightCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float4</name></type>        <name>ratio</name></decl>,
                <decl><type ref="prev"/><name>overlap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>range</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Calculate entries distribution ratio assuming most uniform distribution
     * of common entries.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>minLeftCount</name> <operator>&gt;=</operator> <operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>entriesCount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>leftCount</name> <operator>=</operator> <name>minLeftCount</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>maxLeftCount</name> <operator>&lt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>entriesCount</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>leftCount</name> <operator>=</operator> <name>maxLeftCount</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>leftCount</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>entriesCount</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rightCount</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>entriesCount</name></name> <operator>-</operator> <name>leftCount</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Ratio of split - quotient between size of lesser group and total
     * entries count.
     */</comment>
    <expr_stmt><expr><name>ratio</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float4</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name>leftCount</name></expr></argument>, <argument><expr><name>rightCount</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator>
        <operator>(</operator><operator>(</operator><name>float4</name><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>entriesCount</name></name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ratio</name> <operator>&gt;</operator> <name>LIMIT_RATIO</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>selectthis</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * The ratio is acceptable, so compare current split with previously
         * selected one. Between splits of one dimension we search for minimal
         * overlap (allowing negative values) and minimal ration (between same
         * overlaps. We switch dimension if find less overlap (non-negative)
         * or less range with same overlap.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>dimNum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>range</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>boundingBox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>context</name><operator>-&gt;</operator><name>boundingBox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>range</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>boundingBox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>context</name><operator>-&gt;</operator><name>boundingBox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>overlap</name> <operator>=</operator> <operator>(</operator><name>leftUpper</name> <operator>-</operator> <name>rightLower</name><operator>)</operator> <operator>/</operator> <name>range</name></expr>;</expr_stmt>

        <comment type="block">/* If there is no previous selection, select this */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>first</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>selectthis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>dim</name></name> <operator>==</operator> <name>dimNum</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Within the same dimension, choose the new split if it has a
             * smaller overlap, or same overlap but better ratio.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>overlap</name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>overlap</name></name> <operator>||</operator>
                <operator>(</operator><name>overlap</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>overlap</name></name> <operator>&amp;&amp;</operator> <name>ratio</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>ratio</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>selectthis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Across dimensions, choose the new split if it has a smaller
             * *non-negative* overlap, or same *non-negative* overlap but
             * bigger range. This condition differs from the one described in
             * the article. On the datasets where leaf MBRs don't overlap
             * themselves, non-overlapping splits (i.e. splits which have zero
             * *non-negative* overlap) are frequently possible. In this case
             * splits tends to be along one dimension, because most distant
             * non-overlapping splits (i.e. having lowest negative overlap)
             * appears to be in the same dimension as in the previous split.
             * Therefore MBRs appear to be very prolonged along another
             * dimension, which leads to bad search performance. Using range
             * as the second split criteria makes MBRs more quadratic. Using
             * *non-negative* overlap instead of overlap as the first split
             * criteria gives to range criteria a chance to matter, because
             * non-overlapping splits are equivalent in this criteria.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>non_negative</name><argument_list>(<argument><expr><name>overlap</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>non_negative</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>overlap</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>(</operator><name>range</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>range</name></name> <operator>&amp;&amp;</operator>
                 <call><name>non_negative</name><argument_list>(<argument><expr><name>overlap</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>non_negative</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>overlap</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>selectthis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>selectthis</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* save information about selected split */</comment>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ratio</name></name> <operator>=</operator> <name>ratio</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>range</name></name> <operator>=</operator> <name>range</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>overlap</name></name> <operator>=</operator> <name>overlap</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>rightLower</name></name> <operator>=</operator> <name>rightLower</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>leftUpper</name></name> <operator>=</operator> <name>leftUpper</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>dim</name></name> <operator>=</operator> <name>dimNum</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare common entries by their deltas.
 * (We assume the deltas can't be NaN.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>common_entry_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>delta1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CommonEntry</name> <operator>*</operator><operator>)</operator> <name>i1</name><operator>)</operator><operator>-&gt;</operator><name>delta</name></expr></init></decl>,
                <decl><type ref="prev"/><name>delta2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CommonEntry</name> <operator>*</operator><operator>)</operator> <name>i2</name><operator>)</operator><operator>-&gt;</operator><name>delta</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>delta1</name> <operator>&lt;</operator> <name>delta2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>delta1</name> <operator>&gt;</operator> <name>delta2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * --------------------------------------------------------------------------
 * Double sorting split algorithm. This is used for both boxes and points.
 *
 * The algorithm finds split of boxes by considering splits along each axis.
 * Each entry is first projected as an interval on the X-axis, and different
 * ways to split the intervals into two groups are considered, trying to
 * minimize the overlap of the groups. Then the same is repeated for the
 * Y-axis, and the overall best split is chosen. The quality of a split is
 * determined by overlap along that axis and some other criteria (see
 * g_box_consider_split).
 *
 * After that, all the entries are divided into three groups:
 *
 * 1) Entries which should be placed to the left group
 * 2) Entries which should be placed to the right group
 * 3) "Common entries" which can be placed to any of groups without affecting
 *      of overlap along selected axis.
 *
 * The common entries are distributed by minimizing penalty.
 *
 * For details see:
 * "A new double sorting-based node splitting algorithm for R-tree", A. Korotkov
 * http://syrcose.ispras.ru/2011/files/SYRCoSE2011_Proceedings.pdf#page=36
 * --------------------------------------------------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_picksplit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>GIST_SPLITVEC</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConsiderSplitContext</name></type> <name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>leftBox</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>rightBox</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dim</name></decl>,
                <decl><type ref="prev"/><name>commonEntriesCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SplitInterval</name> <modifier>*</modifier></type><name>intervalsLower</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>intervalsUpper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommonEntry</name> <modifier>*</modifier></type><name>commonEntries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nentries</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsiderSplitContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nentries</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>entriesCount</name></name> <operator>=</operator> <name>maxoff</name> <operator>-</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* Allocate arrays for intervals along axes */</comment>
    <expr_stmt><expr><name>intervalsLower</name> <operator>=</operator> <operator>(</operator><name>SplitInterval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SplitInterval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>intervalsUpper</name> <operator>=</operator> <operator>(</operator><name>SplitInterval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SplitInterval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calculate the overall minimum bounding box over all the entries.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>FirstOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>boundingBox</name></name> <operator>=</operator> <operator>*</operator><name>box</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>adjustBox</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>boundingBox</name></name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Iterate over axes for optimal split searching.
     */</comment>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* nothing selected yet */</comment>
    <for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>leftUpper</name></decl>,
                    <decl><type ref="prev"/><name>rightLower</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i1</name></decl>,
                    <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>

        <comment type="block">/* Project each entry as an interval on the selected axis. */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>dim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>intervalsLower</name><index>[<expr><name>i</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr>]</index></name><operator>.</operator><name>lower</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>intervalsLower</name><index>[<expr><name>i</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr>]</index></name><operator>.</operator><name>upper</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>intervalsLower</name><index>[<expr><name>i</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr>]</index></name><operator>.</operator><name>lower</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>intervalsLower</name><index>[<expr><name>i</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr>]</index></name><operator>.</operator><name>upper</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Make two arrays of intervals: one sorted by lower bound and another
         * sorted by upper bound.
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>intervalsUpper</name></expr></argument>, <argument><expr><name>intervalsLower</name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SplitInterval</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nentries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>intervalsLower</name></expr></argument>, <argument><expr><name>nentries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SplitInterval</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>interval_cmp_lower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>intervalsUpper</name></expr></argument>, <argument><expr><name>nentries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SplitInterval</name></expr></argument>)</argument_list></sizeof></expr></argument>,
              <argument><expr><name>interval_cmp_upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*----
         * The goal is to form a left and right interval, so that every entry
         * interval is contained by either left or right interval (or both).
         *
         * For example, with the intervals (0,1), (1,3), (2,3), (2,4):
         *
         * 0 1 2 3 4
         * +-+
         *     +---+
         *       +-+
         *       +---+
         *
         * The left and right intervals are of the form (0,a) and (b,4).
         * We first consider splits where b is the lower bound of an entry.
         * We iterate through all entries, and for each b, calculate the
         * smallest possible a. Then we consider splits where a is the
         * upper bound of an entry, and for each a, calculate the greatest
         * possible b.
         *
         * In the above example, the first loop would consider splits:
         * b=0: (0,1)-(0,4)
         * b=1: (0,1)-(1,4)
         * b=2: (0,3)-(2,4)
         *
         * And the second loop:
         * a=1: (0,1)-(1,4)
         * a=3: (0,3)-(2,4)
         * a=4: (0,4)-(2,4)
         */</comment>

        <comment type="block">/*
         * Iterate over lower bound of right group, finding smallest possible
         * upper bound of left group.
         */</comment>
        <expr_stmt><expr><name>i1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>i2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rightLower</name> <operator>=</operator> <name><name>intervalsLower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>leftUpper</name> <operator>=</operator> <name><name>intervalsUpper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>true</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Find next lower bound of right group.
             */</comment>
            <while>while <condition>(<expr><name>i1</name> <operator>&lt;</operator> <name>nentries</name> <operator>&amp;&amp;</operator>
                   <call><name>FLOAT8_EQ</name><argument_list>(<argument><expr><name>rightLower</name></expr></argument>, <argument><expr><name><name>intervalsLower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_LT</name><argument_list>(<argument><expr><name>leftUpper</name></expr></argument>, <argument><expr><name><name>intervalsLower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>leftUpper</name> <operator>=</operator> <name><name>intervalsLower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>i1</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name>i1</name> <operator>&gt;=</operator> <name>nentries</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>rightLower</name> <operator>=</operator> <name><name>intervalsLower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Find count of intervals which anyway should be placed to the
             * left group.
             */</comment>
            <while>while <condition>(<expr><name>i2</name> <operator>&lt;</operator> <name>nentries</name> <operator>&amp;&amp;</operator>
                   <call><name>FLOAT8_LE</name><argument_list>(<argument><expr><name><name>intervalsUpper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>, <argument><expr><name>leftUpper</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>i2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

            <comment type="block">/*
             * Consider found split.
             */</comment>
            <expr_stmt><expr><call><name>g_box_consider_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>rightLower</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>leftUpper</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/*
         * Iterate over upper bound of left group finding greatest possible
         * lower bound of right group.
         */</comment>
        <expr_stmt><expr><name>i1</name> <operator>=</operator> <name>nentries</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>i2</name> <operator>=</operator> <name>nentries</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rightLower</name> <operator>=</operator> <name><name>intervalsLower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>leftUpper</name> <operator>=</operator> <name><name>intervalsUpper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>true</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Find next upper bound of left group.
             */</comment>
            <while>while <condition>(<expr><name>i2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FLOAT8_EQ</name><argument_list>(<argument><expr><name>leftUpper</name></expr></argument>, <argument><expr><name><name>intervalsUpper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_GT</name><argument_list>(<argument><expr><name>rightLower</name></expr></argument>, <argument><expr><name><name>intervalsUpper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>rightLower</name> <operator>=</operator> <name><name>intervalsUpper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>i2</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name>i2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>leftUpper</name> <operator>=</operator> <name><name>intervalsUpper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Find count of intervals which anyway should be placed to the
             * right group.
             */</comment>
            <while>while <condition>(<expr><name>i1</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FLOAT8_GE</name><argument_list>(<argument><expr><name><name>intervalsLower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>, <argument><expr><name>rightLower</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>i1</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

            <comment type="block">/*
             * Consider found split.
             */</comment>
            <expr_stmt><expr><call><name>g_box_consider_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>,
                                 <argument><expr><name>rightLower</name></expr></argument>, <argument><expr><name>i1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>leftUpper</name></expr></argument>, <argument><expr><name>i2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <comment type="block">/*
     * If we failed to find any acceptable splits, use trivial split.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>first</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fallbackSplit</name><argument_list>(<argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Ok, we have now selected the split across one axis.
     *
     * While considering the splits, we already determined that there will be
     * enough entries in both groups to reach the desired ratio, but we did
     * not memorize which entries go to which group. So determine that now.
     */</comment>

    <comment type="block">/* Allocate vectors for results */</comment>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Allocate bounding boxes of left and right groups */</comment>
    <expr_stmt><expr><name>leftBox</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rightBox</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocate an array for "common entries" - entries which can be placed to
     * either group without affecting overlap along selected axis.
     */</comment>
    <expr_stmt><expr><name>commonEntriesCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>commonEntries</name> <operator>=</operator> <operator>(</operator><name>CommonEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CommonEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Helper macros to place an entry in the left or right group */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLACE_LEFT</name><parameter_list>(<parameter><type><name>box</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro>                    \
    <cpp:value>do {                                        \
        if (v-&gt;spl_nleft &gt; 0)                    \
            adjustBox(leftBox, box);            \
        else                                    \
            *leftBox = *(box);                    \
        v-&gt;spl_left[v-&gt;spl_nleft++] = off;        \
    } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLACE_RIGHT</name><parameter_list>(<parameter><type><name>box</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro>                    \
    <cpp:value>do {                                        \
        if (v-&gt;spl_nright &gt; 0)                    \
            adjustBox(rightBox, box);            \
        else                                    \
            *rightBox = *(box);                    \
        v-&gt;spl_right[v-&gt;spl_nright++] = off;    \
    } while(0)</cpp:value></cpp:define>

    <comment type="block">/*
     * Distribute entries which can be distributed unambiguously, and collect
     * common entries.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>lower</name></decl>,
                    <decl><type ref="prev"/><name>upper</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Get upper and lower bounds along selected axis.
         */</comment>
        <expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>dim</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lower</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>upper</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>lower</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>upper</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_LE</name><argument_list>(<argument><expr><name>upper</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>leftUpper</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Fits to the left group */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>FLOAT8_GE</name><argument_list>(<argument><expr><name>lower</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>rightLower</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Fits also to the right group, so "common entry" */</comment>
                <expr_stmt><expr><name><name>commonEntries</name><index>[<expr><name>commonEntriesCount</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Doesn't fit to the right group, so join to the left group */</comment>
                <expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Each entry should fit on either left or right group. Since this
             * entry didn't fit on the left group, it better fit in the right
             * group.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FLOAT8_GE</name><argument_list>(<argument><expr><name>lower</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>rightLower</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Doesn't fit to the left group, so join to the right group */</comment>
            <expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Distribute "common entries", if any.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>commonEntriesCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Calculate minimum number of entries that must be placed in both
         * groups, to reach LIMIT_RATIO.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>m</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>LIMIT_RATIO</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nentries</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Calculate delta between penalties of join "common entries" to
         * different groups.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>commonEntriesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name><name>commonEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>commonEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>delta</name> <operator>=</operator> <call><name>Abs</name><argument_list>(<argument><expr><call><name>box_penalty</name><argument_list>(<argument><expr><name>leftBox</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call> <operator>-</operator>
                                         <call><name>box_penalty</name><argument_list>(<argument><expr><name>rightBox</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Sort "common entries" by calculated deltas in order to distribute
         * the most ambiguous entries first.
         */</comment>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>commonEntries</name></expr></argument>, <argument><expr><name>commonEntriesCount</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CommonEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>common_entry_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Distribute "common entries" between groups.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>commonEntriesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name><name>commonEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Check if we have to place this entry in either group to achieve
             * LIMIT_RATIO.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>+</operator> <operator>(</operator><name>commonEntriesCount</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>&lt;=</operator> <name>m</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name><name>commonEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>+</operator> <operator>(</operator><name>commonEntriesCount</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>&lt;=</operator> <name>m</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name><name>commonEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Otherwise select the group by minimal penalty */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>box_penalty</name><argument_list>(<argument><expr><name>leftBox</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>box_penalty</name><argument_list>(<argument><expr><name>rightBox</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name><name>commonEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name><name>commonEntries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>leftBox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>rightBox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Equality method
 *
 * This is used for boxes, points, circles, and polygons, all of which store
 * boxes as GiST index entries.
 *
 * Returns true only when boxes are exactly the same.  We can't use fuzzy
 * comparisons here without breaking index consistency; therefore, this isn't
 * equivalent to box_same().
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_box_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>b1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>b2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>b1</name> <operator>&amp;&amp;</operator> <name>b2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><call><name>FLOAT8_EQ</name><argument_list>(<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FLOAT8_EQ</name><argument_list>(<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FLOAT8_EQ</name><argument_list>(<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>FLOAT8_EQ</name><argument_list>(<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>b1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b2</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Leaf-level consistency for boxes: just apply the query operator
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gist_box_leaf_consistent</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>retval</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RTLeftStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_left</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverLeftStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overleft</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverlapStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overlap</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverRightStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overright</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTRightStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_right</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTSameStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_same</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTContainsStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainsStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_contain</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTContainedByStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainedByStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_contained</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverBelowStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overbelow</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTBelowStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_below</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTAboveStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_above</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverAboveStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overabove</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************
 * Common rtree functions (for boxes, polygons, and circles)
 *****************************************/</comment>

<comment type="block">/*
 * Internal-page consistency for all these types
 *
 * We can use the same function since all types use bounding boxes as the
 * internal-page representation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rtree_internal_consistent</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>retval</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RTLeftStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overright</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverLeftStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_right</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverlapStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overlap</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverRightStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_left</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTRightStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overleft</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTSameStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTContainsStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainsStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_contain</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTContainedByStrategyNumber</name></expr>:</case>
        <case>case <expr><name>RTOldContainedByStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overlap</name></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverBelowStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_above</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTBelowStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overabove</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTAboveStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_overbelow</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTOverAboveStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>box_below</name></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************************************
 * Polygon ops
 **************************************************/</comment>

<comment type="block">/*
 * GiST compress for polygons: represent a polygon by its bounding box
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_poly_compress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>leafkey</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>DatumGetPolygonP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>boundbox</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST Consistent method for polygons
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_poly_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Oid        subtype = PG_GETARG_OID(3); */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* All cases served by this function are inexact */</comment>
    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Since the operators require recheck anyway, we can just use
     * rtree_internal_consistent even at leaf nodes.  (This works in part
     * because the index entries are bounding boxes not polygons.)
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rtree_internal_consistent</name><argument_list>(<argument><expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>boundbox</name></name><operator>)</operator></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Avoid memory leak if supplied poly is toasted */</comment>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************************************
 * Circle ops
 **************************************************/</comment>

<comment type="block">/*
 * GiST compress for circles: represent a circle by its bounding box
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_circle_compress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>leafkey</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>DatumGetCircleP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>in</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>in</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>in</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>in</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST Consistent method for circles
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_circle_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Oid        subtype = PG_GETARG_OID(3); */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name></type>            <name>bbox</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* All cases served by this function are inexact */</comment>
    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Since the operators require recheck anyway, we can just use
     * rtree_internal_consistent even at leaf nodes.  (This works in part
     * because the index entries are bounding boxes not circles.)
     */</comment>
    <expr_stmt><expr><name><name>bbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>query</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>query</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>query</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>query</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rtree_internal_consistent</name><argument_list>(<argument><expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>bbox</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************************************
 * Point ops
 **************************************************/</comment>

<function><type><name>Datum</name></type>
<name>gist_point_compress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>leafkey</name></name></expr>)</condition>            <comment type="block">/* Point, actually */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>DatumGetPointP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>retval</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name></name> <operator>=</operator> <operator>*</operator><name>point</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><call><name>BoxPGetDatum</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GiST Fetch method for point
 *
 * Get point coordinates from its bounding box coordinates and form new
 * gistentry.
 */</comment>
<function><type><name>Datum</name></type>
<name>gist_point_fetch</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Point</name>       <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
                  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>point_point_distance</name><parameter_list>(<parameter><type><name>p1</name></type></parameter>,<parameter><type><name>p2</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>DatumGetFloat8(DirectFunctionCall2(point_distance, \
                                       PointPGetDatum(p1), PointPGetDatum(p2)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>computeDistance</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isLeaf</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>double</name></type>        <name>result</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>isLeaf</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* simple point to point distance */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_point_distance</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator>
             <name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* point inside the box */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* point is over or below box */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent point values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* point is to left or right of box */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent point values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* closest point will be a vertex */</comment>
        <decl_stmt><decl><type><name>Point</name></type>        <name>p</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>subresult</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>point_point_distance</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>subresult</name> <operator>=</operator> <call><name>point_point_distance</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <name>subresult</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>subresult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subresult</name> <operator>=</operator> <call><name>point_point_distance</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <name>subresult</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>subresult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subresult</name> <operator>=</operator> <call><name>point_point_distance</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <name>subresult</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>subresult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gist_point_consistent_internal</name><parameter_list>(<parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
                               <parameter><decl><type><name>bool</name></type> <name>isLeaf</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RTLeftStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FPlt</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTRightStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FPgt</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTAboveStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FPgt</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTBelowStrategyNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FPlt</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>RTSameStrategyNumber</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>isLeaf</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* key.high must equal key.low, so we can disregard it */</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                          <call><name>FPeq</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>FPle</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                          <call><name>FPge</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                          <call><name>FPle</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                          <call><name>FPge</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GeoStrategyNumberOffset</name></cpp:macro>        <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PointStrategyNumberGroup</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BoxStrategyNumberGroup</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PolygonStrategyNumberGroup</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CircleStrategyNumberGroup</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>

<function><type><name>Datum</name></type>
<name>gist_point_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategyGroup</name> <init>= <expr><name>strategy</name> <operator>/</operator> <name>GeoStrategyNumberOffset</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>strategyGroup</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PointStrategyNumberGroup</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>gist_point_consistent_internal</name><argument_list>(<argument><expr><name>strategy</name> <operator>%</operator> <name>GeoStrategyNumberOffset</name></expr></argument>,
                                                    <argument><expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>BoxStrategyNumberGroup</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * The only operator in this group is point &lt;@ box (on_pb), so
                 * we needn't examine strategy again.
                 *
                 * For historical reasons, on_pb uses exact rather than fuzzy
                 * comparisons.  We could use box_overlap when at an internal
                 * page, but that would lead to possibly visiting child pages
                 * uselessly, because box_overlap uses fuzzy comparisons.
                 * Instead we write a non-fuzzy overlap test.  The same code
                 * will also serve for leaf-page tests, since leaf keys have
                 * high == low.
                 */</comment>
                <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>query</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>query</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator>
                          <name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>query</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&amp;&amp;</operator>
                          <name><name>key</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>query</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&amp;&amp;</operator>
                          <name><name>key</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>query</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>PolygonStrategyNumberGroup</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall5</name><argument_list>(
                                                          <argument><expr><name>gist_poly_consistent</name></expr></argument>,
                                                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><call><name>PolygonPGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>RTOverlapStrategyNumber</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>result</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * We are on leaf page and quick check shows overlapping
                     * of polygon's bounding box and point
                     */</comment>
                    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>==</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name>
                           <operator>&amp;&amp;</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>==</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
                                                              <argument><expr><name>poly_contain_pt</name></expr></argument>,
                                                              <argument><expr><call><name>PolygonPGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                                                              <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>CircleStrategyNumberGroup</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CIRCLE</name>       <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall5</name><argument_list>(
                                                          <argument><expr><name>gist_circle_consistent</name></expr></argument>,
                                                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><call><name>CirclePGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>RTOverlapStrategyNumber</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>result</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * We are on leaf page and quick check shows overlapping
                     * of polygon's bounding box and point
                     */</comment>
                    <decl_stmt><decl><type><name>BOX</name>           <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>==</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name>
                           <operator>&amp;&amp;</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>==</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
                                                              <argument><expr><name>circle_contain_pt</name></expr></argument>,
                                                              <argument><expr><call><name>CirclePGetDatum</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                                                              <argument><expr><call><name>PointPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gist_point_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>distance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategyGroup</name> <init>= <expr><name>strategy</name> <operator>/</operator> <name>GeoStrategyNumberOffset</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>strategyGroup</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PointStrategyNumberGroup</name></expr>:</case>
            <expr_stmt><expr><name>distance</name> <operator>=</operator> <call><name>computeDistance</name><argument_list>(<argument><expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>distance</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The inexact GiST distance method for geometric types that store bounding
 * boxes.
 *
 * Compute lossy distance from point to index entries.  The result is inexact
 * because index entries are bounding boxes, not the exact shapes of the
 * indexed geometric types.  We use distance from point to MBR of index entry.
 * This is a lower bound estimate of distance from point to indexed geometric
 * type.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>gist_bbox_distance</name><parameter_list>(<parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>query</name></decl></parameter>,
                   <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>distance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategyGroup</name> <init>= <expr><name>strategy</name> <operator>/</operator> <name>GeoStrategyNumberOffset</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Bounding box distance is always inexact. */</comment>
    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>strategyGroup</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PointStrategyNumberGroup</name></expr>:</case>
            <expr_stmt><expr><name>distance</name> <operator>=</operator> <call><name>computeDistance</name><argument_list>(<argument><expr><name>false</name></expr></argument>,
                                       <argument><expr><call><name>DatumGetBoxP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>DatumGetPointP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>distance</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></switch>

    <return>return <expr><name>distance</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gist_circle_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>query</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Oid subtype = PG_GETARG_OID(3); */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>distance</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>distance</name> <operator>=</operator> <call><name>gist_bbox_distance</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gist_poly_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>query</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Oid subtype = PG_GETARG_OID(3); */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>distance</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>distance</name> <operator>=</operator> <call><name>gist_bbox_distance</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
