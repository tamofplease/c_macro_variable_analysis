<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/gist/gistsplit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gistsplit.c
 *      Multi-column page splitting algorithm
 *
 * This file is concerned with making good page-split decisions in multi-column
 * GiST indexes.  The opclass-specific picksplit functions can only be expected
 * to produce answers based on a single column.  We first run the picksplit
 * function for column 1; then, if there are more columns, we check if any of
 * the tuples are "don't cares" so far as the column 1 split is concerned
 * (that is, they could go to either side for no additional penalty).  If so,
 * we try to redistribute those tuples on the basis of the next column.
 * Repeat till we're out of columns.
 *
 * gistSplitByKey() is the entry point to this file.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/access/gist/gistsplit.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>dontcare</name></decl>;</decl_stmt>
}</block></struct></type> <name>GistSplitUnion</name>;</typedef>


<comment type="block">/*
 * Form unions of subkeys in itvec[] entries listed in gsvp-&gt;entries[],
 * ignoring any tuples that are marked in gsvp-&gt;dontcare[].  Subroutine for
 * gistunionsubkey.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistunionsubkeyvec</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl></parameter>,
                   <parameter><decl><type><name>GistSplitUnion</name> <modifier>*</modifier></type><name>gsvp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>cleanedItVec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>cleanedLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>cleanedItVec</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>gsvp</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gsvp</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>gsvp</name><operator>-&gt;</operator><name>dontcare</name></name> <operator>&amp;&amp;</operator> <name><name>gsvp</name><operator>-&gt;</operator><name>dontcare</name><index>[<expr><name><name>gsvp</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>cleanedItVec</name><index>[<expr><name>cleanedLen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>itvec</name><index>[<expr><name><name>gsvp</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>gistMakeUnionItVec</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>cleanedItVec</name></expr></argument>, <argument><expr><name>cleanedLen</name></expr></argument>,
                       <argument><expr><name><name>gsvp</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name><name>gsvp</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cleanedItVec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recompute unions of left- and right-side subkeys after a page split,
 * ignoring any tuples that are marked in spl-&gt;spl_dontcare[].
 *
 * Note: we always recompute union keys for all index columns.  In some cases
 * this might represent duplicate work for the leftmost column(s), but it's
 * not safe to assume that "zero penalty to move a tuple" means "the union
 * key doesn't change at all".  Penalty functions aren't 100% accurate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistunionsubkey</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl></parameter>, <parameter><decl><type><name>GistSplitVector</name> <modifier>*</modifier></type><name>spl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GistSplitUnion</name></type> <name>gsvp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>dontcare</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>spl_dontcare</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>attr</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>spl_lattr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>spl_lisnull</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>gistunionsubkeyvec</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>itvec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gsvp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>attr</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>spl_rattr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gsvp</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>spl</name><operator>-&gt;</operator><name>spl_risnull</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>gistunionsubkeyvec</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>itvec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gsvp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find tuples that are "don't cares", that is could be moved to the other
 * side of the split with zero penalty, so far as the attno column is
 * concerned.
 *
 * Don't-care tuples are marked by setting the corresponding entry in
 * spl-&gt;spl_dontcare[] to "true".  Caller must have initialized that array
 * to zeroes.
 *
 * Returns number of don't-cares found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findDontCares</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>valvec</name></decl></parameter>,
              <parameter><decl><type><name>GistSplitVector</name> <modifier>*</modifier></type><name>spl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>NumDontCare</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * First, search the left-side tuples to see if any have zero penalty to
     * be added to the right-side union key.
     *
     * attno column is known all-not-null (see gistSplitByKey), so we need not
     * check for nulls
     */</comment>
    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_rdatum</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                  <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_left</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type>        <name>penalty</name> <init>= <expr><call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>valvec</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>penalty</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>spl</name><operator>-&gt;</operator><name>spl_dontcare</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>NumDontCare</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* And conversely for the right-side tuples */</comment>
    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_ldatum</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                  <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><name><name>spl</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_right</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type>        <name>penalty</name> <init>= <expr><call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>valvec</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>penalty</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>spl</name><operator>-&gt;</operator><name>spl_dontcare</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>NumDontCare</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>NumDontCare</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove tuples that are marked don't-cares from the tuple index array a[]
 * of length *len.  This is applied separately to the spl_left and spl_right
 * arrays.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeDontCares</name><parameter_list>(<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>dontcare</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>origlen</name></decl>,
                <decl><type ref="prev"/><name>newlen</name></decl>,
                <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>curwpos</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>origlen</name> <operator>=</operator> <name>newlen</name> <operator>=</operator> <operator>*</operator><name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>curwpos</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>origlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>ai</name> <init>= <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>dontcare</name><index>[<expr><name>ai</name></expr>]</index></name> <operator>==</operator> <name>FALSE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* re-emit item into a[] */</comment>
            <expr_stmt><expr><operator>*</operator><name>curwpos</name> <operator>=</operator> <name>ai</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>curwpos</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>newlen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Place a single don't-care tuple into either the left or right side of the
 * split, according to which has least penalty for merging the tuple into
 * the previously-computed union keys.  We need consider only columns starting
 * at attno.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>placeOne</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>GistSplitVector</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
         <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name><name>identry</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>toLeft</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gistDeCompressAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                      <argument><expr><name>identry</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>float</name></type>        <name>lpenalty</name></decl>,
                    <decl><type ref="prev"/><name>rpenalty</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name>entry</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_lattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lpenalty</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_lisnull</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>identry</name> <operator>+</operator> <name>attno</name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rpenalty</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_risnull</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>identry</name> <operator>+</operator> <name>attno</name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>lpenalty</name> <operator>!=</operator> <name>rpenalty</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>lpenalty</name> <operator>&gt;</operator> <name>rpenalty</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>toLeft</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>toLeft</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_left</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_right</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAPVAR</name><parameter_list>( <parameter><type><name>s</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>t</name></type></parameter> )</parameter_list></cpp:macro> \
<cpp:value>do {    \
    (t) = (s); \
    (s) = (d); \
    (d) = (t); \
} while(0)</cpp:value></cpp:define>

<comment type="block">/*
 * Clean up when we did a secondary split but the user-defined PickSplit
 * method didn't support it (leaving spl_ldatum_exists or spl_rdatum_exists
 * true).
 *
 * We consider whether to swap the left and right outputs of the secondary
 * split; this can be worthwhile if the penalty for merging those tuples into
 * the previously chosen sets is less that way.
 *
 * In any case we must update the union datums for the current column by
 * adding in the previous union keys (oldL/oldR), since the user-defined
 * PickSplit method didn't do so.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>supportSecondarySplit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>,
                      <parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>oldL</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>oldR</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>leaveOnLeft</name> <init>= <expr><name>true</name></expr></init></decl>,
                <decl><type ref="prev"/><name>tmpBool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GISTENTRY</name></type>    <name>entryL</name></decl>,
                <decl><type ref="prev"/><name>entryR</name></decl>,
                <decl><type ref="prev"/><name>entrySL</name></decl>,
                <decl><type ref="prev"/><name>entrySR</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entryL</name></expr></argument>, <argument><expr><name>oldL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entryR</name></expr></argument>, <argument><expr><name>oldR</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entrySL</name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entrySR</name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name> <operator>&amp;&amp;</operator> <name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum_exists</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>float</name></type>        <name>penalty1</name></decl>,
                    <decl><type ref="prev"/><name>penalty2</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>penalty1</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>+</operator>
            <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>penalty2</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>+</operator>
            <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>penalty1</name> <operator>&gt;</operator> <name>penalty2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>leaveOnLeft</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>entryL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>entryR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type>        <name>penalty1</name></decl>,
                    <decl><type ref="prev"/><name>penalty2</name></decl>;</decl_stmt>

        <comment type="block">/*
         * There is only one previously defined union, so we just choose swap
         * or not by lowest penalty for that side.  We can only get here if a
         * secondary split happened to have all NULLs in its column in the
         * tuples that the outer recursion level had assigned to one side.
         * (Note that the null checks in gistSplitByKey don't prevent the
         * case, because they'll only be checking tuples that were considered
         * don't-cares at the outer recursion level, not the tuples that went
         * into determining the passed-down left and right union keys.)
         */</comment>
        <expr_stmt><expr><name>penalty1</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>entry1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>penalty2</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>entry1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>penalty1</name> <operator>&lt;</operator> <name>penalty2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>leaveOnLeft</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>leaveOnLeft</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum_exists</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>leaveOnLeft</name> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * swap left and right
         */</comment>
        <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>off</name></decl>,
                    <decl><type ref="prev"/><name>noff</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>SWAPVAR</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_left</name></name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_right</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SWAPVAR</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nleft</name></name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nright</name></name></expr></argument>, <argument><expr><name>noff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SWAPVAR</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entrySL</name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><name>entrySR</name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>gistMakeUnionKey</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpBool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>gistMakeUnionKey</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entrySR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpBool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name> <operator>=</operator> <name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Trivial picksplit implementation. Function called only
 * if user-defined picksplit puts all keys on the same side of the split.
 * That is a bug of user-defined picksplit but we don't want to fail.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>genericPickSplit</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>, <parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
                <decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>evec</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>maxoff</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <operator>(</operator><name>maxoff</name> <operator>-</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Form union datums for each side
     */</comment>
    <expr_stmt><expr><name>evec</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name>GEVHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name></name></expr></argument>, <argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name></name> <operator>+</operator> <name>FirstOffsetNumber</name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>evec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>unionFn</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>evec</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>evec</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>evec</name><operator>-&gt;</operator><name>vector</name></name></expr></argument>, <argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name></name> <operator>+</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>evec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>unionFn</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>evec</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calls user picksplit method for attno column to split tuples into
 * two vectors.
 *
 * Returns FALSE if split is complete (there are no more index columns, or
 * there is no need to consider them because split is optimal already).
 *
 * Returns TRUE and v-&gt;spl_dontcare = NULL if the picksplit result is
 * degenerate (all tuples seem to be don't-cares), so we should just
 * disregard this column and split on the next column(s) instead.
 *
 * Returns TRUE and v-&gt;spl_dontcare != NULL if there are don't-care tuples
 * that could be relocated based on the next column(s).  The don't-care
 * tuples have been removed from the split and must be reinserted by caller.
 * There is at least one non-don't-care tuple on each side of the split,
 * and union keys for all columns are updated to include just those tuples.
 *
 * A TRUE result implies there is at least one more index column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gistUserPicksplit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>, <parameter><decl><type><name>GistSplitVector</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                  <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>sv</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>splitVector</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Prepare spl_ldatum/spl_rdatum/spl_ldatum_exists/spl_rdatum_exists in
     * case we are doing a secondary split (see comments in gist.h).
     */</comment>
    <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>spl_lisnull</name><index>[<expr><name>attno</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum_exists</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>spl_risnull</name><index>[<expr><name>attno</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_lattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_rattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the opclass-specific PickSplit method do its thing.  Note that at
     * this point we know there are no null keys in the entryvec.
     */</comment>
    <expr_stmt><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>giststate</name><operator>-&gt;</operator><name>picksplitFn</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>entryvec</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>sv</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * User-defined picksplit failed to create an actual split, ie it put
         * everything on the same side.  Complain but cope.
         */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"picksplit method for column %d of index \"%s\" failed"</literal></expr></argument>,
                        <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The index is not optimal. To optimize it, contact a developer, or try to use the column as the second one in the CREATE INDEX command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Reinit GIST_SPLITVEC. Although these fields are not used by
         * genericPickSplit(), set them up for further processing
         */</comment>
        <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>spl_lisnull</name><index>[<expr><name>attno</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum_exists</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>spl_risnull</name><index>[<expr><name>attno</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_lattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_rattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Do a generic split */</comment>
        <expr_stmt><expr><call><name>genericPickSplit</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* hack for compatibility with old picksplit API */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_left</name><index>[<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_left</name><index>[<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_right</name><index>[<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_right</name><index>[<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Clean up if PickSplit didn't take care of a secondary split */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum_exists</name></name> <operator>||</operator> <name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>supportSecondarySplit</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>,
                              <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_lattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rattr</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* emit union datums computed by PickSplit back to v arrays */</comment>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_lattr</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rattr</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_lisnull</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_risnull</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If index columns remain, then consider whether we can improve the split
     * by using them.
     */</comment>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>NumDontCare</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Make a quick check to see if left and right union keys are equal;
         * if so, the split is certainly degenerate, so tell caller to
         * re-split with the next column.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>gistKeyIsEQ</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_ldatum</name></name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_rdatum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Locate don't-care tuples, if any.  If there are none, the split is
         * optimal, so just fall out and return false.
         */</comment>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>NumDontCare</name> <operator>=</operator> <call><name>findDontCares</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>NumDontCare</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Remove don't-cares from spl_left[] and spl_right[].
             */</comment>
            <expr_stmt><expr><call><name>removeDontCares</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_left</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sv</name><operator>-&gt;</operator><name>spl_nleft</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>removeDontCares</name><argument_list>(<argument><expr><name><name>sv</name><operator>-&gt;</operator><name>spl_right</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sv</name><operator>-&gt;</operator><name>spl_nright</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If all tuples on either side were don't-cares, the split is
             * degenerate, and we're best off to ignore it and split on the
             * next column.  (We used to try to press on with a secondary
             * split by forcing a random tuple on each side to be treated as
             * non-don't-care, but it seems unlikely that that technique
             * really gives a better result.  Note that we don't want to try a
             * secondary split with empty left or right primary split sides,
             * because then there is no union key on that side for the
             * PickSplit function to try to expand, so it can have no good
             * figure of merit for what it's doing.  Also note that this check
             * ensures we can't produce a bogus one-side-only split in the
             * NumDontCare == 1 special case below.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>sv</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Recompute union keys, considering only non-don't-care tuples.
             * NOTE: this will set union keys for remaining index columns,
             * which will cause later calls of gistUserPicksplit to pass those
             * values down to user-defined PickSplit methods with
             * spl_ldatum_exists/spl_rdatum_exists set true.
             */</comment>
            <expr_stmt><expr><call><name>gistunionsubkey</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>NumDontCare</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If there's only one don't-care tuple then we can't do a
                 * PickSplit on it, so just choose whether to send it left or
                 * right by comparing penalties.  We needed the
                 * gistunionsubkey step anyway so that we have appropriate
                 * union keys for figuring the penalties.
                 */</comment>
                <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>toMove</name></decl>;</decl_stmt>

                <comment type="block">/* find it ... */</comment>
                <for>for <control>(<init><expr><name>toMove</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>toMove</name> <operator>&lt;</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>toMove</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name><index>[<expr><name>toMove</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>toMove</name> <operator>&lt;</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* ... and assign it to cheaper side */</comment>
                <expr_stmt><expr><call><name>placeOne</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>itup</name><index>[<expr><name>toMove</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>toMove</name></expr></argument>, <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * At this point the union keys are wrong, but we don't care
                 * because we're done splitting.  The outermost recursion
                 * level of gistSplitByKey will fix things before returning.
                 */</comment>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * simply split page in half
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistSplitHalf</name><parameter_list>(<parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>

    <comment type="block">/* we need not compute union keys, caller took care of it */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * gistSplitByKey: main entry point for page-splitting algorithm
 *
 * r: index relation
 * page: page being split
 * itup: array of IndexTuples to be processed
 * len: number of IndexTuples to be processed (must be at least 2)
 * giststate: additional info about index
 * v: working state and output area
 * attno: column we are working on (zero-based index)
 *
 * Outside caller must initialize v-&gt;spl_lisnull and v-&gt;spl_risnull arrays
 * to all-TRUE.  On return, spl_left/spl_nleft contain indexes of tuples
 * to go left, spl_right/spl_nright contain indexes of tuples to go right,
 * spl_lattr/spl_lisnull contain left-side union key values, and
 * spl_rattr/spl_risnull contain right-side union key values.  Other fields
 * in this struct are workspace for this file.
 *
 * Outside caller must pass zero for attno.  The function may internally
 * recurse to the next column by passing attno+1.
 */</comment>
<function><type><name>void</name></type>
<name>gistSplitByKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
               <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>GistSplitVector</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>offNullTuples</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nOffNullTuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* generate the item array, and identify tuples with null keys */</comment>
    <comment type="block">/* note that entryvec-&gt;vector[0] goes unused in this code */</comment>
    <expr_stmt><expr><name>entryvec</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>GEVHDRSZ</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>offNullTuples</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>IsNull</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name><name>itup</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>IsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistdentryinit</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
                       <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>IsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>IsNull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>offNullTuples</name><index>[<expr><name>nOffNullTuples</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>nOffNullTuples</name> <operator>==</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Corner case: All keys in attno column are null, so just transfer
         * our attention to the next column.  If there's no next column, just
         * split page in half.
         */</comment>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_risnull</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>spl_lisnull</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>gistSplitByKey</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>gistSplitHalf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>splitVector</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>nOffNullTuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We don't want to mix NULL and not-NULL keys on one page, so split
         * nulls to right page and not-nulls to left.
         */</comment>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_right</name></name> <operator>=</operator> <name>offNullTuples</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name> <operator>=</operator> <name>nOffNullTuples</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_risnull</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name> <operator>&amp;&amp;</operator> <name><name>offNullTuples</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_left</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>

        <comment type="block">/* Compute union keys, unless outer recursion level will handle it */</comment>
        <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>gistunionsubkey</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * All keys are not-null, so apply user-defined PickSplit method
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>gistUserPicksplit</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Splitting on attno column is not optimal, so consider
             * redistributing don't-care tuples according to the next column
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * This split was actually degenerate, so ignore it altogether
                 * and just split according to the next column.
                 */</comment>
                <expr_stmt><expr><call><name>gistSplitByKey</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Form an array of just the don't-care tuples to pass to a
                 * recursive invocation of this function for the next column.
                 */</comment>
                <decl_stmt><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>newitup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>newlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>GIST_SPLITVEC</name></type> <name>backupSplit</name></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>newitup</name><index>[<expr><name>newlen</name></expr>]</index></name> <operator>=</operator> <name><name>itup</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>map</name><index>[<expr><name>newlen</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>newlen</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Make a backup copy of v-&gt;splitVector, since the recursive
                 * call will overwrite that with its own result.
                 */</comment>
                <expr_stmt><expr><name>backupSplit</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>splitVector</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>backupSplit</name><operator>.</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>backupSplit</name><operator>.</operator><name>spl_left</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_left</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>backupSplit</name><operator>.</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>backupSplit</name><operator>.</operator><name>spl_right</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_right</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Recursively decide how to split the don't-care tuples */</comment>
                <expr_stmt><expr><call><name>gistSplitByKey</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>newitup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Merge result of subsplit with non-don't-care tuples */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>backupSplit</name><operator>.</operator><name>spl_left</name><index>[<expr><name><name>backupSplit</name><operator>.</operator><name>spl_nleft</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>map</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>backupSplit</name><operator>.</operator><name>spl_right</name><index>[<expr><name><name>backupSplit</name><operator>.</operator><name>spl_nright</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>map</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name><operator>.</operator><name>spl_right</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

                <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>splitVector</name></name> <operator>=</operator> <name>backupSplit</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If we're handling a multicolumn index, at the end of the recursion
     * recompute the left and right union datums for all index columns.  This
     * makes sure we hand back correct union datums in all corner cases,
     * including when we haven't processed all columns to start with, or when
     * a secondary split moved "don't care" tuples from one side to the other
     * (we really shouldn't assume that that didn't change the union datums).
     *
     * Note: when we're in an internal recursion (attno &gt; 0), we do not worry
     * about whether the union datums we return with are sensible, since
     * calling levels won't care.  Also, in a single-column index, we expect
     * that PickSplit (or the special cases above) produced correct union
     * datums.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_dontcare</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gistunionsubkey</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
