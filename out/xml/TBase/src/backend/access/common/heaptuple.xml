<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/common/heaptuple.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * heaptuple.c
 *      This file contains heap tuple accessor and mutator routines, as well
 *      as various tuple utilities.
 *
 * Some notes about varlenas and this code:
 *
 * Before Postgres 8.3 varlenas always had a 4-byte length header, and
 * therefore always needed 4-byte alignment (at least).  This wasted space
 * for short varlenas, for example CHAR(1) took 5 bytes and could need up to
 * 3 additional padding bytes for alignment.
 *
 * Now, a short varlena (up to 126 data bytes) is reduced to a 1-byte header
 * and we don't align it.  To hide this from datatype-specific functions that
 * don't want to deal with it, such a datum is considered "toasted" and will
 * be expanded back to the normal 4-byte-header format by pg_detoast_datum.
 * (In performance-critical code paths we can use pg_detoast_datum_packed
 * and the appropriate access macros to avoid that overhead.)  Note that this
 * conversion is performed directly in heap_form_tuple, without invoking
 * tuptoaster.c.
 *
 * This change will break any code that assumes it needn't detoast values
 * that have been put into a tuple but never sent to disk.  Hopefully there
 * are few such places.
 *
 * Varlenas still have alignment 'i' (or 'd') in pg_type/pg_attribute, since
 * that's the normal requirement for the untoasted format.  But we ignore that
 * for the 1-byte-header format.  This means that the actual start position
 * of a varlena datum may vary depending on which format it has.  To determine
 * what is stored, we have to require that alignment padding bytes be zero.
 * (Postgres actually has always zeroed them, but now it's required!)  Since
 * the first byte of a 1-byte-header varlena can never be zero, we can examine
 * the first byte after the previous datum to tell if it's a pad byte or the
 * start of a 1-byte-header varlena.
 *
 * Note that while formerly we could rely on the first varlena column of a
 * system catalog to be at the offset suggested by the C struct for the
 * catalog, this is now risky: it's only safe if the preceding field is
 * word-aligned, so that there will never be any padding.
 *
 * We don't pack varlenas whose attstorage is 'p', since the data type
 * isn't expecting to have to detoast values.  This is used in particular
 * by oidvector and int2vector, which are used in the system catalogs
 * and we'd like to still refer to them via C struct offsets.
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/access/common/heaptuple.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcrypt.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandeddatum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Does att's datatype allow packing into the 1-byte-header varlena format? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATT_IS_PACKABLE</name><parameter_list>(<parameter><type><name>att</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((att)-&gt;attlen == -1 &amp;&amp; (att)-&gt;attstorage != 'p')</cpp:value></cpp:define>
<comment type="block">/* Use this if it's already known varlena */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARLENA_ATT_IS_PACKABLE</name><parameter_list>(<parameter><type><name>att</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((att)-&gt;attstorage != 'p')</cpp:value></cpp:define>


<comment type="block">/* ----------------------------------------------------------------
 *                        misc support routines
 * ----------------------------------------------------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>getmissingattr</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>slot_getmissingattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startAttNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lastAttNum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>targetHeapTuple</name></decl></parameter>, <parameter><decl><type><name>MinimalTuple</name> <modifier>*</modifier></type><name>targetMinimalTuple</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>sourceTuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Per-attribute helper for heap_fill_tuple and other routines building tuples.
 *
 * Fill in either a data value or a bit in the null bitmask
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>fill_val</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl></parameter>,
         <parameter><decl><type><name>bits8</name> <modifier>*</modifier><modifier>*</modifier></type><name>bit</name></decl></parameter>,
         <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bitmask</name></decl></parameter>,
         <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dataP</name></decl></parameter>,
         <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>infomask</name></decl></parameter>,
         <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>,
         <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>data_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>*</operator><name>dataP</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we're building a null bitmap, set the appropriate bit for the
     * current column value here.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>bit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bitmask</name> <operator>!=</operator> <name>HIGHBIT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>bit</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><operator>*</operator><name>bit</name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASNULL</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><operator>*</operator><name>bit</name> <operator>|=</operator> <operator>*</operator><name>bitmask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * XXX we use the att_align macros on the pointer value itself, not on an
     * offset.  This is a bit of a hack.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* pass-by-value */</comment>
        <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_length</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* varlena */</comment>
        <decl_stmt><decl><type><name>Pointer</name></type>        <name>val</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASVARWIDTH</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * we want to flatten the expanded value so that the
                 * constructed tuple doesn't depend on it
                 */</comment>
                <decl_stmt><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eoh</name> <init>= <expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
                                                  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASEXTERNAL</name></expr>;</expr_stmt>
                <comment type="block">/* no alignment, since it's short by definition */</comment>
                <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE_EXTERNAL</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* no alignment for short varlenas */</comment>
            <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>VARLENA_ATT_IS_PACKABLE</name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <call><name>VARATT_CAN_MAKE_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* convert to short varlena -- no alignment */</comment>
            <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARATT_CONVERTED_SHORT_SIZE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_VARSIZE_SHORT</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* full 4-byte header varlena */</comment>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
                                              <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* cstring ... never needs alignment */</comment>
        <expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASVARWIDTH</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* fixed-length pass-by-reference */</comment>
        <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_length</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>data_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>dataP</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * heap_compute_data_size
 *        Determine size of the data area of a tuple to be constructed
 */</comment>
<function><type><name>Size</name></type>
<name>heap_compute_data_size</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                       <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>data_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ATTRS_EXT_IS_ENABLED</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>atti</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>atti</name> <operator>=</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ATT_IS_PACKABLE</name><argument_list>(<argument><expr><name>atti</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>VARATT_CAN_MAKE_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * we're anticipating converting to a short varlena header, so
             * adjust length and don't count any alignment
             */</comment>
            <expr_stmt><expr><name>data_length</name> <operator>+=</operator> <call><name>VARATT_CONVERTED_SHORT_SIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>atti</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
                 <call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * we want to flatten the expanded value so that the constructed
             * tuple doesn't depend on it
             */</comment>
            <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>data_length</name> <operator>+=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
                                          <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
                                              <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>data_length</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_fill_tuple
 *        Load data portion of a tuple from values/isnull arrays
 *
 * We also fill the null bitmap (if any) and set the infomask bits
 * that reflect the tuple's data contents.
 *
 * NOTE: it is now REQUIRED that the caller have pre-zeroed the data area.
 */</comment>
<function><type><name>void</name></type>
<name>heap_fill_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
                <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>data_size</name></decl></parameter>,
                <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>infomask</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>bit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>bitP</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitmask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>start</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ATTRS_EXT_IS_ENABLED</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>bit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>bitP</name> <operator>=</operator> <operator>&amp;</operator><name><name>bit</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bitmask</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* just to keep compiler quiet */</comment>
        <expr_stmt><expr><name>bitP</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_HASNULL</name> <operator>|</operator> <name>HEAP_HASVARWIDTH</name> <operator>|</operator> <name>HEAP_HASEXTERNAL</name><operator>)</operator></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>        
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fill_val</name><argument_list>(<argument><expr><name>attr</name></expr></argument>,
                 <argument><expr><ternary><condition><expr><name>bitP</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>bitP</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                 <argument><expr><operator>&amp;</operator><name>bitmask</name></expr></argument>,
                 <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,
                 <argument><expr><name>infomask</name></expr></argument>,
                 <argument><expr><ternary><condition><expr><name>values</name></expr> ?</condition><then> <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                 <argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>data</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>==</operator> <name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *                        heap tuple interface
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *        heap_attisnull    - returns TRUE iff tuple attribute is not present
 * ----------------
 */</comment>
<function><type><name>bool</name></type>
<name>heap_attisnull</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>    
    <comment type="block">/*
     * We allow a NULL tupledesc for relations not expected to have missing
     * values, such as catalog relations and indexes.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>tupleDesc</name> <operator>||</operator> <name>attnum</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tupleDesc</name> <operator>&amp;&amp;</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atthasmissing</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleNoNulls</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
        <case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
        <case>case <expr><name>ObjectIdAttributeNumber</name></expr>:</case>
        <case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
        <case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
        <case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
        <case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>XC_NodeIdAttributeNumber</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* these are never null */</comment>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum: %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        nocachegetattr
 *
 *        This only gets called from fastgetattr() macro, in cases where
 *        we can't use a cacheoffset and the value is not null.
 *
 *        This caches attribute offsets in the attribute descriptor.
 *
 *        An alternative way to speed things up would be to cache offsets
 *        with the tuple, but that seems more difficult unless you take
 *        the storage hit of actually putting those offsets into the
 *        tuple you send to disk.  Yuck.
 *
 *        This scheme will be slightly slower than that, but should
 *        perform well for queries which hit large #'s of tuples.  After
 *        you cache the offsets once, examining all the other tuples using
 *        the same attribute descriptor will go much quicker. -cim 5/4/91
 *
 *        NOTE: if you need to change this code, see also heap_deform_tuple.
 *        Also see nocache_index_getattr, which is the same code for index
 *        tuples.
 * ----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>nocachegetattr</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>,
               <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>                <comment type="block">/* ptr to data part of tuple */</comment>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>bp</name> <init>= <expr><name><name>tup</name><operator>-&gt;</operator><name>t_bits</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* ptr to null bitmap in tuple */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>slow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* do we have to walk attrs? */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>off</name></decl>;</decl_stmt>            <comment type="block">/* current offset within data */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ATTRS_EXT_IS_ENABLED</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* ----------------
     *     Three cases:
     *
     *     1: No nulls and no variable-width attributes.
     *     2: Has a null or a var-width AFTER att.
     *     3: Has nulls or var-widths BEFORE att.
     * ----------------
     */</comment>

    <expr_stmt><expr><name>attnum</name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleNoNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * there's a null somewhere in the tuple
         *
         * check to see if any preceding bits are null...
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>byte</name> <init>= <expr><name>attnum</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>finalbit</name> <init>= <expr><name>attnum</name> <operator>&amp;</operator> <literal type="number">0x07</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* check for nulls "before" final bit of last byte */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>~</operator><name><name>bp</name><index>[<expr><name>byte</name></expr>]</index></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>finalbit</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* check for nulls in any "earlier" bytes */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>byte</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>bp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0xFF</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we get here, there are no nulls up to and including the target
         * attribute.  If we have a cached offset, we can use it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name>fetchatt</name><argument_list>(<argument><expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
                            <argument><expr><name>tp</name> <operator>+</operator> <name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Otherwise, check for non-fixed-length attrs up to and including
         * target.  If there aren't any, it's safe to cheaply initialize the
         * cached offsets for these attrs.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasVarWidth</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>attnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If we get here, we have a tuple with no nulls or var-widths up to
         * and including the target attribute, so we can use the cached offset
         * ... only we don't have it yet, or we'd not have got here.  Since
         * it's cheap to compute offsets for fixed-width columns, we take the
         * opportunity to initialize the cached offsets for *all* the leading
         * fixed-width columns, in hope of avoiding future visits to this
         * routine.
         */</comment>
        <expr_stmt><expr><name><name>att</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* we might have set some offsets in the slow path previously */</comment>
        <while>while <condition>(<expr><name><name>j</name> <argument_list type="generic">&lt; <argument><expr><name>natts</name> <operator>&amp;&amp;</operator> <name><name>att</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

        <expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>att</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>+</operator> <name><name>att</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attlen</name></expr>;</expr_stmt>

        <for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>attalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>att</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>off</name> <operator>+=</operator> <name><name>att</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&gt;</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>        <name>usecache</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Now we know that we have to walk the tuple CAREFULLY.  But we still
         * might be able to cache some offsets for next time.
         *
         * Note - This loop is a little tricky.  For each non-null attribute,
         * we have to first account for alignment padding before the attr,
         * then advance over the attr based on its length.  Nulls have no
         * storage and no alignment padding either.  We can use/set
         * attcacheoff until we reach either a null or a var-width attribute.
         */</comment>
        <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>        <comment type="block">/* loop exit is at "break" */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <continue>continue;</continue>        <comment type="block">/* this cannot be the target att */</comment>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* If we know the next offset, we can skip the rest */</comment>
            <if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We can only cache the offset for a varlena attribute if the
                 * offset is already suitably aligned, so that there would be
                 * no pad bytes in any case: then the offset will be valid for
                 * either an aligned or unaligned value.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator>
                    <name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attalign</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attalign</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                            <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
                <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>usecache</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><call><name>fetchatt</name><argument_list>(<argument><expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        heap_getsysattr
 *
 *        Fetch the value of a system attribute for a tuple.
 *
 * This is a support routine for the heap_getattr macro.  The macro
 * has already determined that the attnum refers to a system attribute.
 * ----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>heap_getsysattr</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Currently, no sys attribute ever reads as NULL. */</comment>
    <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
            <comment type="block">/* pass-by-reference datatype */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ObjectIdAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
        <case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>

            <comment type="block">/*
             * cmin and cmax are now both aliases for the same field, which
             * can in fact also be a combo command id.  XXX perhaps we should
             * return the "real" cmin or cmax if possible, that is if we are
             * inside the originating transaction?
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CommandIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>XC_NodeIdAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <case>case <expr><name>ShardIdAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetShardId</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>XmaxGTSIdAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmaxTimestamp</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>XminGTSAttributeNumber</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXminTimestamp</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum: %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        heap_copytuple
 *
 *        returns a copy of an entire tuple
 *
 * The HeapTuple struct, tuple header, and tuple data are all allocated
 * as a single palloc() block.
 * ----------------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_copytuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newTuple</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>newTuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newTuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>newTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        heap_copytuple_with_tuple
 *
 *        copy a tuple into a caller-supplied HeapTuple management struct
 *
 * Note that after calling this function, the "dest" HeapTuple will not be
 * allocated as a single palloc() block (unlike with heap_copytuple()).
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>heap_copytuple_with_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>src</name><operator>-&gt;</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>dest</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>src</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        heap_copy_tuple_as_datum
 *
 *        copy a tuple as a composite-type Datum
 * ----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>heap_copy_tuple_as_datum</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If the tuple contains any external TOAST pointers, we have to inline
     * those fields to meet the conventions for composite-type Datums.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>toast_flatten_tuple_to_datum</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
                                            <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>,
                                            <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Fast path for easy case: just make a palloc'd copy and insert the
     * correct composite-Datum header fields (since those may not be set if
     * the given tuple came from disk, rather than from heap_form_tuple).
     */</comment>
    <expr_stmt><expr><name>td</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>td</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_form_tuple
 *        construct a tuple from the given values[] and isnull[] arrays,
 *        which are of the length indicated by tupleDescriptor-&gt;natts
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_form_tuple_shard</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                , <parameter><decl><type><name>SetShardFlag</name></type> <name>sflag</name></decl></parameter>,
                <parameter><decl><type><name>AttrNumber</name></type> <name>diskey</name></decl></parameter>,
                <parameter><decl><type><name>AttrNumber</name></type> <name>secdiskey</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
                <parameter><decl><type><name>ShardID</name></type>    <name>sid</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>            <comment type="block">/* return tuple */</comment>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>            <comment type="block">/* tuple data */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>,
                <decl><type ref="prev"/><name>data_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfAttributes</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <name>MaxTupleAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of columns (%d) exceeds limit (%d)"</literal></expr></argument>,
                        <argument><expr><name>numberOfAttributes</name></expr></argument>, <argument><expr><name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check for nulls
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Determine total space needed
     */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>

    <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocate and zero the space needed.  Note that the tuple body and
     * HeapTupleData management structure are allocated in one chunk.
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>td</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * And fill in the information.  Note we fill the Datum fields even though
     * this tuple may never become a Datum.  This lets HeapTupleHeaderGetDatum
     * identify the tuple type if needed.
     */</comment>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We also make sure that t_ctid is invalid unless explicitly set */</comment>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>td</name><operator>-&gt;</operator><name>t_ctid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* else leave infomask = 0 */</comment>
        <expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name>HEAP_HASOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
                    <argument><expr><name>values</name></expr></argument>,
                    <argument><expr><name>isnull</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>td</name> <operator>+</operator> <name>hoff</name></expr></argument>,
                    <argument><expr><name>data_len</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><name><name>td</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <switch>switch<condition>(<expr><name>sflag</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>SetFlag_PlainShard</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>   <name>shardId</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>  <name>isdisnull</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>   <name>typeOfDistCol</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type> <name>secvalue</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>   <name>sectypeOfDistCol</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>  <name>secisnull</name></decl>;</decl_stmt>
                
                <if_stmt><if>if<condition>(<expr><name><name>diskey</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>diskey</name></expr></argument> &gt;</argument_list></name> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AttrNum[%d] of distribute key is invalid, "</literal></expr></argument>,<argument><expr><name>diskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><name>secdiskey</name>  <operator>&gt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AttrNum[%d] of second distribute key is invalid, "</literal></expr></argument>, <argument><expr><name>secdiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>        

                <comment type="block">/* process sharding maping */</comment>        
                <expr_stmt><expr><name>typeOfDistCol</name> <operator>=</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>value</name>           <operator>=</operator> <name><name>values</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>isdisnull</name>      <operator>=</operator> <name><name>isnull</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

                <comment type="block">/* secondary distribute key */</comment>
                <if_stmt><if>if <condition>(<expr><name>secdiskey</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>sectypeOfDistCol</name> <operator>=</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>secvalue</name>          <operator>=</operator> <name><name>values</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>secisnull</name>         <operator>=</operator> <name><name>isnull</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>sectypeOfDistCol</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    
                    <expr_stmt><expr><name>secvalue</name>         <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>secisnull</name>        <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
        
                <expr_stmt><expr><name>shardId</name> <operator>=</operator> <call><name>EvaluateShardId</name><argument_list>(<argument><expr><name>typeOfDistCol</name></expr></argument>, <argument><expr><name>isdisnull</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, 
                                          <argument><expr><name>sectypeOfDistCol</name></expr></argument>, <argument><expr><name>secisnull</name></expr></argument>, <argument><expr><name>secvalue</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HeapTupleHeaderSetShardId</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>SetFlag_ToastShard</name></expr>:</case>
            <expr_stmt><expr><call><name>HeapTupleHeaderSetShardId</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <break>break;</break>
        <case>case <expr><name>SetFlag_NoShard</name></expr>:</case>
        <default>default:</default>
            <expr_stmt><expr><call><name>HeapTupleHeaderSetShardId</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>InvalidShardID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_modify_tuple
 *        form a new tuple from an old tuple and a set of replacement values.
 *
 * The replValues, replIsnull, and doReplace arrays must be of the length
 * indicated by tupleDesc-&gt;natts.  The new tuple is constructed using the data
 * from replValues/replIsnull at columns where doReplace is true, and using
 * the data from the old tuple at columns where doReplace is false.
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_modify_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>replValues</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>replIsnull</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>doReplace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newTuple</name></decl>;</decl_stmt>

    <comment type="block">/*
     * allocate and fill values and isnull arrays from either the tuple or the
     * repl information, as appropriate.
     *
     * NOTE: it's debatable whether to use heap_deform_tuple() here or just
     * heap_getattr() only the non-replaced columns.  The latter could win if
     * there are many replaced columns and few non-replaced ones. However,
     * heap_deform_tuple costs only O(N) while the heap_getattr way would cost
     * O(N^2) if there are many non-replaced columns, so it seems better to
     * err on the side of linear cost.
     */</comment>
    <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>attoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attoff</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>attoff</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>doReplace</name><index>[<expr><name>attoff</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>attoff</name></expr>]</index></name> <operator>=</operator> <name><name>replValues</name><index>[<expr><name>attoff</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attoff</name></expr>]</index></name> <operator>=</operator> <name><name>replIsnull</name><index>[<expr><name>attoff</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * create a new tuple from the values and isnull arrays
     */</comment>
    <expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * copy the identification info of the old tuple: t_ctid, t_self, and OID
     * (if any)
     */</comment>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>newTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_modify_tuple_by_cols
 *        form a new tuple from an old tuple and a set of replacement values.
 *
 * This is like heap_modify_tuple, except that instead of specifying which
 * column(s) to replace by a boolean map, an array of target column numbers
 * is used.  This is often more convenient when a fixed number of columns
 * are to be replaced.  The replCols, replValues, and replIsnull arrays must
 * be of length nCols.  Target column numbers are indexed from 1.
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_modify_tuple_by_cols</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                          <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>nCols</name></decl></parameter>,
                          <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>replCols</name></decl></parameter>,
                          <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>replValues</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>replIsnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>newTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * allocate and fill values and isnull arrays from the tuple, then replace
     * selected columns from the input arrays.
     */</comment>
    <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name> <init>= <expr><name><name>replCols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>attnum</name> <operator>&gt;</operator> <name>numberOfAttributes</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid column number %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>replValues</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>replIsnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * create a new tuple from the values and isnull arrays
     */</comment>
    <expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * copy the identification info of the old tuple: t_ctid, t_self, and OID
     * (if any)
     */</comment>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>newTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_deform_tuple
 *        Given a tuple, extract data into values/isnull arrays; this is
 *        the inverse of heap_form_tuple.
 *
 *        Storage for the values/isnull arrays is provided by the caller;
 *        it should be sized according to tupleDesc-&gt;natts not
 *        HeapTupleHeaderGetNatts(tuple-&gt;t_data).
 *
 *        Note that for pass-by-reference datatypes, the pointer placed
 *        in the Datum will point into the given tuple.
 *
 *        When all or most of a tuple's fields need to be extracted,
 *        this routine will be significantly quicker than a loop around
 *        heap_getattr; the loop will become O(N^2) as soon as any
 *        noncacheable attribute offsets are involved.
 */</comment>
<function><type><name>void</name></type>
<name>heap_deform_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasnulls</name> <init>= <expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tdesc_natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name></decl>;</decl_stmt>            <comment type="block">/* number of atts to extract */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>                <comment type="block">/* ptr to tuple data */</comment>
    <decl_stmt><decl><type><name>long</name></type>        <name>off</name></decl>;</decl_stmt>            <comment type="block">/* offset in tuple data */</comment>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>bp</name> <init>= <expr><name><name>tup</name><operator>-&gt;</operator><name>t_bits</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* ptr to null bitmap in tuple */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>slow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* can we use/set attcacheoff? */</comment>

    <expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ATTRS_EXT_IS_ENABLED</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * In inheritance situations, it is possible that the given tuple actually
     * has more fields than the caller is expecting.  Don't run off the end of
     * the caller's arrays.
     */</comment>
    <expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>natts</name></expr></argument>, <argument><expr><name>tdesc_natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>hasnulls</name> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* can't use attcacheoff anymore */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We can only cache the offset for a varlena attribute if the
             * offset is already suitably aligned, so that there would be no
             * pad bytes in any case: then the offset will be valid for either
             * an aligned or unaligned value.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator>
                <name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                        <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
            <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>fetchatt</name><argument_list>(<argument><expr><name>thisatt</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* can't use attcacheoff anymore */</comment>
    </block_content>}</block></for>

    <comment type="block">/*
     * If tuple doesn't have all the atts indicated by tupleDesc, read the
     * rest as nulls or missing values as appropriate.
     */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>tdesc_natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>getmissingattr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * slot_deform_tuple
 *        Given a TupleTableSlot, extract data from the slot's physical tuple
 *        into its Datum/isnull arrays.  Data is extracted up through the
 *        natts'th column (caller must ensure this is a legal column number).
 *
 *        This is essentially an incremental version of heap_deform_tuple:
 *        on each call we extract attributes up to the one needed, without
 *        re-computing information about previously extracted attributes.
 *        slot-&gt;tts_nvalid is the number of attributes already extracted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slot_deform_tuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>isnull</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasnulls</name> <init>= <expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>                <comment type="block">/* ptr to tuple data */</comment>
    <decl_stmt><decl><type><name>long</name></type>        <name>off</name></decl>;</decl_stmt>            <comment type="block">/* offset in tuple data */</comment>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>bp</name> <init>= <expr><name><name>tup</name><operator>-&gt;</operator><name>t_bits</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* ptr to null bitmap in tuple */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>slow</name></decl>;</decl_stmt>            <comment type="block">/* can we use/set attcacheoff? */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>TRANSP_CRYPT_ATTRS_EXT_IS_ENABLED</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs_ext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Check whether the first call for this tuple, and initialize or restore
     * loop state.
     */</comment>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Start from the first attribute */</comment>
        <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Restore state from previous execution */</comment>
        <expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_off</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>slow</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_slow</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><name><name>att</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>hasnulls</name> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* can't use attcacheoff anymore */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We can only cache the offset for a varlena attribute if the
             * offset is already suitably aligned, so that there would be no
             * pad bytes in any case: then the offset will be valid for either
             * an aligned or unaligned value.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator>
                <name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                        <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
            <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>fetchatt</name><argument_list>(<argument><expr><name>thisatt</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>        <comment type="block">/* can't use attcacheoff anymore */</comment>
    </block_content>}</block></for>

    <comment type="block">/*
     * Save state for next execution
     */</comment>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_off</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_slow</name></name> <operator>=</operator> <name>slow</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * get maximum bytes number from column define size, if column is bounded string, return -1
 * then InputFunctionCall -&gt; varchar2_input|varchar_input|varchar2_input|nvarchar2_input
 * avoid to verification the length of string which encoded by client encode
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_typioparam_mod</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>typioparam</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CHAROID</name></expr>:</case>
        <case>case <expr><name>BPCHAROID</name></expr>:</case>
        <case>case <expr><name>VARCHAROID</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_ORCL_</name></cpp:ifdef>
        <case>case <expr><name>VARCHAR2OID</name></expr>:</case>
		<case>case <expr><name>NVARCHAR2OID</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

        <default>default:</default>
            <return>return <expr><name>typmod</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * slot_deform_datarow
 *         Extract data from the DataRow message into Datum/isnull arrays.
 *
 * We always extract all attributes, as specified in tts_tupleDescriptor,
 * because there is no easy way to find random attribute in the DataRow.
 *
 * XXX There's an opportunity for optimization - we might extract only the
 * attributes we already need (up to some attnum), and keep a pointer to
 * the next byte in the DataRow message. On the next call we can either
 * return immediately if the attnum is already extracted, or deform next
 * chunk of the message. Not sure if this is worth the effort, as we're
 * likely to extract all attributes from the message eventually.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slot_deform_datarow</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>col_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfo</name></type>  <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>n16</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <comment type="block">/* fastpath: exit if values already extracted */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>==</operator> <name>natts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>col_count</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>col_count</name> <operator>!=</operator> <name>natts</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Tuple does not match the descriptor, tuple cols %d, descriptor cols %d"</literal></expr></argument>, 
				 <argument><expr><name>col_count</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Ensure info about input functions is available as long as slot lives
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Store values to separate context to easily free them when base datarow is
     * freed
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>,
                                                  <argument><expr><literal type="string">"Datarow"</literal></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

        <comment type="block">/* get size */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* get data */</comment>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* composite type */</comment>
            <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl>;</decl_stmt>
                
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>create_tuple_desc</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>assign_record_type_typmod</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>cur</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name></name> <operator>+</operator> <name>i</name></expr></argument>,
                                                    <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
                                                    <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name><operator>-&gt;</operator><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                    <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Pointer</name></type>        <name>val</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Size</name></type>        <name>data_length</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* varlena */</comment>
                    <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* cstring */</comment>
                    <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* fixed-length pass-by-reference */</comment>
                    <expr_stmt><expr><name>data_length</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>typmod</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name><operator>-&gt;</operator><name>atttypmods</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name>pg_get_client_encoding</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
                            <call><name>pg_get_client_encoding</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>PG_SQL_ASCII</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>get_typioparam_mod</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name><operator>-&gt;</operator><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name></name> <operator>+</operator> <name>i</name></expr></argument>,
                                                    <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
                                                    <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_attinmeta</name><operator>-&gt;</operator><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                    <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The input function was executed in caller's memory context,
             * because it may be allocating working memory, and caller may
             * want to clean it up.
             * However returned Datums need to be in the special context, so
             * if attribute is pass-by-reference, copy it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Pointer</name></type>        <name>val</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Size</name></type>        <name>data_length</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* varlena */</comment>
                    <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* cstring */</comment>
                    <expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* fixed-length pass-by-reference */</comment>
                    <expr_stmt><expr><name>data_length</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_drowcxt</name></name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * slot_getattr
 *        This function fetches an attribute of the slot's current tuple.
 *        It is functionally equivalent to heap_getattr, but fetches of
 *        multiple attributes of the same tuple will be optimized better,
 *        because we avoid O(N^2) behavior from multiple calls of
 *        nocachegetattr(), even when attcacheoff isn't usable.
 *
 *        A difference from raw heap_getattr is that attnums beyond the
 *        slot's tupdesc's last attribute will be considered NULL even
 *        when the physical tuple is longer than the tupdesc.
 */</comment>
<function><type><name>Datum</name></type>
<name>slot_getattr</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl>;</decl_stmt>

    <comment type="block">/*
     * system attributes are handled by heap_getsysattr
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>        <comment type="block">/* internal error */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract system attribute from virtual tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <operator>&amp;</operator><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_minhdr</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* internal error */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract system attribute from minimal tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><call><name>heap_getsysattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * fast path if desired attribute already cached
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * return NULL if attnum is out of range according to the tupdesc
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* If it is a data row tuple extract all and return requested */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_deform_datarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * otherwise we had better have a physical tuple (tts_nvalid should equal
     * natts in all virtual-tuple cases)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract attribute from empty tuple slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * return NULL if attnum is out of range according to the tuple
     *
     * (We have to check this separately because of various inheritance and
     * table-alteration scenarios: the tuple could be either longer or shorter
     * than the tupdesc.)
     */</comment>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>        
        <return>return <expr><call><name>getmissingattr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * check if target attribute is null: no point in groveling through tuple
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_bits</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the attribute's column has been dropped, we force a NULL result.
     * This case should not happen in normal use, but it could happen if we
     * are executing a plan cached before the column was dropped.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Extract the attribute, along with any preceding attributes.
     */</comment>
    <expr_stmt><expr><call><name>slot_deform_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The result is acquired from tts_values array.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * slot_getallattrs
 *        This function forces all the entries of the slot's Datum/isnull
 *        arrays to be valid.  The caller may then extract data directly
 *        from those arrays instead of using slot_getattr.
 */</comment>
<function><type><name>void</name></type>
<name>slot_getallattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>tdesc_natts</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <comment type="block">/* Quick out if we have 'em all already */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>==</operator> <name>tdesc_natts</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Handle the DataRow tuple case */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_deform_datarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * otherwise we had better have a physical tuple (tts_nvalid should equal
     * natts in all virtual-tuple cases)
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract attribute from empty tuple slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * load up any slots available from physical tuple
     */</comment>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tdesc_natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>slot_deform_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If tuple doesn't have all the atts indicated by tupleDesc, read the
     * rest as NULLS or missing values.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>    
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;</operator> <name>tdesc_natts</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_getmissingattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tdesc_natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>tdesc_natts</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * slot_getsomeattrs
 *        This function forces the entries of the slot's Datum/isnull
 *        arrays to be valid at least up through the attnum'th entry.
 */</comment>
<function><type><name>void</name></type>
<name>slot_getsomeattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attno</name></decl>;</decl_stmt>

    <comment type="block">/* Quick out if we have 'em all already */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>&gt;=</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* Handle the DataRow tuple case */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_deform_datarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Check for caller error */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>attnum</name> <operator>&gt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * otherwise we had better have a physical tuple (tts_nvalid should equal
     * natts in all virtual-tuple cases)
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract attribute from empty tuple slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * load up any slots available from physical tuple
     */</comment>
    <expr_stmt><expr><name>attno</name> <operator>=</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attno</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>attno</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>slot_deform_tuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If tuple doesn't have all the atts indicated by tupleDesc, read the
     * rest as NULLs or missing values
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>     
    <if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;</operator> <name>attnum</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_getmissingattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * slot_attisnull
 *        Detect whether an attribute of the slot is null, without
 *        actually fetching it.
 */</comment>
<function><type><name>bool</name></type>
<name>slot_attisnull</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * system attributes are handled by heap_attisnull
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>        <comment type="block">/* internal error */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract system attribute from virtual tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <operator>&amp;</operator><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_minhdr</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* internal error */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract system attribute from minimal tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>    
        <return>return <expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * fast path if desired attribute already cached
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * return NULL if attnum is out of range according to the tupdesc
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* If it is a data row tuple extract all and return requested */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>slot_deform_datarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * otherwise we had better have a physical tuple (tts_nvalid should equal
     * natts in all virtual-tuple cases)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* internal error */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extract attribute from empty tuple slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* and let the tuple tell it */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>    
    <return>return <expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * heap_freetuple
 */</comment>
<function><type><name>void</name></type>
<name>heap_freetuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * heap_form_minimal_tuple
 *        construct a MinimalTuple from the given values[] and isnull[] arrays,
 *        which are of the length indicated by tupleDescriptor-&gt;natts
 *
 * This is exactly like heap_form_tuple() except that the result is a
 * "minimal" tuple lacking a HeapTupleData header as well as room for system
 * columns.
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>heap_form_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
                        <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>            <comment type="block">/* return tuple */</comment>
    <decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>,
                <decl><type ref="prev"/><name>data_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numberOfAttributes</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <name>MaxTupleAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of columns (%d) exceeds limit (%d)"</literal></expr></argument>,
                        <argument><expr><name>numberOfAttributes</name></expr></argument>, <argument><expr><name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check for nulls
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Determine total space needed
     */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>SizeofMinimalTupleHeader</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>

    <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocate and zero the space needed.
     */</comment>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * And fill in the information.
     */</comment>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* else leave infomask = 0 */</comment>
        <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name>HEAP_HASOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
                    <argument><expr><name>values</name></expr></argument>,
                    <argument><expr><name>isnull</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>hoff</name></expr></argument>,
                    <argument><expr><name>data_len</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_shardid</name></name> <operator>=</operator> <name>InvalidShardID</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_free_minimal_tuple
 */</comment>
<function><type><name>void</name></type>
<name>heap_free_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_copy_minimal_tuple
 *        copy a MinimalTuple
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>heap_copy_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>mtup</name></expr></argument>, <argument><expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_tuple_from_minimal_tuple
 *        create a HeapTuple by copying from a MinimalTuple;
 *        system columns are filled with zeroes
 *
 * The result is allocated in the current memory context.
 * The HeapTuple struct, tuple header, and tuple data are all allocated
 * as a single palloc() block.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_tuple_from_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>len</name> <init>= <expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>result</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></argument>, <argument><expr><name>mtup</name></expr></argument>, <argument><expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_infomask2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * minimal_tuple_from_heap_tuple
 *        create a MinimalTuple by copying from a HeapTuple
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>minimal_tuple_from_heap_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>htup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>&gt;</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<comment type="block">/*
 * Return the missing value of an attribute, or NULL if there isn't one.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>getmissingattr</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>false</name> <operator>==</operator> <name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>attrmiss</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name> <operator>+</operator> <operator>(</operator><name>attnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>attrmiss</name><operator>-&gt;</operator><name>ammissingPresent</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <return>return <expr><name><name>attrmiss</name><operator>-&gt;</operator><name>ammissing</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fill in missing values for a TupleTableSlot.
 *
 * This is only exposed because it's needed for JIT compiled tuple
 * deforming. That exception aside, there should be no callers outside of this
 * file.
 */</comment>
<function><type><name>void</name></type>
<name>slot_getmissingattrs</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startAttNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lastAttNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>missattnum</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>attrmiss</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrmiss</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* no missing values array at all, so just fill everything in as NULL */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name> <operator>+</operator> <name>startAttNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
               <argument><expr><operator>(</operator><name>lastAttNum</name> <operator>-</operator> <name>startAttNum</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name> <operator>+</operator> <name>startAttNum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
               <argument><expr><operator>(</operator><name>lastAttNum</name> <operator>-</operator> <name>startAttNum</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* if there is a missing values array we must process them one by one */</comment>
        <for>for <control>(<init><expr><name>missattnum</name> <operator>=</operator> <name>startAttNum</name></expr>;</init>
             <condition><expr><name>missattnum</name> <operator>&lt;</operator> <name>lastAttNum</name></expr>;</condition>
             <incr><expr><name>missattnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>missattnum</name></expr>]</index></name> <operator>=</operator> <name><name>attrmiss</name><index>[<expr><name>missattnum</name></expr>]</index></name><operator>.</operator><name>ammissing</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>missattnum</name></expr>]</index></name> <operator>=</operator>
                <operator>!</operator><name><name>attrmiss</name><index>[<expr><name>missattnum</name></expr>]</index></name><operator>.</operator><name>ammissingPresent</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Expand a tuple which has less attributes than required. For each attribute
 * not present in the sourceTuple, if there is a missing value that will be
 * used. Otherwise the attribute will be set to NULL.
 *
 * The source tuple must have less attributes than the required number.
 *
 * Only one of targetHeapTuple and targetMinimalTuple may be supplied. The
 * other argument must be NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>targetHeapTuple</name></decl></parameter>,
             <parameter><decl><type><name>MinimalTuple</name> <modifier>*</modifier></type><name>targetMinimalTuple</name></decl></parameter>,
             <parameter><decl><type><name>HeapTuple</name></type> <name>sourceTuple</name></decl></parameter>,
             <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>firstmissingnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasNulls</name> <init>= <expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>sourceTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>targetTHeader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>sourceTHeader</name> <init>= <expr><name><name>sourceTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sourceNatts</name> <init>= <expr><call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name>sourceTHeader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>sourceNullLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>targetNullLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>sourceDataLen</name> <init>= <expr><name><name>sourceTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>targetDataLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>hoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bits8</name>       <modifier>*</modifier></type><name>nullBits</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>bitMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>targetData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name>       <modifier>*</modifier></type><name>infoMask</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>targetHeapTuple</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>targetMinimalTuple</name><operator>)</operator>
           <operator>||</operator> <operator>(</operator><operator>!</operator><name>targetHeapTuple</name> <operator>&amp;&amp;</operator> <name>targetMinimalTuple</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sourceNatts</name> <operator>&lt;</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sourceNullLen</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>hasNulls</name></expr> ?</condition><then> <expr><call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>sourceNatts</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>targetDataLen</name> <operator>=</operator> <name>sourceDataLen</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
        <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If there are missing values we want to put them into the tuple.
         * Before that we have to compute the extra length for the values
         * array and the variable length data.
         */</comment>
        <expr_stmt><expr><name>attrmiss</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Find the first item in attrmiss for which we don't have a value in
         * the source. We can ignore all the missing entries before that.
         */</comment>
        <for>for <control>(<init><expr><name>firstmissingnum</name> <operator>=</operator> <name>sourceNatts</name></expr>;</init>
             <condition><expr><name>firstmissingnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition>
             <incr><expr><name>firstmissingnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>attrmiss</name><index>[<expr><name>firstmissingnum</name></expr>]</index></name><operator>.</operator><name>ammissingPresent</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * If there are no more missing values everything else must be NULL
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>firstmissingnum</name> <operator>&gt;=</operator> <name>natts</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hasNulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="block">/*
             * Now walk the missing attributes. If there is a missing value
             * make space for it. Otherwise, it's going to be NULL.
             */</comment>
            <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <name>firstmissingnum</name></expr>;</init>
                 <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition>
                 <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>ammissingPresent</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>targetDataLen</name> <operator>=</operator> <call><name>att_align_datum</name><argument_list>(<argument><expr><name>targetDataLen</name></expr></argument>,
                                                    <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
                                                    <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
                                                    <argument><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>ammissing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>targetDataLen</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>targetDataLen</name></expr></argument>,
                                                          <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
                                                          <argument><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>ammissing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* no missing value, so it must be null */</comment>
                    <expr_stmt><expr><name>hasNulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>                            <comment type="block">/* end if have missing values */</comment>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If there are no missing values at all then NULLS must be allowed,
         * since some of the attributes are known to be absent.
         */</comment>
        <expr_stmt><expr><name>hasNulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>hasNulls</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>targetNullLen</name> <operator>=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>targetNullLen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>targetNullLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Allocate and zero the space needed.  Note that the tuple body and
     * HeapTupleData management structure are allocated in one chunk.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>targetHeapTuple</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>targetDataLen</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>targetHeapTuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_data</name></name>
            <operator>=</operator> <name>targetTHeader</name>
            <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>targetHeapTuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>sourceTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We also make sure that t_ctid is invalid unless explicitly set */</comment>
        <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_ctid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>targetNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nullBits</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_data</name></name>
                                  <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>targetData</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>hoff</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>infoMask</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SizeofMinimalTupleHeader</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>targetDataLen</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>targetMinimalTuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
        <comment type="block">/* Same macro works for MinimalTuples */</comment>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><operator>*</operator><name>targetMinimalTuple</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>targetNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nullBits</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>targetMinimalTuple</name>
                                  <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>MinimalTupleData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>targetData</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>targetMinimalTuple</name> <operator>+</operator> <name>hoff</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>infoMask</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>targetNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>sourceNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* if bitmap pre-existed copy in - all is set */</comment>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nullBits</name></expr></argument>,
                   <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sourceTHeader</name><operator>)</operator>
                   <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>sourceNullLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nullBits</name> <operator>+=</operator> <name>sourceNullLen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>sourceNullLen</name> <operator>=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>sourceNatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Set NOT NULL for all existing attributes */</comment>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nullBits</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>sourceNullLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>nullBits</name> <operator>+=</operator> <name>sourceNullLen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>sourceNatts</name> <operator>&amp;</operator> <literal type="number">0x07</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* build the mask (inverted!) */</comment>
                <expr_stmt><expr><name>bitMask</name> <operator>=</operator> <literal type="number">0xff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>sourceNatts</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr>;</expr_stmt>
                <comment type="block">/* Voila */</comment>
                <expr_stmt><expr><operator>*</operator><name>nullBits</name> <operator>=</operator> <operator>~</operator><name>bitMask</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>bitMask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>sourceNatts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>                            <comment type="block">/* End if have null bitmap */</comment>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>targetData</name></expr></argument>,
           <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>sourceTuple</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>,
           <argument><expr><name>sourceDataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>targetData</name> <operator>+=</operator> <name>sourceDataLen</name></expr>;</expr_stmt>

    <comment type="block">/* Now fill in the missing values */</comment>
    <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <name>sourceNatts</name></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>

        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>attrmiss</name> <operator>&amp;&amp;</operator> <name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>ammissingPresent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fill_val</name><argument_list>(<argument><expr><name>attr</name></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>nullBits</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>nullBits</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>bitMask</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>targetData</name></expr></argument>,
                     <argument><expr><name>infoMask</name></expr></argument>,
                     <argument><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>ammissing</name></expr></argument>,
                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>fill_val</name><argument_list>(<argument><expr><name>attr</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>nullBits</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>bitMask</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>targetData</name></expr></argument>,
                     <argument><expr><name>infoMask</name></expr></argument>,
                     <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                     <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>                            <comment type="block">/* end loop over missing attributes */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Fill in the missing values for a minimal HeapTuple
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>minimal_expand_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>sourceTuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MinimalTuple</name></type> <name>minimalTuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>expand_tuple</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minimalTuple</name></expr></argument>, <argument><expr><name>sourceTuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>minimalTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fill in the missing values for an ordinary HeapTuple
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_expand_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>sourceTuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>heapTuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>expand_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heapTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sourceTuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>heapTuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>slot_deform_tuple_extern</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>slot_deform_tuple</name><argument_list>(<argument><expr><operator>(</operator><name>TupleTableSlot</name><operator>*</operator><operator>)</operator><name>slot</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>heap_tuple_set_shardid</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tupleslot</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>diskey</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>secdiskey</name></decl></parameter>,
				             <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>   <name>shardId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>  <name>isdisnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>   <name>typeOfDistCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>secvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>   <name>sectypeOfDistCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>  <name>secisnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>(</operator><name>TupleTableSlot</name> <operator>*</operator><operator>)</operator><name>tupleslot</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if<condition>(<expr><name><name>diskey</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>diskey</name></expr></argument> &gt;</argument_list></name> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AttrNum[%d] of distribute key is invalid, "</literal></expr></argument>,<argument><expr><name>diskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>secdiskey</name>  <operator>&gt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AttrNum[%d] of second distribute key is invalid, "</literal></expr></argument>, <argument><expr><name>secdiskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>		

	<comment type="block">/* process sharding maping */</comment>		
	<expr_stmt><expr><name>typeOfDistCol</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name>     	  <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>isdisnull</name>	  <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>diskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* secondary distribute key */</comment>
	<if_stmt><if>if <condition>(<expr><name>secdiskey</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sectypeOfDistCol</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>secvalue</name>     	 <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>secisnull</name>	     <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>secdiskey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sectypeOfDistCol</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	
		<expr_stmt><expr><name>secvalue</name>         <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>secisnull</name>        <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>shardId</name> <operator>=</operator> <call><name>EvaluateShardId</name><argument_list>(<argument><expr><name>typeOfDistCol</name></expr></argument>, <argument><expr><name>isdisnull</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, 
		                      <argument><expr><name>sectypeOfDistCol</name></expr></argument>, <argument><expr><name>secisnull</name></expr></argument>, <argument><expr><name>secvalue</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetShardId</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
