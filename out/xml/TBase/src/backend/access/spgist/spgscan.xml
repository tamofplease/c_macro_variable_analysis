<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/spgist/spgscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spgscan.c
 *      routines for scanning SP-GiST indexes
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *            src/backend/access/spgist/spgscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>storeRes_func</name>) <parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
                               <parameter><decl><type><name>Datum</name></type> <name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>ScanStackEntry</name>
<block>{
    <decl_stmt><decl><type><name>Datum</name></type>        <name>reconstructedValue</name></decl>;</decl_stmt> <comment type="block">/* value reconstructed from parent */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>traversalValue</name></decl>;</decl_stmt> <comment type="block">/* opclass-specific traverse value */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>level</name></decl>;</decl_stmt>            <comment type="block">/* level of items on this page */</comment>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>ptr</name></decl>;</decl_stmt>        <comment type="block">/* block and offset to scan from */</comment>
}</block></struct></type> <name>ScanStackEntry</name>;</typedef>


<comment type="block">/* Free a ScanStackEntry */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freeScanStackEntry</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ScanStackEntry</name> <modifier>*</modifier></type><name>stackEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attType</name><operator>.</operator><name>attbyval</name></name> <operator>&amp;&amp;</operator>
        <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>reconstructedValue</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>reconstructedValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>stackEntry</name><operator>-&gt;</operator><name>traversalValue</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>traversalValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stackEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free the entire stack */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freeScanStack</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>so-&gt;scanStack</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>freeScanStackEntry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><operator>(</operator><name>ScanStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize scanStack to search the root page, resetting
 * any previously active scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resetSpGistScanOpaque</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanStackEntry</name> <modifier>*</modifier></type><name>startEntry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>freeScanStack</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Stack a work item to scan the null index entries */</comment>
        <expr_stmt><expr><name>startEntry</name> <operator>=</operator> <operator>(</operator><name>ScanStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanStackEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>startEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>SPGIST_NULL_BLKNO</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name></expr></argument>, <argument><expr><name>startEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Stack a work item to scan the non-null index entries */</comment>
        <expr_stmt><expr><name>startEntry</name> <operator>=</operator> <operator>(</operator><name>ScanStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanStackEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>startEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>SPGIST_ROOT_BLKNO</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name></expr></argument>, <argument><expr><name>startEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Must pfree reconstructed tuples to avoid memory leak */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare scan keys in SpGistScanOpaque from caller-given scan keys
 *
 * Sets searchNulls, searchNonNulls, numberOfKeys, keyData fields of *so.
 *
 * The point here is to eliminate null-related considerations from what the
 * opclass consistent functions need to deal with.  We assume all SPGiST-
 * indexable operators are strict, so any null RHS value makes the scan
 * condition unsatisfiable.  We also pull out any IS NULL/IS NOT NULL
 * conditions; their effect is reflected into searchNulls/searchNonNulls.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgPrepareScanKeys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>qual_ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>haveIsNull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>haveNotNull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If no quals, whole-index scan is required */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Examine the given quals */</comment>
    <expr_stmt><expr><name>qual_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>haveIsNull</name> <operator>=</operator> <name>haveNotNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanKey</name></type>        <name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>haveIsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>haveNotNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* ordinary qual with null argument - unsatisfiable */</comment>
            <expr_stmt><expr><name>qual_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* ordinary qual, propagate into so-&gt;keyData */</comment>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>nkeys</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>skey</name></expr>;</expr_stmt>
            <comment type="block">/* this effectively creates a not-null requirement */</comment>
            <expr_stmt><expr><name>haveNotNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* IS NULL in combination with something else is unsatisfiable */</comment>
    <if_stmt><if>if <condition>(<expr><name>haveIsNull</name> <operator>&amp;&amp;</operator> <name>haveNotNull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>qual_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Emit results */</comment>
    <if_stmt><if>if <condition>(<expr><name>qual_ok</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name> <operator>=</operator> <name>haveIsNull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name> <operator>=</operator> <name>haveNotNull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>IndexScanDesc</name></type>
<name>spgbeginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>orderbysz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>RelationGetIndexScan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistScanOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>keysz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>keysz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>initSpGistState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                        <argument><expr><literal type="string">"SP-GiST search temporary context"</literal></expr></argument>,
                                        <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up indexTupDesc and xs_hitupdesc in case it's an index-only scan */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>indexTupDesc</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>xs_hitupdesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>so</name></expr>;</expr_stmt>

    <return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spgrescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nscankeys</name></decl></parameter>,
          <parameter><decl><type><name>ScanKey</name></type> <name>orderbys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* copy scankeys into local storage */</comment>
    <if_stmt><if>if <condition>(<expr><name>scankey</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>,
                <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* preprocess scankeys, set up the representation in *so */</comment>
    <expr_stmt><expr><call><name>spgPrepareScanKeys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set up starting stack entries */</comment>
    <expr_stmt><expr><call><name>resetSpGistScanOpaque</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spgendscan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether a leaf tuple satisfies all the scan keys
 *
 * *leafValue is set to the reconstructed datum, if provided
 * *recheck is set true if any of the operators are lossy
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>spgLeafTest</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>,
            <parameter><decl><type><name>SpGistLeafTuple</name></type> <name>leafTuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>reconstructedValue</name></decl></parameter>,
            <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>traversalValue</name></decl></parameter>,
            <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>leafDatum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>spgLeafConsistentIn</name></type> <name>in</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>spgLeafConsistentOut</name></type> <name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Should not have arrived on a nulls page unless nulls are wanted */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>leafValue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>leafDatum</name> <operator>=</operator> <call><name>SGLTDATUM</name><argument_list>(<argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* use temp context for calling leaf_consistent */</comment>
    <expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>in</name><operator>.</operator><name>scankeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>in</name><operator>.</operator><name>nkeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>in</name><operator>.</operator><name>reconstructedValue</name></name> <operator>=</operator> <name>reconstructedValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>in</name><operator>.</operator><name>traversalValue</name></name> <operator>=</operator> <name>traversalValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>in</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>in</name><operator>.</operator><name>returnData</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>in</name><operator>.</operator><name>leafDatum</name></name> <operator>=</operator> <name>leafDatum</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>out</name><operator>.</operator><name>leafValue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>.</operator><name>recheck</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_LEAF_CONSISTENT_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>procinfo</name></expr></argument>,
                                            <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>leafValue</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>leafValue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>recheck</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Walk the tree and report all tuples passing the scan quals to the storeRes
 * subroutine.
 *
 * If scanWholeIndex is true, we'll do just that.  If not, we'll stop at the
 * next page boundary once we have reported at least one tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgWalk</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>scanWholeIndex</name></decl></parameter>,
        <parameter><decl><type><name>storeRes_func</name></type> <name>storeRes</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>reportedSome</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>scanWholeIndex</name> <operator>||</operator> <operator>!</operator><name>reportedSome</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ScanStackEntry</name> <modifier>*</modifier></type><name>stackEntry</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

        <comment type="block">/* Pull next to-do item from the list */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* there are no more pages to scan */</comment>

        <expr_stmt><expr><name>stackEntry</name> <operator>=</operator> <operator>(</operator><name>ScanStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>redirect</name>:</label>
        <comment type="block">/* Check for interrupts, just in case of infinite loop */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>blkno</name> <operator>!=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* else new pointer points to the same page, no work needed */</comment>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>isnull</name> <operator>=</operator> <ternary><condition><expr><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>leafTuple</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>max</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>leafValue</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>recheck</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* When root is a leaf, examine all its tuples */</comment>
                <for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offset</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>offset</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator>
                        <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_LIVE</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* all tuples on root should be live */</comment>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>,
                             <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>spgLeafTest</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>so</name></expr></argument>,
                                    <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
                                    <argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>level</name></name></expr></argument>,
                                    <argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>reconstructedValue</name></name></expr></argument>,
                                    <argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>traversalValue</name></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>leafValue</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>storeRes</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>leafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>,
                                 <argument><expr><name>leafValue</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>reportedSome</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Normal case: just examine the chain we arrived at */</comment>
                <while>while <condition>(<expr><name>offset</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator>
                        <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_LIVE</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* redirection tuple should be first in chain */</comment>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>==</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/* transfer attention to redirect point */</comment>
                            <expr_stmt><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <name>leafTuple</name><operator>)</operator><operator>-&gt;</operator><name>pointer</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <goto>goto <name>redirect</name>;</goto>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_DEAD</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* dead tuple should be first in chain */</comment>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>==</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="block">/* No live entries on this page */</comment>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/* We should not arrive at a placeholder */</comment>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>,
                             <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>spgLeafTest</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>so</name></expr></argument>,
                                    <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
                                    <argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>level</name></name></expr></argument>,
                                    <argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>reconstructedValue</name></name></expr></argument>,
                                    <argument><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>traversalValue</name></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>leafValue</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>storeRes</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>leafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>,
                                 <argument><expr><name>leafValue</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>reportedSome</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>leafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
                </block_content>}</block></while>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else                    <comment type="block">/* page is inner */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>spgInnerConsistentIn</name></type> <name>in</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>spgInnerConsistentOut</name></type> <name>out</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SpGistNodeTuple</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
                                                        <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_LIVE</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* transfer attention to redirect point */</comment>
                    <expr_stmt><expr><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <name>innerTuple</name><operator>)</operator><operator>-&gt;</operator><name>pointer</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stackEntry</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>redirect</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>,
                     <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* use temp context for calling inner_consistent */</comment>
            <expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>scankeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>nkeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>reconstructedValue</name></name> <operator>=</operator> <name><name>stackEntry</name><operator>-&gt;</operator><name>reconstructedValue</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>traversalMemoryContext</name></name> <operator>=</operator> <name>oldCtx</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>traversalValue</name></name> <operator>=</operator> <name><name>stackEntry</name><operator>-&gt;</operator><name>traversalValue</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>stackEntry</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>returnData</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>allTheSame</name></name> <operator>=</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>hasPrefix</name></name> <operator>=</operator> <operator>(</operator><name><name>innerTuple</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>prefixDatum</name></name> <operator>=</operator> <call><name>SGITDATUM</name><argument_list>(<argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>nNodes</name></name> <operator>=</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>in</name><operator>.</operator><name>nodeLabels</name></name> <operator>=</operator> <call><name>spgExtractNodeLabels</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* collect node pointers */</comment>
            <expr_stmt><expr><name>nodes</name> <operator>=</operator> <operator>(</operator><name>SpGistNodeTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistNodeTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>.</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* use user-defined inner consistent method */</comment>
                <expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_INNER_CONSISTENT_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>procinfo</name></expr></argument>,
                                  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* force all children to be visited */</comment>
                <expr_stmt><expr><name><name>out</name><operator>.</operator><name>nNodes</name></name> <operator>=</operator> <name><name>in</name><operator>.</operator><name>nNodes</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>out</name><operator>.</operator><name>nodeNumbers</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>.</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>.</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>out</name><operator>.</operator><name>nodeNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If allTheSame, they should all or none of 'em match */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>)</condition><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>out</name><operator>.</operator><name>nNodes</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name> <operator>!=</operator> <name><name>in</name><operator>.</operator><name>nNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent inner_consistent results for allTheSame inner tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>nodeN</name> <init>= <expr><name><name>out</name><operator>.</operator><name>nodeNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nodeN</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nodeN</name> <operator>&lt;</operator> <name><name>in</name><operator>.</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeN</name></expr>]</index></name><operator>-&gt;</operator><name>t_tid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ScanStackEntry</name> <modifier>*</modifier></type><name>newEntry</name></decl>;</decl_stmt>

                    <comment type="block">/* Create new work item for this node */</comment>
                    <expr_stmt><expr><name>newEntry</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanStackEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>newEntry</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>nodeN</name></expr>]</index></name><operator>-&gt;</operator><name>t_tid</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>out</name><operator>.</operator><name>levelAdds</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>newEntry</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>stackEntry</name><operator>-&gt;</operator><name>level</name></name> <operator>+</operator> <name><name>out</name><operator>.</operator><name>levelAdds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>newEntry</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>stackEntry</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <comment type="block">/* Must copy value out of temp context */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>out</name><operator>.</operator><name>reconstructedValues</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>newEntry</name><operator>-&gt;</operator><name>reconstructedValue</name></name> <operator>=</operator>
                            <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>out</name><operator>.</operator><name>reconstructedValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attType</name><operator>.</operator><name>attbyval</name></name></expr></argument>,
                                      <argument><expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attType</name><operator>.</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>newEntry</name><operator>-&gt;</operator><name>reconstructedValue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="block">/*
                     * Elements of out.traversalValues should be allocated in
                     * in.traversalMemoryContext, which is actually a long
                     * lived context of index scan.
                     */</comment>
                    <expr_stmt><expr><name><name>newEntry</name><operator>-&gt;</operator><name>traversalValue</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>out</name><operator>.</operator><name>traversalValues</name></name><operator>)</operator></expr> ?</condition><then>
                        <expr><name><name>out</name><operator>.</operator><name>traversalValues</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>newEntry</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* done with this scan stack entry */</comment>
        <expr_stmt><expr><call><name>freeScanStackEntry</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>stackEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* clear temp context before proceeding to the next one */</comment>
        <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* storeRes subroutine for getbitmap case */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storeBitmap</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
            <parameter><decl><type><name>Datum</name></type> <name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tbm</name></name></expr></argument>, <argument><expr><name>heapPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>ntids</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>spggetbitmap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Copy want_itup to *so so we don't need to pass it around separately */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>tbm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>ntids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>spgWalk</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>so</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>storeBitmap</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>so</name><operator>-&gt;</operator><name>ntids</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* storeRes subroutine for gettuple case */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storeGettuple</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
              <parameter><decl><type><name>Datum</name></type> <name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>&lt;</operator> <name>MaxIndexTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>heapPtrs</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>heapPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>recheck</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <name>recheck</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>indexTupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong natts in indexTupDesc."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/*
         * Reconstruct index data.  We have to copy the datum out of the temp
         * context anyway, so we may as well create the tuple here.
         */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>indexTupDesc</name></name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>leafValue</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>spggettuple</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <name>ForwardScanDirection</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SP-GiST only supports forward scan direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Copy want_itup to *so so we don't need to pass it around separately */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* continuing to return tuples from a leaf page */</comment>
            <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>heapPtrs</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>recheck</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name><operator>++</operator></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Must pfree reconstructed tuples to avoid memory leak */</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>spgWalk</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>so</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>storeGettuple</name></expr></argument>,
                <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* must have completed scan */</comment>
    </block_content>}</block></for>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>spgcanreturn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>

    <comment type="block">/* We can do it if the opclass config function says so */</comment>
    <expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>spgGetCache</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>canReturnData</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
