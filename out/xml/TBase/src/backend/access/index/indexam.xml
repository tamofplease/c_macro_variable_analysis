<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/index/indexam.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * indexam.c
 *      general index access method routines
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/access/index/indexam.c
 *
 * INTERFACE ROUTINES
 *        index_open        - open an index relation by relation OID
 *        index_close        - close an index relation
 *        index_beginscan - start a scan of an index with amgettuple
 *        index_beginscan_bitmap - start a scan of an index with amgetbitmap
 *        index_rescan    - restart a scan of an index
 *        index_endscan    - end a scan
 *        index_insert    - insert an index tuple into a relation
 *        index_markpos    - mark a scan position
 *        index_restrpos    - restore a scan position
 *        index_parallelscan_estimate - estimate shared memory for parallel scan
 *        index_parallelscan_initialize - initialize parallel scan
 *        index_parallelrescan  - (re)start a parallel scan of an index
 *        index_beginscan_parallel - join parallel index scan
 *        index_getnext_tid    - get the next TID from a scan
 *        index_fetch_heap        - get the scan's next heap tuple
 *        index_getnext    - get the next heap tuple from a scan
 *        index_getbitmap - get all tuples from a scan
 *        index_bulk_delete    - bulk deletion of index tuples
 *        index_vacuum_cleanup    - post-deletion cleanup of an index
 *        index_can_return    - does index support index-only scans?
 *        index_getprocid - get a support procedure OID
 *        index_getprocinfo - get a support procedure's lookup info
 *
 * NOTES
 *        This file contains the index_ routines which used
 *        to be a scattered collection of stuff in access/genam.
 *
 *
 * old comments
 *        Scans are implemented as follows:
 *
 *        `0' represents an invalid item pointer.
 *        `-' represents an unknown item pointer.
 *        `X' represents a known item pointers.
 *        `+' represents known or invalid item pointers.
 *        `*' represents any item pointers.
 *
 *        State is represented by a triple of these symbols in the order of
 *        previous, current, next.  Note that the case of reverse scans works
 *        identically.
 *
 *                State    Result
 *        (1)        + + -    + 0 0            (if the next item pointer is invalid)
 *        (2)                + X -            (otherwise)
 *        (3)        * 0 0    * 0 0            (no change)
 *        (4)        + X 0    X 0 0            (shift)
 *        (5)        * + X    + X -            (shift, add unknown)
 *
 *        All other states cannot occur.
 *
 *        Note: It would be possible to cache the status of the previous and
 *              next item pointer using the flags.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>


<comment type="block">/* ----------------------------------------------------------------
 *                    macros used in index_ routines
 *
 * Note: the ReindexIsProcessingIndex() check in RELATION_CHECKS is there
 * to check that we don't try to scan or do retail insertions into an index
 * that is currently being rebuilt or pending rebuild.  This helps to catch
 * things that don't work when reindexing system catalogs.  The assertion
 * doesn't prevent the actual rebuild because we don't use RELATION_CHECKS
 * when calling the index AM's ambuild routine, and there is no reason for
 * ambuild to call its subsidiary routines through this file.
 * ----------------------------------------------------------------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELATION_CHECKS</name></cpp:macro> \
<cpp:value>( \
    AssertMacro(RelationIsValid(indexRelation)), \
    AssertMacro(PointerIsValid(indexRelation-&gt;rd_amroutine)), \
    AssertMacro(!ReindexIsProcessingIndex(RelationGetRelid(indexRelation))) \
)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCAN_CHECKS</name></cpp:macro> \
<cpp:value>( \
    AssertMacro(IndexScanIsValid(scan)), \
    AssertMacro(RelationIsValid(scan-&gt;indexRelation)), \
    AssertMacro(PointerIsValid(scan-&gt;indexRelation-&gt;rd_amroutine)) \
)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_REL_PROCEDURE</name><parameter_list>(<parameter><type><name>pname</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    if (indexRelation-&gt;rd_amroutine-&gt;pname == NULL) \
        elog(ERROR, "function %s is not defined for index %s", \
             CppAsString(pname), RelationGetRelationName(indexRelation)); \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_SCAN_PROCEDURE</name><parameter_list>(<parameter><type><name>pname</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    if (scan-&gt;indexRelation-&gt;rd_amroutine-&gt;pname == NULL) \
        elog(ERROR, "function %s is not defined for index %s", \
             CppAsString(pname), RelationGetRelationName(scan-&gt;indexRelation)); \
} while(0)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>IndexScanDesc</name></type> <name>index_beginscan_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                         <parameter><decl><type><name>ParallelIndexScanDesc</name></type> <name>pscan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>temp_snap</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *                   index_ interface functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *        index_open - open an index relation by relation OID
 *
 *        If lockmode is not "NoLock", the specified kind of lock is
 *        obtained on the index.  (Generally, NoLock should only be
 *        used if the caller knows it has some appropriate lock on the
 *        index already.)
 *
 *        An error is raised if the index does not exist.
 *
 *        This is a convenience routine adapted for indexscan use.
 *        Some callers may prefer to use relation_open directly.
 * ----------------
 */</comment>
<function><type><name>Relation</name></type>
<name>index_open</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>r</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>r</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_close - close an index relation
 *
 *        If lockmode is not "NoLock", we then release the specified lock.
 *
 *        Note that it is often sensible to hold a lock beyond index_close;
 *        in that case, the lock is released automatically at xact end.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>index_close</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LockRelId</name></type>    <name>relid</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lockmode</name> <operator>&gt;=</operator> <name>NoLock</name> <operator>&amp;&amp;</operator> <name>lockmode</name> <operator>&lt;</operator> <name>MAX_LOCKMODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The relcache does the real work... */</comment>
    <expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>!=</operator> <name>NoLock</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockRelationId</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_insert - insert an index tuple into a relation
 * ----------------
 */</comment>
<function><type><name>bool</name></type>
<name>index_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
             <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
             <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
             <parameter><decl><type><name>ItemPointer</name></type> <name>heap_t_ctid</name></decl></parameter>,
             <parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
             <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>,
             <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>RELATION_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REL_PROCEDURE</name><argument_list>(<argument><expr><name>aminsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ampredlocks</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>NULL</name></expr></argument>,
                                       <argument><expr><name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>aminsert</name></name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
                                                 <argument><expr><name>heap_t_ctid</name></expr></argument>, <argument><expr><name>heapRelation</name></expr></argument>,
                                                 <argument><expr><name>checkUnique</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_beginscan - start a scan of an index with amgettuple
 *
 * Caller must be holding suitable locks on the heap and the index.
 */</comment>
<function><type><name>IndexScanDesc</name></type>
<name>index_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
                <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
                <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>index_beginscan_internal</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>norderbys</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Save additional parameters into the scandesc.  Everything else was set
     * up by RelationGetIndexScan.
     */</comment>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name> <operator>=</operator> <name>heapRelation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>

    <return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_beginscan_bitmap - start a scan of an index with amgetbitmap
 *
 * As above, caller had better be holding some lock on the parent heap
 * relation, even though it's not explicitly mentioned here.
 */</comment>
<function><type><name>IndexScanDesc</name></type>
<name>index_beginscan_bitmap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
                       <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>index_beginscan_internal</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Save additional parameters into the scandesc.  Everything else was set
     * up by RelationGetIndexScan.
     */</comment>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>

    <return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_beginscan_internal --- common code for index_beginscan variants
 */</comment>
<function><type><specifier>static</specifier> <name>IndexScanDesc</name></type>
<name>index_beginscan_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                         <parameter><decl><type><name>ParallelIndexScanDesc</name></type> <name>pscan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>temp_snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>RELATION_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REL_PROCEDURE</name><argument_list>(<argument><expr><name>ambeginscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ampredlocks</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PredicateLockRelation</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We hold a reference count to the relcache entry throughout the scan.
     */</comment>
    <expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Tell the AM to open a scan.
     */</comment>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ambeginscan</name></name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>,
                                                    <argument><expr><name>norderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Initialize information for parallel scan. */</comment>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>=</operator> <name>pscan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_temp_snap</name></name> <operator>=</operator> <name>temp_snap</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enable_distri_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_start_timestamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>number_visible_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>scanned_tuples_before_prepare</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>scanned_tuples_after_prepare</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>scanned_tuples_after_committed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>scanned_tuples_after_abort</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_rescan  - (re)start a scan of an index
 *
 * During a restart, the caller may specify a new set of scankeys and/or
 * orderbykeys; but the number of keys cannot differ from what index_beginscan
 * was told.  (Later we might relax that to "must not exceed", but currently
 * the index AMs tend to assume that scan-&gt;numberOfKeys is what to believe.)
 * To restart the scan without changing keys, pass NULL for the key arrays.
 * (Of course, keys *must* be passed on the first call, unless
 * scan-&gt;numberOfKeys is zero.)
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>index_rescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
             <parameter><decl><type><name>ScanKey</name></type> <name>keys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
             <parameter><decl><type><name>ScanKey</name></type> <name>orderbys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>SCAN_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_SCAN_PROCEDURE</name><argument_list>(<argument><expr><name>amrescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nkeys</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>norderbys</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release any held pin on a heap page */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_continue_hot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* for safety */</comment>

    <expr_stmt><expr><call><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amrescan</name></name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>,
                                                <argument><expr><name>orderbys</name></expr></argument>, <argument><expr><name>norderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_endscan - end a scan
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>index_endscan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><name>SCAN_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_SCAN_PROCEDURE</name><argument_list>(<argument><expr><name>amendscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>enable_distri_debug</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"statistic account: index scan rel %s snapshot start ts "</literal> <name>INT64_FORMAT</name> <literal type="string">" scanned number "</literal> <name>INT64_FORMAT</name></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"statistic account: index scan rel %s snapshot start ts "</literal> <name>INT64_FORMAT</name> <literal type="string">" snapshot scanned number "</literal> <name>INT64_FORMAT</name></expr></argument>,
                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>number_visible_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>LogScanGTM</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, 
                           <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_start_timestamp</name></name></expr></argument>,
                           <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr><name>INDEX_SCAN</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogScanGTM</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, 
                           <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_start_timestamp</name></name></expr></argument>,
                           <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr><name>SNAPSHOT_SCAN</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>number_visible_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogScanGTM</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, 
                           <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_start_timestamp</name></name></expr></argument>,
                           <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr><name>SNAPSHOT_SCAN_BEFORE_PREPARE</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>scanned_tuples_before_prepare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogScanGTM</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, 
                           <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_start_timestamp</name></name></expr></argument>,
                           <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr><name>SNAPSHOT_SCAN_AFTER_PREPARE</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>scanned_tuples_after_prepare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogScanGTM</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, 
                           <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_start_timestamp</name></name></expr></argument>,
                           <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr><name>SNAPSHOT_SCAN_AFTER_COMMITTED</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>scanned_tuples_after_committed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogScanGTM</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, 
                           <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_start_timestamp</name></name></expr></argument>,
                           <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr><name>SNAPSHOT_SCAN_AFTER_ABORT</name></expr></argument>,
                           <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>scanned_tuples_after_abort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"statistic account: index scan snapshot start ts "</literal> <name>INT64_FORMAT</name> <literal type="string">" scanned number "</literal> <name>INT64_FORMAT</name></expr></argument>,
                         <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_scan_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"statistic account: index scan snapshot start ts "</literal> <name>INT64_FORMAT</name> <literal type="string">" snapshot scanned number "</literal> <name>INT64_FORMAT</name></expr></argument>,
                        <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name><operator>-&gt;</operator><name>number_visible_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Release any held pin on a heap page */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* End the AM's scan */</comment>
    <expr_stmt><expr><call><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amendscan</name></name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release index refcount acquired by index_beginscan */</comment>
    <expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_temp_snap</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Release the scan data structure itself */</comment>
    <expr_stmt><expr><call><name>IndexScanEnd</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_markpos  - mark a scan position
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>index_markpos</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>SCAN_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_SCAN_PROCEDURE</name><argument_list>(<argument><expr><name>ammarkpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ammarkpos</name></name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_restrpos    - restore a scan position
 *
 * NOTE: this only restores the internal scan state of the index AM.
 * The current result tuple (scan-&gt;xs_ctup) doesn't change.  See comments
 * for ExecRestrPos().
 *
 * NOTE: in the presence of HOT chains, mark/restore only works correctly
 * if the scan's snapshot is MVCC-safe; that ensures that there's at most one
 * returnable tuple in each HOT chain, and so restoring the prior state at the
 * granularity of the index AM is sufficient.  Since the only current user
 * of mark/restore functionality is nodeMergejoin.c, this effectively means
 * that merge-join plans only work for MVCC snapshots.  This could be fixed
 * if necessary, but for now it seems unimportant.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>index_restrpos</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>SCAN_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_SCAN_PROCEDURE</name><argument_list>(<argument><expr><name>amrestrpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_continue_hot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* for safety */</comment>

    <expr_stmt><expr><call><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amrestrpos</name></name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * index_parallelscan_estimate - estimate shared memory for parallel scan
 *
 * Currently, we don't pass any information to the AM-specific estimator,
 * so it can probably only return a constant.  In the future, we might need
 * to pass more information.
 */</comment>
<function><type><name>Size</name></type>
<name>index_parallelscan_estimate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>nbytes</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>RELATION_CHECKS</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>ParallelIndexScanDescData</name></expr></argument>, <argument><expr><name>ps_snapshot_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><call><name>EstimateSnapshotSpace</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If amestimateparallelscan is not provided, assume there is no
     * AM-specific data needed.  (It's hard to believe that could work, but
     * it's easy enough to cater to it here.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amestimateparallelscan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>,
                          <argument><expr><call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amestimateparallelscan</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>nbytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_parallelscan_initialize - initialize parallel scan
 *
 * We initialize both the ParallelIndexScanDesc proper and the AM-specific
 * information which follows it.
 *
 * This function calls access method specific initialization routine to
 * initialize am specific information.  Call this just once in the leader
 * process; then, individual workers attach via index_beginscan_parallel.
 */</comment>
<function><type><name>void</name></type>
<name>index_parallelscan_initialize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
                              <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>ParallelIndexScanDesc</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>RELATION_CHECKS</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParallelIndexScanDescData</name></expr></argument>, <argument><expr><name>ps_snapshot_data</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>EstimateSnapshotSpace</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>ps_relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>ps_indexid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>ps_offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SerializeSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>ps_snapshot_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* aminitparallelscan is optional; assume no-op if not provided by AM */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>aminitparallelscan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>amtarget</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>amtarget</name> <operator>=</operator> <call><name>OffsetToPointer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>aminitparallelscan</name></name><argument_list>(<argument><expr><name>amtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_parallelrescan  - (re)start a parallel scan of an index
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>index_parallelrescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>SCAN_CHECKS</name></expr>;</expr_stmt>

    <comment type="block">/* amparallelrescan is optional; assume no-op if not provided by AM */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amparallelrescan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amparallelrescan</name></name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * index_beginscan_parallel - join parallel index scan
 *
 * Caller must be holding suitable locks on the heap and the index.
 */</comment>
<function><type><name>IndexScanDesc</name></type>
<name>index_beginscan_parallel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heaprel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>, <parameter><decl><type><name>ParallelIndexScanDesc</name></type> <name>pscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heaprel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>pscan</name><operator>-&gt;</operator><name>ps_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RestoreSnapshot</name><argument_list>(<argument><expr><name><name>pscan</name><operator>-&gt;</operator><name>ps_snapshot_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>index_beginscan_internal</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>norderbys</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
                                    <argument><expr><name>pscan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Save additional parameters into the scandesc.  Everything else was set
     * up by index_beginscan_internal.
     */</comment>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name> <operator>=</operator> <name>heaprel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>

    <return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 * index_getnext_tid - get the next TID from a scan
 *
 * The result is the next TID satisfying the scan keys,
 * or NULL if no more matching tuples exist.
 * ----------------
 */</comment>
<function><type><name>ItemPointer</name></type>
<name>index_getnext_tid</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>SCAN_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_SCAN_PROCEDURE</name><argument_list>(<argument><expr><name>amgettuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The AM's amgettuple proc finds the next index entry matching the scan
     * keys, and puts the TID into scan-&gt;xs_ctup.t_self.  It should also set
     * scan-&gt;xs_recheck and possibly scan-&gt;xs_itup/scan-&gt;xs_hitup, though we
     * pay no attention to those fields here.
     */</comment>
    <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset kill flag immediately for safety */</comment>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* If we're out of index entries, we're done */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* ... but first, release any held pin on a heap page */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_count_index_tuples</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return the TID of the tuple we found. */</comment>
    <return>return <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_fetch_heap - get the scan's next heap tuple
 *
 * The result is a visible heap tuple associated with the index TID most
 * recently fetched by index_getnext_tid, or NULL if no more matching tuples
 * exist.  (There can be more than one matching tuple because of HOT chains,
 * although when using an MVCC snapshot it should be impossible for more than
 * one such tuple to exist.)
 *
 * On success, the buffer containing the heap tup is pinned (the pin will be
 * dropped in a future index_getnext_tid, index_fetch_heap or index_endscan
 * call).
 *
 * Note: caller must check scan-&gt;xs_recheck, and perform rechecking of the
 * scan keys if required.  We do not do that here because we don't have
 * enough information to do it efficiently in the general case.
 * ----------------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>index_fetch_heap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name> <init>= <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>all_dead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>got_heap_tuple</name></decl>;</decl_stmt>

    <comment type="block">/* We can skip the buffer-switching logic if we're in mid-HOT chain. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_continue_hot</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Switch to correct buffer if we don't have it already */</comment>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>prev_buf</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name> <operator>=</operator> <call><name>ReleaseAndReadBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>,
                                             <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>,
                                             <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Prune page, but only if we weren't already on this page
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>prev_buf</name> <operator>!=</operator> <name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>heap_page_prune_opt</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Obtain share-lock on the buffer so we can examine visibility */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>got_heap_tuple</name> <operator>=</operator> <call><name>heap_hot_search_buffer</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>,
                                            <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>,
                                            <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>all_dead</name></expr></argument>,
                                            <argument><expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_continue_hot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>got_heap_tuple</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Only in a non-MVCC snapshot can more than one member of the HOT
         * chain be visible.
         */</comment>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_continue_hot</name></name> <operator>=</operator> <operator>!</operator><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgstat_count_heap_fetch</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We've reached the end of the HOT chain. */</comment>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_continue_hot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If we scanned a whole HOT chain and found only dead tuples, tell index
     * AM to kill its entry for that TID (this will take effect in the next
     * amgettuple call, in index_getnext_tid).  We do not do this when in
     * recovery because it may violate MVCC to do so.  See comments in
     * RelationGetIndexScan().
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xactStartedInRecovery</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name> <operator>=</operator> <name>all_dead</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_getnext - get the next heap tuple from a scan
 *
 * The result is the next heap tuple satisfying the scan keys and the
 * snapshot, or NULL if no more matching tuples exist.
 *
 * On success, the buffer containing the heap tup is pinned (the pin will be
 * dropped in a future index_getnext_tid, index_fetch_heap or index_endscan
 * call).
 *
 * Note: caller must check scan-&gt;xs_recheck, and perform rechecking of the
 * scan keys if required.  We do not do that here because we don't have
 * enough information to do it efficiently in the general case.
 * ----------------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>index_getnext</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>heapTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_continue_hot</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We are resuming scan of a HOT chain after having returned an
             * earlier member.  Must still hold pin on current heap page.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
                   <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Time to fetch the next TID from the index */</comment>
            <expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>index_getnext_tid</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If we're out of index entries, we're done */</comment>
            <if_stmt><if>if <condition>(<expr><name>tid</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Fetch the next (or only) visible heap tuple for this index entry.
         * If we don't find anything, loop around and grab the next TID from
         * the index.
         */</comment>
        <expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>index_fetch_heap</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>heapTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>heapTuple</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>                <comment type="block">/* failure exit */</comment>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_getbitmap - get all tuples at once from an index scan
 *
 * Adds the TIDs of all heap tuples satisfying the scan keys to a bitmap.
 * Since there's no interlock between the index scan and the eventual heap
 * access, this is only safe to use with MVCC-based snapshots: the heap
 * item slot could have been replaced by a newer tuple by the time we get
 * to it.
 *
 * Returns the number of matching tuples found.  (Note: this might be only
 * approximate, so it should only be used for statistical purposes.)
 * ----------------
 */</comment>
<function><type><name>int64</name></type>
<name>index_getbitmap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>bitmap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type>        <name>ntids</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>SCAN_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_SCAN_PROCEDURE</name><argument_list>(<argument><expr><name>amgetbitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* just make sure this is false... */</comment>
    <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * have the am's getbitmap proc do all the work.
     */</comment>
    <expr_stmt><expr><name>ntids</name> <operator>=</operator> <call><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_count_index_tuples</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>ntids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ntids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_bulk_delete - do mass deletion of index entries
 *
 *        callback routine tells whether a given main-heap tuple is
 *        to be deleted
 *
 *        return value is an optional palloc'd struct of statistics
 * ----------------
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>index_bulk_delete</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
                  <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
                  <parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>,
                  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRelation</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>RELATION_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REL_PROCEDURE</name><argument_list>(<argument><expr><name>ambulkdelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ambulkdelete</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>,
                                                     <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_vacuum_cleanup - do post-deletion cleanup of an index
 *
 *        return value is an optional palloc'd struct of statistics
 * ----------------
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>index_vacuum_cleanup</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
                     <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>indexRelation</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>RELATION_CHECKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_REL_PROCEDURE</name><argument_list>(<argument><expr><name>amvacuumcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amvacuumcleanup</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_can_return
 *
 *        Does the index access method support index-only scans for the given
 *        column?
 * ----------------
 */</comment>
<function><type><name>bool</name></type>
<name>index_can_return</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>RELATION_CHECKS</name></expr>;</expr_stmt>

    <comment type="block">/* amcanreturn is optional; assume FALSE if not provided by AM */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_getprocid
 *
 *        Index access methods typically require support routines that are
 *        not directly the implementation of any WHERE-clause query operator
 *        and so cannot be kept in pg_amop.  Instead, such routines are kept
 *        in pg_amproc.  These registered procedure OIDs are assigned numbers
 *        according to a convention established by the access method.
 *        The general index code doesn't know anything about the routines
 *        involved; it just builds an ordered list of them for
 *        each attribute on which an index is defined.
 *
 *        As of Postgres 8.3, support routines within an operator family
 *        are further subdivided by the "left type" and "right type" of the
 *        query operator(s) that they support.  The "default" functions for a
 *        particular indexed attribute are those with both types equal to
 *        the index opclass' opcintype (note that this is subtly different
 *        from the indexed attribute's own type: it may be a binary-compatible
 *        type instead).  Only the default functions are stored in relcache
 *        entries --- access methods can use the syscache to look up non-default
 *        functions.
 *
 *        This routine returns the requested default procedure OID for a
 *        particular indexed attribute.
 * ----------------
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>index_getprocid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>irel</name></decl></parameter>,
                <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
                <parameter><decl><type><name>uint16</name></type> <name>procnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>loc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nproc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>procindex</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nproc</name> <operator>=</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amsupport</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>procnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>procnum</name> <operator>&lt;=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <name>nproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>procindex</name> <operator>=</operator> <operator>(</operator><name>nproc</name> <operator>*</operator> <operator>(</operator><name>attnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><name>procnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_support</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>loc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>loc</name><index>[<expr><name>procindex</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *        index_getprocinfo
 *
 *        This routine allows index AMs to keep fmgr lookup info for
 *        support procs in the relcache.  As above, only the "default"
 *        functions for any particular indexed attribute are cached.
 *
 * Note: the return value points into cached data that will be lost during
 * any relcache rebuild!  Therefore, either use the callinfo right away,
 * or save it only after having acquired some type of lock on the index rel.
 * ----------------
 */</comment>
<function><type><name>FmgrInfo</name> <modifier>*</modifier></type>
<name>index_getprocinfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>irel</name></decl></parameter>,
                  <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
                  <parameter><decl><type><name>uint16</name></type> <name>procnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>locinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nproc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>procindex</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nproc</name> <operator>=</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amsupport</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>procnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>procnum</name> <operator>&lt;=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <name>nproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>procindex</name> <operator>=</operator> <operator>(</operator><name>nproc</name> <operator>*</operator> <operator>(</operator><name>attnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><name>procnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>locinfo</name> <operator>=</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_supportinfo</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>locinfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>locinfo</name> <operator>+=</operator> <name>procindex</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize the lookup info if first time through */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>locinfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><name><name>irel</name><operator>-&gt;</operator><name>rd_support</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RegProcedure</name></type> <name>procId</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>loc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>procId</name> <operator>=</operator> <name><name>loc</name><index>[<expr><name>procindex</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Complain if function was not found during IndexSupportInitialize.
         * This should not happen unless the system tables contain bogus
         * entries for the index opclass.  (If an AM wants to allow a support
         * function to be optional, it can use index_getprocid.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>procId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d for attribute %d of index \"%s\""</literal></expr></argument>,
                 <argument><expr><name>procnum</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>irel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>procId</name></expr></argument>, <argument><expr><name>locinfo</name></expr></argument>, <argument><expr><name><name>irel</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>locinfo</name></expr>;</return>
</block_content>}</block></function>
</unit>
