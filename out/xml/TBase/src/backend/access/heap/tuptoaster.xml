<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/heap/tuptoaster.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tuptoaster.c
 *      Support routines for external and compressed storage of
 *      variable size attributes.
 *
 * Copyright (c) 2000-2017, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/access/heap/tuptoaster.c
 *
 *
 * INTERFACE ROUTINES
 *        toast_insert_or_update -
 *            Try to make a given tuple fit into one page by compressing
 *            or moving off attributes
 *
 *        toast_delete -
 *            Reclaim toast storage when a tuple is deleted
 *
 *        heap_tuple_untoast_attr -
 *            Fetch back a given value from the "secondary" relation
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandeddatum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TOAST_DEBUG</name></cpp:undef>

<comment type="block">/*
 *    The information at the start of the compressed toast data.
 */</comment>
<typedef>typedef <type><struct>struct <name>toast_compress_header</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>        <name>vl_len_</name></decl>;</decl_stmt>        <comment type="block">/* varlena header (do not touch directly!) */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>rawsize</name></decl>;</decl_stmt>
}</block></struct></type> <name>toast_compress_header</name>;</typedef>

<comment type="block">/*
 * Utilities for manipulation of header information for compressed
 * toast entries.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOAST_COMPRESS_HDRSZ</name></cpp:macro>        <cpp:value>((int32) sizeof(toast_compress_header))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOAST_COMPRESS_RAWSIZE</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((toast_compress_header *) (ptr))-&gt;rawsize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOAST_COMPRESS_RAWDATA</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(((char *) (ptr)) + TOAST_COMPRESS_HDRSZ)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOAST_COMPRESS_SET_RAWSIZE</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(((toast_compress_header *) (ptr))-&gt;rawsize = (len))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>toast_delete_datum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_speculative</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>toast_save_datum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
                 <parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>oldexternal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                 , <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>toastrel_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>toastid_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>toastrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>toast_fetch_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>toast_fetch_datum_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>,
                        <parameter><decl><type><name>int32</name></type> <name>sliceoffset</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>length</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>toast_decompress_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>toast_open_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>,
                   <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>,
                   <parameter><decl><type><name>Relation</name> <modifier>*</modifier><modifier>*</modifier></type><name>toastidxs</name></decl></parameter>,
                   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_indexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>toast_close_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>toastidxs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_indexes</name></decl></parameter>,
                    <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_toast_snapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>toast_snapshot</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------
 * heap_tuple_fetch_attr -
 *
 *    Public entry point to get back a toasted value from
 *    external source (possibly still in compressed format).
 *
 * This will return a datum that contains all the data internally, ie, not
 * relying on external storage or memory, but it can still be compressed or
 * have a short header.  Note some callers assume that if the input is an
 * EXTERNAL datum, the result will be a pfree'able chunk.
 * ----------
 */</comment>
<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>heap_tuple_fetch_attr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is an external stored plain value
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>toast_fetch_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is an indirect pointer --- dereference it
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>redirect</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr>;</expr_stmt>

        <comment type="block">/* nested indirect Datums aren't allowed */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* recurse if value is still external in some other way */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Copy into the caller's memory context, in case caller tries to
         * pfree the result.
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is an expanded-object pointer --- get flat format
         */</comment>
        <decl_stmt><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eoh</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>resultsize</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>eoh</name> <operator>=</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>resultsize</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>, <argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * This is a plain value inside of the main tuple - why am I called?
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * heap_tuple_untoast_attr -
 *
 *    Public entry point to get back a toasted value from compression
 *    or external storage.  The result is always non-extended varlena form.
 *
 * Note some callers assume that if the input is an EXTERNAL or COMPRESSED
 * datum, the result will be a pfree'able chunk.
 * ----------
 */</comment>
<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>heap_tuple_untoast_attr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is an externally stored datum --- fetch it back from there
         */</comment>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>toast_fetch_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* If it's compressed, decompress it */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>attr</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>toast_decompress_datum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is an indirect pointer --- dereference it
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>redirect</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr>;</expr_stmt>

        <comment type="block">/* nested indirect Datums aren't allowed */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* recurse in case value is still extended in some other way */</comment>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_tuple_untoast_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if it isn't, we'd better copy it */</comment>
        <if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>attr</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is an expanded-object pointer --- get flat format
         */</comment>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* flatteners are not allowed to produce compressed/short output */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is a compressed value inside of the main tuple
         */</comment>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>toast_decompress_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * This is a short-header varlena --- convert to 4-byte header format
         */</comment>
        <decl_stmt><decl><type><name>Size</name></type>        <name>data_size</name> <init>= <expr><call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>new_size</name> <init>= <expr><name>data_size</name> <operator>+</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_attr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>new_attr</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>new_attr</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>new_attr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name>new_attr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>attr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * heap_tuple_untoast_attr_slice -
 *
 *        Public entry point to get back part of a toasted value
 *        from compression or external storage.
 * ----------
 */</comment>
<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>heap_tuple_untoast_attr_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>,
                              <parameter><decl><type><name>int32</name></type> <name>sliceoffset</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>slicelength</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>preslice</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>attrdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>attrsize</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* fast path for non-compressed external datums */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>toast_fetch_datum_slice</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* fetch it back (compressed marker will get set automatically) */</comment>
        <expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>toast_fetch_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>redirect</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* nested indirect Datums aren't allowed */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>heap_tuple_untoast_attr_slice</name><argument_list>(<argument><expr><name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr></argument>,
                                             <argument><expr><name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* pass it off to heap_tuple_fetch_attr to flatten */</comment>
        <expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>preslice</name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>preslice</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>toast_decompress_datum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>attr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>attrdata</name> <operator>=</operator> <call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attrsize</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>attrdata</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>attrsize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* slicing of datum for compressed cases and plain value */</comment>

    <if_stmt><if>if <condition>(<expr><name>sliceoffset</name> <operator>&gt;=</operator> <name>attrsize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sliceoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>slicelength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sliceoffset</name> <operator>+</operator> <name>slicelength</name><operator>)</operator> <operator>&gt;</operator> <name>attrsize</name><operator>)</operator> <operator>||</operator> <name>slicelength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>slicelength</name> <operator>=</operator> <name>attrsize</name> <operator>-</operator> <name>sliceoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrdata</name> <operator>+</operator> <name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>preslice</name> <operator>!=</operator> <name>attr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_raw_datum_size -
 *
 *    Return the raw (detoasted) size of a varlena datum
 *    (including the VARHDRSZ header)
 * ----------
 */</comment>
<function><type><name>Size</name></type>
<name>toast_raw_datum_size</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* va_rawsize is the size of the original datum -- including header */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* nested indirect Datums aren't allowed */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* here, va_rawsize is just the payload size */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARRAWSIZE_4B_C</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * we have to normalize the header length to VARHDRSZ or else the
         * callers of this function will be confused.
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* plain untoasted datum */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_datum_size
 *
 *    Return the physical storage size (possibly compressed) of a varlena datum
 * ----------
 */</comment>
<function><type><name>Size</name></type>
<name>toast_datum_size</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Attribute is stored externally - return the extsize whether
         * compressed or not.  We do not count the size of the toast pointer
         * ... should we?
         */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* nested indirect Datums aren't allowed */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>toast_datum_size</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Attribute is stored inline either compressed or not, just calculate
         * the size of the datum in either case.
         */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_delete -
 *
 *    Cascaded delete toast-entries on DELETE
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>toast_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_speculative</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numAttrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>toast_values</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_isnull</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * We should only ever be called for tuples of plain relations or
     * materialized views --- recursing on a toast rel is bad news.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
           <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the tuple descriptor and break down the tuple into fields.
     *
     * NOTE: it's debatable whether to use heap_deform_tuple() here or just
     * heap_getattr() only the varlena columns.  The latter could win if there
     * are few varlena columns and many non-varlena ones. However,
     * heap_deform_tuple costs only O(N) while the heap_getattr way would cost
     * O(N^2) if there are many varlena columns, so it seems better to err on
     * the side of linear cost.  (We won't even be here unless there's at
     * least one varlena column, by the way.)
     */</comment>
    <expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numAttrs</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for external stored attributes and delete them from the secondary
     * relation.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name> <init>= <expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>toast_delete_datum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>is_speculative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_insert_or_update -
 *
 *    Delete no-longer-used toast-entries and create new ones to
 *    make the new tuple fit on INSERT or UPDATE
 *
 * Inputs:
 *    newtup: the candidate new tuple to be inserted
 *    oldtup: the old row version for UPDATE, or NULL for INSERT
 *    options: options to be passed to heap_insert() for toast rows
 * Result:
 *    either newtup if no toasting is needed, or a palloc'd modified tuple
 *    that is what should actually get stored
 *
 * NOTE: neither newtup nor oldtup will be modified.  This is a change
 * from the pre-8.1 API of this routine.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>toast_insert_or_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>result_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupleDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numAttrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type>        <name>need_change</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_free</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_delold</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_nulls</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Size</name></type>        <name>maxDataLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>hoff</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name></type>        <name><name>toast_action</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_isnull</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_oldisnull</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>toast_values</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>toast_oldvalues</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name><name>toast_oldexternal</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name><name>toast_sizes</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_free</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_delold</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Ignore the INSERT_SPECULATIVE option. Speculative insertions/super
     * deletions just normally insert/delete the toast values. It seems
     * easiest to deal with that here, instead on, potentially, multiple
     * callers.
     */</comment>
    <expr_stmt><expr><name>options</name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_INSERT_SPECULATIVE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We should only ever be called for tuples of plain relations or
     * materialized views --- recursing on a toast rel is bad news.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
           <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the tuple descriptor and break down the tuple(s) into fields.
     */</comment>
    <expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numAttrs</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>oldtup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_oldvalues</name></expr></argument>, <argument><expr><name>toast_oldisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* ----------
     * Then collect information about the values given
     *
     * NOTE: toast_action[i] can have these values:
     *        ' '        default handling
     *        'p'        already processed --- don't touch it
     *        'x'        incompressible, but OK to move off
     *
     * NOTE: toast_sizes[i] is only made valid for varlena attributes with
     *        toast_action[i] different from 'p'.
     * ----------
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_action</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_oldexternal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>varlena</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_free</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_delold</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>old_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>oldtup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * For UPDATE get the old and new values of this attribute
             */</comment>
            <expr_stmt><expr><name>old_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_oldvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the old value is stored on disk, check if it has changed so
             * we have to delete it later.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>toast_oldisnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
                <call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>!</operator><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>old_value</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_value</name></expr></argument>,
                           <argument><expr><call><name>VARSIZE_EXTERNAL</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * The old external stored value isn't needed any more
                     * after the update
                     */</comment>
                    <expr_stmt><expr><name><name>toast_delold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>need_delold</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * This attribute isn't changed by this update so we reuse
                     * the original reference to the old value in the new
                     * tuple.
                     */</comment>
                    <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * For INSERT simply get the new value
             */</comment>
            <expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Handle NULL attributes
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>has_nulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Now look at varlena attributes
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If the table's attribute says PLAIN always, force it so.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We took care of UPDATE above, so any external value we find
             * still in the tuple must be someone else's that we cannot reuse
             * (this includes the case of an out-of-line in-memory datum).
             * Fetch it back (without decompression, unless we are forcing
             * PLAIN storage).  If necessary, we'll push it out as a new
             * external value below.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>toast_oldexternal</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>new_value</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>heap_tuple_untoast_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>need_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>need_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Remember the size of this attribute
             */</comment>
            <expr_stmt><expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Not a varlena attribute, plain storage always
             */</comment>
            <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* ----------
     * Compress and/or save external until data fits into target length
     *
     *    1: Inline compress attributes with attstorage 'x', and store very
     *       large attributes with attstorage 'x' or 'e' external immediately
     *    2: Store attributes with attstorage 'x' or 'e' external
     *    3: Inline compress attributes with attstorage 'm'
     *    4: Store attributes with attstorage 'm' external
     * ----------
     */</comment>

    <comment type="block">/* compute header overhead --- this should match heap_form_tuple() */</comment>
    <expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>has_nulls</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>hoff</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_HASOID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>hoff</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hoff</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* now convert to a limit on the tuple data size */</comment>
    <expr_stmt><expr><name>maxDataLen</name> <operator>=</operator> <name>TOAST_TUPLE_TARGET</name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Look for attributes with attstorage 'x' to compress.  Also find large
     * attributes with attstorage 'x' or 'e', and store them external.
     */</comment>
    <while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                                  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>biggest_attno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>biggest_size</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>TOAST_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>old_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>new_value</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Search for the biggest yet unprocessed internal attribute
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* can't happen, toast_action would be 'p' */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>!=</operator> <literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>!=</operator> <literal type="char">'e'</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>biggest_size</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>biggest_size</name> <operator>=</operator> <name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Attempt to compress it inline, if it has attstorage 'x'
         */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>biggest_attno</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>old_value</name> <operator>=</operator> <name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>toast_compress_datum</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* successful compression */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>new_value</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>need_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>need_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* incompressible, ignore on subsequent compression passes */</comment>
                <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* has attstorage 'e', ignore on subsequent compression passes */</comment>
            <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If this value is by itself more than maxDataLen (after compression
         * if any), push it out to the toast table immediately, if possible.
         * This avoids uselessly compressing other fields in the common case
         * where we have one long field and several short ones.
         *
         * XXX maybe the threshold should be less than maxDataLen?
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxDataLen</name> <operator>&amp;&amp;</operator>
            <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>old_value</name> <operator>=</operator> <name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>toast_save_datum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                               <argument><expr><name><name>toast_oldexternal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>options</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                                               ,<argument><expr><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                                )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Second we look for attributes of attstorage 'x' or 'e' that are still
     * inline.  But skip this if there's no toast table to push them to.
     */</comment>
    <while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                                  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name> <operator>&amp;&amp;</operator>
           <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>biggest_attno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>biggest_size</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>TOAST_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>old_value</name></decl>;</decl_stmt>

        <comment type="block">/*------
         * Search for the biggest yet inlined attribute with
         * attstorage equals 'x' or 'e'
         *------
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* can't happen, toast_action would be 'p' */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>!=</operator> <literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>!=</operator> <literal type="char">'e'</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>biggest_size</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>biggest_size</name> <operator>=</operator> <name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Store this external
         */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>biggest_attno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_value</name> <operator>=</operator> <name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>toast_save_datum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>toast_oldexternal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>options</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                                            ,<argument><expr><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                            )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>need_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>need_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Round 3 - this time we take attributes with storage 'm' into
     * compression
     */</comment>
    <while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                                  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>biggest_attno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>biggest_size</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>TOAST_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>old_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>new_value</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Search for the biggest yet uncompressed internal attribute
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* can't happen, toast_action would be 'p' */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>!=</operator> <literal type="char">'m'</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>biggest_size</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>biggest_size</name> <operator>=</operator> <name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Attempt to compress it inline
         */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>biggest_attno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_value</name> <operator>=</operator> <name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>toast_compress_datum</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* successful compression */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>new_value</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* incompressible, ignore on subsequent compression passes */</comment>
            <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Finally we store attributes of type 'm' externally.  At this point we
     * increase the target tuple size, so that 'm' attributes aren't stored
     * externally unless really necessary.
     */</comment>
    <expr_stmt><expr><name>maxDataLen</name> <operator>=</operator> <name>TOAST_TUPLE_TARGET_MAIN</name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                                  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name> <operator>&amp;&amp;</operator>
           <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>biggest_attno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>biggest_size</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>TOAST_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>old_value</name></decl>;</decl_stmt>

        <comment type="block">/*--------
         * Search for the biggest yet inlined attribute with
         * attstorage = 'm'
         *--------
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>        <comment type="block">/* can't happen, toast_action would be 'p' */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>!=</operator> <literal type="char">'m'</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>biggest_size</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>biggest_size</name> <operator>=</operator> <name><name>toast_sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Store this external
         */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>biggest_attno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_value</name> <operator>=</operator> <name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_action</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>toast_save_datum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>toast_oldexternal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>options</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                                            ,<argument><expr><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                            )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>need_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>need_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * In the case we toasted any values, we need to build a new heap tuple
     * with the changed values.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>need_change</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>olddata</name> <init>= <expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>new_data</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>new_header_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>new_data_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>        <name>new_tuple_len</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Calculate the new size of the tuple.
         *
         * Note: we used to assume here that the old tuple's t_hoff must equal
         * the new_header_len value, but that was incorrect.  The old tuple
         * might have a smaller-than-current natts, if there's been an ALTER
         * TABLE ADD COLUMN since it was stored; and that would lead to a
         * different conclusion about the size of the null bitmap, or even
         * whether there needs to be one at all.
         */</comment>
        <expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>has_nulls</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>new_header_len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>olddata</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_HASOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>new_header_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>new_header_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                                              <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_tuple_len</name> <operator>=</operator> <name>new_header_len</name> <operator>+</operator> <name>new_data_len</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Allocate and zero the space needed, and fill HeapTupleData fields.
         */</comment>
        <expr_stmt><expr><name>result_tuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>new_tuple_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>new_tuple_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_xc_node_id</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_xc_node_id</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>new_data</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result_tuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>new_data</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Copy the existing tuple header, but adjust natts and t_hoff.
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>olddata</name></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>new_header_len</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>olddata</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_HASOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>HeapTupleHeaderSetOid</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><call><name>HeapTupleHeaderGetOid</name><argument_list>(<argument><expr><name>olddata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Copy over the data, and fill the null bitmap if needed */</comment>
        <expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                        <argument><expr><name>toast_values</name></expr></argument>,
                        <argument><expr><name>toast_isnull</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_data</name> <operator>+</operator> <name>new_header_len</name></expr></argument>,
                        <argument><expr><name>new_data_len</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_data</name><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>has_nulls</name></expr> ?</condition><then> <expr><name><name>new_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result_tuple</name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Free allocated temp values
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>need_free</name></expr>)</condition><block type="pseudo"><block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Delete external values from the old tuple
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>need_delold</name></expr>)</condition><block type="pseudo"><block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>toast_delold</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>toast_delete_datum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>toast_oldvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

    <return>return <expr><name>result_tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_flatten_tuple -
 *
 *    "Flatten" a tuple to contain no out-of-line toasted fields.
 *    (This does not eliminate compressed or short-header datums.)
 *
 *    Note: we expect the caller already checked HeapTupleHasExternal(tup),
 *    so there is no need for a short-circuit path.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>toast_flatten_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>new_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numAttrs</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>toast_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_isnull</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_free</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Break down the tuple into fields.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_free</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Look at non-null varlena attributes
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Form the reconfigured tuple.
     */</comment>
    <expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Be sure to copy the tuple's OID and identity fields.  We also make a
     * point of copying visibility info, just in case anybody looks at those
     * fields in a syscache entry.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_choice</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_choice</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XACT_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator>
        <name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XACT_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP2_XACT_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator>
        <name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;</operator> <name>HEAP2_XACT_MASK</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Free allocated temp values
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <return>return <expr><name>new_tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_flatten_tuple_to_datum -
 *
 *    "Flatten" a tuple containing out-of-line toasted fields into a Datum.
 *    The result is always palloc'd in the current memory context.
 *
 *    We have a general rule that Datums of container types (rows, arrays,
 *    ranges, etc) must not contain any external TOAST pointers.  Without
 *    this rule, we'd have to look inside each Datum when preparing a tuple
 *    for storage, which would be expensive and would fail to extend cleanly
 *    to new sorts of container types.
 *
 *    However, we don't want to say that tuples represented as HeapTuples
 *    can't contain toasted fields, so instead this routine should be called
 *    when such a HeapTuple is being converted into a Datum.
 *
 *    While we're at it, we decompress any compressed fields too.  This is not
 *    necessary for correctness, but reflects an expectation that compression
 *    will be more effective if applied to the whole tuple not individual
 *    fields.  We are not so concerned about that that we want to deconstruct
 *    and reconstruct tuples just to get rid of compressed fields, however.
 *    So callers typically won't call this unless they see that the tuple has
 *    at least one external field.
 *
 *    On the other hand, in-line short-header varlena fields are left alone.
 *    If we "untoasted" them here, they'd just get changed back to short-header
 *    format anyway within heap_fill_tuple.
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>toast_flatten_tuple_to_datum</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>,
                             <parameter><decl><type><name>uint32</name></type> <name>tup_len</name></decl></parameter>,
                             <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>new_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>new_header_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>new_data_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>new_tuple_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numAttrs</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_nulls</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>toast_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_isnull</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>toast_free</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Build a temporary HeapTuple control structure */</comment>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name>tup_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_xc_node_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Break down the tuple into fields.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_free</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Look at non-null varlena attributes
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>has_nulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>heap_tuple_untoast_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Calculate the new size of the tuple.
     *
     * This should match the reconstruction code in toast_insert_or_update.
     */</comment>
    <expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>has_nulls</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>new_header_len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_HASOID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>new_header_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>new_header_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                                          <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_tuple_len</name> <operator>=</operator> <name>new_header_len</name> <operator>+</operator> <name>new_data_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>new_data</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_tuple_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Copy the existing tuple header, but adjust natts and t_hoff.
     */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>new_header_len</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_HASOID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>HeapTupleHeaderSetOid</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><call><name>HeapTupleHeaderGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Set the composite-Datum header fields correctly */</comment>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>new_tuple_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy over the data, and fill the null bitmap if needed */</comment>
    <expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
                    <argument><expr><name>toast_values</name></expr></argument>,
                    <argument><expr><name>toast_isnull</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_data</name> <operator>+</operator> <name>new_header_len</name></expr></argument>,
                    <argument><expr><name>new_data_len</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_data</name><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>has_nulls</name></expr> ?</condition><then> <expr><name><name>new_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Free allocated temp values
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_build_flattened_tuple -
 *
 *    Build a tuple containing no out-of-line toasted fields.
 *    (This does not eliminate compressed or short-header datums.)
 *
 *    This is essentially just like heap_form_tuple, except that it will
 *    expand any external-data pointers beforehand.
 *
 *    It's not very clear whether it would be preferable to decompress
 *    in-line compressed datums while at it.  For now, we don't.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>toast_build_flattened_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                            <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
                            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>new_tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numAttrs</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_to_free</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>new_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pointer</name></type>        <name><name>freeable_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * We can pass the caller's isnull array directly to heap_form_tuple, but
     * we potentially need to modify the values array.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_values</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>num_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Look at non-null varlena attributes
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>att</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>new_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>new_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>freeable_values</name><index>[<expr><name>num_to_free</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>new_value</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Form the reconfigured tuple.
     */</comment>
    <expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>new_values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Free allocated temp values
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_to_free</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>freeable_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>new_tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_compress_datum -
 *
 *    Create a compressed version of a varlena datum
 *
 *    If we fail (ie, compressed result is actually bigger than original)
 *    then return NULL.  We must not use compressed data if it'd expand
 *    the tuple!
 *
 *    We use VAR{SIZE,DATA}_ANY so we can handle short varlenas here without
 *    copying them.  But we can't handle external or compressed datums.
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>toast_compress_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>valsize</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * No point in wasting a palloc cycle if value size is out of the allowed
     * range for compression
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>valsize</name> <argument_list type="generic">&lt; <argument><expr><name><name>PGLZ_strategy_default</name><operator>-&gt;</operator><name>min_input_size</name></name> <operator>||</operator>
        <name>valsize</name></expr></argument> &gt;</argument_list></name> <name><name>PGLZ_strategy_default</name><operator>-&gt;</operator><name>max_input_size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>PGLZ_MAX_OUTPUT</name><argument_list>(<argument><expr><name>valsize</name></expr></argument>)</argument_list></call> <operator>+</operator>
                                    <name>TOAST_COMPRESS_HDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We recheck the actual size even if pglz_compress() reports success,
     * because it might be satisfied with having saved as little as one byte
     * in the compressed data --- which could turn into a net loss once you
     * consider header and alignment padding.  Worst case, the compressed
     * format might require three padding bytes (plus header, which is
     * included in VARSIZE(tmp)), whereas the uncompressed format would take
     * only one header byte and no padding if the value is short enough.  So
     * we insist on a savings of more than 2 bytes to ensure we have a gain.
     */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pglz_compress</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>valsize</name></expr></argument>,
                        <argument><expr><call><name>TOAST_COMPRESS_RAWDATA</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>PGLZ_strategy_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name>len</name> <operator>+</operator> <name>TOAST_COMPRESS_HDRSZ</name> <operator>&lt;</operator> <name>valsize</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TOAST_COMPRESS_SET_RAWSIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>valsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>TOAST_COMPRESS_HDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* successful compression */</comment>
        <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* incompressible data */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_get_valid_index
 *
 *    Get OID of valid index associated to given toast relation. A toast
 *    relation can have only one valid index at the same time.
 */</comment>
<function><type><name>Oid</name></type>
<name>toast_get_valid_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>toastoid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_indexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>validIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>validIndexOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toastrel</name></decl>;</decl_stmt>

    <comment type="block">/* Open the toast relation */</comment>
    <expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>toastoid</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Look for the valid index of the toast relation */</comment>
    <expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                    <argument><expr><name>lock</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>validIndexOid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Close the toast relation and all its indexes */</comment>
    <expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>validIndexOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_save_datum -
 *
 *    Save one single datum into the secondary relation and return
 *    a Datum reference for it.
 *
 * rel: the main relation we're working with (not the toast rel!)
 * value: datum to be pushed to toast storage
 * oldexternal: if not NULL, toast pointer previously representing the datum
 * options: options to be passed to heap_insert() for toast rows
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>toast_save_datum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
                 <parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>oldexternal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
                , <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                )</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toastrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>toasttup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>toasttupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>t_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>t_isnull</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>mycid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
    <union>union
    <block>{
        <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name></type> <name>hdr</name></decl>;</decl_stmt>
        <comment type="block">/* this is to make the union big enough for a chunk: */</comment>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>data</name><index>[<expr><name>TOAST_MAX_CHUNK_SIZE</name> <operator>+</operator> <name>VARHDRSZ</name></expr>]</index></name></decl>;</decl_stmt>
        <comment type="block">/* ensure union is aligned well enough: */</comment>
        <decl_stmt><decl><type><name>int32</name></type>        <name>align_it</name></decl>;</decl_stmt>
    }</block>            <decl><name>chunk_data</name></decl>;</union>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chunk_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chunk_seq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data_p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>data_todo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pointer</name></type>        <name>dval</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_indexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>validIndex</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the toast relation and its indexes.  We can use the index to check
     * uniqueness of the OID we assign to the toasted item, even though it has
     * additional columns besides OID.
     */</comment>
    <expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>toasttupDesc</name> <operator>=</operator> <name><name>toastrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

    <comment type="block">/* Open all the toast indexes and look for the valid one */</comment>
    <expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                    <argument><expr><name>RowExclusiveLock</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the data pointer and length, and compute va_rawsize and va_extsize.
     *
     * va_rawsize is the size of the equivalent fully uncompressed datum, so
     * we have to adjust for short headers.
     *
     * va_extsize is the actual size of the data payload in the toast records.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>data_p</name> <operator>=</operator> <call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_todo</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name> <operator>=</operator> <name>data_todo</name> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>    <comment type="block">/* as if not short */</comment>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name> <operator>=</operator> <name>data_todo</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>data_p</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_todo</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
        <comment type="block">/* rawsize in a compressed datum is just the size of the payload */</comment>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name> <operator>=</operator> <call><name>VARRAWSIZE_4B_C</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name> <operator>=</operator> <name>data_todo</name></expr>;</expr_stmt>
        <comment type="block">/* Assert that the numbers look like it's compressed */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>data_p</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_todo</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name> <operator>=</operator> <name>data_todo</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Insert the correct table OID into the result TOAST pointer.
     *
     * Normally this is the actual OID of the target toast table, but during
     * table-rewriting operations such as CLUSTER, we have to insert the OID
     * of the table's real permanent toast table instead.  rd_toastoid is set
     * if we have to substitute such an OID.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Choose an OID to use as the value ID for this toast value.
     *
     * Normally we just choose an unused OID within the toast table.  But
     * during table-rewriting operations where we are preserving an existing
     * toast table OID, we want to preserve toast value OIDs too.  So, if
     * rd_toastoid is set and we had a prior external value from that same
     * toast table, re-use its value ID.  If we didn't have a prior external
     * value (which is a corner case, but possible if the table's attstorage
     * options have been changed), we have to pick a value ID that doesn't
     * conflict with either new or existing toast value OIDs.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* normal case: just choose an unused OID */</comment>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator>
            <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* rewrite case: check to see if value was in old toast table */</comment>
        <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>oldexternal</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>old_toast_pointer</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>oldexternal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Must copy to access aligned fields */</comment>
            <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>old_toast_pointer</name></expr></argument>, <argument><expr><name>oldexternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>old_toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* This value came from the old toast table; reuse its OID */</comment>
                <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator> <name><name>old_toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * There is a corner case here: the table rewrite might have
                 * to copy both live and recently-dead versions of a row, and
                 * those versions could easily reference the same toast value.
                 * When we copy the second or later version of such a row,
                 * reusing the OID will mean we select an OID that's already
                 * in the new toast table.  Check for that, and if so, just
                 * fall through without writing the data again.
                 *
                 * While annoying and ugly-looking, this is a good thing
                 * because it ensures that we wind up with only one copy of
                 * the toast value when there is only one copy in the old
                 * toast table.  Before we detected this case, we'd have made
                 * multiple copies, wasting space; and what's worse, the
                 * copies belonging to already-deleted heap tuples would not
                 * be reclaimed by VACUUM.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>toastrel_valueid_exists</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                            <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Match, so short-circuit the data storage loop below */</comment>
                    <expr_stmt><expr><name>data_todo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * new value; must choose an OID that doesn't conflict in either
             * old or new toast table
             */</comment>
            <do>do
            <block>{<block_content>
                <expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator>
                    <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                       <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><call><name>toastid_valueid_exists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr></argument>,
                                            <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Initialize constant parts of the tuple data
     */</comment>
    <expr_stmt><expr><name><name>t_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t_isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t_isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t_isnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Split up the item into chunks
     */</comment>
    <while>while <condition>(<expr><name>data_todo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Calculate the size of this chunk
         */</comment>
        <expr_stmt><expr><name>chunk_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>TOAST_MAX_CHUNK_SIZE</name></expr></argument>, <argument><expr><name>data_todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Build a tuple and store it
         */</comment>
        <expr_stmt><expr><name><name>t_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_seq</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_data</name></expr></argument>, <argument><expr><name>chunk_size</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_p</name></expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>toasttup</name> <operator>=</operator> <call><name>heap_form_tuple_toast</name><argument_list>(<argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><name>t_values</name></expr></argument>, <argument><expr><name>t_isnull</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>toasttup</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Create the index entry.  We cheat a little here by not using
         * FormIndexDatum: this relies on the knowledge that the index columns
         * are the same as the initial columns of the table for all the
         * indexes.  We also cheat by not providing an IndexInfo: this is okay
         * for now because btree doesn't need one, but we might have to be
         * more honest someday.
         *
         * Note also that there had better not be any user-created index on
         * the TOAST table, since we don't bother to update anything else.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Only index relations marked as ready can be updated */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IndexIsReady</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rd_index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>index_insert</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>t_values</name></expr></argument>, <argument><expr><name>t_isnull</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>toasttup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
                             <argument><expr><name>toastrel</name></expr></argument>,
                             <argument><expr><ternary><condition><expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr> ?</condition><then>
                             <expr><name>UNIQUE_CHECK_YES</name></expr> </then><else>: <expr><name>UNIQUE_CHECK_NO</name></expr></else></ternary></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Free memory
         */</comment>
        <expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>toasttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Move on to next chunk
         */</comment>
        <expr_stmt><expr><name>data_todo</name> <operator>-=</operator> <name>chunk_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_p</name> <operator>+=</operator> <name>chunk_size</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Done - close toast relation and its indexes
     */</comment>
    <expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the TOAST pointer value that we'll return
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>TOAST_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARTAG_EXTERNAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>VARTAG_ONDISK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA_EXTERNAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>toast_pointer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_delete_datum -
 *
 *    Delete a single external stored value.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>toast_delete_datum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_speculative</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toastrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>toastkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>toastscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>toasttup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_indexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>validIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotToast</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Must copy to access aligned fields */</comment>
    <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the toast relation and its indexes
     */</comment>
    <expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch valid relation used for process */</comment>
    <expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                    <argument><expr><name>RowExclusiveLock</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup a scan key to find chunks with matching va_valueid
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>,
                <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find all the chunks.  (We don't actually care whether we see them in
     * sequence or not, but since we've already locked the index we might as
     * well use systable_beginscan_ordered.)
     */</comment>
    <expr_stmt><expr><call><name>init_toast_snapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>toastscan</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>toasttup</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Have a chunk, delete it
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_speculative</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>heap_abort_speculative</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>toasttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>toasttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * End scan and close relations
     */</comment>
    <expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toastrel_valueid_exists -
 *
 * Test whether a toast value with the given ID exists in the toast relation.
 * For safety, we consider a value to exist if there are either live or dead
 * toast rows with that ID; see notes for GetNewOid().
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>toastrel_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>toastkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>toastscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_indexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>validIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>

    <comment type="block">/* Fetch a valid index relation */</comment>
    <expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                    <argument><expr><name>RowExclusiveLock</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup a scan key to find chunks with matching va_valueid
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>,
                <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>valueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Is there any such chunk?
     */</comment>
    <expr_stmt><expr><name>toastscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up */</comment>
    <expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toastid_valueid_exists -
 *
 *    As above, but work from toast rel's OID not an open relation
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>toastid_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>toastrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toastrel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>toastrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>toastrel_valueid_exists</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>valueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_fetch_datum -
 *
 *    Reconstruct an in memory Datum from the chunks saved
 *    in the toast relation
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>toast_fetch_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toastrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>toastkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>toastscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>ttup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>toasttupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>ressize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>residx</name></decl>,
                <decl><type ref="prev"/><name>nextidx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>numchunks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pointer</name></type>        <name>chunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>chunkdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chunksize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_indexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>validIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotToast</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"toast_fetch_datum shouldn't be called for non-ondisk datums"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Must copy to access aligned fields */</comment>
    <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ressize</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numchunks</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ressize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>TOAST_MAX_CHUNK_SIZE</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ressize</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ressize</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ressize</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Open the toast relation and its indexes
     */</comment>
    <expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>toasttupDesc</name> <operator>=</operator> <name><name>toastrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

    <comment type="block">/* Look for the valid index of the toast relation */</comment>
    <expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                    <argument><expr><name>AccessShareLock</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup a scan key to fetch from the index by va_valueid
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>,
                <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read the chunks by index
     *
     * Note that because the index is actually on (valueid, chunkidx) we will
     * see the chunks in chunkidx order, even though we didn't explicitly ask
     * for it.
     */</comment>
    <expr_stmt><expr><name>nextidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_toast_snapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>toastscan</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ttup</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Have a chunk, extract the sequence number and the data
         */</comment>
        <expr_stmt><expr><name>residx</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>ttup</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>ttup</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* could happen due to heap_form_tuple doing its thing */</comment>
            <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* should never happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found toasted toast chunk for toast value %u in %s"</literal></expr></argument>,
                 <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Some checks on the data we've found
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>residx</name> <operator>!=</operator> <name>nextidx</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk number %d (expected %d) for toast value %u in %s"</literal></expr></argument>,
                 <argument><expr><name>residx</name></expr></argument>, <argument><expr><name>nextidx</name></expr></argument>,
                 <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>residx</name> <operator>&lt;</operator> <name>numchunks</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>chunksize</name> <operator>!=</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk size %d (expected %d) in chunk %d of %d for toast value %u in %s"</literal></expr></argument>,
                     <argument><expr><name>chunksize</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr></argument>,
                     <argument><expr><name>residx</name></expr></argument>, <argument><expr><name>numchunks</name></expr></argument>,
                     <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                     <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>residx</name> <operator>==</operator> <name>numchunks</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>residx</name> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name> <operator>+</operator> <name>chunksize</name><operator>)</operator> <operator>!=</operator> <name>ressize</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk size %d (expected %d) in final chunk %d for toast value %u in %s"</literal></expr></argument>,
                     <argument><expr><name>chunksize</name></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ressize</name> <operator>-</operator> <name>residx</name> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name><operator>)</operator></expr></argument>,
                     <argument><expr><name>residx</name></expr></argument>,
                     <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                     <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk number %d (out of range %d..%d) for toast value %u in %s"</literal></expr></argument>,
                 <argument><expr><name>residx</name></expr></argument>,
                 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numchunks</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                 <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Copy the data into proper place in our result
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>residx</name> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr></argument>,
               <argument><expr><name>chunkdata</name></expr></argument>,
               <argument><expr><name>chunksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>nextidx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Final checks that we successfully fetched the datum
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nextidx</name> <operator>!=</operator> <name>numchunks</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing chunk number %d for toast value %u in %s"</literal></expr></argument>,
             <argument><expr><name>nextidx</name></expr></argument>,
             <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * End scan and close relations
     */</comment>
    <expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_fetch_datum_slice -
 *
 *    Reconstruct a segment of a Datum from the chunks saved
 *    in the toast relation
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>toast_fetch_datum_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sliceoffset</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>toastrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>toastkey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nscankeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>toastscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>ttup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>toasttupDesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>attrsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>residx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>nextidx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numchunks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>startchunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>endchunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>startoffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>endoffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>totalchunks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pointer</name></type>        <name>chunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>chunkdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chunksize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chcpystrt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>chcpyend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_indexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>validIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotToast</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"toast_fetch_datum_slice shouldn't be called for non-ondisk datums"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Must copy to access aligned fields */</comment>
    <expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * It's nonsense to fetch slices of a compressed datum -- this isn't lo_*
     * we can't return a compressed datum which is meaningful to toast later
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attrsize</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>totalchunks</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>attrsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>TOAST_MAX_CHUNK_SIZE</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>sliceoffset</name> <operator>&gt;=</operator> <name>attrsize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sliceoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sliceoffset</name> <operator>+</operator> <name>length</name><operator>)</operator> <operator>&gt;</operator> <name>attrsize</name><operator>)</operator> <operator>||</operator> <name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>attrsize</name> <operator>-</operator> <name>sliceoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>length</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>length</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* Can save a lot of work at this point! */</comment>

    <expr_stmt><expr><name>startchunk</name> <operator>=</operator> <name>sliceoffset</name> <operator>/</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endchunk</name> <operator>=</operator> <operator>(</operator><name>sliceoffset</name> <operator>+</operator> <name>length</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numchunks</name> <operator>=</operator> <operator>(</operator><name>endchunk</name> <operator>-</operator> <name>startchunk</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>startoffset</name> <operator>=</operator> <name>sliceoffset</name> <operator>%</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endoffset</name> <operator>=</operator> <operator>(</operator><name>sliceoffset</name> <operator>+</operator> <name>length</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Open the toast relation and its indexes
     */</comment>
    <expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>toasttupDesc</name> <operator>=</operator> <name><name>toastrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

    <comment type="block">/* Look for the valid index of toast relation */</comment>
    <expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
                                    <argument><expr><name>AccessShareLock</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup a scan key to fetch from the index. This is either two keys or
     * three depending on the number of chunks.
     */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Use equality condition for one chunk, a range condition otherwise:
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numchunks</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
                    <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>startchunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nscankeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
                    <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4GE</name></expr></argument>,
                    <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>startchunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
                    <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4LE</name></expr></argument>,
                    <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>endchunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nscankeys</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Read the chunks by index
     *
     * The index is on (valueid, chunkidx) so they will come in order
     */</comment>
    <expr_stmt><expr><call><name>init_toast_snapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nextidx</name> <operator>=</operator> <name>startchunk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>toastscan</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>, <argument><expr><name>nscankeys</name></expr></argument>, <argument><expr><name>toastkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>ttup</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Have a chunk, extract the sequence number and the data
         */</comment>
        <expr_stmt><expr><name>residx</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>ttup</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>ttup</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* could happen due to heap_form_tuple doing its thing */</comment>
            <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* should never happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found toasted toast chunk for toast value %u in %s"</literal></expr></argument>,
                 <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Some checks on the data we've found
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>residx</name> <operator>!=</operator> <name>nextidx</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>residx</name> <operator>&gt;</operator> <name>endchunk</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>residx</name> <operator>&lt;</operator> <name>startchunk</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk number %d (expected %d) for toast value %u in %s"</literal></expr></argument>,
                 <argument><expr><name>residx</name></expr></argument>, <argument><expr><name>nextidx</name></expr></argument>,
                 <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>residx</name> <operator>&lt;</operator> <name>totalchunks</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>chunksize</name> <operator>!=</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk size %d (expected %d) in chunk %d of %d for toast value %u in %s when fetching slice"</literal></expr></argument>,
                     <argument><expr><name>chunksize</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr></argument>,
                     <argument><expr><name>residx</name></expr></argument>, <argument><expr><name>totalchunks</name></expr></argument>,
                     <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                     <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>residx</name> <operator>==</operator> <name>totalchunks</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>residx</name> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name> <operator>+</operator> <name>chunksize</name><operator>)</operator> <operator>!=</operator> <name>attrsize</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk size %d (expected %d) in final chunk %d for toast value %u in %s when fetching slice"</literal></expr></argument>,
                     <argument><expr><name>chunksize</name></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>attrsize</name> <operator>-</operator> <name>residx</name> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name><operator>)</operator></expr></argument>,
                     <argument><expr><name>residx</name></expr></argument>,
                     <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                     <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk number %d (out of range %d..%d) for toast value %u in %s"</literal></expr></argument>,
                 <argument><expr><name>residx</name></expr></argument>,
                 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>totalchunks</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
                 <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
                 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Copy the data into proper place in our result
         */</comment>
        <expr_stmt><expr><name>chcpystrt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>chcpyend</name> <operator>=</operator> <name>chunksize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>residx</name> <operator>==</operator> <name>startchunk</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>chcpystrt</name> <operator>=</operator> <name>startoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>residx</name> <operator>==</operator> <name>endchunk</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>chcpyend</name> <operator>=</operator> <name>endoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator>
               <operator>(</operator><name>residx</name> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name> <operator>-</operator> <name>sliceoffset</name><operator>)</operator> <operator>+</operator> <name>chcpystrt</name></expr></argument>,
               <argument><expr><name>chunkdata</name> <operator>+</operator> <name>chcpystrt</name></expr></argument>,
               <argument><expr><operator>(</operator><name>chcpyend</name> <operator>-</operator> <name>chcpystrt</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>nextidx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Final checks that we successfully fetched the datum
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nextidx</name> <operator>!=</operator> <operator>(</operator><name>endchunk</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing chunk number %d for toast value %u in %s"</literal></expr></argument>,
             <argument><expr><name>nextidx</name></expr></argument>,
             <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * End scan and close relations
     */</comment>
    <expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_decompress_datum -
 *
 * Decompress a compressed version of a varlena datum
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>toast_decompress_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><call><name>TOAST_COMPRESS_RAWSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>TOAST_COMPRESS_RAWSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pglz_decompress</name><argument_list>(<argument><expr><call><name>TOAST_COMPRESS_RAWDATA</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>TOAST_COMPRESS_HDRSZ</name></expr></argument>,
                        <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>TOAST_COMPRESS_RAWSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"compressed data is corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_open_indexes
 *
 *    Get an array of the indexes associated to the given toast relation
 *    and return as well the position of the valid index used by the toast
 *    relation in this array. It is the responsibility of the caller of this
 *    function to close the indexes as well as free them.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>toast_open_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>,
                   <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>,
                   <parameter><decl><type><name>Relation</name> <modifier>*</modifier><modifier>*</modifier></type><name>toastidxs</name></decl></parameter>,
                   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Get index list of the toast relation */</comment>
    <expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexlist</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>num_indexes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Open all the index relations */</comment>
    <expr_stmt><expr><operator>*</operator><name>toastidxs</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_indexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><call><name>foreach</name><argument_list>(<argument><expr><name>lc</name></expr></argument>, <argument><expr><name>indexlist</name></expr></argument>)</argument_list></call>
        <argument_list>(<argument><expr><operator>*</operator><name>toastidxs</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name><operator>++</operator></expr>]</index> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch the first valid index in list */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>    <name>toastidx</name> <init>= <expr><operator>(</operator><operator>*</operator><name>toastidxs</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>toastidx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Free index list, not necessary anymore as relations are opened and a
     * valid index has been found.
     */</comment>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The toast relation should have one valid index, so something is going
     * wrong if there is nothing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no valid index found for toast relation with Oid %u"</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_close_indexes
 *
 *    Close an array of indexes for a toast relation and free it. This should
 *    be called for a set of indexes opened previously with toast_open_indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>toast_close_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>toastidxs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_indexes</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Close relations and clean up things */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * init_toast_snapshot
 *
 *    Initialize an appropriate TOAST snapshot.  We must use an MVCC snapshot
 *    to initialize the TOAST snapshot; since we don't know which one to use,
 *    just use the oldest one.  This is safe: at worst, we will get a "snapshot
 *    too old" error that might have been avoided otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_toast_snapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>toast_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name> <init>= <expr><call><name>GetOldestSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no known snapshots"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>InitToastSnapshot</name><argument_list>(<argument><expr><operator>*</operator><name>toast_snapshot</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>whenTaken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
