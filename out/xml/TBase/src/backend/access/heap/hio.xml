<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/heap/hio.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hio.c
 *      POSTGRES heap access method input/output code.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/access/heap/hio.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/extentmapping.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/freespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationAddExtraBlocks_repair</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ShardID</name> <modifier>*</modifier></type><name>shardid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * RelationPutHeapTuple - place tuple at specified page
 *
 * !!! EREPORT(ERROR) IS DISALLOWED HERE !!!  Must PANIC on failure!!!
 *
 * Note - caller must hold BUFFER_LOCK_EXCLUSIVE on the buffer.
 */</comment>
<function><type><name>void</name></type>
<name>RelationPutHeapTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
                     <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
                     <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>pageHeader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

    <comment type="block">/*
     * A tuple that's being inserted speculatively should already have its
     * token set.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>token</name> <operator>||</operator> <call><name>HeapTupleHeaderIsSpeculative</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add the tuple to the page */</comment>
    <expr_stmt><expr><name>pageHeader</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>pageHeader</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
                         <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add tuple to page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Update tuple-&gt;t_self to the actual position where it was stored */</comment>
    <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Insert the correct position into CTID of the stored tuple, too (unless
     * this is a speculative insertion, in which case the token is held in
     * CTID field instead)
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>itemId</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>pageHeader</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Item</name></type>        <name>item</name> <init>= <expr><call><name>PageGetItem</name><argument_list>(<argument><expr><name>pageHeader</name></expr></argument>, <argument><expr><name>itemId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <name>item</name><operator>)</operator><operator>-&gt;</operator><name>t_ctid</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read in a buffer, using bulk-insert strategy if bistate isn't NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>ReadBufferBI</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>targetBlock</name></decl></parameter>,
             <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>

    <comment type="block">/* If not bulk-insert, exactly like ReadBuffer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bistate</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we have the desired block already pinned, re-pin and return it */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>targetBlock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* ... else drop the old buffer */</comment>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>sid</name></name> <operator>=</operator> <name>InvalidShardID</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Perform a read using the buffer strategy */</comment>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>,
                                <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Save the selected block as target for future inserts */</comment>
    <expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <comment type="line">//bistate-&gt;sid = PageGetShardId(BufferGetPage(buffer));</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For each heap page which is all-visible, acquire a pin on the appropriate
 * visibility map page, if we haven't already got one.
 *
 * buffer2 may be InvalidBuffer, if only one buffer is involved.  buffer1
 * must not be InvalidBuffer.  If both buffers are specified, buffer1 must
 * be less than buffer2.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetVisibilityMapPins</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer1</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer2</name></decl></parameter>,
                     <parameter><decl><type><name>BlockNumber</name></type> <name>block1</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>block2</name></decl></parameter>,
                     <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>vmbuffer1</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>vmbuffer2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_to_pin_buffer1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_to_pin_buffer2</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer2</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>||</operator> <name>buffer1</name> <operator>&lt;=</operator> <name>buffer2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Figure out which pins we need but don't have. */</comment>
        <expr_stmt><expr><name>need_to_pin_buffer1</name> <operator>=</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <operator>!</operator><call><name>visibilitymap_pin_ok</name><argument_list>(<argument><expr><name>block1</name></expr></argument>, <argument><expr><operator>*</operator><name>vmbuffer1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>need_to_pin_buffer2</name> <operator>=</operator> <name>buffer2</name> <operator>!=</operator> <name>InvalidBuffer</name>
            <operator>&amp;&amp;</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <operator>!</operator><call><name>visibilitymap_pin_ok</name><argument_list>(<argument><expr><name>block2</name></expr></argument>, <argument><expr><operator>*</operator><name>vmbuffer2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_to_pin_buffer1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>need_to_pin_buffer2</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="block">/* We must unlock both buffers before doing any I/O. */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer1</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>buffer2</name> <operator>!=</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator> <name>buffer2</name> <operator>!=</operator> <name>buffer1</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer2</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Get pins. */</comment>
        <if_stmt><if>if <condition>(<expr><name>need_to_pin_buffer1</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block1</name></expr></argument>, <argument><expr><name>vmbuffer1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_to_pin_buffer2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block2</name></expr></argument>, <argument><expr><name>vmbuffer2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Relock buffers. */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer1</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>buffer2</name> <operator>!=</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator> <name>buffer2</name> <operator>!=</operator> <name>buffer1</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer2</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If there are two buffers involved and we pinned just one of them,
         * it's possible that the second one became all-visible while we were
         * busy pinning the first one.  If it looks like that's a possible
         * scenario, we'll need to make a second pass through this loop.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>buffer2</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>||</operator> <name>buffer1</name> <operator>==</operator> <name>buffer2</name>
            <operator>||</operator> <operator>(</operator><name>need_to_pin_buffer1</name> <operator>&amp;&amp;</operator> <name>need_to_pin_buffer2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Extend a relation by multiple blocks to avoid future contention on the
 * relation extension lock.  Our goal is to pre-extend the relation by an
 * amount which ramps up as the degree of contention ramps up, but limiting
 * the result to some sane overall value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationAddExtraBlocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockNum</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>,
                <decl><type ref="prev"/><name>firstBlock</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>extraBlocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>lockWaiters</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>    
    <if_stmt><if>if<condition>(<expr><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extent-organized relation must extend with shardid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Use the length of the lock wait queue to judge how much to extend. */</comment>
        <expr_stmt><expr><name>lockWaiters</name> <operator>=</operator> <call><name>RelationExtensionLockWaiterCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>lockWaiters</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>extraBlocks</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * It might seem like multiplying the number of lock waiters by as much as
             * 20 is too aggressive, but benchmarking revealed that smaller numbers
             * were insufficient.  512 is just an arbitrary cap to prevent
             * pathological results.
             */</comment>
            <expr_stmt><expr><name>extraBlocks</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>, <argument><expr><name>lockWaiters</name> <operator>*</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>extent_off</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>next_extent</name></decl>;</decl_stmt>
    
        <expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>extent_off</name> <operator>=</operator> <name>nblocks</name> <operator>%</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>next_extent</name> <operator>=</operator> <operator>(</operator><name>ExtentID</name><operator>)</operator><operator>(</operator><name>nblocks</name> <operator>/</operator> <name>PAGES_PER_EXTENTS</name><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>extent_off</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ShardID</name></type> <name>repair_sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"relation %d is not extented-align. number of blocks is %d"</literal></expr></argument>,
                    <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RelationAddExtraBlocks_repair</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>repair_sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>repair_sid</name> <operator>==</operator> <name>sid</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* 
                 * If system crushes when it had finished extending extent catalog but not finished 
                 * extending heap, there would be inconsistency between extent catalog and heap.
                 * As it happend, caller would get block from shard alloc list first because the 
                 * extent catalog has been flushed to storage.
                 * So, program will nerver reach this branch.
                 * And, I must deal with failure to read block in last extent of heap to buffer.
                 */</comment>
            </block_content>}</block></if></if_stmt>
            
            <comment type="block">/* skip current extent. */</comment>
            <expr_stmt><expr><name>next_extent</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* init extent info */</comment>
        <expr_stmt><expr><call><name>ExtendExtentForShard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>next_extent</name></expr></argument>, <argument><expr><name>MAX_FREESPACE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>extraBlocks</name> <operator>=</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>extraBlocks</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"extraBlocks cannot be zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>extraBlocks</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Ouch - an unnecessary lseek() each time through the loop! */</comment>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferBI</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Extend by one page. */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageInit_shard</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>blockNum</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>bistate</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>sid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Remember first block number thus added. */</comment>
        <if_stmt><if>if <condition>(<expr><name>firstBlock</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>firstBlock</name> <operator>=</operator> <name>blockNum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Immediately update the bottom level of the FSM.  This has a good
         * chance of making this page visible to other concurrently inserting
         * backends, and we want that to happen without delay.
         */</comment>
        <expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Updating the upper levels of the free space map is too expensive to do
     * for every block, but it's worth doing once at the end to make sure that
     * subsequent insertion activity sees all of those nifty free pages we
     * just inserted.
     *
     * Note that we're using the freespace value that was reported for the
     * last block we added as if it were the freespace value for every block
     * we added.  That's actually true, because they're all equally empty.
     */</comment>
    <expr_stmt><expr><call><name>UpdateFreeSpaceMap</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>firstBlock</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationAddExtraBlocks_repair</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ShardID</name> <modifier>*</modifier></type><name>shardid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockNum</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>,
                <decl><type ref="prev"/><name>firstBlock</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>extraBlocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>        <name>sid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>shardBlock</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>shardid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>shardid</name> <operator>=</operator> <name>InvalidShardID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>    
    
    <expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>nblocks</name> <operator>%</operator> <name>PAGES_PER_EXTENTS</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* get shardid from first page of this extent */</comment>
    <expr_stmt><expr><name>shardBlock</name> <operator>=</operator> <operator>(</operator><name>nblocks</name> <operator>/</operator> <name>PAGES_PER_EXTENTS</name><operator>)</operator> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferBI</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>shardBlock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>PageGetShardId</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* init extent info */</comment>
    <comment type="line">//ExtendExtentForShard(relation, sid, next_extent, 250);</comment>
    
    <expr_stmt><expr><name>extraBlocks</name> <operator>=</operator> <name>PAGES_PER_EXTENTS</name> <operator>-</operator> <name>nblocks</name> <operator>%</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>extraBlocks</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Ouch - an unnecessary lseek() each time through the loop! */</comment>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferBI</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Extend by one page. */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageInit_shard</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>blockNum</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Remember first block number thus added. */</comment>
        <if_stmt><if>if <condition>(<expr><name>firstBlock</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>firstBlock</name> <operator>=</operator> <name>blockNum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Immediately update the bottom level of the FSM.  This has a good
         * chance of making this page visible to other concurrently inserting
         * backends, and we want that to happen without delay.
         */</comment>
        <expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Updating the upper levels of the free space map is too expensive to do
     * for every block, but it's worth doing once at the end to make sure that
     * subsequent insertion activity sees all of those nifty free pages we
     * just inserted.
     *
     * Note that we're using the freespace value that was reported for the
     * last block we added as if it were the freespace value for every block
     * we added.  That's actually true, because they're all equally empty.
     */</comment>
    <expr_stmt><expr><call><name>UpdateFreeSpaceMap</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>firstBlock</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>shardid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>shardid</name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
void
RelationExtendHeapForRedo(RelFileNode rnode, ExtentID eid, ShardID sid)
{
    SMgrRelation smgr;
    BlockNumber nblocks;
    BlockNumber maxblocks;
    BlockNumber minblocks;
    BlockNumber currBlock;
    Buffer        buffer;
    Page        page;
    Size        freespace;
    BlockNumber    blockNum;

    maxblocks = (eid+1) * PAGES_PER_EXTENTS;
    minblocks = eid * PAGES_PER_EXTENTS;
    
    smgr = smgropen(rnode, InvalidBackendId);

    smgrcreate(smgr, MAIN_FORKNUM, true);

    nblocks = smgrnblocks(smgr, MAIN_FORKNUM);
    
    <comment type="block">/* return if head has been extend already. */</comment>
    if( maxblocks &lt;= nblocks )
    {
        smgrclose(smgr);
        return;
    }

    if(nblocks &lt; minblocks)
    {
        smgrclose(smgr);
        elog(ERROR, "extend heap failed when redo xlog. "
                "it may has skip one or more append extent xlog.");
    }
    
    if(!ShardIDIsValid(sid))
    {
        smgrclose(smgr);
        elog(FATAL, "extend head failed when redo wal. shardid %d is invalid.",
                    sid);
    }

    if(nblocks &gt; minblocks)
    {
        buffer = ReadBufferForRedoExtentTable(smgr, minblocks, RBM_NORMAL);
        if(!PageIsNew(BufferGetPage(buffer)))
        {
            if(sid != PageGetShardId(BufferGetPage(buffer)))
            {
                elog(ERROR, "extend heap failed when redo xlog. "
                            "shardid of first page in extent %d is %d,"
                            "but the given shardid is %d.",
                        eid,
                        PageGetShardId(BufferGetPage(buffer)),
                        sid);
            }
        }
        ReleaseBuffer(buffer);
    }

    currBlock = nblocks;
    while (currBlock++ &lt; maxblocks)
    {
        buffer = ReadBufferForRedoExtentTable(smgr, P_NEW, RBM_NORMAL);

        <comment type="block">/* Extend by one page. */</comment>
        LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);
        page = BufferGetPage(buffer);
        PageInit_shard(page, BufferGetPageSize(buffer), 0, sid, false);
        MarkBufferDirty(buffer);
        blockNum = BufferGetBlockNumber(buffer);
        freespace = PageGetHeapFreeSpace(page);
        UnlockReleaseBuffer(buffer);        

        XLogRecordPageWithFreeSpace_extent(rnode, blockNum, freespace, true);
    }

    <comment type="block">/*
     * for sharded table, searching a free page is implemented by searching a free extent first. 
     * So, not to update searching tree above the bottom fsmpage is ok.
     */</comment>
    <comment type="line">//UpdateFreeSpaceMap(relation, firstBlock, blockNum, freespace);</comment>
    
    smgrclose(smgr);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>RelationExtendHeapForRedo</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>maxblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>minblocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>currBlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freespace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type>    <name>blockNum</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>maxblocks</name> <operator>=</operator> <operator>(</operator><name>eid</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>minblocks</name> <operator>=</operator> <name>eid</name> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>smgr</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>nblocks</name> <operator>&lt;</operator> <name>minblocks</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend heap failed when redo xlog. "</literal>
                <literal type="string">"it may has skip one or more append extent xlog."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"extend head failed when redo wal. shardid %d is invalid."</literal></expr></argument>,
                    <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>currBlock</name> <operator>=</operator> <name>minblocks</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>currBlock</name> <operator>&lt;</operator> <name>maxblocks</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>currBlock</name> <operator>&lt;</operator> <name>nblocks</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferForRedoExtentTable</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>currBlock</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferForRedoExtentTable</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend heap failed when redo xlog, read block %d from relation %d/%d/%d fialed."</literal></expr></argument>,
                        <argument><expr><name>currBlock</name></expr></argument>,
                        <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageInit_shard</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>blockNum</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRecordPageWithFreeSpace_extent</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currBlock</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * for sharded table, searching a free page is implemented by searching a free extent first. 
     * So, not to update searching tree above the bottom fsmpage is ok.
     */</comment>
    <comment type="line">//UpdateFreeSpaceMap(relation, firstBlock, blockNum, freespace);</comment>
    
    <expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * RelationGetBufferForTuple
 *
 *    Returns pinned and exclusive-locked buffer of a page in given relation
 *    with free space &gt;= given len.
 *
 *    If otherBuffer is not InvalidBuffer, then it references a previously
 *    pinned buffer of another page in the same relation; on return, this
 *    buffer will also be exclusive-locked.  (This case is used by heap_update;
 *    the otherBuffer contains the tuple being updated.)
 *
 *    The reason for passing otherBuffer is that if two backends are doing
 *    concurrent heap_update operations, a deadlock could occur if they try
 *    to lock the same two buffers in opposite orders.  To ensure that this
 *    can't happen, we impose the rule that buffers of a relation must be
 *    locked in increasing page number order.  This is most conveniently done
 *    by having RelationGetBufferForTuple lock them both, with suitable care
 *    for ordering.
 *
 *    NOTE: it is unlikely, but not quite impossible, for otherBuffer to be the
 *    same buffer we select for insertion of the new tuple (this could only
 *    happen if space is freed in that page after heap_update finds there's not
 *    enough there).  In that case, the page will be pinned and locked only once.
 *
 *    For the vmbuffer and vmbuffer_other arguments, we avoid deadlock by
 *    locking them only after locking the corresponding heap page, and taking
 *    no further lwlocks while they are locked.
 *
 *    We normally use FSM to help us find free space.  However,
 *    if HEAP_INSERT_SKIP_FSM is specified, we just append a new empty page to
 *    the end of the relation if the tuple won't fit on the current target page.
 *    This can save some cycles when we know the relation is new and doesn't
 *    contain useful amounts of free space.
 *
 *    HEAP_INSERT_SKIP_FSM is also useful for non-WAL-logged additions to a
 *    relation, if the caller holds exclusive lock and is careful to invalidate
 *    relation's smgr_targblock before the first insertion --- that ensures that
 *    all insertions will occur into newly added pages and not be intermixed
 *    with tuples from other transactions.  That way, a crash can't risk losing
 *    any committed data of other transactions.  (See heap_insert's comments
 *    for additional constraints needed for safe usage of this behavior.)
 *
 *    The caller can also provide a BulkInsertState object to optimize many
 *    insertions into the same relation.  This keeps a pin on the current
 *    insertion target page (to save pin/unpin cycles) and also passes a
 *    BULKWRITE buffer selection strategy object to the buffer manager.
 *    Passing NULL for bistate selects the default behavior.
 *
 *    We always try to avoid filling existing pages further than the fillfactor.
 *    This is OK since this routine is not consulted when updating a tuple and
 *    keeping it on the same page, which is the scenario fillfactor is meant
 *    to reserve space for.
 *
 *    ereport(ERROR) is allowed here, so this routine *must* be called
 *    before any (unlogged) changes are made in buffer pool.
 */</comment>
<function><type><name>Buffer</name></type>
<name>RelationGetBufferForTuple_shard</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>,
                          <parameter><decl><type><name>Buffer</name></type> <name>otherBuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
                          <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>,
                          <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>vmbuffer</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>vmbuffer_other</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>use_fsm</name> <init>= <expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_FSM</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>pageFreeSpace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
                <decl><type ref="prev"/><name>saveFreeSpace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetBlock</name></decl>,
                <decl><type ref="prev"/><name>otherBlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>needLock</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>last_got</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type>    <name>last_gotten_block</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* be conservative */</comment>

    <comment type="block">/* Bulk insert is not supported for updates, only inserts. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>otherBuffer</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>||</operator> <operator>!</operator><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get buffer for extent-ed tuple, but param sid is invalid. relation:%d, sid:%d"</literal></expr></argument>, 
                         <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>sid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we're gonna fail for oversize tuple, do it right away
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>MaxHeapTupleSize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row is too big: size %zu, maximum size %zu"</literal></expr></argument>,
                        <argument><expr><name>len</name></expr></argument>, <argument><expr><name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Compute desired extra freespace due to fillfactor option */</comment>
    <expr_stmt><expr><name>saveFreeSpace</name> <operator>=</operator> <call><name>RelationGetTargetPageFreeSpace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
                                                   <argument><expr><name>HEAP_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>otherBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>otherBlock</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>otherBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>otherBlock</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* just to keep compiler quiet */</comment>

    <comment type="block">/*
     * We first try to put the tuple on the same page we last inserted a tuple
     * on, as cached in the BulkInsertState or relcache entry.  If that
     * doesn't work, we ask the Free Space Map to locate a suitable page.
     * Since the FSM's info might be out of date, we have to be prepared to
     * loop around and retry multiple times. (To insure this isn't an infinite
     * loop, we must update the FSM with the correct amount of free space on
     * each page that proves not to be suitable.)  If the FSM has no record of
     * a page with enough free space, we give up and extend the relation.
     *
     * When use_fsm is false, we either put the tuple onto the existing target
     * page or extend the relation.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name> <operator>&gt;</operator> <name>MaxHeapTupleSize</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* can't fit, don't bother asking FSM */</comment>
        <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>use_fsm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>bistate</name> <operator>&amp;&amp;</operator> <name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>bistate</name><operator>-&gt;</operator><name>sid</name></name> <operator>==</operator> <name>sid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>targetBlock</name> <operator>=</operator>  <call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>RelationGetTargetBlock_Shard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>targetBlock</name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>&amp;&amp;</operator> <name>use_fsm</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have no cached target page, so ask the FSM for an initial
         * target.
         */</comment>
        <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>GetPageWithFreeSpace_withshard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>last_got</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>targetBlock</name> <operator>==</operator> <name>last_gotten_block</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"To get free block may causes infinite loop. "</literal>
                                <literal type="string">"extent catalog of relation %s(%d) may has error."</literal></expr></argument>,
                                <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>last_got</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>last_gotten_block</name> <operator>=</operator> <name>targetBlock</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * If the FSM knows nothing of the rel, try the last page before we
         * give up and extend.  This avoids one-tuple-per-page syndrome during
         * bootstrapping or in a recently-started system.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>targetBlock</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <name>nblocks</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>loop</name>:</label>
    <while>while <condition>(<expr><name>targetBlock</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <decl_stmt><decl><type><name>bool</name></type>        <name>shard_need_repair</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Read and exclusive-lock the target block, as well as the other
         * block if one was given, taking suitable care with lock ordering and
         * the possibility they are the same block.
         *
         * If the page-level all-visible flag is set, caller will need to
         * clear both that and the corresponding visibility map bit.  However,
         * by the time we return, we'll have x-locked the buffer, and we don't
         * want to do any I/O while in that state.  So we check the bit here
         * before taking the lock, and pin the page if it appears necessary.
         * Checking without the lock creates a risk of getting the wrong
         * answer, so we'll have to recheck after acquiring the lock.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>otherBuffer</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* easy case */</comment>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferBI</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <if_stmt><if>if<condition>(<expr><name>bistate</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>sid</name></name> <operator>=</operator> <call><name>PageGetShardId</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>otherBlock</name> <operator>==</operator> <name>targetBlock</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* also easy case */</comment>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>otherBuffer</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>otherBlock</name> <operator>&lt;</operator> <name>targetBlock</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* lock other buffer first */</comment>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>otherBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* lock target buffer first */</comment>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>otherBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * We now have the target page (and the other buffer, if any) pinned
         * and locked.  However, since our initial PageIsAllVisible checks
         * were performed before acquiring the lock, the results might now be
         * out of date, either for the selected victim buffer, or for the
         * other buffer passed by the caller.  In that case, we'll need to
         * give up our locks, go get the pin(s) we failed to get earlier, and
         * re-lock.  That's pretty painful, but hopefully shouldn't happen
         * often.
         *
         * Note that there's a small possibility that we didn't pin the page
         * above but still have the correct page pinned anyway, either because
         * we've already made a previous pass through this loop, or because
         * caller passed us the right page anyway.
         *
         * Note also that it's possible that by the time we get the pin and
         * retake the buffer locks, the visibility map bit will have been
         * cleared by some other backend anyway.  In that case, we'll have
         * done a bit of extra work for no gain, but there's no real harm
         * done.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>otherBuffer</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>||</operator> <name>buffer</name> <operator>&lt;=</operator> <name>otherBuffer</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>GetVisibilityMapPins</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>otherBuffer</name></expr></argument>,
                                 <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>otherBlock</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>,
                                 <argument><expr><name>vmbuffer_other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>GetVisibilityMapPins</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>otherBuffer</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
                                 <argument><expr><name>otherBlock</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>vmbuffer_other</name></expr></argument>,
                                 <argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Now we can check to see if there's enough free space here. If so,
         * we're done.
         */</comment>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <comment type="block">/*check if shardid of page is correct */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PageInit_shard</name><argument_list>(<argument><expr><name>page</name></expr></argument>,<argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>PageIsInUse</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* 
                 * check shardid of extent.
                 * After one shard truncated, all extents included in this shard will be free.
                 * After then, all pages which belong to these extents will be reinit, 
                 * so page's shardid will be set to InvalidShardID. 
                 */</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>is_occu</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ShardID</name></type>    <name>e_sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExtentID</name></type> <name>eid</name> <init>= <expr><name>targetBlock</name> <operator>/</operator> <name>PAGES_PER_EXTENTS</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ema_get_eme_extract</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_occu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e_sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><name>is_occu</name> <operator>&amp;&amp;</operator> <name>sid</name> <operator>==</operator> <name>e_sid</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PageSetShardId</name><argument_list>(<argument><expr><name>page</name></expr></argument>,<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>otherBuffer</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>otherBlock</name> <operator>!=</operator> <name>targetBlock</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>otherBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>GetPageWithFreeSpace_withshard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if<condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if<condition>(<expr><name>last_got</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if<condition>(<expr><name>targetBlock</name> <operator>==</operator> <name>last_gotten_block</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"To get free block may causes infinite loop. "</literal>
                                            <literal type="string">"extent catalog of relation %s(%d) may has error."</literal></expr></argument>,
                                            <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name>last_got</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>last_gotten_block</name> <operator>=</operator> <name>targetBlock</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <continue>continue;</continue>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if<condition>(<expr><call><name>PageIsInUse</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PageGetShardId</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>sid</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">//ERROR: shardid</comment>
                <comment type="block">/*repair EME in extent mapping*/</comment>
                <expr_stmt><expr><call><name>repair_eme</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><call><name>PageGetShardId</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>shard_need_repair</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>pageFreeSpace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name> <operator>&lt;=</operator> <name>pageFreeSpace</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name>PageGetShardId</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>sid</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* use this page as future insert target, too */</comment>
                    <expr_stmt><expr><call><name>RelationSetTargetBlock_Shard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>buffer</name></expr>;</return>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>repair_eme</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>targetBlock</name></expr></argument>, <argument><expr><call><name>PageGetShardId</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>shard_need_repair</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,<argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>buffer</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Not enough space, so we must give up our page locks and pin (if
         * any) and prepare to look elsewhere.  We don't care which order we
         * unlock the two buffers in, so this can be slightly simpler than the
         * code above.
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>otherBuffer</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>otherBlock</name> <operator>!=</operator> <name>targetBlock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>otherBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Without FSM, always fall out of the loop and extend */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_fsm</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Update FSM as to condition of this page, and ask for another page
         * to try.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>shard_need_repair</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>RecordAndGetPageWithFreeSpace_extent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
                                                        <argument><expr><name>targetBlock</name></expr></argument>,
                                                        <argument><expr><name>pageFreeSpace</name></expr></argument>,
                                                        <argument><expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name></expr></argument>,
                                                        <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>GetPageWithFreeSpace_withshard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if<condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>last_got</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>targetBlock</name> <operator>==</operator> <name>last_gotten_block</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"To get free block may causes infinite looping. "</literal>
                                    <literal type="string">"Extent catalog of relation %s(%d) may has error."</literal></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>last_got</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>last_gotten_block</name> <operator>=</operator> <name>targetBlock</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>RecordAndGetPageWithFreeSpace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
                                                        <argument><expr><name>targetBlock</name></expr></argument>,
                                                        <argument><expr><name>pageFreeSpace</name></expr></argument>,
                                                        <argument><expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></while>

    <comment type="block">/*
     * Have to extend the relation.
     *
     * We have to use a lock to ensure no one else is extending the rel at the
     * same time, else we will both try to initialize the same new page.  We
     * can skip locking for new or temp relations, however, since no one else
     * could be accessing them.
     */</comment>
    <expr_stmt><expr><name>needLock</name> <operator>=</operator> <operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we need the lock but are not able to acquire it immediately, we'll
     * consider extending the relation by multiple blocks at a time to manage
     * contention on the relation extension lock.  However, this only makes
     * sense if we're using the FSM; otherwise, there's no point.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_fsm</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationForExtension</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Couldn't get the lock immediately; wait for it. */</comment>
            <expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Check if some other backend has extended a block for us while
             * we were waiting on the lock.
             */</comment>
            <expr_stmt><expr><name>targetBlock</name> <operator>=</operator> <call><name>GetPageWithFreeSpace_withshard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>saveFreeSpace</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <if_stmt><if>if<condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>targetBlock</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>last_got</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>targetBlock</name> <operator>==</operator> <name>last_gotten_block</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"To get free block may causes infinite loop. "</literal>
                                    <literal type="string">"extent catalog of relation %s(%d) may has error."</literal></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>last_got</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>last_gotten_block</name> <operator>=</operator> <name>targetBlock</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*
             * If some other waiter has already extended the relation, we
             * don't need to do so; just use the existing freespace.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>targetBlock</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>loop</name>;</goto>
            </block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>RelationAddExtraBlocks</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>, 
								<argument><expr><ternary><condition><expr><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>sid</name></expr> </then><else>: <expr><name>InvalidShardID</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    

    <comment type="block">/*
     * In addition to whatever extension we performed above, we always add at
     * least one block to satisfy our own request.
     *
     * XXX This does an lseek - rather expensive - but at the moment it is the
     * only way to accurately determine how many blocks are in a relation.  Is
     * it worth keeping an accurate file length in shared memory someplace,
     * rather than relying on the kernel to do it for us?
     */</comment>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferBI</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We can be certain that locking the otherBuffer first is OK, since it
     * must have a lower page number.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>otherBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>otherBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now acquire lock on the new page.
     */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Release the file-extension lock; it's now OK for someone else to extend
     * the relation some more.  Note that we cannot release this lock before
     * we have buffer lock on the new page, or we risk a race condition
     * against vacuumlazy.c --- see comments therein.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We need to initialize the empty new page.  Double-check that it really
     * is empty (this should never happen, but if it does we don't want to
     * risk wiping out valid data).
     */</comment>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"buffer is invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"page %u of relation \"%s\" should be empty but is not"</literal></expr></argument>,
             <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PageInit_shard</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We should not get here given the test at the top */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"tuple is too big: size %zu"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Remember the new page as our target for future insertions.
     *
     * XXX should we enter the new page into the free space map immediately,
     * or just keep it for this backend's exclusive use in the short run
     * (until VACUUM sees it)?    Seems to depend on whether you expect the
     * current backend to make more insertions or not, which is probably a
     * good bet most of the time.  So for now, don't add it to FSM yet.
     */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RelationSetTargetBlock_Shard</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>
</unit>
