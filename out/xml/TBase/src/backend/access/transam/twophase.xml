<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/transam/twophase.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * twophase.c
 *        Two-phase commit support functions.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 * IDENTIFICATION
 *        src/backend/access/transam/twophase.c
 *
 * NOTES
 *        Each global transaction is associated with a global transaction
 *        identifier (GID). The client assigns a GID to a postgres
 *        transaction with the PREPARE TRANSACTION command.
 *
 *        We keep all active global transactions in a shared memory array.
 *        When the PREPARE TRANSACTION command is issued, the GID is
 *        reserved for the transaction in the array. This is done before
 *        a WAL entry is made, because the reservation checks for duplicate
 *        GIDs and aborts the transaction if there already is a global
 *        transaction in prepared state with the same GID.
 *
 *        A global transaction (gxact) also has dummy PGXACT and PGPROC; this is
 *        what keeps the XID considered running by TransactionIdIsInProgress.
 *        It is also convenient as a PGPROC to hook the gxact's locks to.
 *
 *        Information to recover prepared transactions in case of crash is
 *        now stored in WAL for the common case. In some cases there will be
 *        an extended period between preparing a GXACT and commit/abort, in
 *        which case we need to separately record prepared transaction data
 *        in permanent storage. This includes locking information, pending
 *        notifications etc. All that state information is written to the
 *        per-transaction state file in the pg_twophase directory.
 *        All prepared transactions will be written prior to shutdown.
 *
 *        Life track of state data is following:
 *
 *        * On PREPARE TRANSACTION backend writes state data only to the WAL and
 *          stores pointer to the start of the WAL record in
 *          gxact-&gt;prepare_start_lsn.
 *        * If COMMIT occurs before checkpoint then backend reads data from WAL
 *          using prepare_start_lsn.
 *        * On checkpoint state data copied to files in pg_twophase directory and
 *          fsynced
 *        * If COMMIT happens after checkpoint then backend reads state data from
 *          files
 *
 *        During replay and replication, TwoPhaseState also holds information
 *        about active prepared transactions that haven't been moved to disk yet.
 *
 *        Replay of twophase records happens by the following rules:
 *
 *        * At the beginning of recovery, pg_twophase is scanned once, filling
 *          TwoPhaseState with entries marked with gxact-&gt;inredo and
 *          gxact-&gt;ondisk.  Two-phase file data older than the XID horizon of
 *          the redo position are discarded.
 *        * On PREPARE redo, the transaction is added to TwoPhaseState-&gt;prepXacts.
 *          gxact-&gt;inredo is set to true for such entries.
 *        * On Checkpoint we iterate through TwoPhaseState-&gt;prepXacts entries
 *          that have gxact-&gt;inredo set and are behind the redo_horizon. We
 *          save them to disk and then switch gxact-&gt;ondisk to true.
 *        * On COMMIT/ABORT we delete the entry from TwoPhaseState-&gt;prepXacts.
 *          If gxact-&gt;ondisk is true, the corresponding entry from the disk
 *          is additionally deleted.
 *        * RecoverPreparedTransactions(), StandbyRecoverPreparedTransactions()
 *          and PrescanPreparedTransactions() have been modified to go through
 *          gxact-&gt;inredo entries that have not made it to disk.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase_rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/xc_maintenance_mode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmap.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Directory where Two-phase commit files reside within PGDATA
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWOPHASE_DIR</name></cpp:macro> <cpp:value>"pg_twophase"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWOPHASE_RECORD_DIR</name></cpp:macro> <cpp:value>"pg_2pc"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_2PC_FILE_PATH</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>tid</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>snprintf(path, MAXPGPATH, TWOPHASE_RECORD_DIR "/%s", tid)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type>  <name>transaction_threshold</name> <init>= <expr><literal type="number">200000</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_CONTENT_SIZE</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>

<comment type="block">/* GUC variable, can't be changed after startup */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type>            <name>max_prepared_xacts</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* We require 2PC */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type>            <name>max_prepared_xacts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>        <name>enable_2pc_recovery_info</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>record_2pc_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>enable_2pc_file_cache</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_2pc_file_check</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_2pc_entry_key_check</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_2pc_entry_trace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>record_2pc_cache_size</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>record_2pc_entry_size</name> <init>= <expr><literal type="number">2048</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_OUTPUT_FILE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TID_SIZE</name></cpp:macro>        <cpp:value>MAXPGPATH</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_2PC_INFO_SIZE</name></cpp:macro>   <cpp:value>(record_2pc_entry_size - MAX_TID_SIZE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DFLT_2PC_INFO_SIZE</name></cpp:macro>  <cpp:value>1024</cpp:value></cpp:define>  <comment type="block">/* default size */</comment>

<function_decl><type><name>uint32</name></type> <name>Record2pcCacheHashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * The 2pc info cache is partitioned to reduce contention.
 * To determine which partition lock a given tid requires, compute the tid's
 * hash code with Record2pcCacheHashCode(), then apply Cache2pcPartitionLock().
 * NB: NUM_CACHE_2PC_PARTITIONS must be a power of 2!
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Cache2pcHashPartition</name><parameter_list>(<parameter><type><name>hashcode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((hashcode) % NUM_CACHE_2PC_PARTITIONS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Cache2pcPartitionLock</name><parameter_list>(<parameter><type><name>hashcode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(&amp;MainLWLockArray[CACHE_2PC_LWLOCK_OFFSET + \
		Cache2pcHashPartition(hashcode)].lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Cache2pcPartitionLockByIndex</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(&amp;MainLWLockArray[CACHE_2PC_LWLOCK_OFFSET + (i)].lock)</cpp:value></cpp:define>

<comment type="block">/* hash table entry for 2pc record */</comment>
<typedef>typedef <type><struct>struct <name>Cache2pcInfo</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><name>MAX_TID_SIZE</name></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* hash key: tid */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>info</name><index>[<expr><name>DFLT_2PC_INFO_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

}</block></struct></type> <name>Cache2pcInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_entry_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>add_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>append_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>remove_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>get_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>save_and_remove_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>check_2pc_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>GlobalTransaction</name></type>
<name>LookupGXact</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GlobalTransaction</name></type>
<name>LockGXact</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_check</name></decl></parameter>)</parameter_list>;</function_decl>



<comment type="block">/*
 * This struct describes one global transaction that is in prepared state
 * or attempting to become prepared.
 *
 * The lifecycle of a global transaction is:
 *
 * 1. After checking that the requested GID is not in use, set up an entry in
 * the TwoPhaseState-&gt;prepXacts array with the correct GID and valid = false,
 * and mark it as locked by my backend.
 *
 * 2. After successfully completing prepare, set valid = true and enter the
 * referenced PGPROC into the global ProcArray.
 *
 * 3. To begin COMMIT PREPARED or ROLLBACK PREPARED, check that the entry is
 * valid and not locked, then mark the entry as locked by storing my current
 * backend ID into locking_backend.  This prevents concurrent attempts to
 * commit or rollback the same prepared xact.
 *
 * 4. On completion of COMMIT PREPARED or ROLLBACK PREPARED, remove the entry
 * from the ProcArray and the TwoPhaseState-&gt;prepXacts array and return it to
 * the freelist.
 *
 * Note that if the preparing transaction fails between steps 1 and 2, the
 * entry must be removed so that the GID and the GlobalTransaction struct
 * can be reused.  See AtAbort_Twophase().
 *
 * typedef struct GlobalTransactionData *GlobalTransaction appears in
 * twophase.h
 *
 * Note that the max value of GIDSIZE must fit in the uint16 gidlen,
 * specified in TwoPhaseFileHeader.
 * refer to MAX_IMPLICIT_2PC_STR_LEN (5 + 21 + 64 + 1 + 5 + 5), bigger than it.
 */</comment>

<typedef>typedef <type><struct>struct <name>GlobalTransactionData</name>
<block>{
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>next</name></decl>;</decl_stmt>        <comment type="block">/* list link for free list */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>pgprocno</name></decl>;</decl_stmt>        <comment type="block">/* ID of associated dummy PGPROC */</comment>
    <decl_stmt><decl><type><name>BackendId</name></type>    <name>dummyBackendId</name></decl>;</decl_stmt> <comment type="block">/* similar to backend id for backends */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl>;</decl_stmt>    <comment type="block">/* time of preparation */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>prepared_timestamp</name></decl>;</decl_stmt>    <comment type="block">/* prepared global timestamp */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Note that we need to keep track of two LSNs for each GXACT. We keep
     * track of the start LSN because this is the address we must use to read
     * state data back from WAL when committing a prepared GXACT. We keep
     * track of the end LSN because that is the LSN we need to wait for prior
     * to commit.
     */</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>prepare_start_lsn</name></decl>;</decl_stmt>    <comment type="block">/* XLOG offset of prepare record start */</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>prepare_end_lsn</name></decl>;</decl_stmt>    <comment type="block">/* XLOG offset of prepare record end */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>            <comment type="block">/* The GXACT id */</comment>

    <decl_stmt><decl><type><name>Oid</name></type>            <name>owner</name></decl>;</decl_stmt>            <comment type="block">/* ID of user that executed the xact */</comment>
    <decl_stmt><decl><type><name>BackendId</name></type>    <name>locking_backend</name></decl>;</decl_stmt>    <comment type="block">/* backend currently working on the xact */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>valid</name></decl>;</decl_stmt>            <comment type="block">/* TRUE if PGPROC entry is in proc array */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>ondisk</name></decl>;</decl_stmt>            <comment type="block">/* TRUE if prepare state file is on disk */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>inredo</name></decl>;</decl_stmt>            <comment type="block">/* TRUE if entry was added via xlog_redo */</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>gid</name><index>[<expr><name>GIDSIZE</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* The GID assigned to the prepared xact */</comment>
}</block></struct></type>            <name>GlobalTransactionData</name>;</typedef>

<comment type="block">/*
 * Two Phase Commit shared state.  Access to this struct is protected
 * by TwoPhaseStateLock.
 */</comment>
<typedef>typedef <type><struct>struct <name>TwoPhaseStateData</name>
<block>{
    <comment type="block">/* Head of linked list of free GlobalTransactionData structs */</comment>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>freeGXacts</name></decl>;</decl_stmt>

    <comment type="block">/* Number of valid prepXacts entries. */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numPrepXacts</name></decl>;</decl_stmt>

    <comment type="block">/* There are max_prepared_xacts items in this array */</comment>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name><name>prepXacts</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TwoPhaseStateData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>TwoPhaseStateData</name> <modifier>*</modifier></type><name>TwoPhaseState</name></decl>;</decl_stmt>

<comment type="block">/*
 * Global transaction entry currently locked by us, if any.  Note that any
 * access to the entry pointed to by this variable must be protected by
 * TwoPhaseStateLock, though obviously the pointer itself doesn't need to be
 * (since it's just local memory).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>GlobalTransaction</name></type> <name>MyLockedGxact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>twophaseExitRegistered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordTransactionCommitPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
                                <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
                                <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>ninvalmsgs</name></decl></parameter>,
                                <parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>initfileinval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordTransactionAbortPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
                               <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
                               <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessRecords</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bufptr</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>TwoPhaseCallback</name></type> <name><name>callbacks</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveGXact</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XlogReadTwoPhaseData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ProcessTwoPhaseBuffer</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                      <parameter><decl><type><name>XLogRecPtr</name></type> <name>prepare_start_lsn</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>fromdisk</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setParent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setNextXid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkAsPreparingGuts</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>,
                    <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>giveWarning</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecreateTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialization of shared memory
 */</comment>
<function><type><name>Size</name></type>
<name>TwoPhaseShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* Need the fixed struct, the array of pointers, and the GTD structs */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>TwoPhaseStateData</name></expr></argument>, <argument><expr><name>prepXacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_prepared_xacts</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_prepared_xacts</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>TwoPhaseShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>TwoPhaseState</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Prepared Transaction Table"</literal></expr></argument>,
                                    <argument><expr><call><name>TwoPhaseShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxacts</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Initialize the linked list of free GlobalTransactionData structs
         */</comment>
        <expr_stmt><expr><name>gxacts</name> <operator>=</operator> <operator>(</operator><name>GlobalTransaction</name><operator>)</operator>
            <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>TwoPhaseState</name> <operator>+</operator>
             <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>TwoPhaseStateData</name></expr></argument>, <argument><expr><name>prepXacts</name></expr></argument>)</argument_list></call> <operator>+</operator>
                      <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransaction</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_prepared_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_prepared_xacts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* insert into linked list */</comment>
            <expr_stmt><expr><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

            <comment type="block">/* associate it with a PGPROC assigned by InitProcGlobal */</comment>
            <expr_stmt><expr><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pgprocno</name> <operator>=</operator> <name><name>PreparedXactProcs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pgprocno</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Assign a unique ID for each dummy proc, so that the range of
             * dummy backend IDs immediately follows the range of normal
             * backend IDs. We don't dare to assign a real backend ID to dummy
             * procs, because prepared transactions don't take part in cache
             * invalidation like a real backend ID would imply, but having a
             * unique ID for them is nevertheless handy. This arrangement
             * allows you to allocate an array of size (MaxBackends +
             * max_prepared_xacts + 1), and have a slot for every backend and
             * prepared transaction. Currently multixact.c uses that
             * technique.
             */</comment>
            <expr_stmt><expr><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dummyBackendId</name> <operator>=</operator> <name>MaxBackends</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exit hook to unlock the global transaction entry we're working on.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtProcExit_Twophase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* same logic as abort */</comment>
    <expr_stmt><expr><call><name>AtAbort_Twophase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Abort hook to unlock the global transaction entry we're working on.
 */</comment>
<function><type><name>void</name></type>
<name>AtAbort_Twophase</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>MyLockedGxact</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * What to do with the locked global transaction entry?  If we were in the
     * process of preparing the transaction, but haven't written the WAL
     * record and state file yet, the transaction must not be considered as
     * prepared.  Likewise, if we are in the process of finishing an
     * already-prepared transaction, and fail after having already written the
     * 2nd phase commit or rollback record to the WAL, the transaction should
     * not be considered as prepared anymore.  In those cases, just remove the
     * entry from shared memory.
     *
     * Otherwise, the entry must be left in place so that the transaction can
     * be finished later, so just unlock it.
     *
     * If we abort during prepare, after having written the WAL record, we
     * might not have transferred all locks and other state to the prepared
     * transaction yet.  Likewise, if we abort during commit or rollback,
     * after having written the WAL record, we might not have released all the
     * resources held by the transaction yet.  In those cases, the in-memory
     * state can be wrong, but it's too late to back out.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyLockedGxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RemoveGXact</name><argument_list>(<argument><expr><name>MyLockedGxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>MyLockedGxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is called after we have finished transferring state to the prepared
 * PGXACT entry.
 */</comment>
<function><type><name>void</name></type>
<name>PostPrepare_Twophase</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>MyLockedGxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecoverEndGlobalPrepare</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name>    <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"recover proc no %d prepare timestamp "</literal> <name>INT64_FORMAT</name> <literal type="string">" xid %d."</literal></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, 
                            <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_timestamp</name></name></expr></argument>, <argument><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>EndGlobalPrepare</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isImplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name>	<modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>, <argument><expr><call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"proc no %d prepare timestamp "</literal> <name>INT64_FORMAT</name> <literal type="string">" xid %d."</literal></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, 
							<argument><expr><call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>isImplicit</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"prepare transaction %d does not have valid prepare timestamp. autovacuum %d"</literal></expr></argument>, 
             <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE_DEBUG__</name></cpp:ifdef>
	<if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InsertPreparedXid</name><argument_list>(<argument><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	

	<comment type="line">// SetGlobalPrepareTimestamp(InvalidGlobalTimestamp);</comment>
	<comment type="block">/* 
	 * Transfer the tmin to the prepared proc without locking. 
	 * As the prepare xact procs lie behind the normal procs in proc array,
	 * Get Snapshot would not miss the tmin even when it is being transferred.
	 * 
	 * According to PortalRunUtility, we do not set snapshot if transaction
	 * only contains utilities that do not need one. In that case,
	 * xmin and tmin are both invalid, for they are both set by snapshot.
	 * So if xmin is valid, tmin should also be.
	 */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>, <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyPgXact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyPgXact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"prepare transaction %d does not have valid tmin. autovacuum %d"</literal></expr></argument>, 
			 <argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>EndExplicitGlobalPrepare</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>gxact</name> <operator>=</operator> <call><name>LookupGXact</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>==</operator> <name>gxact</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>pgxact</name> <operator>=</operator>  <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>, <argument><expr><call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"proc no %d explicit prepare timestamp "</literal> <name>INT64_FORMAT</name> <literal type="string">" xid %d gid %s."</literal></expr></argument>, 
                        <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, <argument><expr><call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"explicit prepared transaction %d does not have valid prepare timestamp. autovacuum %d"</literal></expr></argument>, 
             <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SetGlobalPrepareTimestamp</name><argument_list>(<argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/*
 * MarkAsPreparing
 *        Reserve the GID for the given transaction.
 */</comment>
<function><type><name>GlobalTransaction</name></type>
<name>MarkAsPreparing</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>,
                <parameter><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>GIDSIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction identifier \"%s\" is too long"</literal></expr></argument>,
                        <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* fail immediately if feature is disabled */</comment>
    <if_stmt><if>if <condition>(<expr><name>max_prepared_xacts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transactions are disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set max_prepared_transactions to a nonzero value."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* on first call, register the exit hook */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>twophaseExitRegistered</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>AtProcExit_Twophase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>twophaseExitRegistered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for conflicting GID */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction identifier \"%s\" is already in use"</literal></expr></argument>,
                            <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Get a free gxact from the freelist */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"maximum number of prepared transactions reached"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase max_prepared_transactions (currently %d)."</literal></expr></argument>,
                         <argument><expr><name>max_prepared_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MarkAsPreparingGuts</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>prepared_at</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>databaseid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* And insert it into the active array */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>&lt;</operator> <name>max_prepared_xacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>gxact</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MarkAsPreparingGuts
 *
 * This uses a gxact struct and puts it into the active array.
 * NOTE: this is also used when reloading a gxact after a crash; so avoid
 * assuming that we can use very much backend context.
 *
 * Note: This function should be called with appropriate locks held.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkAsPreparingGuts</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>,
                    <parameter><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gxact</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgxact</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Initialize the PGPROC entry */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>STATUS_OK</name></expr>;</expr_stmt>
    <comment type="block">/* We set up the gxact's VXID as InvalidBackendId/XID */</comment>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <operator>(</operator><name>LocalTransactionId</name><operator>)</operator> <name>xid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>prepare_timestamp</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgxact</name><operator>-&gt;</operator><name>tmin</name></name></expr></argument>, <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>=</operator> <name>databaseid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>roleId</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>isBackgroundWorker</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <comment type="block">/* subxid data must be filled later by GXactLoadSubxactData */</comment>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name> <operator>=</operator> <name>prepared_at</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Remember that we have this GlobalTransaction entry locked for us. If we
     * abort after this, we must release it.
     */</comment>
    <expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GXactLoadSubxactData
 *
 * If the transaction being persisted had any subtransactions, this must
 * be called before MarkAsPrepared() to load information into the dummy
 * PGPROC.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GXactLoadSubxactData</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsubxacts</name></decl></parameter>,
                     <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We need no extra lock since the GXACT isn't valid yet */</comment>
    <if_stmt><if>if <condition>(<expr><name>nsubxacts</name> <operator>&gt;</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nsubxacts</name> <operator>=</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nsubxacts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
               <argument><expr><name>nsubxacts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <name>nsubxacts</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MarkAsPrepared
 *        Mark the GXACT as fully valid, and enter it into the global ProcArray.
 *
 * lock_held indicates whether caller already holds TwoPhaseStateLock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkAsPrepared</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock_held</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Lock here may be overkill, but I'm not convinced of that ... */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock_held</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock_held</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/*
     * Put it into the global ProcArray so TransactionIdIsInProgress considers
     * the XID as still running.
     */</comment>
    <expr_stmt><expr><call><name>ProcArrayAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GlobalTransaction</name></type>
<name>LookupGXact</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>


    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Ignore not-yet-valid GIDs */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Found it, but has someone else got it locked? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction with identifier \"%s\" is busy"</literal></expr></argument>,
                            <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>user</name> <operator>!=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to finish prepared transaction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Must be superuser or the user that prepared the transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Note: it probably would be possible to allow committing from
         * another database; but at the moment NOTIFY is known not to work and
         * there may be some other issues as well.  Hence disallow until
         * someone gets motivated to make it work.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>MyDatabaseId</name> <operator>!=</operator> <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction belongs to another database"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Connect to the database where the transaction was prepared to finish it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>gxact</name></expr>;</return>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * In PGXC, if xc_maintenance_mode is on, COMMIT/ROLLBACK PREPARED may be issued to the
     * node where the given xid does not exist.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>xc_maintenance_mode</name></expr>)</condition>
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction with identifier \"%s\" does not exist"</literal></expr></argument>,
                    <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* NOTREACHED */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockGXact
 *        Locate the prepared transaction and mark it busy for COMMIT or PREPARE.
 */</comment>
<function><type><specifier>static</specifier> <name>GlobalTransaction</name></type>
<name>LockGXact</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_check</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* on first call, register the exit hook */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>twophaseExitRegistered</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>AtProcExit_Twophase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>twophaseExitRegistered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Ignore not-yet-valid GIDs */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Found it, but has someone else got it locked? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction with identifier \"%s\" is busy"</literal></expr></argument>,
                            <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>user</name> <operator>!=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to finish prepared transaction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Must be superuser or the user that prepared the transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Note: it probably would be possible to allow committing from
         * another database; but at the moment NOTIFY is known not to work and
         * there may be some other issues as well.  Hence disallow until
         * someone gets motivated to make it work.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>MyDatabaseId</name> <operator>!=</operator> <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction belongs to another database"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Connect to the database where the transaction was prepared to finish it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_check</name></expr>)</condition>
		<block>{<block_content>
        <comment type="block">/* OK for me to lock it */</comment>
        <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>gxact</name></expr>;</return>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * In PGXC, if xc_maintenance_mode is on, COMMIT/ROLLBACK PREPARED may be issued to the
     * node where the given xid does not exist.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>xc_maintenance_mode</name></expr>)</condition>
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction with identifier \"%s\" does not exist"</literal></expr></argument>,
                    <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* NOTREACHED */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveGXact
 *        Remove the prepared transaction from the shared memory array.
 *
 * NB: caller should have already removed it from ProcArray
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveGXact</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>gxact</name> <operator>==</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* remove from the active array */</comment>
            <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>]</index></name></expr>;</expr_stmt>

            <comment type="block">/* and put it back in the freelist */</comment>
            <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find %p in GlobalTransaction array"</literal></expr></argument>, <argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns an array of all prepared transactions for the user-level
 * function pg_prepared_xact.
 *
 * The returned array and all its elements are copies of internal data
 * structures, to minimize the time we need to hold the TwoPhaseStateLock.
 *
 * WARNING -- we return even those transactions that are not fully prepared
 * yet.  The caller should filter them out if he doesn't want them.
 *
 * The returned array is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetPreparedTransactionList</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name> <modifier>*</modifier></type><name>gxacts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>gxacts</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>array</name> <operator>=</operator> <operator>(</operator><name>GlobalTransaction</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>gxacts</name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>array</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Working status for pg_prepared_xact */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ngxacts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>currIdx</name></decl>;</decl_stmt>
}</block></struct></type> <name>Working_State</name>;</typedef>

<comment type="block">/*
 * pg_prepared_xact
 *        Produce a view with one row per prepared transaction.
 *
 * This function is here so we don't have to export the
 * GlobalTransactionData struct definition.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_prepared_xact</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Working_State</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Switch to memory context appropriate for multiple function calls
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <comment type="block">/* this had better match pg_prepared_xacts view in system_views.sql */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"transaction"</literal></expr></argument>,
                           <argument><expr><name>XIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"gid"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"prepared"</literal></expr></argument>,
                           <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ownerid"</literal></expr></argument>,
                           <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"dbid"</literal></expr></argument>,
                           <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Collect all the 2PC status information that we will format and send
         * out as a result set.
         */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name>Working_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Working_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>ngxacts</name></name> <operator>=</operator> <call><name>GetPreparedTransactionList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>status</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name>Working_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>array</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name><name>status</name><operator>-&gt;</operator><name>ngxacts</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><operator>&amp;</operator><name><name>status</name><operator>-&gt;</operator><name>array</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Form tuple with appropriate data.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TwoPhaseGetGXact
 *        Get the GlobalTransaction struct for a prepared transaction
 *        specified by XID
 */</comment>
<function><type><specifier>static</specifier> <name>GlobalTransaction</name></type>
<name>TwoPhaseGetGXact</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>cached_xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>GlobalTransaction</name></type> <name>cached_gxact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * During a recovery, COMMIT PREPARED, or ABORT PREPARED, we'll be called
     * repeatedly for the same XID.  We can save work with a simple cache.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>xid</name> <operator>==</operator> <name>cached_xid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>cached_gxact</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find GlobalTransaction for xid %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cached_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cached_gxact</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TwoPhaseGetDummyProc
 *        Get the dummy backend ID for prepared transaction specified by XID
 *
 * Dummy backend IDs are similar to real backend IDs of real backends.
 * They start at MaxBackends + 1, and are unique across all currently active
 * real backends and prepared transactions.
 */</comment>
<function><type><name>BackendId</name></type>
<name>TwoPhaseGetDummyBackendId</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><call><name>TwoPhaseGetGXact</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><name><name>gxact</name><operator>-&gt;</operator><name>dummyBackendId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TwoPhaseGetDummyProc
 *        Get the PGPROC that represents a prepared transaction specified by XID
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>TwoPhaseGetDummyProc</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><call><name>TwoPhaseGetGXact</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************************************************************/</comment>
<comment type="block">/* State file support                                                    */</comment>
<comment type="block" format="doxygen">/************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TwoPhaseFilePath</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>snprintf(path, MAXPGPATH, TWOPHASE_DIR "/%08X", xid)</cpp:value></cpp:define>

<comment type="block">/*
 * 2PC state file format:
 *
 *    1. TwoPhaseFileHeader
 *    2. TransactionId[] (subtransactions)
 *    3. RelFileNode[] (files to be deleted at commit)
 *    4. RelFileNode[] (files to be deleted at abort)
 *    5. SharedInvalidationMessage[] (inval messages to be sent at commit)
 *    6. TwoPhaseRecordOnDisk
 *    7. ...
 *    8. TwoPhaseRecordOnDisk (end sentinel, rmid == TWOPHASE_RM_END_ID)
 *    9. checksum (CRC-32C)
 *
 * Each segment except the final checksum is MAXALIGN'd.
 */</comment>

<comment type="block">/*
 * Header for a 2PC state file
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWOPHASE_MAGIC</name></cpp:macro>    <cpp:value>0x57F94533</cpp:value></cpp:define>    <comment type="block">/* format identifier */</comment>

<typedef>typedef <type><struct>struct <name>TwoPhaseFileHeader</name>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type>        <name>magic</name></decl>;</decl_stmt>            <comment type="block">/* format identifier */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>total_len</name></decl>;</decl_stmt>        <comment type="block">/* actual file length */</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>            <comment type="block">/* original transaction XID */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>database</name></decl>;</decl_stmt>        <comment type="block">/* OID of database it was in */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl>;</decl_stmt>    <comment type="block">/* time of preparation */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>owner</name></decl>;</decl_stmt>            <comment type="block">/* user running the transaction */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>nsubxacts</name></decl>;</decl_stmt>        <comment type="block">/* number of following subxact XIDs */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>ncommitrels</name></decl>;</decl_stmt>    <comment type="block">/* number of delete-on-commit rels */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>nabortrels</name></decl>;</decl_stmt>        <comment type="block">/* number of delete-on-abort rels */</comment>
    <decl_stmt><decl><type><name>int32</name></type>        <name>ninvalmsgs</name></decl>;</decl_stmt>        <comment type="block">/* number of cache invalidation messages */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>prepared_timestamp</name></decl>;</decl_stmt> <comment type="block">/* global prepare timestamp */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int32</name></type>       <name>ncreatesegs</name></decl>;</decl_stmt>    <comment type="block">/* number of created sequences */</comment>
    <decl_stmt><decl><type><name>int32</name></type>       <name>ndropsegs</name></decl>;</decl_stmt>        <comment type="block">/* number of dropped sequences */</comment>
    <decl_stmt><decl><type><name>int32</name></type>       <name>nrenamesegs</name></decl>;</decl_stmt>    <comment type="block">/* number of renamed sequences */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>bool</name></type>        <name>initfileinval</name></decl>;</decl_stmt>    <comment type="block">/* does relcache init file need invalidation? */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>gidlen</name></decl>;</decl_stmt>            <comment type="block">/* length of the GID - GID follows the header */</comment>
}</block></struct></type> <name>TwoPhaseFileHeader</name>;</typedef>

<comment type="block">/*
 * Header for each record in a state file
 *
 * NOTE: len counts only the rmgr data, not the TwoPhaseRecordOnDisk header.
 * The rmgr data will be stored starting on a MAXALIGN boundary.
 */</comment>
<typedef>typedef <type><struct>struct <name>TwoPhaseRecordOnDisk</name>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type>        <name>len</name></decl>;</decl_stmt>            <comment type="block">/* length of rmgr data */</comment>
    <decl_stmt><decl><type><name>TwoPhaseRmgrId</name></type> <name>rmid</name></decl>;</decl_stmt>        <comment type="block">/* resource manager for this record */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>info</name></decl>;</decl_stmt>            <comment type="block">/* flag bits for use by rmgr */</comment>
}</block></struct></type> <name>TwoPhaseRecordOnDisk</name>;</typedef>

<comment type="block">/*
 * During prepare, the state file is assembled in memory before writing it
 * to WAL and the actual state file.  We use a chain of StateFileChunk blocks
 * for that.
 */</comment>
<typedef>typedef <type><struct>struct <name>StateFileChunk</name>
<block>{
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>StateFileChunk</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>StateFileChunk</name>;</typedef>

<struct><specifier>static</specifier> struct <name>xllist</name>
<block>{
    <decl_stmt><decl><type><name>StateFileChunk</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>        <comment type="block">/* first data block in the chain */</comment>
    <decl_stmt><decl><type><name>StateFileChunk</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>        <comment type="block">/* last block in chain */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>num_chunks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>bytes_free</name></decl>;</decl_stmt>        <comment type="block">/* free bytes left in tail block */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>total_len</name></decl>;</decl_stmt>        <comment type="block">/* total data bytes in chain */</comment>
}</block>            <decl><name>records</name></decl>;</struct>


<comment type="block">/*
 * Append a block of data to records data structure.
 *
 * NB: each block is padded to a MAXALIGN multiple.  This must be
 * accounted for when the file is later read!
 *
 * The data is copied, so the caller is free to modify it afterwards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>save_state_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>padlen</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>padlen</name> <operator>&gt;</operator> <name><name>records</name><operator>.</operator><name>bytes_free</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StateFileChunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>padlen</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator> <operator>+</operator> <name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>padlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name> <operator>-=</operator> <name>padlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>total_len</name></name> <operator>+=</operator> <name>padlen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start preparing a state file.
 *
 * Initializes data structure and inserts the 2PC file header record.
 */</comment>
<function><type><name>void</name></type>
<name>StartPrepare</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TwoPhaseFileHeader</name></type> <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>commitrels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>abortrels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>create_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>drop_info</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rename_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Initialize linked list */</comment>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StateFileChunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>total_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Create header */</comment>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>TWOPHASE_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>total_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* EndPrepare will fill this in */</comment>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>database</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>prepared_at</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name> <operator>=</operator> <call><name>xactGetCommittedChildren</name><argument_list>(<argument><expr><operator>&amp;</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>ncommitrels</name></name> <operator>=</operator> <call><name>smgrGetPendingDeletes</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commitrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>nabortrels</name></name> <operator>=</operator> <call><name>smgrGetPendingDeletes</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abortrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>ninvalmsgs</name></name> <operator>=</operator> <call><name>xactGetCommittedInvalidationMessages</name><argument_list>(<argument><expr><operator>&amp;</operator><name>invalmsgs</name></expr></argument>,
                                                          <argument><expr><operator>&amp;</operator><name><name>hdr</name><operator>.</operator><name>initfileinval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>ncreatesegs</name></name> <operator>=</operator> <call><name>GetGTMCreateSeq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>create_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>ndropsegs</name></name>   <operator>=</operator> <call><name>GetGTMDropSeq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>drop_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>nrenamesegs</name></name>    <operator>=</operator> <call><name>GetGTMRenameSeq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rename_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>prepared_timestamp</name></name> <operator>=</operator> <call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc record prepare timestamp "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>prepared_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>gidlen</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* Include '\0' */</comment>

    <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>gidlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Add the additional info about subxacts, deletable files and cache
     * invalidation messages.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* While we have the child-xact data, stuff it in the gxact too */</comment>
        <expr_stmt><expr><call><name>GXactLoadSubxactData</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>ncommitrels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>commitrels</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>ncommitrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>commitrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>nabortrels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>abortrels</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>nabortrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>abortrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>ninvalmsgs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>invalmsgs</name></expr></argument>,
                        <argument><expr><name><name>hdr</name><operator>.</operator><name>ninvalmsgs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>invalmsgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>ncreatesegs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>create_info</name></expr></argument>,
                        <argument><expr><name><name>hdr</name><operator>.</operator><name>ncreatesegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CreateInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>create_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>ndropsegs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>drop_info</name></expr></argument>,
                        <argument><expr><name><name>hdr</name><operator>.</operator><name>ndropsegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DropInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>drop_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>nrenamesegs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>rename_info</name></expr></argument>,
                        <argument><expr><name><name>hdr</name><operator>.</operator><name>nrenamesegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RenameInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rename_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Finish preparing state data and writing it to WAL.
 */</comment>
<function><type><name>void</name></type>
<name>EndPrepare</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StateFileChunk</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Here is where we really truly prepare.
     *
     * We have to record transaction prepares even if we didn't make any
     * updates, because the transaction manager might get confused if we lose
     * a global transaction.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"record remote 2pc on node:%s,  gid: %s, startnode:%s, startxid: %u, "</literal>
                                     <literal type="string">"partnodes:%s, localxid: %u"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, 
                                         <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, 
                                         <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, 
                                         <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, 
                                         <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * record 2pc file for explicit trans at the beginning of EndPrepare,
     * since g_twophase_state is cleared after the explicit "PREPARE TRANSACTION"
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>&amp;&amp;</operator> 
            <operator>(</operator><name>FILE_KERNEL_EXSISTED</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>||</operator> 
                <operator>(</operator><name>FILE_PGCLEAN_EXISTED_CONSISTENT</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
                    <name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>record_2pc_involved_nodes_xid</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, 
                                  <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, 
                                  <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, 
                                  <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, 
                                  <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>&amp;&amp;</operator> 
            <name>FILE_PGCLEAN_EXISTED_NCONSISTENT</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>record_2pc_involved_nodes_xid</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, 
                                      <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, 
                                      <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, 
                                      <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, 
                                      <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>record_2pc_involved_nodes_xid</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, 
                                  <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, 
                                  <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, 
                                  <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, 
                                  <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>record_2pc_readonly</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* is a start node? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>GIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_PREPARING</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>PART_PREPARE_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
        <operator>!</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name>PGXCNodeId</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PREPARE_ERROR_RESPONSE_ERROR at node '%s'"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
        
    <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>&amp;&amp;</operator> 
        <name>PART_PREPARE_ENDPREPARE</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PART_PREPARE_ENDPREPARE complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Add the end sentinel to the list of 2PC records */</comment>
    <expr_stmt><expr><call><name>RegisterTwoPhaseRecord</name><argument_list>(<argument><expr><name>TWOPHASE_RM_END_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Go back and fill in total_len in the file header record */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>TWOPHASE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>total_len</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>total_len</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <comment type="block">/*
     * If the data size exceeds MaxAllocSize, we won't be able to read it in
     * ReadTwoPhaseFile. Check for that now, rather than fail in the case
     * where we write data to file and then re-read at commit time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>total_len</name></name> <operator>&gt;</operator> <name>MaxAllocSize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"two-phase state file maximum length exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Now writing 2PC state data to WAL. We let the WAL's CRC protection
     * cover us, so no need to calculate a separate CRC.
     *
     * We have to set delayChkpt here, too; otherwise a checkpoint starting
     * immediately after the WAL record is inserted could complete without
     * fsync'ing our state file.  (This is essentially the same kind of race
     * condition as the COMMIT-to-clog-write case that RecordTransactionCommit
     * uses delayChkpt for; see notes there.)
     *
     * We save the PREPARE record's location in the gxact for later use by
     * CheckPointTwoPhase.
     */</comment>
    <expr_stmt><expr><call><name>XLogEnsureRecordSpace</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>record</name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>record</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XACT_ID</name></expr></argument>, <argument><expr><name>XLOG_XACT_PREPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we crash now, we have prepared: WAL replay will fix things */</comment>

    <comment type="block">/* Store record's start location to read that later on Commit */</comment>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name> <operator>=</operator> <name>ProcLastRecPtr</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark the prepared transaction as valid.  As soon as xact.c marks
     * MyPgXact as not running our XID (which it will do immediately after
     * this function returns), others can commit/rollback the xact.
     *
     * NB: a side effect of this is to make a dummy ProcArray entry for the
     * prepared XID.  This must happen before we clear the XID from MyPgXact,
     * else there is a window where the XID is not running according to
     * TransactionIdIsInProgress, and onlookers would be entitled to assume
     * the xact crashed.  Instead we have a window where the same XID appears
     * twice in ProcArray, which is OK.
     */</comment>
    <expr_stmt><expr><call><name>MarkAsPrepared</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now we can mark ourselves as out of the commit critical section: a
     * checkpoint starting after this will certainly see the gxact as a
     * candidate for fsyncing.
     */</comment>
    <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Remember that we have this GlobalTransaction entry locked for us.  If
     * we crash after this point, it's too late to abort, but we must unlock
     * it so that the prepared transaction can be committed or rolled back.
     */</comment>
    <expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Wait for synchronous replication, if required.
     *
     * Note that at this stage we have marked the prepare, but still show as
     * running in the procarray (twice!) and continue to hold locks.
     */</comment>
    <expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a 2PC record to be written to state file.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterTwoPhaseRecord</name><parameter_list>(<parameter><decl><type><name>TwoPhaseRmgrId</name></type> <name>rmid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TwoPhaseRecordOnDisk</name></type> <name>record</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>record</name><operator>.</operator><name>rmid</name></name> <operator>=</operator> <name>rmid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>record</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>record</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseRecordOnDisk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Read and validate the state file for xid.
 *
 * If it looks OK (has a valid magic number and CRC), return the palloc'd
 * contents of the file.  Otherwise return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ReadTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>give_warnings</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>crc_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>    <name>calc_crc</name></decl>,
                <decl><type ref="prev"/><name>file_crc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TwoPhaseFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>give_warnings</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open two-phase state file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check file length.  We can determine a lower bound pretty easily. We
     * set an upper bound to avoid palloc() failure on a corrupt file, though
     * we can't guarantee that we won't get an out of memory error anyway,
     * even on a valid file.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>give_warnings</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat two-phase state file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stat</name><operator>.</operator><name>st_size</name></name> <operator>&lt;</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
                        <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseRecordOnDisk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
                        <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>||</operator>
        <name><name>stat</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <name>MaxAllocSize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>crc_offset</name> <operator>=</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>crc_offset</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>crc_offset</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * OK, slurp in the file.
     */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>stat</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TWOPHASE_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stat</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>give_warnings</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read two-phase state file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>TWOPHASE_MAGIC</name> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>total_len</name></name> <operator>!=</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>crc_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>file_crc</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>pg_crc32c</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>buf</name> <operator>+</operator> <name>crc_offset</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>, <argument><expr><name>file_crc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Reads 2PC data from xlog. During checkpoint this data will be moved to
 * twophase files and ReadTwoPhaseFile should be used instead.
 *
 * Note clearly that this function can access WAL during normal operation,
 * similarly to the way WALSender or Logical Decoding would do.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XlogReadTwoPhaseData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>xlogreader</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>read_local_xlog_page</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read two-phase state from WAL at %X/%X"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RM_XACT_ID</name> <operator>||</operator>
        <operator>(</operator><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name><operator>)</operator> <operator>!=</operator> <name>XLOG_XACT_PREPARE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected two-phase state data is not present in WAL at %X/%X"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                        <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogReaderFree</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Confirms an xid is prepared, during recovery
 */</comment>
<function><type><name>bool</name></type>
<name>StandbyTransactionIdIsPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>max_prepared_xacts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* nothing to do */</comment>

    <comment type="block">/* Read and validate file */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Check header also */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CheckPreparedTransactionLock: Check whether the prepared transaction
 * can be rollbacked
 */</comment>
<function><type><name>void</name></type>
<name>CheckPreparedTransactionLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><call><name>LockGXact</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>gxact</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"prepared gid %s gxact is NULL."</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"prepared gid %s gxact xid %d."</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FinishPreparedTransaction: execute COMMIT PREPARED or ROLLBACK PREPARED
 */</comment>
<function><type><name>void</name></type>
<name>FinishPreparedTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGPROC</name>       <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXACT</name>       <modifier>*</modifier></type><name>pgxact</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>commitrels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>abortrels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>delrels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ndelrels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RenameInfo</name>  <modifier>*</modifier></type><name>rename_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CreateInfo</name>    <modifier>*</modifier></type><name>create_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DropInfo</name>    <modifier>*</modifier></type><name>drop_info</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <comment type="block">/* not allow user commit twophase trans in xc_maintenance_mode */</comment>
    <if_stmt><if>if <condition>(<expr><name>xc_maintenance_mode</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can not commit transaction '%s' in xc_maintainence_mode"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* after abnormal exit g_twophase_state is lost */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>gid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>GIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* 
         *if current node is startnode, the twophase state should satisfy COMMIT_END in most situations, 
         *that is, remote nodes are already committed, or
         *explict trans exit after FinishGTMGID, or nodestring and gxid is lost due to GTM restart, or
         *the transaction abnormal exit last time and it lost g_twophase_state
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_timeout_safely</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_COMMIT_END</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* 
             *if current node is participate, the twophase state should be COMMITTING, 
             */</comment>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_COMMITTING</name></expr>;</expr_stmt>
            <comment type="block">/* explicit twophase state is cleaned after 'prepare transaction' */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsXidImplicit</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>GIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_ABORT_END</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_ABORTTING</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsXidImplicit</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>GIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>PREPARE_ERROR_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>||</operator>
            <name>PART_COMMIT_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name>PGXCNodeId</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s at node '%s'"</literal></expr></argument>, 
                <argument><expr><ternary><condition><expr><operator>(</operator><name>PREPARE_ERROR_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"PREPARE_ERROR_RESPONSE_ERROR"</literal></expr> </then><else>: <expr><literal type="string">"PART_COMMIT_RESPONSE_ERROR"</literal></expr></else></ternary></expr></argument>, 
                <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>&amp;&amp;</operator> 
        <operator>(</operator><name>PART_COMMIT_FINISH_PREPARED</name> <operator>==</operator> <name>twophase_exception_case</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PART_COMMIT_FINISH_PREPARED at node '%s'"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"finish prepared gid %s is commit %d."</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Validate the GID, and lock the GXACT to ensure that two backends do not
     * try to commit the same GID at once.
     */</comment>
	<expr_stmt><expr><name>gxact</name> <operator>=</operator> <call><name>LockGXact</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/*
     * LockGXact returns NULL if this node does not contain given two-phase
     * TXN.  This can happen when COMMIT/ROLLBACK PREPARED is issued at
     * the originating Coordinator for cleanup.
     * In this case, no local handling is needed.   Only report to GTM
     * is needed and this has already been handled in
     * FinishRemotePreparedTransaction().
     *
     * Second predicate may not be necessary.   It is just in case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>gxact</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>xc_maintenance_mode</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"finish prepared gid %s is commit %d gxact xid %d."</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgxact</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <comment type="block">/* 
     * except the start node, other participants record 2pc file 
     * at the beginning of FinishPrepareTransaction , 
     * or record 2pc in start node during AbortTransaction, 
     * since other participants may not abortted
     */</comment>
     <comment type="block">/*
      * if run in pg_clean, partial prepare transaction may rollback without write 2pc, since no participants
      * since partial prepare do not have enough infomation for record
      */</comment>
    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"before record 2pc of '%s', readonly:'%s', after_prepare:'%s'"</literal></expr></argument>, 
                <argument><expr><name>gid</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_after_prepare</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>&amp;&amp;</operator> 
        <operator>!</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name> <operator>&amp;&amp;</operator> 
        <name>isCommit</name> <operator>&amp;&amp;</operator> 
        <operator>(</operator><operator>!</operator><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name> <operator>||</operator>
            <operator>(</operator><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name> <operator>&amp;&amp;</operator> 
            <name><name>g_twophase_state</name><operator>.</operator><name>is_after_prepare</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>record_2pc_involved_nodes_xid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>record_2pc_commit_timestamp</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>GetGlobalCommitTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Read and validate 2PC state data. State data will typically be stored
     * in WAL files if the LSN is after the last checkpoint record, or moved
     * to disk if for some reason they have lived for a long time.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"read two-phase file failed, gid: %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
    <else>else
	<block>{<block_content>
        <expr_stmt><expr><call><name>XlogReadTwoPhaseData</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"read two-phase data from xlog failed, gid: %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>


    <comment type="block">/*
     * Disassemble the header area
     */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>gidlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>children</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>commitrels</name> <operator>=</operator> <operator>(</operator><name>RelFileNode</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>abortrels</name> <operator>=</operator> <operator>(</operator><name>RelFileNode</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>invalmsgs</name> <operator>=</operator> <operator>(</operator><name>SharedInvalidationMessage</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>create_info</name> <operator>=</operator> <operator>(</operator><name>CreateInfo</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncreatesegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CreateInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>drop_info</name> <operator>=</operator> <operator>(</operator><name>DropInfo</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ndropsegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DropInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rename_info</name> <operator>=</operator> <operator>(</operator><name>RenameInfo</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nrenamesegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RenameInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RestoreSeqCreate</name><argument_list>(<argument><expr><name>create_info</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncreatesegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RestoreSeqDrop</name><argument_list>(<argument><expr><name>drop_info</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ndropsegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RestoreSeqRename</name><argument_list>(<argument><expr><name>rename_info</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nrenamesegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* compute latestXid among all children */</comment>
    <expr_stmt><expr><name>latestXid</name> <operator>=</operator> <call><name>TransactionIdLatest</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The order of operations here is critical: make the XLOG entry for
     * commit or abort, then mark the transaction committed or aborted in
     * pg_xact, then remove its PGPROC from the global ProcArray (which means
     * TransactionIdIsInProgress will stop saying the prepared xact is in
     * progress), then run the post-commit or post-abort callbacks. The
     * callbacks will release the locks the transaction held.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RecordTransactionCommitPrepared</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
                                        <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
                                        <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name></expr></argument>, <argument><expr><name>commitrels</name></expr></argument>,
                                        <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name></expr></argument>, <argument><expr><name>invalmsgs</name></expr></argument>,
                                        <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>initfileinval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RecordTransactionAbortPrepared</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
                                       <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
                                       <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name></expr></argument>, <argument><expr><name>abortrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>ProcArrayRemove</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * In case we fail while running the callbacks, mark the gxact invalid so
     * no one else will try to commit/rollback, and so it will be recycled if
     * we fail after this point.  It is still locked by our backend so it
     * won't go away yet.
     *
     * (We assume it's safe to do this without taking TwoPhaseStateLock.)
     */</comment>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We have to remove any files that were supposed to be dropped. For
     * consistency with the regular xact.c code paths, must do this before
     * releasing locks, so do it before running the callbacks.
     *
     * NB: this code knows that we couldn't be dropping any temp rels ...
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>delrels</name> <operator>=</operator> <name>commitrels</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ndelrels</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>delrels</name> <operator>=</operator> <name>abortrels</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ndelrels</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndelrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name> <init>= <expr><call><name>smgropen</name><argument_list>(<argument><expr><name><name>delrels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>smgrdounlink</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
		<comment type="block">/*
		 * clean up the rnode infomation in rel crypt hash table
		 */</comment>
		<expr_stmt><expr><call><name>remove_rel_crypt_hash_elem</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>srel</name><operator>-&gt;</operator><name>smgr_relcrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>srel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Handle cache invalidation messages.
     *
     * Relcache init file invalidation requires processing both before and
     * after we send the SI messages. See AtEOXact_Inval()
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>initfileinval</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RelationCacheInitFilePreInvalidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>SendSharedInvalidMessages</name><argument_list>(<argument><expr><name>invalmsgs</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>initfileinval</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RelationCacheInitFilePostInvalidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* And now do the callbacks */</comment>
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ProcessRecords</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>twophase_postcommit_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ProcessRecords</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>twophase_postabort_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>FinishSeqOp</name><argument_list>(<argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>PredicateLockTwoPhaseFinish</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Count the prepared xact as committed or aborted */</comment>
    <expr_stmt><expr><call><name>AtEOXact_PgStat</name><argument_list>(<argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * And now we can clean up any files we may have left.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RemoveGXact</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    
    <if_stmt><if>if<condition>(<expr><name>enable_distri_debug</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"finish prepared transaction top xid %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LogCommitTranGTM</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, 
                         <argument><expr><name>gid</name></expr></argument>, 
                         <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                         <argument><expr><literal type="number">1</literal></expr></argument>, 
                         <argument><expr><name>false</name></expr></argument>,
                         <argument><expr><name>isCommit</name></expr></argument>, 
                         <argument><expr><call><name>GetLocalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>, 
                         <argument><expr><call><name>GetLocalCommitTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>AtEOXact_Global</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE_DEBUG__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DeletePreparedXid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <comment type="block">/*
     * explain the code from two angles:
     * a. startnode: whole twophase trans complete 'commit prepared' or 'rollback prepared'
     * b. participates: complete ''commit prepared' or 'rollback prepared' only on local node 
     */</comment>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>isCommit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMITTED</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORTTED</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* delete the 2pc file while twophase transaction is committed on the current node */</comment>
    <if_stmt><if>if<condition>(<expr><name>isCommit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>remove_2pc_records</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* rename 2pc file when rollback on the current node */</comment>
        <expr_stmt><expr><call><name>rename_2pc_records</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ClearLocalTwoPhaseState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition> 
    <block>{<block_content>
        <expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* clean timeout status */</comment>

        <if_stmt><if>if <condition>(<expr><call><name>IsQueryCancelPending</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator>  <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>InterruptPending</name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>            
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

</block_content>}</block></function>

<comment type="block">/*
 * Scan 2PC state data in memory and call the indicated callbacks for each 2PC record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessRecords</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bufptr</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>TwoPhaseCallback</name></type> <name><name>callbacks</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TwoPhaseRecordOnDisk</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>(</operator><name>TwoPhaseRecordOnDisk</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name> <operator>&lt;=</operator> <name>TWOPHASE_RM_MAX_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name> <operator>==</operator> <name>TWOPHASE_RM_END_ID</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseRecordOnDisk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>callbacks</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>callbacks</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name></expr>]</index></name> <operator>(</operator><name>xid</name><operator>,</operator> <name><name>record</name><operator>-&gt;</operator><name>info</name></name><operator>,</operator>
                                     <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>bufptr</name><operator>,</operator> <name><name>record</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the 2PC file for the specified XID.
 *
 * If giveWarning is false, do not complain about file-not-present;
 * this is an expected case during WAL replay.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>giveWarning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TwoPhaseFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name> <operator>||</operator> <name>giveWarning</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove two-phase state file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recreates a state file. This is used in WAL replay and during
 * checkpoint creation.
 *
 * Note: content and len don't include CRC.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecreateTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>    <name>statefile_crc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>

    <comment type="block">/* Recompute CRC */</comment>
    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>statefile_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>statefile_crc</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>statefile_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TwoPhaseFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                           <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>,
                           <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not recreate two-phase state file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Write content and CRC */</comment>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TWOPHASE_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write two-phase state file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statefile_crc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write two-phase state file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We must fsync the file because the end-of-replay checkpoint will not do
     * so, there being no GXACT in shared memory yet to tell it to.
     */</comment>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TWOPHASE_FILE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync two-phase state file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close two-phase state file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckPointTwoPhase -- handle 2PC component of checkpointing.
 *
 * We must fsync the state file of any GXACT that is valid or has been
 * generated during redo and has a PREPARE LSN &lt;= the checkpoint's redo
 * horizon.  (If the gxact isn't valid yet, has not been generated in
 * redo, or has a later LSN, this checkpoint is not responsible for
 * fsyncing it.)
 *
 * This is deliberately run as late as possible in the checkpoint sequence,
 * because GXACTs ordinarily have short lifespans, and so it is quite
 * possible that GXACTs that were valid at checkpoint start will no longer
 * exist if we wait a little bit. With typical checkpoint settings this
 * will be about 3 minutes for an online checkpoint, so as a result we
 * we expect that there will be no GXACTs that need to be copied to disk.
 *
 * If a GXACT remains valid across multiple checkpoints, it will already
 * be on disk so we don't bother to repeat that write.
 */</comment>
<function><type><name>void</name></type>
<name>CheckPointTwoPhase</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_horizon</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>serialized_xacts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] checkpoint: "</literal><name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>redo_horizon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>max_prepared_xacts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>                    <comment type="block">/* nothing to do */</comment>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We are expecting there to be zero GXACTs that need to be copied to
     * disk, so we perform all I/O while holding TwoPhaseStateLock for
     * simplicity. This prevents any new xacts from preparing while this
     * occurs, which shouldn't be a problem since the presence of long-lived
     * prepared xacts indicates the transaction manager isn't active.
     *
     * It's also possible to move I/O out of the lock, but on every error we
     * should check whether somebody committed our transaction in different
     * backend. Let's leave this optimization for future, if somebody will
     * spot that this place cause bottleneck.
     *
     * Note that it isn't possible for there to be a GXACT with a
     * prepare_end_lsn set prior to the last checkpoint yet is marked invalid,
     * because of the efforts with delayChkpt.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Note that we are using gxact not pgxact so this works in recovery
         * also
         */</comment>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>||</operator> <name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
            <name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>&lt;=</operator> <name>redo_horizon</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>len</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr>)</condition>
			<block>{<block_content>
			<comment type="block">/* save to pg_twophase */</comment>
            <expr_stmt><expr><call><name>XlogReadTwoPhaseData</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecreateTwoPhaseFile</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>serialized_xacts</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
			<comment type="block">/* save to pg_2pc */</comment>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>save_and_remove_2pc_info</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s save to file failed"</literal></expr></argument>,
						<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is saved to file"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
	<comment type="block">/* start node maybe no in prepared xacts */</comment>
	<if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cache2pcInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>tid</name><index>[<expr><name>MAX_TID_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>start_node</name><index>[<expr><name>MAX_TID_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * set start_node likes ":cn001:"
		 * use to check whether the tid is started from this node
		 */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>start_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name>MAX_TID_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"[%s] node name length(%d) overflow"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>start_node</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_node</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>start_node</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>size</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] entry key is empty"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] tid is empty"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>enable_2pc_file_check</name></expr>)</condition>
				<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is found in hash table seq"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsXidImplicit</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>start_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pos</name></expr>)</condition>
			<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is not on start node"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is on start node"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>save_and_remove_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s save to file failed"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is saved to file"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Flush unconditionally the parent directory to make any information
     * durable on disk.  Two-phase files could have been removed and those
     * removals need to be made persistent as well as any files newly created
     * previously since the last checkpoint.
     */</comment>
    <expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>TWOPHASE_DIR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>    
    <expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>TWOPHASE_RECORD_DIR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_checkpoints</name> <operator>&amp;&amp;</operator> <name>serialized_xacts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"%u two-phase state file was written "</literal>
                               <literal type="string">"for a long-running prepared transaction"</literal></expr></argument>,
                               <argument><expr><literal type="string">"%u two-phase state files were written "</literal>
                               <literal type="string">"for long-running prepared transactions"</literal></expr></argument>,
                               <argument><expr><name>serialized_xacts</name></expr></argument>,
                               <argument><expr><name>serialized_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * restoreTwoPhaseData
 *
 * Scan pg_twophase and fill TwoPhaseState depending on the on-disk data.
 * This is called once at the beginning of recovery, saving any extra
 * lookups in the future.  Two-phase files that are newer than the
 * minimum XID horizon are discarded on the way.
 */</comment>
<function><type><name>void</name></type>
<name>restoreTwoPhaseData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>cldir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>clde</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cldir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>TWOPHASE_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>clde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>, <argument><expr><name>TWOPHASE_DIR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
            <call><name>strspn</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">8</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>xid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
                                        <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>PrepareRedoAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PrescanPreparedTransactions
 *
 * Scan the shared memory entries of TwoPhaseState and determine the range
 * of valid XIDs present.  This is run during database startup, after we
 * have completed reading WAL.  ShmemVariableCache-&gt;nextXid has been set to
 * one more than the highest XID for which evidence exists in WAL.
 *
 * We throw away any prepared xacts with main XID beyond nextXid --- if any
 * are present, it suggests that the DBA has done a PITR recovery to an
 * earlier point in time without cleaning out pg_twophase.  We dare not
 * try to recover such prepared xacts since they likely depend on database
 * state that doesn't exist now.
 *
 * However, we will advance nextXid beyond any subxact XIDs belonging to
 * valid prepared xacts.  We need to do this since subxact commit doesn't
 * write a WAL entry, and so there might be no evidence in WAL of those
 * subxact XIDs.
 *
 * Our other responsibility is to determine and return the oldest valid XID
 * among the prepared xacts (if none, return ShmemVariableCache-&gt;nextXid).
 * This is needed to synchronize pg_subtrans startup properly.
 *
 * If xids_p and nxids_p are not NULL, pointer to a palloc'd array of all
 * top-level xids is stored in *xids_p. The number of entries in the array
 * is returned in *nxids_p.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>PrescanPreparedTransactions</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier><modifier>*</modifier></type><name>xids_p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nxids_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>origNextXid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>result</name> <init>= <expr><name>origNextXid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>allocsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
                                    <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>,
                                    <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * OK, we think this file is valid.  Incorporate xid into the
         * running-minimum result.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>xids_p</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>==</operator> <name>allocsize</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>allocsize</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>xids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>allocsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>allocsize</name> <operator>=</operator> <name>allocsize</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>xids</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>xids</name></expr></argument>, <argument><expr><name>allocsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>xids</name><index>[<expr><name>nxids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>xids_p</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>xids_p</name> <operator>=</operator> <name>xids</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>nxids_p</name> <operator>=</operator> <name>nxids</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StandbyRecoverPreparedTransactions
 *
 * Scan the shared memory entries of TwoPhaseState and setup all the required
 * information to allow standby queries to treat prepared transactions as still
 * active.
 *
 * This is never called at the end of recovery - we use
 * RecoverPreparedTransactions() at that point.
 *
 * The lack of calls to SubTransSetParent() calls here is by design;
 * those calls are made by RecoverPreparedTransactions() at the end of recovery
 * for those xacts that need this.
 */</comment>
<function><type><name>void</name></type>
<name>StandbyRecoverPreparedTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
                                    <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>,
                                    <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RecoverPreparedTransactions
 *
 * Scan the shared memory entries of TwoPhaseState and reload the state for
 * each prepared transaction (reacquire locks, etc).
 *
 * This is run at the end of recovery, but before we allow backends to write
 * WAL.
 *
 * At the end of recovery the way we take snapshots will change. We now need
 * to mark all running transactions with their full SubTransSetParent() info
 * to allow normal snapshots to work correctly if snapshots overflow.
 * We do this here because by definition prepared transactions are the only
 * type of write transaction still running, so this is necessary and
 * complete.
 */</comment>
<function><type><name>void</name></type>
<name>RecoverPreparedTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Reconstruct subtrans state for the transaction --- needed because
         * pg_subtrans is not preserved over a restart.  Note that we are
         * linking all the subtransactions directly to the top-level XID;
         * there may originally have been a more complex hierarchy, but
         * there's no need to restore that exactly. It's possible that
         * SubTransSetParent has been set before, if the prepared transaction
         * generated xid assignment records.
         */</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
                                    <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>,
                                    <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovering prepared transaction %u from shared memory"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>gid</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>gidlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subxids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncreatesegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CreateInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ndropsegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DropInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nrenamesegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RenameInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Recreate its GXACT and dummy PGPROC. But, check whether it was
         * added in redo and already has a shmem entry for it.
         */</comment>
        <expr_stmt><expr><call><name>MarkAsPreparingGuts</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>,
                            <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>prepared_at</name></name></expr></argument>,
                            <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* recovered, so reset the flag for entries generated by redo */</comment>
        <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>GXactLoadSubxactData</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>subxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"recovery prepared transaction %u"</literal></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>


        <expr_stmt><expr><call><name>MarkAsPrepared</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>RecoverEndGlobalPrepare</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Recover other state (notably locks) using resource managers.
         */</comment>
        <expr_stmt><expr><call><name>ProcessRecords</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>twophase_recover_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Release locks held by the standby process after we process each
         * prepared transaction. As a result, we don't need too many
         * additional locks at any one time.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>StandbyReleaseLockTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>subxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We're done with recovering this transaction. Clear MyLockedGxact,
         * like we do in PrepareTransaction() during normal operation.
         */</comment>
        <expr_stmt><expr><call><name>PostPrepare_Twophase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessTwoPhaseBuffer
 *
 * Given a transaction id, read it either from disk or read it directly
 * via shmem xlog record pointer using the provided "prepare_start_lsn".
 *
 * If setParent is true, set up subtransaction parent linkages.
 *
 * If setNextXid is true, set ShmemVariableCache-&gt;nextXid to the newest
 * value scanned.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ProcessTwoPhaseBuffer</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                      <parameter><decl><type><name>XLogRecPtr</name></type> <name>prepare_start_lsn</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>fromdisk</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>setParent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setNextXid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>origNextXid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fromdisk</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prepare_start_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Already processed? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing stale two-phase state file for \"%u\""</literal></expr></argument>,
                            <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing stale two-phase state from shared memory for \"%u\""</literal></expr></argument>,
                            <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PrepareRedoRemove</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Reject XID if too new */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>origNextXid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing future two-phase state file for \"%u\""</literal></expr></argument>,
                            <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing future two-phase state from memory for \"%u\""</literal></expr></argument>,
                            <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PrepareRedoRemove</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Read and validate file */</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing corrupt two-phase state file for \"%u\""</literal></expr></argument>,
                            <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Read xlog data */</comment>
        <expr_stmt><expr><call><name>XlogReadTwoPhaseData</name><argument_list>(<argument><expr><name>prepare_start_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Deconstruct header */</comment>
    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing corrupt two-phase state file for \"%u\""</literal></expr></argument>,
                            <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing corrupt two-phase state from memory for \"%u\""</literal></expr></argument>,
                            <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PrepareRedoRemove</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Examine subtransaction XIDs ... they should all follow main XID, and
     * they may force us to advance nextXid.
     */</comment>
    <expr_stmt><expr><name>subxids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>buf</name> <operator>+</operator>
                                 <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
                                 <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>gidlen</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>subxid</name> <init>= <expr><name><name>subxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* update nextXid if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name>setNextXid</name> <operator>&amp;&amp;</operator>
            <call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>,
                                         <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We don't expect anyone else to modify nextXid, hence we don't
             * need to hold a lock while examining it.  We still acquire the
             * lock to modify it, though, so we recheck.
             */</comment>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>,
                                             <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>subxid</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>setParent</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SubTransSetParent</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *    RecordTransactionCommitPrepared
 *
 * This is basically the same as RecordTransactionCommit (q.v. if you change
 * this function): in particular, we must set the delayChkpt flag to avoid a
 * race condition.
 *
 * We know the transaction made at least one XLOG entry (its PREPARE),
 * so it is never possible to optimize out the commit record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordTransactionCommitPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
                                <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
                                <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>ninvalmsgs</name></decl></parameter>,
                                <parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>initfileinval</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>committs</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>replorigin</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>global_committs</name> <init>= <expr><call><name>GetGlobalCommitTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>false</name> <operator>==</operator> <call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot commit a prepared transaction xid %d with invalid committs"</literal></expr></argument>,
                    <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"record commit prepared transaction xid %d ts "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Are we using the replication origins feature?  Or, in other words, are
     * we replaying remote actions?
     */</comment>
    <expr_stmt><expr><name>replorigin</name> <operator>=</operator> <operator>(</operator><name>replorigin_session_origin</name> <operator>!=</operator> <name>InvalidRepOriginId</name> <operator>&amp;&amp;</operator>
                  <name>replorigin_session_origin</name> <operator>!=</operator> <name>DoNotReplicateId</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* See notes in RecordTransactionCommit */</comment>
    <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Emit the XLOG commit record. Note that we mark 2PC commits as
     * potentially having AccessExclusiveLocks since we don't know whether or
     * not they do.
     */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>=</operator> <name>global_committs</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XactLogCommitRecord</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>,
                                 <argument><expr><name>committs</name></expr></argument>,
                                 <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
                                 <argument><expr><name>ninvalmsgs</name></expr></argument>, <argument><expr><name>invalmsgs</name></expr></argument>,
                                 <argument><expr><name>initfileinval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name>MyXactFlags</name> <operator>|</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name></expr></argument>,
                                 <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"record transaction commit %d."</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XactLogCommitRecord</name><argument_list>(<argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>,
                                 <argument><expr><name>committs</name></expr></argument>,
                                 <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
                                 <argument><expr><name>ninvalmsgs</name></expr></argument>, <argument><expr><name>invalmsgs</name></expr></argument>,
                                 <argument><expr><name>initfileinval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name>MyXactFlags</name> <operator>|</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name></expr></argument>,
                                 <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>replorigin</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* Move LSNs forward for this replication origin */</comment>
        <expr_stmt><expr><call><name>replorigin_session_advance</name><argument_list>(<argument><expr><name>replorigin_session_origin_lsn</name></expr></argument>,
                                   <argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Record commit timestamp.  The value comes from plain commit timestamp
     * if replorigin is not enabled, or replorigin already set a value for us
     * in replorigin_session_origin_timestamp otherwise.
     *
     * We don't need to WAL-log anything here, as the commit record written
     * above already contains the data.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>replorigin</name> <operator>||</operator> <name>replorigin_session_origin_timestamp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>replorigin_session_origin_timestamp</name> <operator>=</operator> <name>committs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifndef>
    <expr_stmt><expr><call><name>TransactionTreeSetCommitTsData</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
                                   <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>,
                                   <argument><expr><name>replorigin_session_origin_timestamp</name></expr></argument>,
                                   <argument><expr><name>replorigin_session_origin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * We don't currently try to sleep before flush here ... nor is there any
     * support for async commit of a prepared xact (the very idea is probably
     * a contradiction)
     */</comment>

    <comment type="block">/* Flush XLOG to disk */</comment>
    <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Mark the transaction committed in pg_xact */</comment>
    <expr_stmt><expr><call><name>TransactionIdCommitTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Checkpoint can proceed now */</comment>
    <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CommitTimestampIsLocal</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>TransactionTreeSetCommitTsData</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
                                           <argument><expr><name>global_committs</name></expr></argument>,
                                           <argument><expr><name>replorigin_session_origin_timestamp</name></expr></argument>,
                                           <argument><expr><name>replorigin_session_origin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"commit prepared xid %d time "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else 
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Commit prepared: Global Timestamp is not set. Current XID = %d, Autovac = %d, global committs "</literal> <name>INT64_FORMAT</name></expr></argument>, 
                                <argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Commit prepared: transaction should not be abnormal. Current XID = %d, Autovac = %d"</literal></expr></argument>, 
                                <argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>enable_distri_debug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetLocalCommitTimestamp</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>committed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Wait for synchronous replication, if required.
     *
     * Note that at this stage we have marked clog, but still show as running
     * in the procarray and continue to hold locks.
     */</comment>
    <expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    RecordTransactionAbortPrepared
 *
 * This is basically the same as RecordTransactionAbort.
 *
 * We know the transaction made at least one XLOG entry (its PREPARE),
 * so it is never possible to optimize out the abort record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordTransactionAbortPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
                               <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
                               <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>global_time</name> <init>= <expr><name>InvalidGlobalTimestamp</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Catch the scenario where we aborted partway through
     * RecordTransactionCommitPrepared ...
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"cannot abort transaction %u, it was already committed"</literal></expr></argument>,
             <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>global_time</name> <operator>=</operator> <call><name>GetGlobalTimestampGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>global_time</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* During the transaction rollback phase, 
		 * it is not mandatory to obtain a global timestamp from the GTM.
		 * it is sufficient to simply print a log when falied to get GTS from GTM
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"failed to get global timestamp for abort command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>commitTs</name></name> <operator>=</operator> <name>global_time</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Emit the XLOG commit record. Note that we mark 2PC aborts as
     * potentially having AccessExclusiveLocks since we don't know whether or
     * not they do.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XactLogAbortRecord</name><argument_list>(<argument><expr><name>global_time</name></expr></argument>,
                                <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
                                <argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
                                <argument><expr><name>MyXactFlags</name> <operator>|</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name></expr></argument>,
                                <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XactLogAbortRecord</name><argument_list>(<argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>,
                                <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
                                <argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
                                <argument><expr><name>MyXactFlags</name> <operator>|</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name></expr></argument>,
                                <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Always flush, since we're about to remove the 2PC state file */</comment>
    <expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark the transaction aborted in clog.  This is not absolutely necessary
     * but we may as well do it while we are here.
     */</comment>
    <expr_stmt><expr><call><name>TransactionIdAbortTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Wait for synchronous replication, if required.
     *
     * Note that at this stage we have marked clog, but still show as running
     * in the procarray and continue to hold locks.
     */</comment>
    <expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PrepareRedoAdd
 *
 * Store pointers to the start/end of the WAL record along with the xid in
 * a gxact entry in shared memory TwoPhaseState structure.  If caller
 * specifies InvalidXLogRecPtr as WAL location to fetch the two-phase
 * data, the entry is marked as located on disk.
 */</comment>
<function><type><name>void</name></type>
<name>PrepareRedoAdd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>gid</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Reserve the GID for the given transaction in the redo code path.
     *
     * This creates a gxact struct and puts it into the active array.
     *
     * In redo, this struct is mainly used to track PREPARE/COMMIT entries in
     * shared memory. Hence, we only fill up the bare minimum contents here.
     * The gxact also gets marked with gxact-&gt;inredo set to true to indicate
     * that it got added in the redo phase
     */</comment>

    <comment type="block">/* Get a free gxact from the freelist */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"maximum number of prepared transactions reached"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase max_prepared_transactions (currently %d)."</literal></expr></argument>,
                         <argument><expr><name>max_prepared_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>prepared_at</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name> <operator>=</operator> <name>start_lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>owner</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name> <operator>=</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>        <comment type="block">/* yes, added in redo */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_timestamp</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>prepared_timestamp</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2pc redo xid %d prepare timestamp "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* And insert it into the active array */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>&lt;</operator> <name>max_prepared_xacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"added 2PC data in shared memory for transaction %u"</literal></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PrepareRedoRemove
 *
 * Remove the corresponding gxact entry from TwoPhaseState. Also remove
 * the 2PC file if a prepared transaction was saved via an earlier checkpoint.
 *
 * Caller must hold TwoPhaseStateLock in exclusive mode, because TwoPhaseState
 * is updated.
 */</comment>
<function><type><name>void</name></type>
<name>PrepareRedoRemove</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>giveWarning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Just leave if there is nothing, this is expected during WAL replay.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * And now we can clean up any files we may have left.
     */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"removing 2PC data for transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>giveWarning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>RemoveGXact</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
<comment type="block">/*
 * check_entry_key: check the entry key in the hash table whether is same with tid.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>check_entry_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_key_check</name></expr>)</condition>
	<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"%s(hashvalue: 0x%x) mismatch with %s(hashvalue: 0x%x)"</literal></expr></argument>,
				<argument><expr><name>tid</name></expr></argument>, <argument><expr><call><name>Record2pcCacheHashCode</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>Record2pcCacheHashCode</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_2pc_info: add 2pc info to hash table
 * return true: add success
 * return false: add failed
 */</comment>
<function><type><name>bool</name></type> <name>add_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
	<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cache2pcInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashvalue</name> <init>= <expr><call><name>Record2pcCacheHashCode</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name> <init>= <expr><call><name>Cache2pcPartitionLock</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>Cache2pcInfo</name> <operator>*</operator><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>record_2pc_cache</name></expr></argument>,
		<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>entry</name></expr>)</condition>
		<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_key</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[%s] found %s"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_trace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is added to hash table, entry: %p, info: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * append_2pc_info: append 2pc info to hash table
 * return true: append success
 * return false: append failed
 */</comment>
<function><type><name>bool</name></type> <name>append_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cur_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>app_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>new_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache2pcInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashvalue</name> <init>= <expr><call><name>Record2pcCacheHashCode</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name> <init>= <expr><call><name>Cache2pcPartitionLock</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>Cache2pcInfo</name> <operator>*</operator><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>record_2pc_cache</name></expr></argument>,
		<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
		<comment type="block">/* not found */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

	<comment type="block">/* found */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_key</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cur_size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>app_size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_size</name> <operator>=</operator> <name>cur_size</name> <operator>+</operator> <name>app_size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&gt;=</operator> <name>MAX_2PC_INFO_SIZE</name></expr>)</condition>
		<block>{<block_content>
		<comment type="block">/* overflow */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s new size(%d) overflow(%d)"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>, <argument><expr><name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name> <operator>+</operator> <name>cur_size</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>app_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_trace</name></expr>)</condition>
			<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is found in hash table"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></function>

<comment type="block">/*
 * remove_2pc_info: remove 2pc info from hash table
 * return true: remove success
 * return false: remove failed
 */</comment>
<function><type><name>bool</name></type> <name>remove_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>)</parameter_list>
		<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache2pcInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashvalue</name> <init>= <expr><call><name>Record2pcCacheHashCode</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name> <init>= <expr><call><name>Cache2pcPartitionLock</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>Cache2pcInfo</name> <operator>*</operator><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>record_2pc_cache</name></expr></argument>,
		<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
		<comment type="block">/* not found */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

	<comment type="block">/* found */</comment>
		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_trace</name></expr>)</condition>
		<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is removed from hash table, entry: %p"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_2pc_info: get 2pc info from hash table
 * return true: get success
 * return false: get failed
 */</comment>
<function><type><name>bool</name></type> <name>get_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache2pcInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashvalue</name> <init>= <expr><call><name>Record2pcCacheHashCode</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name> <init>= <expr><call><name>Cache2pcPartitionLock</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>Cache2pcInfo</name> <operator>*</operator><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>record_2pc_cache</name></expr></argument>,
		<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
        <block>{<block_content>
		<comment type="block">/* not found */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* found */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_key</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * save_and_remove_2pc_info: save 2pc info from hash table to disk file, 
 * then remove it
 * return true: save and remove success
 * return false: save and remove failed
 */</comment>
<function><type><name>bool</name></type> <name>save_and_remove_2pc_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache2pcInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashvalue</name> <init>= <expr><call><name>Record2pcCacheHashCode</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name> <init>= <expr><call><name>Cache2pcPartitionLock</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get 2pc info */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>Cache2pcInfo</name> <operator>*</operator><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>record_2pc_cache</name></expr></argument>,
		<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not found */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* found */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_entry_key</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* file exist */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_2pc_file_check</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] found file %s"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* remove file */</comment>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not unlink file %s, errMsg: %s"</literal></expr></argument>,
				<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] unlink file %s"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* save to file */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not create file %s, errMsg: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not write file %s, errMsg: %s, "</literal>
			<literal type="string">"ret: %d, size: %d, info: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remove 2pc info */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>Cache2pcInfo</name> <operator>*</operator><operator>)</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>record_2pc_cache</name></expr></argument>,
		<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_trace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is removed from hash table, entry: %p"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the 2pc file is exist when it is saved in the hash table.
 */</comment>
<function><type><name>void</name></type> <name>check_2pc_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>enable_2pc_file_check</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>filestate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>File</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>result</name><index>[<expr><name>MAX_2PC_INFO_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[check_2pc_file][%s] found file %s"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filestate</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[check_2pc_file][%s] could not stat file %s, info: %s"</literal></expr></argument>,
				<argument><expr><name>func</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>filestate</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[check_2pc_file][%s] file %s is empty, info: %s"</literal></expr></argument>,
				<argument><expr><name>func</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <name>MAX_2PC_INFO_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[check_2pc_file][%s] file %s size(%d) overflow(%d)"</literal></expr></argument>,
				<argument><expr><name>func</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[check_2pc_file][%s] could not open file %s, "</literal>
				<literal type="string">"errMsg: %s"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name> <operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>WAIT_EVENT_BUFFILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[check_2pc_file][%s] could not read file %s, "</literal>
				<literal type="string">"ret: %d, file size: %d"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[check_2pc_file][%s] file %s mismatch, "</literal>
				<literal type="string">"result: %s, info: %s"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>record_2pc_redo_remove_gid_xid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>enable_2pc_recovery_info</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>remove_2pc_records</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>record_2pc_involved_nodes_xid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>tid</name></decl></parameter>, 
                                  <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>startnode</name></decl></parameter>, 
                                  <parameter><decl><type><name>GlobalTransactionId</name></type> <name>startxid</name></decl></parameter>, 
                                  <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>nodestring</name></decl></parameter>, 
                                  <parameter><decl><type><name>GlobalTransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type> <name>fd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>content</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>xlogrec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_2pc_recovery_info</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_distri_print</name> <operator>||</operator> <name>enable_2pc_entry_trace</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] record %s, startnode: %s, participants: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>tid</name> <operator>||</operator> <literal type="char">'\0'</literal> <operator>==</operator> <name><name>tid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] gid is empty"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>startnode</name> <operator>||</operator> <literal type="char">'\0'</literal> <operator>==</operator> <name><name>startnode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s startnode is empty"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>nodestring</name> <operator>||</operator> <literal type="char">'\0'</literal> <operator>==</operator> <name><name>nodestring</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s participants is empty"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>, <argument><expr><literal type="string">"startnode:%s\n"</literal></expr></argument>, <argument><expr><name>startnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>, <argument><expr><literal type="string">"startxid:%u\n"</literal></expr></argument>, <argument><expr><name>startxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>, <argument><expr><literal type="string">"nodes:%s\n"</literal></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>, <argument><expr><literal type="string">"xid:%u\n"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>content</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if in_pg_clean, then check whether the file exists */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name></expr>)</condition>
    <block>{<block_content>
		<comment type="block">/* if tid already exists, check content and return */</comment>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>info</name><index>[<expr><name>MAX_2PC_INFO_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>get_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>check_2pc_file</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] pg_clean attemp to write %s info conflict, "</literal>
						<literal type="string">"content: %s, info: %s"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>,
						<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if file already exists, check content and return */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>file_size</name> <init>= <expr><name><name>fst</name><operator>.</operator><name>st_size</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>file_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>   
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not open file %s, errMsg: %s"</literal></expr></argument>,
					<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt> 
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>file_size</name></expr></argument>, <argument><expr><name>WAIT_EVENT_BUFFILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>file_size</name></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not read file %s, ret: %d, file_size: %d"</literal></expr></argument>,
					<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>file_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] pg_clean attemp to write %s info conflict, "</literal>
					<literal type="string">"content: %s, info: %s"</literal></expr></argument>,
					<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>startnode</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>startnode</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>startxid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>nodestring</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>nodestring</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
		<expr_stmt><expr><name>xlogrec</name> <operator>=</operator> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_CREATE_2PC_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>PART_PREPARE_AFTER_RECORD_2PC</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
			<name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>xlogrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_pg_clean</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>STOP</name></expr></argument>, <argument><expr><literal type="string">"[%s] twophase exception: simulate kill start node "</literal>
				<literal type="string">"after record 2pc file"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
			<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr>)</condition>
				<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>add_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
				<expr_stmt><expr><call><name>check_2pc_file</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s add to cache failed"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s info size(%d) overflow(%d)"</literal></expr></argument>,
				<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * we open 2pc file under the following two different situations:
     * a. if in recovery mode, 
     *  the existed 2pc file can be trucated and reused.
     * b. if not under recovery progress, 
     *  we not allowed the implicit trans gid existed, 
     *  since the xid in startnode should not be truncate if the twophase trans is part commit or part abort.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>   
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not create file %s, errMsg: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>WAIT_EVENT_BUFFILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>size</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not write file %s, errMsg: %s, ret: %d, content: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* record commit timestamp in 2pc file while twophase trans failed in commit phase in the current node */</comment>
<function><type><name>void</name></type> <name>record_2pc_commit_timestamp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><name>GlobalTimestamp</name></type> <name>commit_timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>file_content</name><index>[<expr><name>FILE_CONTENT_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>content</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>xlogrec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_2pc_recovery_info</name></expr>)</condition>
    <block>{<block_content>
    	<return>return ;</return>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_distri_print</name> <operator>||</operator> <name>enable_2pc_entry_trace</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s commit_timestamp: "</literal><name>INT64_FORMAT</name></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>commit_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidGlobalTimestamp</name> <operator>==</operator> <name>commit_timestamp</name> <operator>&amp;&amp;</operator> 
        <operator>(</operator><name>TWO_PHASE_COMMITTING</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>||</operator> 
        <name>TWO_PHASE_COMMIT_END</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not commit transaction '%s' on node '%s' "</literal>
			<literal type="string">"with InvalidGlobalTimestamp"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>commit_timestamp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xlogrec</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_RECORD_2PC_TIMESTAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* only start node need to flush and sync XLOG_RECORD_2PC_TIMESTAMP */</comment>
		<if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>xlogrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name>xlogrec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
        
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>, <argument><expr><literal type="string">"global_commit_timestamp:"</literal><name>INT64_FORMAT</name><literal type="string">"\n"</literal></expr></argument>,
		<argument><expr><name>commit_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>content</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
			<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>overflow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>append_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>overflow</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition>
				<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is overflow"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>save_and_remove_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s save to file"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
			<else>else
				<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s save to file failed"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is not found in hash table"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the 2pc file exists already */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_APPEND</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>            
			int i;
			GlobalTransaction gxact = NULL;
            for (i = 0; i &lt; TwoPhaseState-&gt;numPrepXacts; i++)
            {
                gxact = TwoPhaseState-&gt;prepXacts[i];
                if (NULL == gxact)
                {
                    continue;
                }
                if (0 == strcmp(gxact-&gt;gid, tid))
                {
					elog(ERROR, "[%s] could not append timestamp in file %s, "
						"errMsg: %s", __FUNCTION__, path, strerror(errno));
                }
            }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not open file %s, errMsg: %s"</literal></expr></argument>,
				<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not open file %s, errMsg: %s"</literal></expr></argument>,
				<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>file_content</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FILE_CONTENT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>file_content</name></expr></argument>, <argument><expr><name>FILE_CONTENT_SIZE</name></expr></argument>, <argument><expr><name>WAIT_EVENT_BUFFILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] before append file: %s, file_content: %s, content.data: %s, "</literal>
			<literal type="string">"ret: %d"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>file_content</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>WAIT_EVENT_BUFFILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>size</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not write file %s, errMsg: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>file_content</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FILE_CONTENT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FileSeek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>file_content</name></expr></argument>, <argument><expr><name>FILE_CONTENT_SIZE</name></expr></argument>, <argument><expr><name>WAIT_EVENT_BUFFILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] after append file: %s, file_content: %s, ret: %d"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>file_content</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>content</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>remove_2pc_records</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>record_in_xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>    

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_2pc_recovery_info</name></expr>)</condition>
    <block>{<block_content>
    	<return>return ;</return>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_distri_print</name> <operator>||</operator> <name>enable_2pc_entry_trace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s record_in_xlog: %d"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>record_in_xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>record_in_xlog</name></expr>)</condition>
    <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><literal type="string">"remove"</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>type</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_CLEAN_2PC_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_key_check</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>info</name><index>[<expr><name>MAX_2PC_INFO_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>get_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>check_2pc_file</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* remove from hash table */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>remove_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>enable_2pc_file_check</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] still found file %s"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
		* no need to check file exists.
		* since when it do not exists, unlink won't success.
	*/</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not unlink file %s, errMsg: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>rename_2pc_records</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>new_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_2pc_recovery_info</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_distri_print</name> <operator>||</operator> <name>enable_2pc_entry_trace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s timestamp: "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>timestamp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><literal type="string">"rename"</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>type</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimestampTz</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_CLEAN_2PC_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>save_and_remove_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s save to file"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s save to file failed"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal> <name>INT64_FORMAT</name> <literal type="string">".rollback"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not access file %s in recovery mode, errMsg: %s"</literal></expr></argument>,
				<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
		<else>else
			<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not access file %s, errMsg: %s"</literal></expr></argument>,
				<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>access</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] file %s exist"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[%s] file %s exist"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not unlink file %s, errMsg: %s"</literal></expr></argument>,
				<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>link</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not link file %s to %s, errMsg: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not unlink file %s, errMsg: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>record_2pc_readonly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>File</name></type> <name>fd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>content</name> <init>= <expr><literal type="string">"readonly"</literal></expr></init></decl>;</decl_stmt>
        
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>enable_2pc_recovery_info</name></expr>)</condition>
    <block>{<block_content>
    	<return>return ;</return>
    </block_content>}</block></if></if_stmt>
        
	<if_stmt><if>if <condition>(<expr><name>enable_distri_print</name> <operator>||</operator> <name>enable_2pc_entry_trace</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is readonly"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>gid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>content</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_CREATE_2PC_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>add_2pc_info</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
			<expr_stmt><expr><call><name>check_2pc_file</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s add to cache failed"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* the 2pc dir is already created in initdb */</comment>
	<expr_stmt><expr><call><name>GET_2PC_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * we open 2pc file under the following two different situations:
     * a. if in recovery mode, 
     *  the existed 2pc file can be trucated and reused.
     * b. if not under recovery progress, 
     *  we not allowed the implicit trans gid existed, 
		*  since the xid in startnode should not be truncate if the 
		*  twophase trans is part commit or part abort.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>   
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not create file %s, errMsg: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WAIT_EVENT_BUFFILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[%s] could not write file %s, errMsg: %s, ret: %d, content: %s"</literal></expr></argument>,
			<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
    
<comment type="block">/*
 * Get 2pc info from hash table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>get_2pc_info_from_cache</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>record_2pc_cache</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_TID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>info</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_2pc_info</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_2PC_INFO_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_2pc_file</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_trace</name></expr>)</condition>
			<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is found in hash table"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

		<return>return <expr><name>info</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>enable_2pc_entry_trace</name></expr>)</condition>
		<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s is not found in hash table"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get 2pc list from hash table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>get_2pc_list_from_cache</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache2pcInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>recordList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>record_2pc_cache</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_2pc_file</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>==</operator> <name>recordList</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recordList</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>recordList</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>recordList</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>recordList</name></expr></argument>,
				<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>recordList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>recordList</name></expr></argument>, <argument><expr><literal type="string">"%s,%s"</literal></expr></argument>, <argument><expr><name>recordList</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator> <operator>&gt;=</operator> <name>MAX_OUTPUT_FILE</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>recordList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize 2pc info cache using shared memory hash table.
 */</comment>
<function><type><name>void</name></type>
<name>Record2pcCacheInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_2pc_file_cache</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>record_2pc_cache</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>MAX_TID_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <name>record_2pc_entry_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name> <operator>=</operator> <name>NUM_CACHE_2PC_PARTITIONS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>HASH_ELEM</name> <operator>|</operator> <name>HASH_PARTITION</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>record_2pc_cache</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Record 2pc cache"</literal></expr></argument>,
		<argument><expr><name>record_2pc_cache_size</name></expr></argument>, <argument><expr><name>record_2pc_cache_size</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return 2pc info cache size.
 */</comment>
<function><type><name>Size</name></type>
<name>Record2pcCacheSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>cache_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_2pc_file_cache</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cache_size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>record_2pc_cache_size</name></expr></argument>, <argument><expr><name>record_2pc_entry_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>cache_size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Record2pcCacheHashCode
 *             Compute the hash code associated with a tid
 *
 * This must be passed to the lookup/insert/delete routines along with the
 * tag.  We do it like this because the callers need to know the hash code
 * in order to determine which buffer partition to lock, and we don't want
 * to do the hash computation twice.
 */</comment>
<function><type><name>uint32</name></type>
<name>Record2pcCacheHashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>record_2pc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>get_hash_value</name><argument_list>(<argument><expr><name>record_2pc_cache</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
