<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/transam/xlogreader.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xlogreader.c
 *        Generic XLog reading facility
 *
 * Portions Copyright (c) 2013-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *        src/backend/access/transam/xlogreader.c
 *
 * NOTES
 *        See xlogreader.h for more notes on this facility.
 *
 *        This file is compiled as both front-end and backend code, so it
 *        may not use ereport, server-defined static variables, etc.
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>allocate_recordbuf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>reclength</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ValidXLogPageHeader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>,
                    <parameter><decl><type><name>XLogPageHeader</name></type> <name>hdr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ValidXLogRecordHeader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>,
                      <parameter><decl><type><name>XLogRecPtr</name></type> <name>PrevRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randAccess</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ValidXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
                <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReadPageInternal</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>pageptr</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_invalid_record</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetDecoder</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* size of the buffer allocated for error message. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ERRORMSG_LEN</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * Construct a string in state-&gt;errormsg_buf explaining what's wrong with
 * the current record being read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_invalid_record</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type>        <name>args</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>, <argument><expr><name>MAX_ERRORMSG_LEN</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate and initialize a new XLogReader.
 *
 * Returns NULL if the xlogreader couldn't be allocated.
 */</comment>
<function><type><name>XLogReaderState</name> <modifier>*</modifier></type>
<name>XLogReaderAllocate</name><parameter_list>(<parameter><decl><type><name>XLogPageReadCB</name></type> <name>pagereadfunc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>XLogReaderState</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc_extended</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogReaderState</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                        <argument><expr><name>MCXT_ALLOC_NO_OOM</name> <operator>|</operator> <name>MCXT_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Permanently allocate readBuf.  We do it this way, rather than just
     * making a static array, for two reasons: (1) no need to waste the
     * storage in most instantiations of the backend; (2) a static char array
     * isn't guaranteed to have any particular alignment, whereas
     * palloc_extended() will provide MAXALIGN'd storage.
     */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>XLOG_BLCKSZ</name></expr></argument>,
                                              <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name> <operator>=</operator> <name>pagereadfunc</name></expr>;</expr_stmt>
    <comment type="block">/* system_identifier initialized to zeroes above */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>private_data</name></name> <operator>=</operator> <name>private_data</name></expr>;</expr_stmt>
    <comment type="block">/* ReadRecPtr and EndRecPtr initialized to zeroes above */</comment>
    <comment type="block">/* readSegNo, readOff, readLen, readPageTLI initialized to zeroes above */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name> <operator>=</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>MAX_ERRORMSG_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                          <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocate an initial readRecordBuf of minimal size, which can later be
     * enlarged if necessary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>allocate_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>XLogReaderFree</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>block_id</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name>XLR_MAX_BLOCK_ID</name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate readRecordBuf to fit a record of at least the given length.
 * Returns true if successful, false if out of memory.
 *
 * readRecordBufSize is set to the new buffer size.
 *
 * To avoid useless small increases, round its size to a multiple of
 * XLOG_BLCKSZ, and make sure it's at least 5*Max(BLCKSZ, XLOG_BLCKSZ) to start
 * with.  (That is enough for all "normal" records, but very large commit or
 * abort records might need more space.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>allocate_recordbuf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>reclength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>newSize</name> <init>= <expr><name>reclength</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>newSize</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <operator>(</operator><name>newSize</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSize</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>, <argument><expr><literal type="number">5</literal> <operator>*</operator> <call><name>Max</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
    <comment type="block">/*
     * Note that in much unlucky circumstances, the random data read from a
     * recycled segment can cause this routine to be called with a size
     * causing a hard failure at allocation.  For a standby, this would cause
     * the instance to stop suddenly with a hard failure, preventing it to
     * retry fetching WAL from one of its sources which could allow it to move
     * on with replay without a manual restart. If the data comes from a past
     * recycled segment and is still valid, then the allocation may succeed
     * but record checks are going to fail so this would be short-lived.  If
     * the allocation fails because of a memory shortage, then this is not a
     * hard failure either per the guarantee given by MCXT_ALLOC_NO_OOM.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name> <operator>=</operator>
        <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>, <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to read an XLOG record.
 *
 * If RecPtr is valid, try to read a record at that position.  Otherwise
 * try to read a record just after the last one previously read.
 *
 * If the read_page callback fails to read the requested data, NULL is
 * returned.  The callback is expected to have reported the error; errormsg
 * is set to NULL.
 *
 * If the reading fails for some other reason, NULL is also returned, and
 * *errormsg is set to a string with details of the failure.
 *
 * The returned pointer (or *errormsg) points to an internal buffer that's
 * valid until the next call to XLogReadRecord.
 */</comment>
<function><type><name>XLogRecord</name> <modifier>*</modifier></type>
<name>XLogReadRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>targetPagePtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>randAccess</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>len</name></decl>,
                <decl><type ref="prev"/><name>total_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>targetRecOff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>pageHeaderSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>gotheader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>readOff</name></decl>;</decl_stmt>

    <comment type="block">/*
     * randAccess indicates whether to verify the previous-record pointer of
     * the record we're reading.  We only do this if we're reading
     * sequentially, which is what we initially assume.
     */</comment>
    <expr_stmt><expr><name>randAccess</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* reset error state */</comment>
    <expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ResetDecoder</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* No explicit start point; read the record after the one we just read */</comment>
        <expr_stmt><expr><name>RecPtr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>randAccess</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * RecPtr is pointing to end+1 of the previous WAL record.  If we're
         * at a page boundary, no more records can fit on the current page. We
         * must skip over the page header, but we can't do that until we've
         * read in the page, since the header size is variable.
         */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Caller supplied a position to start at.
         *
         * In this case, the passed-in record pointer should already be
         * pointing to a valid record starting position.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XRecOffIsValid</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>randAccess</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>targetPagePtr</name> <operator>=</operator> <name>RecPtr</name> <operator>-</operator> <operator>(</operator><name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Read the page containing the record into state-&gt;readBuf. Request enough
     * byte to cover the whole record header, or at least the part of it that
     * fits on the same page.
     */</comment>
    <expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                               <argument><expr><name>targetPagePtr</name></expr></argument>,
                               <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>targetRecOff</name> <operator>+</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * ReadPageInternal always returns at least the page header, so we can
     * examine it now.
     */</comment>
    <expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>targetRecOff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * At page start, so skip over page header.
         */</comment>
        <expr_stmt><expr><name>RecPtr</name> <operator>+=</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>targetRecOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"invalid record offset at %X/%X"</literal></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name><operator>)</operator><operator>-&gt;</operator><name>xlp_info</name> <operator>&amp;</operator> <name>XLP_FIRST_IS_CONTRECORD</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <name>targetRecOff</name> <operator>==</operator> <name>pageHeaderSize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"contrecord is requested by %X/%X"</literal></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ReadPageInternal has verified the page header */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageHeaderSize</name> <operator>&lt;=</operator> <name>readOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read the record length.
     *
     * NB: Even though we use an XLogRecord pointer here, the whole record
     * header might not fit on this page. xl_tot_len is the first field of the
     * struct, so it must be on this page (the records are MAXALIGNed), but we
     * cannot access any other fields until we've verified that we got the
     * whole header.
     */</comment>
    <expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>+</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>total_len</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the whole record header is on this page, validate it immediately.
     * Otherwise do just a basic sanity check on xl_tot_len, and validate the
     * rest of the header after reading it from the next page.  The xl_tot_len
     * check is necessary here to ensure that we enter the "Need to reassemble
     * record" code path below; otherwise we might fail to apply
     * ValidXLogRecordHeader at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>targetRecOff</name> <operator>&lt;=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecordHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>, <argument><expr><name>record</name></expr></argument>,
                                   <argument><expr><name>randAccess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* XXX: more validation should be done here */</comment>
        <if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&lt;</operator> <name>SizeOfXLogRecord</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"invalid record length at %X/%X: wanted %u, got %u"</literal></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Enlarge readRecordBuf as needed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>allocate_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We treat this as a "bogus data" condition */</comment>
        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"record length %u at %X/%X too long"</literal></expr></argument>,
                              <argument><expr><name>total_len</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Need to reassemble record */</comment>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>contdata</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>pageHeader</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>gotlen</name></decl>;</decl_stmt>

        <comment type="block">/* Copy the first fragment of the record from the first page. */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>,
               <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>+</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>gotlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

        <do>do
        <block>{<block_content>
            <comment type="block">/* Calculate pointer to beginning of next page */</comment>
            <expr_stmt><expr><name>targetPagePtr</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

            <comment type="block">/* Wait for the next page to become available */</comment>
            <expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
                                       <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>total_len</name> <operator>-</operator> <name>gotlen</name> <operator>+</operator> <name>SizeOfXLogShortPHD</name></expr></argument>,
                                           <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SizeOfXLogShortPHD</name> <operator>&lt;=</operator> <name>readOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Check that the continuation on next page looks valid */</comment>
            <expr_stmt><expr><name>pageHeader</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>XLP_FIRST_IS_CONTRECORD</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                      <argument><expr><literal type="string">"there is no contrecord flag at %X/%X"</literal></expr></argument>,
                                      <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Cross-check that xlp_rem_len agrees with how much of the record
             * we expect there to be left.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <name>total_len</name> <operator>!=</operator> <operator>(</operator><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>+</operator> <name>gotlen</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                      <argument><expr><literal type="string">"invalid contrecord length %u at %X/%X"</literal></expr></argument>,
                                      <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Append the continuation from this page to the buffer */</comment>
            <expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>pageHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
                                           <argument><expr><name>pageHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageHeaderSize</name> <operator>&lt;=</operator> <name>readOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>contdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>+</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
                                           <argument><expr><name>pageHeaderSize</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>contdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>gotlen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

            <comment type="block">/* If we just reassembled the record header, validate it. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gotheader</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecordHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
                                           <argument><expr><name>record</name></expr></argument>, <argument><expr><name>randAccess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block> while <condition>(<expr><name>gotlen</name> <operator>&lt;</operator> <name>total_len</name></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gotheader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name>
            <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Wait for the record data to become available */</comment>
        <expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
                                   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>targetRecOff</name> <operator>+</operator> <name>total_len</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Record does not cross a page boundary */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>RecPtr</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Special processing if it's an XLOG SWITCH record
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name><operator>)</operator> <operator>==</operator> <name>XLOG_SWITCH</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Pretend it extends to end of segment */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>+=</operator> <name>XLogSegSize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>-=</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>%</operator> <name>XLogSegSize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>DecodeXLogRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>record</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>

<label><name>err</name>:</label>

    <comment type="block">/*
     * Invalidate the read state. We might read from a different source after
     * failure.
     */</comment>
    <expr_stmt><expr><call><name>XLogReaderInvalReadState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a single xlog page including at least [pageptr, reqLen] of valid data
 * via the read_page() callback.
 *
 * Returns -1 if the required page cannot be read for some reason; errormsg_buf
 * is set in that case (unless the error occurs in the read_page callback).
 *
 * We fetch the page from a reader-local cache if we know we have the required
 * data and if there hasn't been any error since caching the data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadPageInternal</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>pageptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>readLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>targetPageOff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>targetSegNo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>hdr</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>pageptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>pageptr</name></expr></argument>, <argument><expr><name>targetSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>targetPageOff</name> <operator>=</operator> <operator>(</operator><name>pageptr</name> <operator>%</operator> <name>XLogSegSize</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* check whether we have all the requested data already */</comment>
    <if_stmt><if>if <condition>(<expr><name>targetSegNo</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name> <operator>&amp;&amp;</operator> <name>targetPageOff</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>readOff</name></name> <operator>&amp;&amp;</operator>
        <name>reqLen</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readLen</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Data is not in our buffer.
     *
     * Every time we actually read the page, even if we looked at parts of it
     * before, we need to do verification as the read_page callback might now
     * be rereading data from a different source.
     *
     * Whenever switching to a new WAL segment, we read the first page of the
     * file and validate its header, even if that's not where the target
     * record is.  This is so that we can check the additional identification
     * info that is present in the first page's "long" header.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>targetSegNo</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name> <operator>&amp;&amp;</operator> <name>targetPageOff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>hdr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>targetSegmentPtr</name> <init>= <expr><name>pageptr</name> <operator>-</operator> <name>targetPageOff</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* we can be sure to have enough WAL available, we scrolled back */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readLen</name> <operator>==</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogPageHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * First, read the requested data length, but at least a short page header
     * so that we can validate it.
     */</comment>
    <expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>reqLen</name></expr></argument>, <argument><expr><name>SizeOfXLogShortPHD</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>,
                               <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readLen</name> <operator>&lt;=</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do we have enough data to check the header length? */</comment>
    <if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;=</operator> <name>SizeOfXLogShortPHD</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readLen</name> <operator>&gt;=</operator> <name>reqLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>;</expr_stmt>

    <comment type="block">/* still not enough */</comment>
    <if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now that we know we have the full header, validate it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogPageHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* update read state information */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name> <operator>=</operator> <name>targetSegNo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readOff</name></name> <operator>=</operator> <name>targetPageOff</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>=</operator> <name>readLen</name></expr>;</expr_stmt>

    <return>return <expr><name>readLen</name></expr>;</return>

<label><name>err</name>:</label>
    <expr_stmt><expr><call><name>XLogReaderInvalReadState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invalidate the xlogreader's read state to force a re-read.
 */</comment>
<function><type><name>void</name></type>
<name>XLogReaderInvalReadState</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Validate an XLOG record header.
 *
 * This is just a convenience subroutine to avoid duplicated code in
 * XLogReadRecord.  It's not intended for use from anywhere else.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ValidXLogRecordHeader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>,
                      <parameter><decl><type><name>XLogRecPtr</name></type> <name>PrevRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>randAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>&lt;</operator> <name>SizeOfXLogRecord</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                              <argument><expr><literal type="string">"invalid record length at %X/%X: wanted %u, got %u"</literal></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>&gt;</operator> <name>RM_MAX_ID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                              <argument><expr><literal type="string">"invalid resource manager ID %u at %X/%X"</literal></expr></argument>,
                              <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>randAccess</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We can't exactly verify the prev-link, but surely it should be less
         * than the record's own address.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&lt;</operator> <name>RecPtr</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Record's prev-link should exactly match our previous location. This
         * check guards against torn WAL pages where a stale but valid-looking
         * WAL record starts on a sector boundary.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>!=</operator> <name>PrevRecPtr</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CRC-check an XLOG record.  We do not believe the contents of an XLOG
 * record (other than to the minimal extent of computing the amount of
 * data to read in) until we've checked the CRCs.
 *
 * We assume all of the record (that is, xl_tot_len bytes) has been read
 * into memory at *record.  Also, ValidXLogRecordHeader() has accepted the
 * record's header, which means in particular that xl_tot_len is at least
 * SizeOfXlogRecord.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ValidXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>    <name>crc</name></decl>;</decl_stmt>

    <comment type="block">/* Calculate the CRC */</comment>
    <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator> <operator>+</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* include the record header last */</comment>
    <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                              <argument><expr><literal type="string">"incorrect resource manager data checksum in record at %X/%X"</literal></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate a page header
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ValidXLogPageHeader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>,
                    <parameter><decl><type><name>XLogPageHeader</name></type> <name>hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recaddr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogSegNo</name></type>    <name>segno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>recptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>recptr</name> <operator>%</operator> <name>XLogSegSize</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>recaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>!=</operator> <name>XLOG_PAGE_MAGIC</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                              <argument><expr><literal type="string">"invalid magic number %04X in log segment %s, offset %u"</literal></expr></argument>,
                              <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name></expr></argument>,
                              <argument><expr><name>fname</name></expr></argument>,
                              <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLP_ALL_FLAGS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                              <argument><expr><literal type="string">"invalid info bits %04X in log segment %s, offset %u"</literal></expr></argument>,
                              <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
                              <argument><expr><name>fname</name></expr></argument>,
                              <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>XLP_LONG_HEADER</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogLongPageHeader</name></type> <name>longhdr</name> <init>= <expr><operator>(</operator><name>XLogLongPageHeader</name><operator>)</operator> <name>hdr</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name> <operator>&amp;&amp;</operator>
            <name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>fhdrident_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>sysident_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

            <comment type="block">/*
             * Format sysids separately to keep platform-dependent format code
             * out of the translatable message string.
             */</comment>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fhdrident_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fhdrident_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
                     <argument><expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sysident_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sysident_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
                     <argument><expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"WAL file is from different database system: WAL file database system identifier is %s, pg_control database system identifier is %s"</literal></expr></argument>,
                                  <argument><expr><name>fhdrident_str</name></expr></argument>, <argument><expr><name>sysident_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>!=</operator> <name>XLogSegSize</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"WAL file is from different database system: incorrect XLOG_SEG_SIZE in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_xlog_blcksz</name></name> <operator>!=</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"WAL file is from different database system: incorrect XLOG_BLCKSZ in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* hmm, first page of file doesn't have a long header? */</comment>
        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                              <argument><expr><literal type="string">"invalid info bits %04X in log segment %s, offset %u"</literal></expr></argument>,
                              <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
                              <argument><expr><name>fname</name></expr></argument>,
                              <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>!=</operator> <name>recaddr</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                              <argument><expr><literal type="string">"unexpected pageaddr %X/%X in log segment %s, offset %u"</literal></expr></argument>,
                              <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr></argument>,
                              <argument><expr><name>fname</name></expr></argument>,
                              <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Since child timelines are always assigned a TLI greater than their
     * immediate parent's TLI, we should never see TLI go backwards across
     * successive pages of a consistent WAL sequence.
     *
     * Sometimes we re-read a segment that's already been (partially) read. So
     * we only verify TLIs for pages that are later than the last remembered
     * LSN.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>recptr</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>latestPagePtr</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_tli</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>latestPageTLI</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"out-of-sequence timeline ID %u (after %u) in log segment %s, offset %u"</literal></expr></argument>,
                                  <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_tli</name></name></expr></argument>,
                                  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>latestPageTLI</name></name></expr></argument>,
                                  <argument><expr><name>fname</name></expr></argument>,
                                  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>latestPagePtr</name></name> <operator>=</operator> <name>recptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>latestPageTLI</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xlp_tli</name></name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FRONTEND</name></cpp:ifdef>
<comment type="block">/*
 * Functions that are currently not needed in the backend, but are better
 * implemented inside xlogreader.c because of the internal facilities available
 * here.
 */</comment>

<comment type="block">/*
 * Find the first record with an lsn &gt;= RecPtr.
 *
 * Useful for checking whether RecPtr is a valid xlog address for reading, and
 * to find the first valid address after some address when dumping records for
 * debugging purposes.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XLogFindNextRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XLogReaderState</name></type> <name>saved_state</name> <init>= <expr><operator>*</operator><name>state</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>tmpRecPtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>found</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * skip over potential continuation data, keeping in mind that it may span
     * multiple pages
     */</comment>
    <expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>targetPagePtr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>targetRecOff</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>pageHeaderSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>readLen</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Compute targetRecOff. It should typically be equal or greater than
         * short page-header since a valid record can't start anywhere before
         * that, except when caller has explicitly specified the offset that
         * falls somewhere there or when we are skipping multi-page
         * continuation record. It doesn't matter though because
         * ReadPageInternal() is prepared to handle that and will read at
         * least short page-header worth of data
         */</comment>
        <expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>tmpRecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

        <comment type="block">/* scroll back to page boundary */</comment>
        <expr_stmt><expr><name>targetPagePtr</name> <operator>=</operator> <name>tmpRecPtr</name> <operator>-</operator> <name>targetRecOff</name></expr>;</expr_stmt>

        <comment type="block">/* Read the page containing the record */</comment>
        <expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>targetRecOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* make sure we have enough data for the page header */</comment>
        <expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>pageHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* skip over potential continuation data */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>XLP_FIRST_IS_CONTRECORD</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If the length of the remaining continuation data is more than
             * what can fit in this page, the continuation record crosses over
             * this page. Read the next page and try again. xlp_rem_len in the
             * next page header will contain the remaining length of the
             * continuation data
             *
             * Note that record headers are MAXALIGN'ed
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>-</operator> <name>pageHeaderSize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * The previous continuation record ends in this page. Set
                 * tmpRecPtr to point to the first valid record
                 */</comment>
                <expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name>
                    <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * we know now that tmpRecPtr is an address pointing to a valid XLogRecord
     * because either we're at the first record after the beginning of a page
     * or we just jumped over the remaining data of a continuation.
     */</comment>
    <while>while <condition>(<expr><call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tmpRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* continue after the record */</comment>
        <expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

        <comment type="block">/* past the record we've found, break out */</comment>
        <if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

<label><name>err</name>:</label>
<label><name>out</name>:</label>
    <comment type="block">/* Reset state to what we had before finding the record */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name><name>saved_state</name><operator>.</operator><name>ReadRecPtr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name><name>saved_state</name><operator>.</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogReaderInvalReadState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* FRONTEND */</comment>


<comment type="block">/* ----------------------------------------
 * Functions for decoding the data and block references in a record.
 * ----------------------------------------
 */</comment>

<comment type="block">/* private function to reset the state between records */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetDecoder</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>block_id</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>has_image</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>has_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>apply_image</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decode the previously read record.
 *
 * On error, a human-readable error message is returned in *errormsg, and
 * the return value is false.
 */</comment>
<function><type><name>bool</name></type>
<name>DecodeXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * read next _size bytes from record buffer, but check for overrun first.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_HEADER_FIELD</name><parameter_list>(<parameter><type><name>_dst</name></type></parameter>, <parameter><type><name>_size</name></type></parameter>)</parameter_list></cpp:macro>            \
    <cpp:value>do {                                        \
        if (remaining &lt; _size)                    \
            goto shortdata_err;                    \
        memcpy(_dst, ptr, _size);                \
        ptr += _size;                            \
        remaining -= _size;                        \
    } while(0)</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>remaining</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>datatotal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name>block_id</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ResetDecoder</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name> <operator>=</operator> <name>record</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>record_origin</name></name> <operator>=</operator> <name>InvalidRepOriginId</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>remaining</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>

    <comment type="block">/* Decode the headers */</comment>
    <expr_stmt><expr><name>datatotal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <name>datatotal</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block_id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_DATA_SHORT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* XLogRecordDataHeaderShort */</comment>
            <decl_stmt><decl><type><name>uint8</name></type>        <name>main_data_len</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>main_data_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <name>main_data_len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name>main_data_len</name></expr>;</expr_stmt>
            <break>break;</break>                <comment type="block">/* by convention, the main data fragment is
                                 * always last */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_DATA_LONG</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* XLogRecordDataHeaderLong */</comment>
            <decl_stmt><decl><type><name>uint32</name></type>        <name>main_data_len</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>main_data_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <name>main_data_len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name>main_data_len</name></expr>;</expr_stmt>
            <break>break;</break>                <comment type="block">/* by convention, the main data fragment is
                                 * always last */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_ORIGIN</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>record_origin</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RepOriginId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>&lt;=</operator> <name>XLR_MAX_BLOCK_ID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* XLogRecordBlockHeader */</comment>
            <decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8</name></type>        <name>fork_flags</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                      <argument><expr><literal type="string">"out-of-order block_id %u at %X/%X"</literal></expr></argument>,
                                      <argument><expr><name>block_id</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                      <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <name>block_id</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>blk</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fork_flags</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>forknum</name></name> <operator>=</operator> <name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_FORK_MASK</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>fork_flags</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_HAS_IMAGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_HAS_DATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
            <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>sid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* cross-check that the HAS_DATA flag is set iff data_length &gt; 0 */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>&amp;&amp;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                      <argument><expr><literal type="string">"BKPBLOCK_HAS_DATA set, but no data included at %X/%X"</literal></expr></argument>,
                                      <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>&amp;&amp;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                      <argument><expr><literal type="string">"BKPBLOCK_HAS_DATA not set, but data length is %u at %X/%X"</literal></expr></argument>,
                                      <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_APPLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr>;</expr_stmt>

                <comment type="block">/*
                 * cross-check that hole_offset &gt; 0, hole_length &gt; 0 and
                 * bimg_len &lt; BLCKSZ if the HAS_HOLE flag is set.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                     <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                     <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>==</operator> <name>BLCKSZ</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                          <argument><expr><literal type="string">"BKPIMAGE_HAS_HOLE set, but hole offset %u length %u block image length %u at %X/%X"</literal></expr></argument>,
                                          <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>err</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * cross-check that hole_offset == 0 and hole_length == 0 if
                 * the HAS_HOLE flag is not set.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                          <argument><expr><literal type="string">"BKPIMAGE_HAS_HOLE not set, but hole offset %u length %u at %X/%X"</literal></expr></argument>,
                                          <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>err</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * cross-check that bimg_len &lt; BLCKSZ if the IS_COMPRESSED
                 * flag is set.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>==</operator> <name>BLCKSZ</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                          <argument><expr><literal type="string">"BKPIMAGE_IS_COMPRESSED set, but block image length %u at %X/%X"</literal></expr></argument>,
                                          <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>err</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * cross-check that bimg_len = BLCKSZ if neither HAS_HOLE nor
                 * IS_COMPRESSED flag is set.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                          <argument><expr><literal type="string">"neither BKPIMAGE_HAS_HOLE nor BKPIMAGE_IS_COMPRESSED set, but block image length is %u at %X/%X"</literal></expr></argument>,
                                          <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>err</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_SAME_REL</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rnode</name> <operator>=</operator> <operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>rnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                          <argument><expr><literal type="string">"BKPBLOCK_SAME_REL set but no previous rel at %X/%X"</literal></expr></argument>,
                                          <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>err</name>;</goto>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name> <operator>=</operator> <operator>*</operator><name>rnode</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                  <argument><expr><literal type="string">"invalid block_id %u at %X/%X"</literal></expr></argument>,
                                  <argument><expr><name>block_id</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>!=</operator> <name>datatotal</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>shortdata_err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Ok, we've parsed the fragment headers, and verified that the total
     * length of the payload in the fragments is equal to the amount of data
     * left. Copy the data of each fragment to a separate buffer.
     *
     * We could just set up pointers into readRecordBuf, but we want to align
     * the data for the convenience of the callers. Backup images are not
     * copied, however; they don't need alignment.
     */</comment>

    <comment type="block">/* block data first */</comment>
    <for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name> <operator>||</operator> <operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>bkp_image</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>data</name></name> <operator>||</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>&gt;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_bufsz</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>data_bufsz</name></name> <operator>=</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data_bufsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* and finally, the main data */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>

<label><name>shortdata_err</name>:</label>
    <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                          <argument><expr><literal type="string">"record with invalid length at %X/%X"</literal></expr></argument>,
                          <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
    <expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns information about the block that a block reference refers to.
 *
 * If the WAL record contains a block reference with the given ID, *rnode,
 * *forknum, and *blknum are filled in (if not NULL), and returns TRUE.
 * Otherwise returns FALSE.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogRecGetBlockTag</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>,
                   <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name> <modifier>*</modifier></type><name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>blknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>bkpb</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bkpb</name> <operator>=</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rnode</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>rnode</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>forknum</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>forknum</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>forknum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>blknum</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>blknum</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>XLogRecGetBlockShardID</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>,
                                   <parameter><decl><type><name>ShardID</name> <modifier>*</modifier></type><name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>bkpb</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bkpb</name> <operator>=</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>sid</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>sid</name></name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the data associated with a block reference, or NULL if there is
 * no data (e.g. because a full-page image was taken instead). The returned
 * pointer points to a MAXALIGNed buffer.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>XLogRecGetBlockData</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>bkpb</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bkpb</name> <operator>=</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bkpb</name><operator>-&gt;</operator><name>has_data</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>data_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name><name>bkpb</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restore a full-page image from a backup block attached to an XLOG record.
 *
 * Returns the buffer number containing the page.
 */</comment>
<function><type><name>bool</name></type>
<name>RestoreBlockImage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>bkpb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>tmp</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>has_image</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>bkpb</name> <operator>=</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>bkp_image</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>bkpb</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If a backup block image is compressed, decompress it */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pglz_decompress</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>bkpb</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>,
                            <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="string">"invalid compressed image at %X/%X, block %d"</literal></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
                                  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
                                  <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* generate page, taking into account hole if necessary */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* must zero-fill the hole */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <operator>(</operator><name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name><operator>)</operator></expr></argument>,
               <argument><expr><name>ptr</name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
               <argument><expr><name>BLCKSZ</name> <operator>-</operator> <operator>(</operator><name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
