<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/transam/timeline.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * timeline.c
 *        Functions for reading and writing timeline history files.
 *
 * A timeline history file lists the timeline changes of the timeline, in
 * a simple text format. They are archived along with the WAL segments.
 *
 * The files are named like "&lt;tli&gt;.history". For example, if the database
 * starts up and switches to timeline 5, the timeline history file would be
 * called "00000005.history".
 *
 * Each line in the file represents a timeline switch:
 *
 * &lt;parentTLI&gt; &lt;switchpoint&gt; &lt;reason&gt;
 *
 *    parentTLI    ID of the parent timeline
 *    switchpoint XLogRecPtr of the WAL location where the switch happened
 *    reason        human-readable explanation of why the timeline was changed
 *
 * The fields are separated by tabs. Lines beginning with # are comments, and
 * are ignored. Empty lines are also ignored.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/timeline.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Copies all timeline history files with id's between 'begin' and 'end'
 * from archive to pg_wal.
 */</comment>
<function><type><name>void</name></type>
<name>restoreTimeLineHistoryFiles</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>begin</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>histfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>tli</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>tli</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>tli</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>tli</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tli</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>RestoreArchivedFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><literal type="string">"RECOVERYHISTORY"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>KeepFileRestoredFromArchive</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Try to read a timeline's history file.
 *
 * If successful, return the list of component TLIs (the given TLI followed by
 * its ancestor TLIs).  If we can't find the history file, assume that the
 * timeline has no parents, and return a list of just the specified timeline
 * ID.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>readTimeLineHistory</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>targetTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>histfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>fline</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineHistoryEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>lasttli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>prevend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>fromArchive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Timeline 1 does not have a history file, so no need to check */</comment>
    <if_stmt><if>if <condition>(<expr><name>targetTLI</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeLineHistoryEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>targetTLI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
        <return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name>targetTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fromArchive</name> <operator>=</operator>
            <call><name>RestoreArchivedFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><literal type="string">"RECOVERYHISTORY"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TLHistoryFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>targetTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Not there, so assume no parents */</comment>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeLineHistoryEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>targetTLI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
        <return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Parse the file...
     */</comment>
    <expr_stmt><expr><name>prevend</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>fline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fline</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* skip leading whitespace and check for # comment */</comment>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>tli</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>switchpoint_hi</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>switchpoint_lo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>nfields</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>fline</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>nfields</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>fline</name></expr></argument>, <argument><expr><literal type="string">"%u\t%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>switchpoint_hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>switchpoint_lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* expect a numeric timeline ID as first field of line */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error in history file: %s"</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Expected a numeric timeline ID."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error in history file: %s"</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Expected a write-ahead log switchpoint location."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>tli</name> <operator>&lt;=</operator> <name>lasttli</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in history file: %s"</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Timeline IDs must be in increasing sequence."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>lasttli</name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeLineHistoryEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name>prevend</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><name>switchpoint_hi</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>switchpoint_lo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prevend</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>

        <comment type="block">/* Build list with newest item first */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* we ignore the remainder of each line */</comment>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>targetTLI</name> <operator>&lt;=</operator> <name>lasttli</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in history file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Timeline IDs must be less than child timeline's ID."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create one more entry for the "tip" of the timeline, which has no entry
     * in the history file.
     */</comment>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeLineHistoryEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>targetTLI</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name>prevend</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the history file was fetched from archive, save it in pg_wal for
     * future reference.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>fromArchive</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>KeepFileRestoredFromArchive</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Probe whether a timeline history file exists for the given timeline ID
 */</comment>
<function><type><name>bool</name></type>
<name>existsTimeLineHistory</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>probeTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>histfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

    <comment type="block">/* Timeline 1 does not have a history file, so no need to check */</comment>
    <if_stmt><if>if <condition>(<expr><name>probeTLI</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name>probeTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RestoreArchivedFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><literal type="string">"RECOVERYHISTORY"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TLHistoryFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>probeTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the newest existing timeline, assuming that startTLI exists.
 *
 * Note: while this is somewhat heuristic, it does positively guarantee
 * that (result + 1) is not a known timeline, and therefore it should
 * be safe to assign that ID to a new timeline.
 */</comment>
<function><type><name>TimeLineID</name></type>
<name>findNewestTimeLine</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>startTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>newestTLI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimeLineID</name></type>    <name>probeTLI</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The algorithm is just to probe for the existence of timeline history
     * files.  XXX is it useful to allow gaps in the sequence?
     */</comment>
    <expr_stmt><expr><name>newestTLI</name> <operator>=</operator> <name>startTLI</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>probeTLI</name> <operator>=</operator> <name>startTLI</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init><condition>;</condition> <incr><expr><name>probeTLI</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>existsTimeLineHistory</name><argument_list>(<argument><expr><name>probeTLI</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>newestTLI</name> <operator>=</operator> <name>probeTLI</name></expr>;</expr_stmt>    <comment type="block">/* probeTLI exists */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* doesn't exist, assume we're done */</comment>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>newestTLI</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new timeline history file.
 *
 *    newTLI: ID of the new timeline
 *    parentTLI: ID of its immediate parent
 *    switchpoint: WAL location where the system switched to the new timeline
 *    reason: human-readable explanation of why the timeline was switched
 *
 * Currently this is only used at the end recovery, and so there are no locking
 * considerations.  But we should be just as tense as XLogFileInit to avoid
 * emplacing a bogus file.
 */</comment>
<function><type><name>void</name></type>
<name>writeTimeLineHistory</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>newTLI</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>parentTLI</name></decl></parameter>,
                     <parameter><decl><type><name>XLogRecPtr</name></type> <name>switchpoint</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>histfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>srcfd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nbytes</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newTLI</name> <operator>&gt;</operator> <name>parentTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* else bad selection of newTLI */</comment>

    <comment type="block">/*
     * Write into a temp file name.
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/xlogtemp.%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* do not use get_sync_bit() here --- want to fsync only at end of fill */</comment>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>,
                           <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If a history file exists for the parent, copy it verbatim
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name>parentTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RestoreArchivedFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><literal type="string">"RECOVERYHISTORY"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TLHistoryFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parentTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>srcfd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>srcfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Not there, so assume parent has no parents */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TIMELINE_HISTORY_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>read</name><argument_list>(<argument><expr><name>srcfd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TIMELINE_HISTORY_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nbytes</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * If we fail to make the file, delete it to release disk
                 * space
                 */</comment>
                <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * if write didn't set errno, assume problem is no disk space
                 */</comment>
                <expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>srcfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Append one line with the details of this timeline split.
     *
     * If we did have a parent file, insert an extra newline just in case the
     * parent file failed to end with one.
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
             <argument><expr><literal type="string">"%s%u\t%X/%X\t%s\n"</literal></expr></argument>,
             <argument><expr><ternary><condition><expr><operator>(</operator><name>srcfd</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"\n"</literal></expr></else></ternary></expr></argument>,
             <argument><expr><name>parentTLI</name></expr></argument>,
             <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>switchpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>switchpoint</name><operator>)</operator></expr></argument>,
             <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nbytes</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If we fail to make the file, delete it to release disk space
         */</comment>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TIMELINE_HISTORY_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/*
     * Now move the completed history file into place with its final name.
     */</comment>
    <expr_stmt><expr><call><name>TLHistoryFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>newTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform the rename using link if available, paranoidly trying to avoid
     * overwriting an existing file (there shouldn't be one).
     */</comment>
    <expr_stmt><expr><call><name>durable_link_or_rename</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The history file can be archived immediately. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>XLogArchivingActive</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name>newTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Writes a history file for given timeline and contents.
 *
 * Currently this is only used in the walreceiver process, and so there are
 * no locking considerations.  But we should be just as tense as XLogFileInit
 * to avoid emplacing a bogus file.
 */</comment>
<function><type><name>void</name></type>
<name>writeTimeLineHistoryFile</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Write into a temp file name.
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/xlogtemp.%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* do not use get_sync_bit() here --- want to fsync only at end of fill */</comment>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>,
                           <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If we fail to make the file, delete it to release disk space
         */</comment>
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/*
     * Now move the completed history file into place with its final name.
     */</comment>
    <expr_stmt><expr><call><name>TLHistoryFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform the rename using link if available, paranoidly trying to avoid
     * overwriting an existing file (there shouldn't be one).
     */</comment>
    <expr_stmt><expr><call><name>durable_link_or_rename</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if 'expectedTLEs' contains a timeline with id 'tli'
 */</comment>
<function><type><name>bool</name></type>
<name>tliInHistory</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expectedTLEs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>expectedTLEs</argument>)</argument_list></macro>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>tli</name> <operator>==</operator> <name>tli</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the ID of the timeline in use at a particular point in time, in
 * the given timeline history.
 */</comment>
<function><type><name>TimeLineID</name></type>
<name>tliOfPointInHistory</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>history</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>history</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimeLineHistoryEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>tle</name><operator>-&gt;</operator><name>begin</name></name> <operator>&lt;=</operator> <name>ptr</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>(</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>ptr</name> <operator>&lt;</operator> <name><name>tle</name><operator>-&gt;</operator><name>end</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* found it */</comment>
            <return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>tli</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* shouldn't happen. */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"timeline history was not contiguous"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>                    <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the point in history where we branched off the given timeline,
 * and the timeline we branched to (*nextTLI). Returns InvalidXLogRecPtr if
 * the timeline is current, ie. we have not branched off from it, and throws
 * an error if the timeline is not part of this server's history.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>tliSwitchPoint</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>history</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>nextTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nextTLI</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>nextTLI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>history</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimeLineHistoryEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>tli</name></name> <operator>==</operator> <name>tli</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>end</name></name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>nextTLI</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>nextTLI</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>tli</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested timeline %u is not in this server's history"</literal></expr></argument>,
                    <argument><expr><name>tli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>    <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>
</unit>
