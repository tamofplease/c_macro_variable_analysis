<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/transam/varsup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * varsup.c
 *      postgres OID &amp; XID variables support routines
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 * Copyright (c) 2000-2017, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *      src/backend/access/transam/varsup.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/clean2pc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Number of OIDs to prefetch (preallocate) per XLOG write */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_OID_PREFETCH</name></cpp:macro>        <cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/* pointer to "variable cache" in shared memory (set up by shmem.c) */</comment>
<decl_stmt><decl><type><name>VariableCache</name></type> <name>ShmemVariableCache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>  <comment type="block">/* PGXC_DATANODE */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>next_xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>force_get_xid_from_gtm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type> <name>is_distri_report</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* GUC parameter */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_distri_print</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_distri_debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_distri_visibility_print</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  <name>delay_before_acquire_committs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  <name>delay_after_acquire_committs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Set next transaction id to use
 */</comment>
<function><type><name>void</name></type>
<name>SetNextTransactionId</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[re]setting xid = %d, old_value = %d"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>next_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>next_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allow force of getting XID from GTM
 * Useful for explicit VACUUM (autovacuum already handled)
 */</comment>
<function><type><name>void</name></type>
<name>SetForceXidFromGTM</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>force_get_xid_from_gtm</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * See if we should force using GTM
 * Useful for explicit VACUUM (autovacuum already handled)
 */</comment>
<function><type><name>bool</name></type>
<name>GetForceXidFromGTM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>force_get_xid_from_gtm</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>local_xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name><name>local_subxids</name><index>[<expr><name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>]</index></name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>local_nsub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>local_overflowed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* exported information about parallel workers, see xact.c */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>nParallelCurrentXids</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>TransactionId</name> <modifier>*</modifier></type><name>ParallelCurrentXids</name></decl>;</decl_stmt>
<comment type="block">/*
 * Set next transaction id to use
 */</comment>



<function><type><name>void</name></type>
<name>StoreGlobalXid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>globalXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    
    <if_stmt><if>if<condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"global xid exists %s new %s"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"store global xid %s to myprocno %d"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        
		<expr_stmt><expr><name>local_xid</name> <operator>=</operator> <call><name>GetLocalTransactionId</name><argument_list>(<argument><expr><name>globalXid</name></expr></argument>,
						<argument><expr><name>local_subxids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_nsub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_overflowed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">" global xid %s to local xid %d, %d subxids"</literal></expr></argument>, <argument><expr><name>globalXid</name></expr></argument>, <argument><expr><name>local_xid</name></expr></argument>, <argument><expr><name>local_nsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>SetGlobalXid</name><argument_list>(<argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>StoreLocalGlobalXid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>globalXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"global xid exists %s new %s"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name>globalXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>hasGlobalXid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>globalxidLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"store global xid %s to myprocno %d"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>globalXid</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetLocalTransactionId</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"set local transactionid %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>local_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

	<comment type="block">/* if xid is invalid, also need to reset subxid array */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_nsub</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>TransactionId</name></type>
<name>GetNextTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>local_xid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GetNumSubTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>local_nsub</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TransactionId</name> <modifier>*</modifier></type>
<name>GetSubTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>local_subxids</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>TransactIdIsCurentGlobalTransacId</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"is current transaction xid %u local xid %d"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>local_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>local_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>local_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>local_overflowed</name></expr>)</condition>
	<block>{<block_content>
	<comment type="block">/* check subxids */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>local_nsub</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>local_subxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>topxid</name> <init>= <expr><call><name>SubTransGetTopmostTransaction</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>local_nsub</name> <operator>==</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"subtransaction overflowed: xid=%d, topxid=%d, local_xid=%d"</literal></expr></argument>,
					<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>topxid</name></expr></argument>, <argument><expr><name>local_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>, <argument><expr><name>local_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>StoreStartNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>startnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NAMEDATALEN</name> <operator>&gt;=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, <argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"store startnode %s to g_twophase_state.start_node_name %s"</literal></expr></argument>, <argument><expr><name>startnode</name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>StorePartNodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partNodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, <argument><expr><name>partNodes</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>partNodes</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"store transaction participants %s to g_twophase_state"</literal></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>StoreStartXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>transactionid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name> <operator>=</operator> <name>transactionid</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name> <argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"store transaction startxid %u to g_twophase_state.start_xid %u"</literal></expr></argument>, 
                                     <argument><expr><name>transactionid</name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>


<comment type="block">/*
 * Check if GlobalTransactionId associated with the current distributed session
 * equals to specified xid.
 * It is for tuple visibility checks in secondary datanode sessions, which are
 * not associating next_xid with the current transaction.
 */</comment>
<function><type><name>bool</name></type>
<name>TransactIdIsCurentGlobalTransacId</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>next_xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>next_xid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns GlobalTransactionId associated with the current distributed session
 * without assigning it to the transaction.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetNextTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>next_xid</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/*
 * Allocate the next XID for a new transaction or subtransaction.
 *
 * The new XID is also stored into MyPgXact before returning.
 *
 * Note: when this is called, we are actually already inside a valid
 * transaction, since XIDs are now not allocated until the transaction
 * does something.  So it is safe to do a database lookup if we want to
 * issue a warning about XID wrap.
 */</comment>
<function><type><name>TransactionId</name></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
<name>GetNewTransactionId</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSubXact</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>timestamp_received</name></decl></parameter>, <parameter><decl><type><name>GTM_Timestamp</name> <modifier>*</modifier></type><name>timestamp</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
GetNewTransactionId<parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSubXact</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>increment_xid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>timestamp_received</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* Will be set if we obtain from GTM */</comment>
    <expr_stmt><expr><name>IsXidFromGTM</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
    <comment type="block">/*
     * Workers synchronize transaction state at the beginning of each parallel
     * operation, so we can't account for new XIDs after that point.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign TransactionIds during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * During bootstrap initialization, we return the special bootstrap
     * transaction id.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isSubXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>BootstrapTransactionId</name></expr>;</expr_stmt>
        <return>return <expr><name>BootstrapTransactionId</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* safety check, we should never get this far in a HS standby */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign TransactionIds during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <comment type="block">/* Initialize transaction ID */</comment>
    <expr_stmt><expr><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Get XID from GTM before acquiring the lock as concurrent connections are
     * being handled on GTM side even if the lock is acquired in a different
     * order.
     * 
     * PGXC sessions should typically use gloabl XID passed down by
     * coordinators (or datanodes in case of datanode-datanode connections).
     * But we make following exceptions:
     *
     * 1. If this is a coordinator to which client has connected
     *    (IS_PGXC_COORDINATOR &amp;&amp; !IsConnFromCoord())
     * 
     * 2. If we are autovacuum launcher or worker process
     * 3. We have been explicitly told to get an XID from the GTM, because
     * certain commands such as VACUUM and CLUSTER cannot be run inside a
     * transaction block
     * 4. Or we start currently starting up a new backend which requires a
     * valid XID/snapshot for catalog access
     *
      */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>useLocalXid</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>||</operator>
        <call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>||</operator>
        <call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call> <operator>||</operator>
		<call><name>IsAnyClean2pcProcess</name><argument_list>()</argument_list></call> <operator>||</operator>
        <call><name>GetForceXidFromGTM</name><argument_list>()</argument_list></call> <operator>||</operator>
        <operator>(</operator><call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IsPostmasterEnvironment</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IN_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>next_xid</name> <operator>=</operator> <name>xid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>BeginTranAutovacuumGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>global_session</name><index>[<expr><name>NAMEDATALEN</name> <operator>+</operator> <literal type="number">13</literal> <operator>+</operator> <literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>

            <comment type="block">/*
             * Generate unique global session identifier using coordinator
             * name, backend pid and virtual XID. 
             *
             * For global transactions i.e. those which may involve more than
             * one node, this code will be executed only on the coordinator and
             * hence its correct to use PGXCNodeName and fields from MyProc to
             * generate the global session identifier
             */</comment>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>global_session</name></expr></argument>, <argument><expr><literal type="string">"%s_%d_%d"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
                    <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>next_xid</name> <operator>=</operator> <name>xid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>BeginTranGTM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>,
                    <argument><expr><name>global_session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>timestamp_received</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Unless we are running initdb (which sets useLocalXid to true), we must
     * have either got a valid global XID, either from the coordinator/datanode
     * or fetched directly from the GTM. Everything else warrants an error
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>useLocalXid</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>next_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <name>next_xid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>next_xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
            <name>MyCoordId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>MyCoordPid</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>MyCoordLxid</name> <operator>!=</operator> <name>InvalidLocalTransactionId</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>global_session</name><index>[<expr><name>NAMEDATALEN</name> <operator>+</operator> <literal type="number">13</literal> <operator>+</operator> <literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>

            <comment type="block">/*
             * If we are running on a remote coordinator or a datanode,
             * start a new transaction and associate it with a global session
             * identifier which is guaranteed to be unique across the cluster
             */</comment>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>global_session</name></expr></argument>, <argument><expr><literal type="string">"%s_%d_%u"</literal></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>MyCoordId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MyCoordPid</name></expr></argument>,
                    <argument><expr><name>MyCoordLxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>BeginTranGTM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>global_session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Received new XID from GTM: %s:%d"</literal></expr></argument>, <argument><expr><name>global_session</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Let the coordinator know about GXID assigned to this
                 * transaction
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name> <operator>&amp;&amp;</operator>
                        <operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'x'</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>IsXidFromGTM</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>global_session</name><index>[<expr><name>NAMEDATALEN</name> <operator>+</operator> <literal type="number">13</literal> <operator>+</operator> <literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>

            <comment type="block">/*
             * This is the auto-commit, single datanode transaction. Just use
             * the local node-name and backend id in global session which
             * should give us a globally unique identifier
             */</comment>
            <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>global_session</name></expr></argument>, <argument><expr><literal type="string">"%s_%d"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>xid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>BeginTranGTM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>global_session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Let the coordinator know about GXID assigned to this
                 * transaction
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name> <operator>&amp;&amp;</operator>
                        <operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'x'</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>IsXidFromGTM</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"new xid %d."</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>

    <comment type="block">/*----------
     * Check to see if it's safe to assign another XID.  This protects against
     * catastrophic data loss due to XID wraparound.  The basic rules are:
     *
     * If we're past xidVacLimit, start trying to force autovacuum cycles.
     * If we're past xidWarnLimit, start issuing warnings.
     * If we're past xidStopLimit, refuse to execute transactions, unless
     * we are running in single-user mode (which gives an escape hatch
     * to the DBA who somehow got past the earlier defenses).
     *
     * Note that this coding also appears in GetNewMultiXactId.
     *----------
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <comment type="block">/*
     * In PG, the xid will never cross the wrap-around limit thanks to the
     * above checks. But in PGXC, if a new node is initialized and brought up,
     * it's own xid may not be in sync with the GTM gxid. The wrap-around limits
     * are initially set w.r.t. the last xid used. So if the Gxid-xid difference
     * is already more than 2^31, then the gxid is deemed to have already
     * crossed the wrap-around limit. So again in such cases as well, we should
     * allow only a standalone backend to run vacuum.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWrapLimit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IsPostmasterEnvironment</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
               <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
               <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Xid wraparound might have already happened. database is not accepting commands on database with OID %u"</literal></expr></argument>,
               <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call><operator>,</operator>
               <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Stop the postmaster and use a standalone backend to vacuum that database.\n"</literal>
                       <literal type="string">"You might also need to commit or roll back old prepared transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * For safety's sake, we release XidGenLock while sending signals,
         * warnings, etc.  This is not so much because we care about
         * preserving concurrency in this situation, as to avoid any
         * possibility of deadlock while doing get_database_name(). First,
         * copy all the shared values we'll need in this path.
         */</comment>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWarnLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWarnLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidStopLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidStopLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWrapLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWrapLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>oldest_datoid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * To avoid swamping the postmaster with signals, we issue the autovac
         * request only once per 64K transaction starts.  This still gives
         * plenty of chances before we get into real trouble.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xid</name> <operator>%</operator> <literal type="number">65536</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator>
            <call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xidStopLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
            <comment type="block">/*
             * Allow auto-vacuum to carry-on, so that it gets a chance to correct
             * the xid-wrap-limits w.r.t to gxid fetched from GTM.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                       <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* complain even if that DB has disappeared */</comment>
                <if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands to avoid wraparound data loss in database \"%s\""</literal></expr></argument>,
                                <argument><expr><name>oldest_datname</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Stop the postmaster and vacuum that database in single-user mode.\n"</literal>
                                 <literal type="string">"You might also need to commit or roll back old prepared transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands to avoid wraparound data loss in database with OID %u"</literal></expr></argument>,
                                <argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Stop the postmaster and vacuum that database in single-user mode.\n"</literal>
                                 <literal type="string">"You might also need to commit or roll back old prepared transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xidWarnLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                       <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

            <comment type="block">/* complain even if that DB has disappeared */</comment>
            <if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed within %u transactions"</literal></expr></argument>,
                                <argument><expr><name>oldest_datname</name></expr></argument>,
                                <argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
                                 <literal type="string">"You might also need to commit or roll back old prepared transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed within %u transactions"</literal></expr></argument>,
                                <argument><expr><name>oldest_datoid</name></expr></argument>,
                                <argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
                                 <literal type="string">"You might also need to commit or roll back old prepared transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Re-acquire lock and start over */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
        <comment type="block">/*
         * In the case of Postgres-XC, transaction ID is managed globally at GTM level,
         * so updating the GXID here based on the cache that might have been changed
         * by another session when checking for wraparound errors at this local node
         * level breaks transaction ID consistency of cluster.
         */</comment>
        <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not obtain a transaction ID from GTM. The GTM"</literal>
                     <literal type="string">" might have failed or lost connectivity"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we are allocating the first XID of a new page of the commit log,
     * zero out that commit-log page before returning. We must do this while
     * holding XidGenLock, else another xact could acquire and commit a later
     * XID before we zero the page.  Fortunately, a page of the commit log
     * holds 32K or more transactions, so we don't have to do this very often.
     *
     * Extend pg_subtrans and pg_commit_ts too.
     */</comment>
    <expr_stmt><expr><call><name>ExtendCLOG</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtendCommitTs</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtendSUBTRANS</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now advance the nextXid counter.  This must not happen until after we
     * have successfully completed ExtendCLOG() --- if that routine fails, we
     * want the next incoming transaction to try it again.  We cannot assign
     * more XIDs until there is CLOG space for them.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <comment type="block">/*
     * But first bring nextXid in sync with global xid. Actually we get xid
     * externally anyway, so it should not be needed to update nextXid in
     * theory, but it is required to keep nextXid close to the gxid
     * especially when vacuumfreeze is run using a standalone backend.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>increment_xid</name> <operator>||</operator> <operator>!</operator><name>IsPostmasterEnvironment</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * We must store the new XID into the shared ProcArray before releasing
     * XidGenLock.  This ensures that every active XID older than
     * latestCompletedXid is present in the ProcArray, which is essential for
     * correct OldestXmin tracking; see src/backend/access/transam/README.
     *
     * XXX by storing xid into MyPgXact without acquiring ProcArrayLock, we
     * are relying on fetch/store of an xid to be atomic, else other backends
     * might see a partially-set xid here.  But holding both locks at once
     * would be a nasty concurrency hit.  So for now, assume atomicity.
     *
     * Note that readers of PGXACT xid fields should be careful to fetch the
     * value only once, rather than assume they can read a value multiple
     * times and get the same answer each time.
     *
     * The same comments apply to the subxact xid count and overflow fields.
     *
     * A solution to the atomic-store problem would be to give each PGXACT its
     * own spinlock used only for fetching/storing that PGXACT's xid and
     * related fields.
     *
     * If there's no room to fit a subtransaction XID into PGPROC, set the
     * cache-overflowed flag instead.  This forces readers to look in
     * pg_subtrans to map subtransaction XIDs up to top-level XIDs. There is a
     * race-condition window, in that the new XID will not appear as running
     * until its parent link has been placed into pg_subtrans. However, that
     * will happen before anyone could possibly have a reason to inquire about
     * the status of the XID, so it seems OK.  (Snapshots taken during this
     * window *will* include the parent XID, so they will deliver the correct
     * answer later on when someone does have a reason to inquire.)
     */</comment>
    <block>{<block_content>
        <comment type="block">/*
         * Use volatile pointer to prevent code rearrangement; other backends
         * could be examining my subxids info concurrently, and we don't want
         * them to see an invalid intermediate state, such as incrementing
         * nxids before filling the array entry.  Note we are assuming that
         * TransactionId and int fetch/store are atomic.
         */</comment>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>myproc</name> <init>= <expr><name>MyProc</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>mypgxact</name> <init>= <expr><name>MyPgXact</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>mypgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>nxids</name> <init>= <expr><name><name>mypgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>&lt;</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>myproc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>nxids</name></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mypgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <name>nxids</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>mypgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>xid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read nextXid but don't allocate it.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>ReadNewTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>xid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the cluster-wide value for the oldest valid clog entry.
 *
 * We must acquire CLogTruncationLock to advance the oldestClogXid. It's not
 * necessary to hold the lock during the actual clog truncation, only when we
 * advance the limit, as code looking up arbitrary xids is required to hold
 * CLogTruncationLock from when it tests oldestClogXid through to when it
 * completes the clog lookup.
 */</comment>
<function><type><name>void</name></type>
<name>AdvanceOldestClogXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldest_datfrozenxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name></expr></argument>,
                              <argument><expr><name>oldest_datfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name> <operator>=</operator> <name>oldest_datfrozenxid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the last safe XID to allocate using the currently oldest
 * datfrozenxid (ie, the oldest XID that might exist in any database
 * of our cluster), and the OID of the (or a) database with that value.
 */</comment>
<function><type><name>void</name></type>
<name>SetTransactionIdLimit</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldest_datfrozenxid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldest_datoid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidVacLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWarnLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidStopLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWrapLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>curXid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>oldest_datfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The place where we actually get into deep trouble is halfway around
     * from the oldest potentially-existing XID.  (This calculation is
     * probably off by one or two counts, because the special XIDs reduce the
     * size of the loop a little bit.  But we throw in plenty of slop below,
     * so it doesn't matter.)
     */</comment>
    <expr_stmt><expr><name>xidWrapLimit</name> <operator>=</operator> <name>oldest_datfrozenxid</name> <operator>+</operator> <operator>(</operator><name>MaxTransactionId</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xidWrapLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>xidWrapLimit</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We'll refuse to continue assigning XIDs in interactive mode once we get
     * within 1M transactions of data loss.  This leaves lots of room for the
     * DBA to fool around fixing things in a standalone backend, while not
     * being significant compared to total XID space. (Note that since
     * vacuuming requires one transaction per table cleaned, we had better be
     * sure there's lots of XIDs left...)
     */</comment>
    <expr_stmt><expr><name>xidStopLimit</name> <operator>=</operator> <name>xidWrapLimit</name> <operator>-</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xidStopLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>xidStopLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We'll start complaining loudly when we get within 10M transactions of
     * the stop point.  This is kind of arbitrary, but if you let your gas
     * gauge get down to 1% of full, would you be looking for the next gas
     * station?  We need to be fairly liberal about this number because there
     * are lots of scenarios where most transactions are done by automatic
     * clients that won't pay attention to warnings. (No, we're not gonna make
     * this configurable.  If you know enough to configure it, you know enough
     * to not get in this kind of trouble in the first place.)
     */</comment>
    <expr_stmt><expr><name>xidWarnLimit</name> <operator>=</operator> <name>xidStopLimit</name> <operator>-</operator> <literal type="number">10000000</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xidWarnLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>xidWarnLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We'll start trying to force autovacuums when oldest_datfrozenxid gets
     * to be more than autovacuum_freeze_max_age transactions old.
     *
     * Note: guc.c ensures that autovacuum_freeze_max_age is in a sane range,
     * so that xidVacLimit will be well before xidWarnLimit.
     *
     * Note: autovacuum_freeze_max_age is a PGC_POSTMASTER parameter so that
     * we don't have to worry about dealing with on-the-fly changes in its
     * value.  It doesn't look practical to update shared state from a GUC
     * assign hook (too many processes would try to execute the hook,
     * resulting in race conditions as well as crashes of those not connected
     * to shared memory).  Perhaps this can be improved someday.  See also
     * SetMultiXactIdLimit.
     */</comment>
    <expr_stmt><expr><name>xidVacLimit</name> <operator>=</operator> <name>oldest_datfrozenxid</name> <operator>+</operator> <name>autovacuum_freeze_max_age</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>xidVacLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>xidVacLimit</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Grab lock for just long enough to set the new limit values */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name> <operator>=</operator> <name>oldest_datfrozenxid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name> <operator>=</operator> <name>xidVacLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWarnLimit</name></name> <operator>=</operator> <name>xidWarnLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidStopLimit</name></name> <operator>=</operator> <name>xidStopLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWrapLimit</name></name> <operator>=</operator> <name>xidWrapLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name> <operator>=</operator> <name>oldest_datoid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>curXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Log the info */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction ID wrap limit is %u, limited by database with OID %u"</literal></expr></argument>,
                    <argument><expr><name>xidWrapLimit</name></expr></argument>, <argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If past the autovacuum force point, immediately signal an autovac
     * request.  The reason for this is that autovac only processes one
     * database per invocation.  Once it's finished cleaning up the oldest
     * database, it'll call here, and we'll signal the postmaster to start
     * another iteration immediately if there are still any old databases.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>curXid</name></expr></argument>, <argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Give an immediate warning if past the wrap warn point */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>curXid</name></expr></argument>, <argument><expr><name>xidWarnLimit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oldest_datname</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We can be called when not inside a transaction, for example during
         * StartupXLOG().  In such a case we cannot do database access, so we
         * must just report the oldest DB's OID.
         *
         * Note: it's also possible that get_database_name fails and returns
         * NULL, for example because the database just got dropped.  We'll
         * still warn, even though the warning might now be unnecessary.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed within %u transactions"</literal></expr></argument>,
                            <argument><expr><name>oldest_datname</name></expr></argument>,
                            <argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>curXid</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
                             <literal type="string">"You might also need to commit or roll back old prepared transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed within %u transactions"</literal></expr></argument>,
                            <argument><expr><name>oldest_datoid</name></expr></argument>,
                            <argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>curXid</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
                             <literal type="string">"You might also need to commit or roll back old prepared transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ForceTransactionIdLimitUpdate -- does the XID wrap-limit data need updating?
 *
 * We primarily check whether oldestXidDB is valid.  The cases we have in
 * mind are that that database was dropped, or the field was reset to zero
 * by pg_resetwal.  In either case we should force recalculation of the
 * wrap limit.  Also do it if oldestXid is old enough to be forcing
 * autovacuums or other actions; this ensures we update our state as soon
 * as possible once extra overhead is being incurred.
 */</comment>
<function><type><name>bool</name></type>
<name>ForceTransactionIdLimitUpdate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>xidVacLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>oldestXidDB</name></decl>;</decl_stmt>

    <comment type="block">/* Locking is probably not really necessary, but let's be careful */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nextXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xidVacLimit</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldestXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldestXidDB</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>oldestXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* shouldn't happen, but just in case */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* this shouldn't happen anymore either */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>, <argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* past VacLimit, don't delay updating */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldestXidDB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* could happen, per comments above */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNewObjectId -- allocate a new OID
 *
 * OIDs are generated by a cluster-wide counter.  Since they are only 32 bits
 * wide, counter wraparound will occur eventually, and therefore it is unwise
 * to assume they are unique unless precautions are taken to make them so.
 * Hence, this routine should generally not be used directly.  The only
 * direct callers should be GetNewOid() and GetNewRelFileNode() in
 * catalog/catalog.c.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewObjectId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* safety check, we should never get this far in a HS standby */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign OIDs during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for wraparound of the OID counter.  We *must* not return 0
     * (InvalidOid); and as long as we have to check that, it seems a good
     * idea to skip over everything below FirstNormalObjectId too. (This
     * basically just avoids lots of collisions with bootstrap-assigned OIDs
     * right after a wrap occurs, so as to avoid a possibly large number of
     * iterations in GetNewOid.)  Note we are relying on unsigned comparison.
     *
     * During initdb, we start the OID generator at FirstBootstrapObjectId, so
     * we only wrap if before that point when in bootstrap or standalone mode.
     * The first time through this routine after normal postmaster start, the
     * counter will be forced up to FirstNormalObjectId.  This mechanism
     * leaves the OIDs between FirstBootstrapObjectId and FirstNormalObjectId
     * available for automatic assignment during initdb, while ensuring they
     * will never conflict with user-assigned OIDs.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstNormalObjectId</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IsPostmasterEnvironment</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* wraparound, or first post-initdb assignment, in normal mode */</comment>
            <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstNormalObjectId</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* we may be bootstrapping, so don't enforce the full range */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* wraparound in standalone mode (unlikely but possible) */</comment>
                <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstNormalObjectId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If we run out of logged for use oids then we must log more */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>XLogPutNextOid</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>+</operator> <name>VAR_OID_PREFETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <name>VAR_OID_PREFETCH</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>ExtendLogs</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtendCLOG</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtendCommitTs</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtendSUBTRANS</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
