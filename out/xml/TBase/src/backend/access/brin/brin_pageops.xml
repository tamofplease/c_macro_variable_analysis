<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/brin/brin_pageops.c"><comment type="block">/*
 * brin_pageops.c
 *        Page-handling routines for BRIN indexes
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/access/brin/brin_pageops.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_pageops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_revmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/freespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Maximum size of an entry in a BRIN_PAGETYPE_REGULAR page.  We can tolerate
 * a single item per page, unlike other index AMs.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BrinMaxItemSize</name></cpp:macro> \
    <cpp:value>MAXALIGN_DOWN(BLCKSZ - \
                  (MAXALIGN(SizeOfPageHeaderData + \
                            sizeof(ItemIdData)) + \
                   MAXALIGN(sizeof(BrinSpecialSpace))))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>brin_getinsertbuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>irel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>oldbuf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsz</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>extended</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>br_page_get_freespace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>brin_initialize_empty_new_buffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Update tuple origtup (size origsz), located in offset oldoff of buffer
 * oldbuf, to newtup (size newsz) as summary tuple for the page range starting
 * at heapBlk.  oldbuf must not be locked on entry, and is not locked at exit.
 *
 * If samepage is true, attempt to put the new tuple in the same page, but if
 * there's no room, use some other one.
 *
 * If the update is successful, return true; the revmap is updated to point to
 * the new tuple.  If the update is not done for whatever reason, return false.
 * Caller may retry the update if this happens.
 */</comment>
<function><type><name>bool</name></type>
<name>brin_doupdate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl></parameter>,
              <parameter><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl></parameter>,
              <parameter><decl><type><name>Buffer</name></type> <name>oldbuf</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoff</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>BrinTuple</name> <modifier>*</modifier></type><name>origtup</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>origsz</name></decl></parameter>,
              <parameter><decl><type><specifier>const</specifier> <name>BrinTuple</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newsz</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>samepage</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>oldpage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemId</name></type>        <name>oldlp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>oldsz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>newbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>extended</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsz</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newsz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the item is oversized, don't bother. */</comment>
    <if_stmt><if>if <condition>(<expr><name>newsz</name> <operator>&gt;</operator> <name>BrinMaxItemSize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
                        <argument><expr><name>newsz</name></expr></argument>, <argument><expr><name>BrinMaxItemSize</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>            <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* make sure the revmap is long enough to contain the entry we need */</comment>
    <expr_stmt><expr><call><name>brinRevmapExtend</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>samepage</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* need a page on which to put the item */</comment>
        <expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>brin_getinsertbuffer</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extended</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>extended</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Note: it's possible (though unlikely) that the returned newbuf is
         * the same as oldbuf, if brin_getinsertbuffer determined that the old
         * buffer does in fact have enough space.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>==</operator> <name>oldbuf</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>extended</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>extended</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>oldpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldlp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>oldoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check that the old tuple wasn't updated concurrently: it might have
     * moved someplace else entirely ...
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>oldlp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If this happens, and the new buffer was obtained by extending the
         * relation, then we need to ensure we don't leave it uninitialized or
         * forget about it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>brin_initialize_empty_new_buffer</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>FreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>oldsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>oldlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <operator>(</operator><name>BrinTuple</name> <operator>*</operator><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>oldlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * ... or it might have been updated in place to different contents.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>brin_tuples_equal</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>oldsz</name></expr></argument>, <argument><expr><name>origtup</name></expr></argument>, <argument><expr><name>origsz</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>brin_initialize_empty_new_buffer</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>FreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Great, the old tuple is intact.  We can proceed with the update.
     *
     * If there's enough room in the old page for the new tuple, replace it.
     *
     * Note that there might now be enough space on the page even though the
     * caller told us there isn't, if a concurrent update moved another tuple
     * elsewhere or replaced a tuple with a smaller one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>BrinPageFlags</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BRIN_EVACUATE_PAGE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
        <call><name>brin_can_do_samepage_update</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>origsz</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* as above */</comment>
            <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>brin_initialize_empty_new_buffer</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIndexTupleOverwrite</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>oldoff</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>newtup</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to replace BRIN tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* XLOG stuff */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>xl_brin_samepage_update</name></type> <name>xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8</name></type>        <name>info</name> <init>= <expr><name>XLOG_BRIN_SAMEPAGE_UPDATE</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>oldoff</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBrinSamepageUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newtup</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BRIN_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>newbuf</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Not enough space, but caller said that there was. Tell them to
         * start over.
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Not enough free space on the oldpage. Put the new tuple on the new
         * page, and update the revmap.
         */</comment>
        <decl_stmt><decl><type><name>Page</name></type>        <name>newpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>revmapbuf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>newtid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newoff</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>newblk</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>revmapbuf</name> <operator>=</operator> <call><name>brinLockRevmapPageForUpdate</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We need to initialize the page if it's newly obtained.  Note we
         * will WAL-log the initialization as part of the update, so we don't
         * need to do that here.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>brin_page_init</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BRIN_PAGETYPE_REGULAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>PageIndexTupleDeleteNoCompact</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>oldoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newoff</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>newtup</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>,
                             <argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>newoff</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add BRIN tuple to new page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* needed to update FSM below */</comment>
        <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>newblk</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>br_page_get_freespace</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newtid</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>brinSetHeapBlockItemptr</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>, <argument><expr><name>pagesPerRange</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>newtid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* XLOG stuff */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>xl_brin_update</name></type> <name>xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8</name></type>        <name>info</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_BRIN_UPDATE</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>extended</name></expr> ?</condition><then> <expr><name>XLOG_BRIN_INIT_PAGE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>insert</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>newoff</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>insert</name><operator>.</operator><name>heapBlk</name></name> <operator>=</operator> <name>heapBlk</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>insert</name><operator>.</operator><name>pagesPerRange</name></name> <operator>=</operator> <name>pagesPerRange</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>oldOffnum</name></name> <operator>=</operator> <name>oldoff</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* new page */</comment>
            <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBrinUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>extended</name></expr> ?</condition><then> <expr><name>REGBUF_WILL_INIT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newtup</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* revmap page */</comment>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>revmapbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* old page */</comment>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BRIN_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>newblk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return whether brin_doupdate can do a samepage update.
 */</comment>
<function><type><name>bool</name></type>
<name>brin_can_do_samepage_update</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>origsz</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return
        <expr><operator>(</operator><operator>(</operator><name>newsz</name> <operator>&lt;=</operator> <name>origsz</name><operator>)</operator> <operator>||</operator>
         <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <operator>(</operator><name>newsz</name> <operator>-</operator> <name>origsz</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert an index tuple into the index relation.  The revmap is updated to
 * mark the range containing the given page as pointing to the inserted entry.
 * A WAL record is written.
 *
 * The buffer, if valid, is first checked for free space to insert the new
 * entry; if there isn't enough, a new buffer is obtained and pinned.  No
 * buffer lock must be held on entry, no buffer lock is held on exit.
 *
 * Return value is the offset number where the tuple was inserted.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>brin_doinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl></parameter>,
              <parameter><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl></parameter>,
              <parameter><decl><type><name>BrinTuple</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsz</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>revmapbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>extended</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemsz</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the item is oversized, don't even bother. */</comment>
    <if_stmt><if>if <condition>(<expr><name>itemsz</name> <operator>&gt;</operator> <name>BrinMaxItemSize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
                        <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>BrinMaxItemSize</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidOffsetNumber</name></expr>;</return> <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make sure the revmap is long enough to contain the entry we need */</comment>
    <expr_stmt><expr><call><name>brinRevmapExtend</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Acquire lock on buffer supplied by caller, if any.  If it doesn't have
     * enough space, unpin it to obtain a new one below.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * It's possible that another backend (or ourselves!) extended the
         * revmap over the page we held a pin on, so we cannot assume that
         * it's still a regular page.
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>br_page_get_freespace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>itemsz</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we still don't have a usable buffer, have brin_getinsertbuffer
     * obtain one for us.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <do>do<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <call><name>brin_getinsertbuffer</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extended</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
        while <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>extended</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Now obtain lock on revmap buffer */</comment>
    <expr_stmt><expr><name>revmapbuf</name> <operator>=</operator> <call><name>brinLockRevmapPageForUpdate</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>blk</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Execute the actual insertion */</comment>
    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>brin_page_init</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BRIN_PAGETYPE_REGULAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>tup</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>,
                      <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not insert new index tuple to page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BRIN_elog</name><argument_list>(<argument><expr><operator>(</operator><name>DEBUG2</name><operator>,</operator> <literal type="string">"inserted tuple (%u,%u) for range starting at %u"</literal><operator>,</operator>
               <name>blk</name><operator>,</operator> <name>off</name><operator>,</operator> <name>heapBlk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>brinSetHeapBlockItemptr</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>, <argument><expr><name>pagesPerRange</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XLOG stuff */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_brin_insert</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint8</name></type>        <name>info</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_BRIN_INSERT</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>extended</name></expr> ?</condition><then> <expr><name>XLOG_BRIN_INIT_PAGE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>heapBlk</name></name> <operator>=</operator> <name>heapBlk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>pagesPerRange</name></name> <operator>=</operator> <name>pagesPerRange</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBrinInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>extended</name></expr> ?</condition><then> <expr><name>REGBUF_WILL_INIT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>revmapbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BRIN_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Tuple is firmly on buffer; we can release our locks */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>revmapbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>off</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a page with the given type.
 *
 * Caller is responsible for marking it dirty, as appropriate.
 */</comment>
<function><type><name>void</name></type>
<name>brin_page_init</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinSpecialSpace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BrinPageType</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a new BRIN index' metapage.
 */</comment>
<function><type><name>void</name></type>
<name>brin_metapage_init</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BrinMetaPageData</name> <modifier>*</modifier></type><name>metadata</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>brin_page_init</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BRIN_PAGETYPE_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>metadata</name> <operator>=</operator> <operator>(</operator><name>BrinMetaPageData</name> <operator>*</operator><operator>)</operator> <call><name>PageGetContents</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>brinMagic</name></name> <operator>=</operator> <name>BRIN_META_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>brinVersion</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>pagesPerRange</name></name> <operator>=</operator> <name>pagesPerRange</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Note we cheat here a little.  0 is not a valid revmap block number
     * (because it's the metapage buffer), but doing this enables the first
     * revmap page to be created when the index is.
     */</comment>
    <expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>lastRevmapPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initiate page evacuation protocol.
 *
 * The page must be locked in exclusive mode by the caller.
 *
 * If the page is not yet initialized or empty, return false without doing
 * anything; it can be used for revmap without any further changes.  If it
 * contains tuples, mark it for evacuation and return true.
 */</comment>
<function><type><name>bool</name></type>
<name>brin_start_evacuating_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxRel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>lp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* prevent other backends from adding more stuff to this page */</comment>
            <expr_stmt><expr><call><name>BrinPageFlags</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>|=</operator> <name>BRIN_EVACUATE_PAGE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Move all tuples out of a page.
 *
 * The caller must hold lock on the page. The lock and pin are released.
 */</comment>
<function><type><name>void</name></type>
<name>brin_evacuate_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxRel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl></parameter>,
                   <parameter><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>btup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>btupsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BrinPageFlags</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BRIN_EVACUATE_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>tup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Size</name></type>        <name>sz</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ItemId</name></type>        <name>lp</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>BrinTuple</name> <operator>*</operator><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>brin_copy_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>btup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>btupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>brin_doupdate</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>pagesPerRange</name></expr></argument>, <argument><expr><name>revmap</name></expr></argument>, <argument><expr><name><name>tup</name><operator>-&gt;</operator><name>bt_blkno</name></name></expr></argument>,
                               <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>off</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>            <comment type="block">/* retry */</comment>

            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* It's possible that someone extended the revmap over this page */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BRIN_IS_REGULAR_PAGE</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a BRIN index page, initialize it if necessary, and record it into the
 * FSM if necessary.  Return value is true if the FSM itself needs "vacuuming".
 * The main use for this is when, during vacuuming, an uninitialized page is
 * found, which could be the result of relation extension followed by a crash
 * before the page can be used.
 */</comment>
<function><type><name>bool</name></type>
<name>brin_page_cleanup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freespace</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If a page was left uninitialized, initialize it now; also record it in
     * FSM.
     *
     * Somebody else might be extending the relation concurrently.  To avoid
     * re-initializing the page before they can grab the buffer lock, we
     * acquire the extension lock momentarily.  Since they hold the extension
     * lock from before getting the page and after its been initialized, we're
     * sure to see their initialization.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>brin_initialize_empty_new_buffer</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Nothing to be done for non-regular index pages */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BRIN_IS_META_PAGE</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>BRIN_IS_REVMAP_PAGE</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Measure free space and record it */</comment>
    <expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>br_page_get_freespace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>freespace</name> <operator>&gt;</operator> <call><name>GetRecordedFreeSpace</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a pinned and exclusively locked buffer which can be used to insert an
 * index item of size itemsz (caller must ensure not to request sizes
 * impossible to fulfill).  If oldbuf is a valid buffer, it is also locked (in
 * an order determined to avoid deadlocks.)
 *
 * If we find that the old page is no longer a regular index page (because
 * of a revmap extension), the old buffer is unlocked and we return
 * InvalidBuffer.
 *
 * If there's no existing page with enough free space to accommodate the new
 * item, the relation is extended.  If this happens, *extended is set to true,
 * and it is the caller's responsibility to initialize the page (and WAL-log
 * that fact) prior to use.
 *
 * Note that in some corner cases it is possible for this routine to extend the
 * relation and then not return the buffer.  It is this routine's
 * responsibility to WAL-log the page initialization and to record the page in
 * FSM if that happens.  Such a buffer may later be reused by this routine.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>brin_getinsertbuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>irel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>oldbuf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsz</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>extended</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>oldblk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>newblk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>freespace</name></decl>;</decl_stmt>

    <comment type="block">/* callers must have checked */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemsz</name> <operator>&lt;=</operator> <name>BrinMaxItemSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>extended</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>oldblk</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>oldblk</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Loop until we find a page with sufficient free space.  By the time we
     * return to caller out of this loop, both buffers are valid and locked;
     * if we have to restart here, neither buffer is locked and buf is not a
     * pinned buffer.
     */</comment>
    <expr_stmt><expr><name>newblk</name> <operator>=</operator> <call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newblk</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newblk</name> <operator>=</operator> <call><name>GetPageWithFreeSpace</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>extensionLockHeld</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>newblk</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * There's not enough free space in any existing index page,
             * according to the FSM: extend the relation to obtain a shiny new
             * page.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>irel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>extensionLockHeld</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newblk</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>extended</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>BRIN_elog</name><argument_list>(<argument><expr><operator>(</operator><name>DEBUG2</name><operator>,</operator> <literal type="string">"brin_getinsertbuffer: extending to page %u"</literal><operator>,</operator>
                       <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>newblk</name> <operator>==</operator> <name>oldblk</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * There's an odd corner-case here where the FSM is out-of-date,
             * and gave us the old page.
             */</comment>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <name>oldbuf</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * We lock the old buffer first, if it's earlier than the new one; but
         * before we do, we need to check that it hasn't been turned into a
         * revmap page concurrently; if we detect that it happened, give up
         * and tell caller to start over.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>oldblk</name> <operator>&lt;</operator> <name>newblk</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BRIN_IS_REGULAR_PAGE</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * It is possible that the new page was obtained from
                 * extending the relation.  In that case, we must be sure to
                 * record it in the FSM before leaving, because otherwise the
                 * space would be lost forever.  However, we cannot let an
                 * uninitialized page get in the FSM, so we need to initialize
                 * it first.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>extended</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>brin_initialize_empty_new_buffer</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* shouldn't matter, but don't confuse caller */</comment>
                    <expr_stmt><expr><operator>*</operator><name>extended</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>extensionLockHeld</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>InvalidBuffer</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>extensionLockHeld</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We have a new buffer to insert into.  Check that the new page has
         * enough free space, and return it if it does; otherwise start over.
         * Note that we allow for the FSM to be out of date here, and in that
         * case we update it and move on.
         *
         * (br_page_get_freespace also checks that the FSM didn't hand us a
         * page that has since been repurposed for the revmap.)
         */</comment>
        <expr_stmt><expr><name>freespace</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>extended</name></expr> ?</condition><then>
            <expr><name>BrinMaxItemSize</name></expr> </then><else>: <expr><call><name>br_page_get_freespace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>freespace</name> <operator>&gt;=</operator> <name>itemsz</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Since the target block specification can get lost on cache
             * invalidations, make sure we update the more permanent FSM with
             * data about it before going away.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>extended</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Lock the old buffer if not locked already.  Note that in this
             * case we know for sure it's a regular page: it's later than the
             * new page we just got, which is not a revmap page, and revmap
             * pages are always consecutive.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>oldblk</name> <operator>&gt;</operator> <name>newblk</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BRIN_IS_REGULAR_PAGE</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <return>return <expr><name>buf</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* This page is no good. */</comment>

        <comment type="block">/*
         * If an entirely new page does not contain enough free space for the
         * new item, then surely that item is oversized.  Complain loudly; but
         * first make sure we initialize the page and record it as free, for
         * next time.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>extended</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>brin_initialize_empty_new_buffer</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
                            <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>irel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidBuffer</name></expr>;</return>    <comment type="block">/* keep compiler quiet */</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>newblk</name> <operator>!=</operator> <name>oldblk</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>oldblk</name> <operator>&lt;=</operator> <name>newblk</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>newblk</name> <operator>=</operator> <call><name>RecordAndGetPageWithFreeSpace</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a page as an empty regular BRIN page, WAL-log this, and record
 * the page in FSM.
 *
 * There are several corner situations in which we extend the relation to
 * obtain a new page and later find that we cannot use it immediately.  When
 * that happens, we don't want to leave the page go unrecorded in FSM, because
 * there is no mechanism to get the space back and the index would bloat.
 * Also, because we would not WAL-log the action that would initialize the
 * page, the page would go uninitialized in a standby (or after recovery).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>brin_initialize_empty_new_buffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BRIN_elog</name><argument_list>(<argument><expr><operator>(</operator><name>DEBUG2</name><operator>,</operator>
               <literal type="string">"brin_initialize_empty_new_buffer: initializing blank page %u"</literal><operator>,</operator>
               <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>brin_page_init</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BRIN_PAGETYPE_REGULAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>log_newpage_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We update the FSM for this page, but this is not WAL-logged.  This is
     * acceptable because VACUUM will scan the index and update the FSM with
     * pages whose FSM records were forgotten in a crash.
     */</comment>
    <expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>br_page_get_freespace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return the amount of free space on a regular BRIN index page.
 *
 * If the page is not a regular page, or has been marked with the
 * BRIN_EVACUATE_PAGE flag, returns 0.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>br_page_get_freespace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BRIN_IS_REGULAR_PAGE</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><call><name>BrinPageFlags</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BRIN_EVACUATE_PAGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
