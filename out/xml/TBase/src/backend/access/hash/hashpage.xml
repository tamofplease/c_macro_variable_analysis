<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/hash/hashpage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hashpage.c
 *      Hash table page management code for the Postgres hash access method
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/access/hash/hashpage.c
 *
 * NOTES
 *      Postgres hash pages look like ordinary relation pages.  The opaque
 *      data at high addresses includes information about the page including
 *      whether a page is an overflow page or a true bucket, the bucket
 *      number, and the block numbers of the preceding and following pages
 *      in the same bucket.
 *
 *      The first page in a hash relation, page zero, is special -- it stores
 *      information describing the hash table; it is referred to as the
 *      "meta page." Pages one and higher store the actual data.
 *
 *      There are also bitmap pages, which are not manipulated here;
 *      see hashovfl.c.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_hash_alloc_buckets</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>firstblock</name></decl></parameter>,
                    <parameter><decl><type><name>uint32</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_hash_splitbucket</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>,
                  <parameter><decl><type><name>Bucket</name></type> <name>obucket</name></decl></parameter>, <parameter><decl><type><name>Bucket</name></type> <name>nbucket</name></decl></parameter>,
                  <parameter><decl><type><name>Buffer</name></type> <name>obuf</name></decl></parameter>,
                  <parameter><decl><type><name>Buffer</name></type> <name>nbuf</name></decl></parameter>,
                  <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>htab</name></decl></parameter>,
                  <parameter><decl><type><name>uint32</name></type> <name>maxbucket</name></decl></parameter>,
                  <parameter><decl><type><name>uint32</name></type> <name>highmask</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>lowmask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_split_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * We use high-concurrency locking on hash indexes (see README for an overview
 * of the locking rules).  However, we can skip taking lmgr locks when the
 * index is local to the current backend (ie, either temp or new in the
 * current transaction).  No one else can see it, so there's no reason to
 * take locks.  We still take buffer-level locks, but not lmgr locks.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USELOCKING</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>(!RELATION_IS_LOCAL(rel))</cpp:value></cpp:define>


<comment type="block">/*
 *    _hash_getbuf() -- Get a buffer by block number for read or write.
 *
 *        'access' must be HASH_READ, HASH_WRITE, or HASH_NOLOCK.
 *        'flags' is a bitwise OR of the allowed page types.
 *
 *        This must be used only to fetch pages that are expected to be valid
 *        already.  _hash_checkpage() is applied using the given flags.
 *
 *        When this routine returns, the appropriate lock is set on the
 *        requested buffer and its reference count has been incremented
 *        (ie, the buffer is "locked and pinned").
 *
 *        P_NEW is disallowed because this routine can only be used
 *        to access pages that are known to be before the filesystem EOF.
 *        Extending the index should be done with _hash_getnewbuf.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_hash_getbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash AM does not use P_NEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>access</name> <operator>!=</operator> <name>HASH_NOLOCK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* ref count and lock type are correct */</comment>

    <expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_getbuf_with_condlock_cleanup() -- Try to get a buffer for cleanup.
 *
 *        We read the page and try to acquire a cleanup lock.  If we get it,
 *        we return the buffer; otherwise, we return InvalidBuffer.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_hash_getbuf_with_condlock_cleanup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash AM does not use P_NEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBufferForCleanup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>InvalidBuffer</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ref count and lock type are correct */</comment>

    <expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_getinitbuf() -- Get and initialize a buffer by block number.
 *
 *        This must be used only to fetch pages that are known to be before
 *        the index's filesystem EOF, but are to be filled from scratch.
 *        _hash_pageinit() is applied automatically.  Otherwise it has
 *        effects similar to _hash_getbuf() with access = HASH_WRITE.
 *
 *        When this routine returns, a write lock is set on the
 *        requested buffer and its reference count has been incremented
 *        (ie, the buffer is "locked and pinned").
 *
 *        P_NEW is disallowed because this routine can only be used
 *        to access pages that are known to be before the filesystem EOF.
 *        Extending the index should be done with _hash_getnewbuf.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_hash_getinitbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash AM does not use P_NEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_ZERO_AND_LOCK</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ref count and lock type are correct */</comment>

    <comment type="block">/* initialize the page */</comment>
    <expr_stmt><expr><call><name>_hash_pageinit</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_initbuf() -- Get and initialize a buffer by bucket number.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_initbuf</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>max_bucket</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>num_bucket</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flag</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>initpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>pageopaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialize the page */</comment>
    <if_stmt><if>if <condition>(<expr><name>initpage</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_hash_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set hasho_prevblkno with current hashm_maxbucket. This value will be
     * used to validate cached HashMetaPageData. See
     * _hash_getbucketbuf_from_hashkey().
     */</comment>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name>max_bucket</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>=</operator> <name>num_bucket</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_page_id</name></name> <operator>=</operator> <name>HASHO_PAGE_ID</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_getnewbuf() -- Get a new page at the end of the index.
 *
 *        This has the same API as _hash_getinitbuf, except that we are adding
 *        a page to the index, and hence expect the page to be past the
 *        logical EOF.  (However, we have to support the case where it isn't,
 *        since a prior try might have crashed after extending the filesystem
 *        EOF but before updating the metapage to reflect the added page.)
 *
 *        It is caller's responsibility to ensure that only one process can
 *        extend the index at a time.  In practice, this function is called
 *        only while holding write lock on the metapage, because adding a page
 *        is always associated with an update of metapage data.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_hash_getnewbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>RelationGetNumberOfBlocksInFork</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash AM does not use P_NEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name>nblocks</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"access to noncontiguous page in hash index \"%s\""</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* smgr insists we use P_NEW to extend the relation */</comment>
    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>nblocks</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected hash relation size: %u, should be %u"</literal></expr></argument>,
                 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>HASH_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_ZERO_AND_LOCK</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* ref count and lock type are correct */</comment>

    <comment type="block">/* initialize the page */</comment>
    <expr_stmt><expr><call><name>_hash_pageinit</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_getbuf_with_strategy() -- Get a buffer with nondefault strategy.
 *
 *        This is identical to _hash_getbuf() but also allows a buffer access
 *        strategy to be specified.  We use this for VACUUM operations.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_hash_getbuf_with_strategy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                           <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>P_NEW</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash AM does not use P_NEW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>bstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>access</name> <operator>!=</operator> <name>HASH_NOLOCK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* ref count and lock type are correct */</comment>

    <expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_relbuf() -- release a locked buffer.
 *
 * Lock and pin (refcount) are both dropped.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_relbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_dropbuf() -- release an unlocked buffer.
 *
 * This is used to unpin a buffer on which we hold no lock.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_dropbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_dropscanbuf() -- release buffers used in scan.
 *
 * This routine unpins the buffers used during scan on which we
 * hold no lock.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_dropscanbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HashScanOpaque</name></type> <name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* release pin we hold on primary bucket page */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>!=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/* release pin we hold on primary bucket page  of bucket being split */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name> <operator>!=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/* release any pin we still hold */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

    <comment type="block">/* reset split scan */</comment>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *    _hash_init() -- Initialize the metadata page of a hash index,
 *                the initial buckets, and the initial bitmap page.
 *
 * The initial number of buckets is dependent on num_tuples, an estimate
 * of the number of tuples to be loaded into the index initially.  The
 * chosen number of buckets is returned.
 *
 * We are fairly cavalier about locking here, since we know that no one else
 * could be accessing this index.  In particular the rule about not holding
 * multiple buffer locks is ignored.
 */</comment>
<function><type><name>uint32</name></type>
<name>_hash_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>num_tuples</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>metabuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>bitmapbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegProcedure</name></type> <name>procid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>data_width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>item_width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>ffactor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>num_buckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>use_wal</name></decl>;</decl_stmt>

    <comment type="block">/* safety check */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocksInFork</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot initialize non-empty hash index \"%s\""</literal></expr></argument>,
             <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * WAL log creation of pages if the relation is persistent, or this is the
     * init fork.  Init forks for unlogged relations always need to be WAL
     * logged.
     */</comment>
    <expr_stmt><expr><name>use_wal</name> <operator>=</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine the target fill factor (in tuples per bucket) for this index.
     * The idea is to make the fill factor correspond to pages about as full
     * as the user-settable fillfactor parameter says.  We can compute it
     * exactly since the index datatype (i.e. uint32 hash key) is fixed-width.
     */</comment>
    <expr_stmt><expr><name>data_width</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>data_width</name></expr></argument>)</argument_list></call> <operator>+</operator>
        <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>        <comment type="block">/* include the line pointer */</comment>
    <expr_stmt><expr><name>ffactor</name> <operator>=</operator> <call><name>RelationGetTargetPageUsage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HASH_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>item_width</name></expr>;</expr_stmt>
    <comment type="block">/* keep to a sane range */</comment>
    <if_stmt><if>if <condition>(<expr><name>ffactor</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ffactor</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procid</name> <operator>=</operator> <call><name>index_getprocid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We initialize the metapage, the first N bucket pages, and the first
     * bitmap page in sequence, using _hash_getnewbuf to cause smgrextend()
     * calls to occur.  This ensures that the smgr level has the right idea of
     * the physical index length.
     *
     * Critical section not required, because on error the creation of the
     * whole relation will be rolled back.
     */</comment>
    <expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_hash_getnewbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HASH_METAPAGE</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_hash_init_metabuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>num_tuples</name></expr></argument>, <argument><expr><name>procid</name></expr></argument>, <argument><expr><name>ffactor</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XLOG stuff */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_hash_init_meta_page</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>num_tuples</name></name> <operator>=</operator> <name>num_tuples</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>procid</name></name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_procid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>ffactor</name></name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_ffactor</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHashInitMetaPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HASH_ID</name></expr></argument>, <argument><expr><name>XLOG_HASH_INIT_META_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Release buffer lock on the metapage while we initialize buckets.
     * Otherwise, we'll be in interrupt holdoff and the CHECK_FOR_INTERRUPTS
     * won't accomplish anything.  It's a bad idea to hold buffer locks for
     * long intervals in any case, since that can block the bgwriter.
     */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize and WAL Log the first N buckets
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

        <comment type="block">/* Allow interrupts, in case N is huge */</comment>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>BUCKET_TO_BLKNO</name><argument_list>(<argument><expr><name>metap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getnewbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_hash_initbuf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>,
                        <argument><expr><name>forkNum</name></expr></argument>,
                        <argument><expr><name>blkno</name></expr></argument>,
                        <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Now reacquire buffer lock on metapage */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize bitmap page
     */</comment>
    <expr_stmt><expr><name>bitmapbuf</name> <operator>=</operator> <call><name>_hash_getnewbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>num_buckets</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_hash_initbitmapbuffer</name><argument_list>(<argument><expr><name>bitmapbuf</name></expr></argument>, <argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_bmsize</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>bitmapbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add the new bitmap page to the metapage's list of bitmaps */</comment>
    <comment type="block">/* metapage already has a write lock */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name> <operator>&gt;=</operator> <name>HASH_MAX_BITMAPS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of overflow pages in hash index \"%s\""</literal></expr></argument>,
                        <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_mapp</name><index>[<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name></expr>]</index></name> <operator>=</operator> <name>num_buckets</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XLOG stuff */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_hash_init_bitmap_page</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>bmsize</name></name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_bmsize</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHashInitBitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bitmapbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * This is safe only because nobody else can be modifying the index at
         * this stage; it's only visible to the transaction that is creating
         * it.
         */</comment>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HASH_ID</name></expr></argument>, <argument><expr><name>XLOG_HASH_INIT_BITMAP_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* all done */</comment>
    <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bitmapbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>num_buckets</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_init_metabuffer() -- Initialize the metadata page of a hash index.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_init_metabuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>num_tuples</name></decl></parameter>, <parameter><decl><type><name>RegProcedure</name></type> <name>procid</name></decl></parameter>,
                      <parameter><decl><type><name>uint16</name></type> <name>ffactor</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>pageopaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>dnumbuckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>num_buckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>spare_index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Choose the number of initial bucket pages to match the fill factor
     * given the estimated number of tuples.  We round up the result to the
     * total number of buckets which has to be allocated before using its
     * _hashm_spare element. However always force at least 2 bucket pages. The
     * upper limit is determined by considerations explained in
     * _hash_expandtable().
     */</comment>
    <expr_stmt><expr><name>dnumbuckets</name> <operator>=</operator> <name>num_tuples</name> <operator>/</operator> <name>ffactor</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dnumbuckets</name> <operator>&lt;=</operator> <literal type="number">2.0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>dnumbuckets</name> <operator>&gt;=</operator> <operator>(</operator><name>double</name><operator>)</operator> <literal type="number">0x40000000</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <literal type="number">0x40000000</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <call><name>_hash_get_totalbuckets</name><argument_list>(<argument><expr><call><name>_hash_spareindex</name><argument_list>(<argument><expr><name>dnumbuckets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>spare_index</name> <operator>=</operator> <call><name>_hash_spareindex</name><argument_list>(<argument><expr><name>num_buckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spare_index</name> <operator>&lt;</operator> <name>HASH_MAX_SPLITPOINTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>initpage</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_hash_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name>LH_META_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_page_id</name></name> <operator>=</operator> <name>HASHO_PAGE_ID</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_magic</name></name> <operator>=</operator> <name>HASH_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_version</name></name> <operator>=</operator> <name>HASH_VERSION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ffactor</name></name> <operator>=</operator> <name>ffactor</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_bsize</name></name> <operator>=</operator> <call><name>HashGetMaxBitmapSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* find largest bitmap array size that will fit in page size */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>_hash_log2</name><argument_list>(<argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_bsize</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator> <operator>&lt;=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_bsize</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_bmsize</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_bmshift</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>BYTE_TO_BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>BMPG_SHIFT</name><argument_list>(<argument><expr><name>metap</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>(</operator><call><name>BMPG_MASK</name><argument_list>(<argument><expr><name>metap</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Label the index with its primary hash support function's OID.  This is
     * pretty useless for normal operation (in fact, hashm_procid is not used
     * anywhere), but it might be handy for forensic purposes so we keep it.
     */</comment>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_procid</name></name> <operator>=</operator> <name>procid</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We initialize the index with N buckets, 0 .. N-1, occupying physical
     * blocks 1 to N.  The first freespace bitmap page is in block N+1.
     */</comment>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>=</operator> <name>num_buckets</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Set highmask as next immediate ((2 ^ x) - 1), which should be
     * sufficient to cover num_buckets.
     */</comment>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><call><name>_hash_log2</name><argument_list>(<argument><expr><name>num_buckets</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name> <operator>=</operator> <operator>(</operator><name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_mapp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_mapp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up mapping for one spare page after the initial splitpoints */</comment>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name><index>[<expr><name>spare_index</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name> <operator>=</operator> <name>spare_index</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_firstfree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Set pd_lower just past the end of the metadata.  This is to log full
     * page image of metapage in xloginsert.c.
     */</comment>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
        <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metap</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_pageinit() -- Initialize a new hash index page.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_pageinit</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to expand the hash table by creating one new bucket.
 *
 * This will silently do nothing if we don't get cleanup lock on old or
 * new bucket.
 *
 * Complete the pending splits and remove the tuples from old bucket,
 * if there are any left over from the previous split.
 *
 * The caller must hold a pin, but no lock, on the metapage buffer.
 * The buffer is returned in the same state.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_expandtable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bucket</name></type>        <name>old_bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bucket</name></type>        <name>new_bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>spare_ndx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>start_oblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>start_nblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf_nblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf_oblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>opage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>npage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>oopaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>nopaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>maxbucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>highmask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>lowmask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>metap_update_masks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>metap_update_splitpoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>restart_expand</name>:</label>

    <comment type="block">/*
     * Write-lock the meta page.  It used to be necessary to acquire a
     * heavyweight lock to begin a split, but that is no longer required.
     */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>LH_META_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check to see if split is still needed; someone else might have already
     * done one while we waited for the lock.
     *
     * Make sure this stays in sync with _hash_doinsert()
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>&lt;=</operator>
        <operator>(</operator><name>double</name><operator>)</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_ffactor</name></name> <operator>*</operator> <operator>(</operator><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Can't split anymore if maxbucket has reached its maximum possible
     * value.
     *
     * Ideally we'd allow bucket numbers up to UINT_MAX-1 (no higher because
     * the calculation maxbucket+1 mustn't overflow).  Currently we restrict
     * to half that because of overflow looping in _hash_log2() and
     * insufficient space in hashm_spares[].  It's moot anyway because an
     * index with 2^32 buckets would certainly overflow BlockNumber and hence
     * _hash_alloc_buckets() would fail, but if we supported buckets smaller
     * than a disk block then this would be an independent constraint.
     *
     * If you change this, see also the maximum initial number of buckets in
     * _hash_init().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>&gt;=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <literal type="number">0x7FFFFFFE</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Determine which bucket is to be split, and attempt to take cleanup lock
     * on the old bucket.  If we can't get the lock, give up.
     *
     * The cleanup lock protects us not only against other backends, but
     * against our own backend as well.
     *
     * The cleanup lock is mainly to protect the split from concurrent
     * inserts. See src/backend/access/hash/README, Lock Definitions for
     * further details.  Due to this locking restriction, if there is any
     * pending scan, the split will give up which is not good, but harmless.
     */</comment>
    <expr_stmt><expr><name>new_bucket</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>old_bucket</name> <operator>=</operator> <operator>(</operator><name>new_bucket</name> <operator>&amp;</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>start_oblkno</name> <operator>=</operator> <call><name>BUCKET_TO_BLKNO</name><argument_list>(<argument><expr><name>metap</name></expr></argument>, <argument><expr><name>old_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf_oblkno</name> <operator>=</operator> <call><name>_hash_getbuf_with_condlock_cleanup</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>start_oblkno</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf_oblkno</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>opage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We want to finish the split from a bucket as there is no apparent
     * benefit by not doing so and it will make the code complicated to finish
     * the split that involves multiple buckets considering the case where new
     * split also fails.  We don't need to consider the new bucket for
     * completing the split here as it is not possible that a re-split of new
     * bucket starts when there is still a pending split from old bucket.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>H_BUCKET_BEING_SPLIT</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Copy bucket mapping info now; refer the comment in code below where
         * we copy this information before calling _hash_splitbucket to see
         * why this is okay.
         */</comment>
        <expr_stmt><expr><name>maxbucket</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>highmask</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lowmask</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Release the lock on metapage and old_bucket, before completing the
         * split.
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf_oblkno</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>_hash_finish_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>, <argument><expr><name>old_bucket</name></expr></argument>, <argument><expr><name>maxbucket</name></expr></argument>,
                           <argument><expr><name>highmask</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* release the pin on old buffer and retry for expand. */</comment>
        <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <goto>goto <name>restart_expand</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Clean the tuples remained from the previous split.  This operation
     * requires cleanup lock and we already have one on the old bucket, so
     * let's do it. We also don't want to allow further splits from the bucket
     * till the garbage of previous split is cleaned.  This has two
     * advantages; first, it helps in avoiding the bloat due to garbage and
     * second is, during cleanup of bucket, we are always sure that the
     * garbage tuples belong to most recently split bucket.  On the contrary,
     * if we allow cleanup of bucket after meta page is updated to indicate
     * the new split and before the actual split, the cleanup operation won't
     * be able to decide whether the tuple has been moved to the newly created
     * bucket and ended up deleting such tuples.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>H_NEEDS_SPLIT_CLEANUP</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Copy bucket mapping info now; refer to the comment in code below
         * where we copy this information before calling _hash_splitbucket to
         * see why this is okay.
         */</comment>
        <expr_stmt><expr><name>maxbucket</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>highmask</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lowmask</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr>;</expr_stmt>

        <comment type="block">/* Release the metapage lock. */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>hashbucketcleanup</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>old_bucket</name></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>, <argument><expr><name>start_oblkno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>maxbucket</name></expr></argument>, <argument><expr><name>highmask</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <goto>goto <name>restart_expand</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * There shouldn't be any active scan on new bucket.
     *
     * Note: it is safe to compute the new bucket's blkno here, even though we
     * may still need to update the BUCKET_TO_BLKNO mapping.  This is because
     * the current value of hashm_spares[hashm_ovflpoint] correctly shows
     * where we are going to put a new splitpoint's worth of buckets.
     */</comment>
    <expr_stmt><expr><name>start_nblkno</name> <operator>=</operator> <call><name>BUCKET_TO_BLKNO</name><argument_list>(<argument><expr><name>metap</name></expr></argument>, <argument><expr><name>new_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the split point is increasing we need to allocate a new batch of
     * bucket pages.
     */</comment>
    <expr_stmt><expr><name>spare_ndx</name> <operator>=</operator> <call><name>_hash_spareindex</name><argument_list>(<argument><expr><name>new_bucket</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>spare_ndx</name> <operator>&gt;</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type>        <name>buckets_to_add</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spare_ndx</name> <operator>==</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We treat allocation of buckets as a separate WAL-logged action.
         * Even if we fail after this operation, won't leak bucket pages;
         * rather, the next split will consume this space. In any case, even
         * without failure we don't use all the space in one split operation.
         */</comment>
        <expr_stmt><expr><name>buckets_to_add</name> <operator>=</operator> <call><name>_hash_get_totalbuckets</name><argument_list>(<argument><expr><name>spare_ndx</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>new_bucket</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_hash_alloc_buckets</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>start_nblkno</name></expr></argument>, <argument><expr><name>buckets_to_add</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* can't split due to BlockNumber overflow */</comment>
            <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>fail</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Physically allocate the new bucket's primary page.  We want to do this
     * before changing the metapage's mapping info, in case we can't get the
     * disk space.  Ideally, we don't need to check for cleanup lock on new
     * bucket as no other backend could find this bucket unless meta page is
     * updated.  However, it is good to be consistent with old bucket locking.
     */</comment>
    <expr_stmt><expr><name>buf_nblkno</name> <operator>=</operator> <call><name>_hash_getnewbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>start_nblkno</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBufferCleanupOK</name><argument_list>(<argument><expr><name>buf_nblkno</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf_nblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>fail</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Since we are scribbling on the pages in the shared buffers, establish a
     * critical section.  Any failure in this next code leaves us with a big
     * problem: the metapage is effectively corrupt but could get written back
     * to disk.
     */</comment>
    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Okay to proceed with split.  Update the metapage bucket mapping info.
     */</comment>
    <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>=</operator> <name>new_bucket</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>new_bucket</name> <operator>&gt;</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Starting a new doubling */</comment>
        <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name> <operator>=</operator> <name>new_bucket</name> <operator>|</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>metap_update_masks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the split point is increasing we need to adjust the hashm_spares[]
     * array and hashm_ovflpoint so that future overflow pages will be created
     * beyond this new batch of bucket pages.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>spare_ndx</name> <operator>&gt;</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name><index>[<expr><name>spare_ndx</name></expr>]</index></name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name><index>[<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name> <operator>=</operator> <name>spare_ndx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>metap_update_splitpoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Copy bucket mapping info now; this saves re-accessing the meta page
     * inside _hash_splitbucket's inner loop.  Note that once we drop the
     * split lock, other splits could begin, so these values might be out of
     * date before _hash_splitbucket finishes.  That's okay, since all it
     * needs is to tell which of these two buckets to map hashkeys into.
     */</comment>
    <expr_stmt><expr><name>maxbucket</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>highmask</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lowmask</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>opage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark the old bucket to indicate that split is in progress.  (At
     * operation end, we will clear the split-in-progress flag.)  Also, for a
     * primary bucket page, hasho_prevblkno stores the number of buckets that
     * existed as of the last split, so we must update that value here.
     */</comment>
    <expr_stmt><expr><name><name>oopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>|=</operator> <name>LH_BUCKET_BEING_SPLIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name>maxbucket</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf_nblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize the new bucket's primary page and mark it to indicate that
     * split is in progress.
     */</comment>
    <expr_stmt><expr><name>nopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name>maxbucket</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>=</operator> <name>new_bucket</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_BUCKET_BEING_POPULATED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>hasho_page_id</name></name> <operator>=</operator> <name>HASHO_PAGE_ID</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf_nblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XLOG stuff */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_hash_split_allocate_page</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>new_bucket</name></name> <operator>=</operator> <name>maxbucket</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>old_bucket_flag</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>new_bucket_flag</name></name> <operator>=</operator> <name><name>nopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buf_nblkno</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>metap_update_masks</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_SPLIT_META_UPDATE_MASKS</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>metap_update_splitpoint</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_SPLIT_META_UPDATE_SPLITPOINT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name><index>[<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name></expr>]</index></name></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHashSplitAllocPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HASH_ID</name></expr></argument>, <argument><expr><name>XLOG_HASH_SPLIT_ALLOCATE_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf_nblkno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* drop lock, but keep pin */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Relocate records to the new bucket */</comment>
    <expr_stmt><expr><call><name>_hash_splitbucket</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>,
                      <argument><expr><name>old_bucket</name></expr></argument>, <argument><expr><name>new_bucket</name></expr></argument>,
                      <argument><expr><name>buf_oblkno</name></expr></argument>, <argument><expr><name>buf_nblkno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                      <argument><expr><name>maxbucket</name></expr></argument>, <argument><expr><name>highmask</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* all done, now release the pins on primary buckets. */</comment>
    <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf_oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf_nblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>

    <comment type="block">/* Here if decide not to split or fail to acquire old bucket lock */</comment>
<label><name>fail</name>:</label>

    <comment type="block">/* We didn't write the metapage, so just drop lock */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * _hash_alloc_buckets -- allocate a new splitpoint's worth of bucket pages
 *
 * This does not need to initialize the new bucket pages; we'll do that as
 * each one is used by _hash_expandtable().  But we have to extend the logical
 * EOF to the end of the splitpoint; this keeps smgr's idea of the EOF in
 * sync with ours, so that we don't get complaints from smgr.
 *
 * We do this by writing a page of zeroes at the end of the splitpoint range.
 * We expect that the filesystem will ensure that the intervening pages read
 * as zeroes too.  On many filesystems this "hole" will not be allocated
 * immediately, which means that the index file may end up more fragmented
 * than if we forced it all to be allocated now; but since we don't scan
 * hash indexes sequentially anyway, that probably doesn't matter.
 *
 * XXX It's annoying that this code is executed with the metapage lock held.
 * We need to interlock against _hash_addovflpage() adding a new overflow page
 * concurrently, but it'd likely be better to use LockRelationForExtension
 * for the purpose.  OTOH, adding a splitpoint is a very infrequent operation,
 * so it may not be worth worrying about.
 *
 * Returns TRUE if successful, or FALSE if allocation failed due to
 * BlockNumber overflow.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_hash_alloc_buckets</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>firstblock</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastblock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>zerobuf</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>ovflopaque</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>lastblock</name> <operator>=</operator> <name>firstblock</name> <operator>+</operator> <name>nblocks</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for overflow in block number calculation; if so, we cannot extend
     * the index anymore.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>lastblock</name> <operator>&lt;</operator> <name>firstblock</name> <operator>||</operator> <name>lastblock</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <name>zerobuf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the page.  Just zeroing the page won't work; see
     * _hash_freeovflpage for similar usage.  We take care to make the special
     * space valid for the benefit of tools such as pageinspect.
     */</comment>
    <expr_stmt><expr><call><name>_hash_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ovflopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name>LH_UNUSED_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_page_id</name></name> <operator>=</operator> <name>HASHO_PAGE_ID</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>,
                    <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
                    <argument><expr><name>lastblock</name></expr></argument>,
                    <argument><expr><name>zerobuf</name></expr></argument>,
                    <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>lastblock</name></expr></argument>, <argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * _hash_splitbucket -- split 'obucket' into 'obucket' and 'nbucket'
 *
 * This routine is used to partition the tuples between old and new bucket and
 * is used to finish the incomplete split operations.  To finish the previously
 * interrupted split operation, the caller needs to fill htab.  If htab is set,
 * then we skip the movement of tuples that exists in htab, otherwise NULL
 * value of htab indicates movement of all the tuples that belong to the new
 * bucket.
 *
 * We are splitting a bucket that consists of a base bucket page and zero
 * or more overflow (bucket chain) pages.  We must relocate tuples that
 * belong in the new bucket.
 *
 * The caller must hold cleanup locks on both buckets to ensure that
 * no one else is trying to access them (see README).
 *
 * The caller must hold a pin, but no lock, on the metapage buffer.
 * The buffer is returned in the same state.  (The metapage is only
 * touched if it becomes necessary to add or remove overflow pages.)
 *
 * Split needs to retain pin on primary bucket pages of both old and new
 * buckets till end of operation.  This is to prevent vacuum from starting
 * while a split is in progress.
 *
 * In addition, the caller must have created the new bucket's base page,
 * which is passed in buffer nbuf, pinned and write-locked.  The lock will be
 * released here and pin must be released by the caller.  (The API is set up
 * this way because we must do _hash_getnewbuf() before releasing the metapage
 * write lock.  So instead of passing the new bucket's start block number, we
 * pass an actual buffer.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_hash_splitbucket</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                  <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>,
                  <parameter><decl><type><name>Bucket</name></type> <name>obucket</name></decl></parameter>,
                  <parameter><decl><type><name>Bucket</name></type> <name>nbucket</name></decl></parameter>,
                  <parameter><decl><type><name>Buffer</name></type> <name>obuf</name></decl></parameter>,
                  <parameter><decl><type><name>Buffer</name></type> <name>nbuf</name></decl></parameter>,
                  <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>htab</name></decl></parameter>,
                  <parameter><decl><type><name>uint32</name></type> <name>maxbucket</name></decl></parameter>,
                  <parameter><decl><type><name>uint32</name></type> <name>highmask</name></decl></parameter>,
                  <parameter><decl><type><name>uint32</name></type> <name>lowmask</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>bucket_obuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>bucket_nbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>opage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>npage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>oopaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>nopaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>itup_offsets</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name><name>itups</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>all_tups_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>nitups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>bucket_obuf</name> <operator>=</operator> <name>obuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>opage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bucket_nbuf</name> <operator>=</operator> <name>nbuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Partition the tuples in the old bucket between the old bucket and the
     * new bucket, advancing along the old bucket's overflow bucket chain and
     * adding overflow pages to the new bucket as needed.  Outer loop iterates
     * once per page in old bucket.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>oblkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>ooffnum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>omaxoffnum</name></decl>;</decl_stmt>

        <comment type="block">/* Scan each tuple in old page */</comment>
        <expr_stmt><expr><name>omaxoffnum</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>ooffnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
             <condition><expr><name>ooffnum</name> <operator>&lt;=</operator> <name>omaxoffnum</name></expr>;</condition>
             <incr><expr><name>ooffnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>ooffnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Size</name></type>        <name>itemsz</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bucket</name></type>        <name>bucket</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* skip dead tuples */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>ooffnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Before inserting a tuple, probe the hash table containing TIDs
             * of tuples belonging to new bucket, if we find a match, then
             * skip that tuple, else fetch the item's hash key (conveniently
             * stored in the item) and determine which bucket it now belongs
             * in.
             */</comment>
            <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>opage</name></expr></argument>,
                                            <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>ooffnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>htab</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>bucket</name> <operator>=</operator> <call><name>_hash_hashkey2bucket</name><argument_list>(<argument><expr><call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>maxbucket</name></expr></argument>, <argument><expr><name>highmask</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>bucket</name> <operator>==</operator> <name>nbucket</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>new_itup</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * make a copy of index tuple as we have to scribble on it.
                 */</comment>
                <expr_stmt><expr><name>new_itup</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * mark the index tuple as moved by split, such tuples are
                 * skipped by scan if there is split in progress for a bucket.
                 */</comment>
                <expr_stmt><expr><name><name>new_itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>|=</operator> <name>INDEX_MOVED_BY_SPLIT_MASK</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * insert the tuple into the new bucket.  if it doesn't fit on
                 * the current page in the new bucket, we must allocate a new
                 * overflow page and place the tuple on that page instead.
                 */</comment>
                <expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleDSize</name><argument_list>(<argument><expr><operator>*</operator><name>new_itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpaceForMultipleTuples</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><name>nitups</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>all_tups_size</name> <operator>+</operator> <name>itemsz</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Change the shared buffer state in critical section,
                     * otherwise any error could make it unrecoverable.
                     */</comment>
                    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>_hash_pgaddmultitup</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>itups</name></expr></argument>, <argument><expr><name>itup_offsets</name></expr></argument>, <argument><expr><name>nitups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* log the split operation before releasing the lock */</comment>
                    <expr_stmt><expr><call><name>log_split_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* drop lock, but keep pin */</comment>
                    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* be tidy */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>itups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                    <expr_stmt><expr><name>nitups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>all_tups_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                    <comment type="block">/* chain to a new overflow page */</comment>
                    <expr_stmt><expr><name>nbuf</name> <operator>=</operator> <call><name>_hash_addovflpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>nbuf</name> <operator>==</operator> <name>bucket_nbuf</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>itups</name><index>[<expr><name>nitups</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>new_itup</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>all_tups_size</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * the tuple stays on this page, so nothing to do.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bucket</name> <operator>==</operator> <name>obucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>oblkno</name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt>

        <comment type="block">/* retain the pin on the old primary bucket */</comment>
        <if_stmt><if>if <condition>(<expr><name>obuf</name> <operator>==</operator> <name>bucket_obuf</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>obuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Exit loop if no more overflow pages in old bucket */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>oblkno</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Change the shared buffer state in critical section, otherwise
             * any error could make it unrecoverable.
             */</comment>
            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>_hash_pgaddmultitup</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>itups</name></expr></argument>, <argument><expr><name>itup_offsets</name></expr></argument>, <argument><expr><name>nitups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* log the split operation before releasing the lock */</comment>
            <expr_stmt><expr><call><name>log_split_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>==</operator> <name>bucket_nbuf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* be tidy */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>itups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Else, advance to next old page */</comment>
        <expr_stmt><expr><name>obuf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oblkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * We're at the end of the old bucket chain, so we're done partitioning
     * the tuples.  Mark the old and new buckets to indicate split is
     * finished.
     *
     * To avoid deadlocks due to locking order of buckets, first lock the old
     * bucket and then the new bucket.
     */</comment>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>bucket_obuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bucket_obuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>oopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LH_BUCKET_BEING_SPLIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LH_BUCKET_BEING_POPULATED</name></expr>;</expr_stmt>

    <comment type="block">/*
     * After the split is finished, mark the old bucket to indicate that it
     * contains deletable tuples.  We will clear split-cleanup flag after
     * deleting such tuples either at the end of split or at the next split
     * from old bucket or at the time of vacuum.
     */</comment>
    <expr_stmt><expr><name><name>oopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>|=</operator> <name>LH_BUCKET_NEEDS_SPLIT_CLEANUP</name></expr>;</expr_stmt>

    <comment type="block">/*
     * now write the buffers, here we don't release the locks as caller is
     * responsible to release locks.
     */</comment>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>bucket_obuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_hash_split_complete</name></type> <name>xlrec</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>old_bucket_flag</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>new_bucket_flag</name></name> <operator>=</operator> <name><name>nopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHashSplitComplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bucket_obuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bucket_nbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HASH_ID</name></expr></argument>, <argument><expr><name>XLOG_HASH_SPLIT_COMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bucket_obuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If possible, clean up the old bucket.  We might not be able to do this
     * if someone else has a pin on it, but if not then we can go ahead.  This
     * isn't absolutely necessary, but it reduces bloat; if we don't do it
     * now, VACUUM will do it eventually, but maybe not until new overflow
     * pages have been allocated.  Note that there's no need to clean up the
     * new bucket.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsBufferCleanupOK</name><argument_list>(<argument><expr><name>bucket_obuf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hashbucketcleanup</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>obucket</name></expr></argument>, <argument><expr><name>bucket_obuf</name></expr></argument>,
                          <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bucket_obuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><name>maxbucket</name></expr></argument>, <argument><expr><name>highmask</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>bucket_obuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_finish_split() -- Finish the previously interrupted split operation
 *
 * To complete the split operation, we form the hash table of TIDs in new
 * bucket which is then used by split operation to skip tuples that are
 * already moved before the split operation was previously interrupted.
 *
 * The caller must hold a pin, but no lock, on the metapage and old bucket's
 * primary page buffer.  The buffers are returned in the same state.  (The
 * metapage is only touched if it becomes necessary to add or remove overflow
 * pages.)
 */</comment>
<function><type><name>void</name></type>
<name>_hash_finish_split</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>obuf</name></decl></parameter>, <parameter><decl><type><name>Bucket</name></type> <name>obucket</name></decl></parameter>,
                   <parameter><decl><type><name>uint32</name></type> <name>maxbucket</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>highmask</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>lowmask</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>hash_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTAB</name>       <modifier>*</modifier></type><name>tidhtab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>bucket_nbuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>nbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>npage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>bucket_nblkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>npageopaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bucket</name></type>        <name>nbucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <comment type="block">/* Initialize hash tables used to track TIDs */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>tidhtab</name> <operator>=</operator>
        <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"bucket ctids"</literal></expr></argument>,
                    <argument><expr><literal type="number">256</literal></expr></argument>,        <comment type="block">/* arbitrary initial size */</comment>
                    <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
                    <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bucket_nblkno</name> <operator>=</operator> <name>nblkno</name> <operator>=</operator> <call><name>_hash_get_newblock_from_oldbucket</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>obucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan the new bucket and build hash table of TIDs
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>noffnum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nmaxoffnum</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>nbuf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nblkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>,
                            <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remember the primary bucket buffer to acquire cleanup lock on it. */</comment>
        <if_stmt><if>if <condition>(<expr><name>nblkno</name> <operator>==</operator> <name>bucket_nblkno</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>bucket_nbuf</name> <operator>=</operator> <name>nbuf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>npageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Scan each tuple in new page */</comment>
        <expr_stmt><expr><name>nmaxoffnum</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>noffnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
             <condition><expr><name>noffnum</name> <operator>&lt;=</operator> <name>nmaxoffnum</name></expr>;</condition>
             <incr><expr><name>noffnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>noffnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>

            <comment type="block">/* Fetch the item's TID and insert it in hash table. */</comment>
            <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>npage</name></expr></argument>,
                                            <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><name>noffnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>tidhtab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>nblkno</name> <operator>=</operator> <name><name>npageopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * release our write lock without modifying buffer and ensure to
         * retain the pin on primary bucket.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>==</operator> <name>bucket_nbuf</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Exit loop if no more overflow pages in new bucket */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>nblkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Conditionally get the cleanup lock on old and new buckets to perform
     * the split operation.  If we don't get the cleanup locks, silently give
     * up and next insertion on old bucket will try again to complete the
     * split.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBufferForCleanup</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>tidhtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBufferForCleanup</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>tidhtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bucket_nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>npageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbucket</name> <operator>=</operator> <name><name>npageopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_hash_splitbucket</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>obucket</name></expr></argument>,
                      <argument><expr><name>nbucket</name></expr></argument>, <argument><expr><name>obuf</name></expr></argument>, <argument><expr><name>bucket_nbuf</name></expr></argument>, <argument><expr><name>tidhtab</name></expr></argument>,
                      <argument><expr><name>maxbucket</name></expr></argument>, <argument><expr><name>highmask</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bucket_nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>tidhtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    log_split_page() -- Log the split operation
 *
 *    We log the split operation when the new page in new bucket gets full,
 *    so we log the entire page.
 *
 *    'buf' must be locked by the caller which is also responsible for unlocking
 *    it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_split_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_FORCE_IMAGE</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HASH_ID</name></expr></argument>, <argument><expr><name>XLOG_HASH_SPLIT_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_getcachedmetap() -- Returns cached metapage data.
 *
 *    If metabuf is not InvalidBuffer, caller must hold a pin, but no lock, on
 *    the metapage.  If not set, we'll set it before returning if we have to
 *    refresh the cache, and return with a pin but no lock on it; caller is
 *    responsible for releasing the pin.
 *
 *    We refresh the cache if it's not initialized yet or force_refresh is true.
 */</comment>
<function><type><name>HashMetaPage</name></type>
<name>_hash_getcachedmetap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>metabuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_refresh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>force_refresh</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * It's important that we don't set rd_amcache to an invalid value.
         * Either MemoryContextAlloc or _hash_getbuf could fail, so don't
         * install a pointer to the newly-allocated storage in the actual
         * relcache entry until both have succeeeded.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>,
                                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Read the metapage. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>metabuf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HASH_METAPAGE</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>,
                                    <argument><expr><name>LH_META_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Populate the cache. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>cache</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>, <argument><expr><call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Release metapage lock, but keep the pin. */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><operator>(</operator><name>HashMetaPage</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_getbucketbuf_from_hashkey() -- Get the bucket's buffer for the given
 *                                         hashkey.
 *
 *    Bucket pages do not move or get removed once they are allocated. This give
 *    us an opportunity to use the previously saved metapage contents to reach
 *    the target bucket buffer, instead of reading from the metapage every time.
 *    This saves one buffer access every time we want to reach the target bucket
 *    buffer, which is very helpful savings in bufmgr traffic and contention.
 *
 *    The access type parameter (HASH_READ or HASH_WRITE) indicates whether the
 *    bucket buffer has to be locked for reading or writing.
 *
 *    The out parameter cachedmetap is set with metapage contents used for
 *    hashkey to bucket buffer mapping. Some callers need this info to reach the
 *    old bucket in case of bucket split, see _hash_doinsert().
 */</comment>
<function><type><name>Buffer</name></type>
<name>_hash_getbucketbuf_from_hashkey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>,
                                <parameter><decl><type><name>HashMetaPage</name> <modifier>*</modifier></type><name>cachedmetap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>metabuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bucket</name></type>        <name>bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

    <comment type="block">/* We read from target bucket buffer, hence locking is must. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>access</name> <operator>==</operator> <name>HASH_READ</name> <operator>||</operator> <name>access</name> <operator>==</operator> <name>HASH_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>_hash_getcachedmetap</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>metabuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>metap</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop until we get a lock on the correct target bucket.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Compute the target bucket number, and convert to block number.
         */</comment>
        <expr_stmt><expr><name>bucket</name> <operator>=</operator> <call><name>_hash_hashkey2bucket</name><argument_list>(<argument><expr><name>hashkey</name></expr></argument>,
                                      <argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr></argument>,
                                      <argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr></argument>,
                                      <argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>BUCKET_TO_BLKNO</name><argument_list>(<argument><expr><name>metap</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Fetch the primary bucket page for the bucket */</comment>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>access</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>==</operator> <name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If this bucket hasn't been split, we're done.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>&lt;=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Drop lock on this buffer, update cached metapage, and retry. */</comment>
        <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>_hash_getcachedmetap</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>metabuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>metap</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>cachedmetap</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>cachedmetap</name> <operator>=</operator> <name>metap</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>
</unit>
