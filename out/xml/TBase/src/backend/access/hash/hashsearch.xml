<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/access/hash/hashsearch.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hashsearch.c
 *      search code for postgres hash tables
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/access/hash/hashsearch.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/*
 *    _hash_next() -- Get the next item in a scan.
 *
 *        On entry, we have a valid hashso_curpos in the scan, and a
 *        pin and read lock on the page that contains that item.
 *        We find the next item in the scan, if any.
 *        On success exit, we have the page containing the next item
 *        pinned and locked.
 */</comment>
<function><type><name>bool</name></type>
<name>_hash_next</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointer</name></type> <name>current</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>

    <comment type="block">/* we still have the buffer pinned and read-locked */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * step to next valid tuple.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_hash_step</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* if we're here, _hash_step found a valid tuple */</comment>
    <expr_stmt><expr><name>current</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_curpos</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_heappos</name></name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance to next page in a bucket, if any.  If we are scanning the bucket
 * being populated during split operation then this function advances to the
 * bucket being split after the last bucket page of bucket being populated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_hash_readnext</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
               <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufp</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pagep</name></decl></parameter>, <parameter><decl><type><name>HashPageOpaque</name> <modifier>*</modifier></type><name>opaquep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>block_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>opaquep</name><operator>)</operator><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Retain the pin on primary bucket page till the end of scan.  Refer the
     * comments in _hash_first to know the reason of retaining pin.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator> <operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    <comment type="block">/* check for interrupts while we're not holding any buffer lock */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>block_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * end of bucket, scan bucket being split if there was a split in
         * progress at the start of scan.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * buffer for bucket being split must be valid as we acquire the pin
         * on it before the start of scan and retain it till end of scan.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * setting hashso_buc_split to true indicates that we are scanning
         * bucket being split.
         */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>block_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>block_found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pagep</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>opaquep</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance to previous page in a bucket, if any.  If the current scan has
 * started during split operation then this function advances to bucket
 * being populated after the first bucket page of bucket being split.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_hash_readprev</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
               <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufp</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pagep</name></decl></parameter>, <parameter><decl><type><name>HashPageOpaque</name> <modifier>*</modifier></type><name>opaquep</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>haveprevblk</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>opaquep</name><operator>)</operator><operator>-&gt;</operator><name>hasho_prevblkno</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Retain the pin on primary bucket page till the end of scan.  Refer the
     * comments in _hash_first to know the reason of retaining pin.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator> <operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>haveprevblk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>haveprevblk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
    <comment type="block">/* check for interrupts while we're not holding any buffer lock */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>haveprevblk</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>,
                             <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pagep</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>opaquep</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We always maintain the pin on bucket page for whole scan operation,
         * so releasing the additional pin we have acquired here.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator> <operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * end of bucket, scan bucket being populated if there was a split in
         * progress at the start of scan.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * buffer for bucket being populated must be valid as we acquire the
         * pin on it before the start of scan and retain it till end of scan.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pagep</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>opaquep</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* move to the end of bucket chain */</comment>
        <while>while <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>opaquep</name><operator>)</operator><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_hash_readnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>opaquep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <comment type="block">/*
         * setting hashso_buc_split to false indicates that we are scanning
         * bucket being populated.
         */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_first() -- Find the first item in a scan.
 *
 *        Find the first item in the index that
 *        satisfies the qualification associated with the scan descriptor. On
 *        success, the page containing the current index tuple is read locked
 *        and pinned, and the scan's opaque data entry is updated to
 *        include the buffer.
 */</comment>
<function><type><name>bool</name></type>
<name>_hash_first</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKey</name></type>        <name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>hashkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bucket</name></type>        <name>bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointer</name></type> <name>current</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>current</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_curpos</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We do not support hash scans with no index qualification, because we
     * would have to read the whole index rather than just one bucket. That
     * creates a whole raft of problems, since we haven't got a practical way
     * to lock all the buckets against splits or compactions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash indexes do not support whole-index scans"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* There may be more than one index qual, but we hash only the first */</comment>
    <expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* We support only single-column hash indexes */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* And there's only one operator strategy, too */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the constant in the index qual is NULL, assume it cannot match any
     * items in the index.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Okay to compute the hash key.  We want to do this before acquiring any
     * locks, in case a user-defined hash function happens to be slow.
     *
     * If scankey operator is not a cross-type comparison, we can use the
     * cached hash function; otherwise gotta look it up in the catalogs.
     *
     * We support the convention that sk_subtype == InvalidOid means the
     * opclass input type; this is a hack to simplify life for ScanKeyInit().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
        <name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_datum2hashkey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_datum2hashkey_type</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
                                           <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name> <operator>=</operator> <name>hashkey</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbucketbuf_from_hashkey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bucket</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If a bucket split is in progress, then while scanning the bucket being
     * populated, we need to skip tuples that were copied from bucket being
     * split.  We also need to maintain a pin on the bucket being split to
     * ensure that split-cleanup work done by vacuum doesn't remove tuples
     * from it till this scan is done.  We need to maintain a pin on the
     * bucket being populated to ensure that vacuum doesn't squeeze that
     * bucket till this scan is complete; otherwise, the ordering of tuples
     * can't be maintained during forward and backward scans.  Here, we have
     * to be cautious about locking order: first, acquire the lock on bucket
     * being split; then, release the lock on it but not the pin; then,
     * acquire a lock on bucket being populated and again re-verify whether
     * the bucket split is still in progress.  Acquiring the lock on bucket
     * being split first ensures that the vacuum waits for this scan to
     * finish.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>H_BUCKET_BEING_POPULATED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_blkno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>old_buf</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>old_blkno</name> <operator>=</operator> <call><name>_hash_get_oldblock_from_newbucket</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * release the lock on new bucket and re-acquire it after acquiring
         * the lock on old bucket.
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>old_buf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>old_blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>old_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * remember the split bucket buffer so as to use it later for
         * scanning.
         */</comment>
        <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name> <operator>=</operator> <name>old_buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>old_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>==</operator> <name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>H_BUCKET_BEING_POPULATED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If a backwards scan is requested, move to the end of the chain */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Backward scans that start during split needs to start from end of
         * bucket being split.
         */</comment>
        <while>while <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
               <operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>_hash_readnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now find the first tuple satisfying the qualification */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_hash_step</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* if we're here, _hash_step found a valid tuple */</comment>
    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_heappos</name></name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *    _hash_step() -- step to the next valid item in a scan in the bucket.
 *
 *        If no valid record exists in the requested direction, return
 *        false.  Else, return true and set the hashso_curpos for the
 *        scan to the right thing.
 *
 *        Here we need to ensure that if the scan has started during split, then
 *        skip the tuples that are moved by split while scanning bucket being
 *        populated and then scan the bucket being split to cover all such
 *        tuples.  This is done to ensure that we don't miss tuples in the scans
 *        that are started during split.
 *
 *        'bufP' points to the current buffer, which is pinned and read-locked.
 *        On success exit, we have pin and read-lock on whichever page
 *        contains the right item; on failure, we have released all buffers.
 */</comment>
<function><type><name>bool</name></type>
<name>_hash_step</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufP</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ItemPointer</name></type> <name>current</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexTuple</name></type>    <name>itup</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>current</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_curpos</name></name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>*</operator><name>bufP</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If _hash_step is called from _hash_first, current will not be valid, so
     * we can't dereference it.  However, in that case, we presumably want to
     * start at the beginning/end of the page...
     */</comment>
    <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * 'offnum' now points to the last tuple we examined (if any).
     *
     * continue to step through tuples until: 1) we get to the end of the
     * bucket chain or 2) we find a valid tuple.
     */</comment>
    <do>do
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>dir</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>ForwardScanDirection</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* move forward */</comment>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* new page, locate starting position by binary search */</comment>
                    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_hash_binsearch</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
                <block>{<block_content>
                    <comment type="block">/*
                     * check if we're still in the range of items with the
                     * target hash key
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offnum</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * skip the tuples that are moved by split operation
                         * for the scan that has started when split was in
                         * progress
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>&amp;&amp;</operator>
                            <operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;</operator> <name>INDEX_MOVED_BY_SPLIT_MASK</name><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* move forward */</comment>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name> <operator>==</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* yes, so exit for-loop */</comment>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* Before leaving current page, deal with any killed items */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
                        <expr_stmt><expr><call><name>_hash_kill_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * ran off the end of this page, try the next
                     */</comment>
                    <expr_stmt><expr><call><name>_hash_readnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_hash_binsearch</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>itup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        <break>break;</break>    <comment type="block">/* exit for-loop */</comment>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
                <break>break;</break>

            <case>case <expr><name>BackwardScanDirection</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* move back */</comment>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* new page, locate starting position by binary search */</comment>
                    <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_hash_binsearch_last</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
                <block>{<block_content>
                    <comment type="block">/*
                     * check if we're still in the range of items with the
                     * target hash key
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * skip the tuples that are moved by split operation
                         * for the scan that has started when split was in
                         * progress
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>&amp;&amp;</operator>
                            <operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;</operator> <name>INDEX_MOVED_BY_SPLIT_MASK</name><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* move back */</comment>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name> <operator>==</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* yes, so exit for-loop */</comment>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* Before leaving current page, deal with any killed items */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
                        <expr_stmt><expr><call><name>_hash_kill_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * ran off the end of this page, try the next
                     */</comment>
                    <expr_stmt><expr><call><name>_hash_readprev</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_hash_binsearch_last</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>itup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        <break>break;</break>    <comment type="block">/* exit for-loop */</comment>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
                <break>break;</break>

            <default>default:</default>
                <comment type="block">/* NoMovementScanDirection */</comment>
                <comment type="block">/* this should not be reached */</comment>
                <expr_stmt><expr><name>itup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>itup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We ran off the end of the bucket without finding a match.
             * Release the pin on bucket buffers.  Normally, such pins are
             * released at end of scan, however scrolling cursors can
             * reacquire the bucket lock and pin in the same scan multiple
             * times.
             */</comment>
            <expr_stmt><expr><operator>*</operator><name>bufP</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_hash_dropscanbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* check the tuple quals, loop around if not met */</comment>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>_hash_checkqual</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <comment type="block">/* if we made it to here, we've found a valid tuple */</comment>
    <expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>bufP</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_curbuf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
