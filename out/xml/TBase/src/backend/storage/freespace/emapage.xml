<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/storage/freespace/emapage.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * fsmpage.c
 *      routines to search and manipulate one FSM page.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/storage/freespace/fsmpage.c
 *
 * NOTES:
 *
 *    The public functions in this file form an API that hides the internal
 *    structure of a FSM page. This allows freespace.c to treat each FSM page
 *    as a black box with SlotsPerPage "slots". fsm_set_avail() and
 *    fsm_get_avail() let you get/set the value of a slot, and
 *    fsm_search_avail() lets you search for a slot with value &gt;= X.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/relpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/bitmapset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/extentmapping.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/freespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/extent_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcryptmap.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ExtentAssertEMEIsFree</name><parameter_list>(<parameter><type><name>eme</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ExtentAssert((eme).is_occupied == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ExtentAssertEMEIsOccup</name><parameter_list>(<parameter><type><name>eme</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ExtentAssert((eme).is_occupied == 1)</cpp:value></cpp:define>

<comment type="block">/* common static functions*/</comment>

<comment type="block">/* for EOB bits*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_NEXT_FREE</name><parameter_list>(<parameter><type><name>eob_pg</name></type></parameter>, <parameter><type><name>search_from</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>bms_next_member(&amp;((eob_pg)-&gt;eob_bits), search_from)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_FIRST_FREE</name><parameter_list>(<parameter><type><name>eob_pg</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>EOB_NEXT_FREE(eob_pg, -1)</cpp:value></cpp:define>
    
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_FIRSTFREE_IS_FREE</name><parameter_list>(<parameter><type><name>pg</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>bms_is_member((pg)-&gt;first_empty_extent, &amp;((pg)-&gt;eob_bits))</cpp:value></cpp:define>

<decl_stmt><decl><type><name>bool</name></type>    <name>trace_extent</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* for exent mapping logic*/</comment>
<function_decl><type><specifier>static</specifier> <name>ExtentID</name></type> <name>shard_apply_free_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>     <name>shard_add_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>        <name>shard_append_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_rebuild</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>     <name>shard_append_extent_onlyscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>     <name>shard_add_extent_to_alloclist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_error</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>     <name>shard_remove_extent_from_alloclist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_error</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_lock_shard</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>     <name>shard_remove_extent_from_scanlist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_error</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_lock_shard</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* for system functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>         <name>string_to_reloid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*-----------------------------------------------------------------------------
 *
 *         Fork Manager
 *
 *-----------------------------------------------------------------------------
 */</comment>
<function><type><name>Buffer</name></type>
<name>extent_readbuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>extend</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EmaPageType</name></type> <name>pagetype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>max_eles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>blkno</name> <operator>&lt;</operator> <name>ESAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EOB</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>==</operator> <name>ESAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EOB</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>MAX_EXTENTS</name> <operator>%</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>&lt;</operator> <name>EMAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_ESA</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>ESAS_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>==</operator> <name>EMAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_ESA</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>MAX_EXTENTS</name> <operator>%</operator> <name>ESAS_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>&lt;</operator> <name>EMA_FORK_BLOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EMA</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>==</operator> <name>EMA_FORK_BLOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EMA</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>MAX_EXTENTS</name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if>    
    <else>else <comment type="block">/*(blkno &gt;= EMA_FORK_BLOCKS) */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"blocknumber too larger"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ema page number cannot be greater than %d"</literal></expr></argument>,
                               <argument><expr><name>EMA_FORK_BLOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we haven't cached the size of the FSM yet, check it first.  Also
     * recheck if the requested block seems to be past end, since our cached
     * value might be stale.  (We send smgr inval messages on truncation, but
     * not on extension.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
        <name>blkno</name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>,
                                                         <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle requests beyond EOF */</comment>
    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>extend</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>extent_extend_block</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>InvalidBuffer</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Use ZERO_ON_ERROR mode, and initialize the page if necessary. The FSM
     * information is not accurate anyway, so it's better to clear corrupt
     * pages than error out. Since the FSM changes are not WAL-logged, the
     * so-called torn page problem on crash can lead to pages with corrupt
     * headers, for example.
     */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_ZERO_ON_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageInit_shard</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidShardID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name>pagetype</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>EmaPageType_EOB</name></expr>:</case>
                <expr_stmt><expr><call><name>eob_init_page</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max_eles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EmaPageType_ESA</name></expr>:</case>
                <expr_stmt><expr><call><name>esa_init_page</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max_eles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EmaPageType_EMA</name></expr>:</case>
                <expr_stmt><expr><call><name>ema_init_page</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max_eles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"page type %d is not supported."</literal></expr></argument>, <argument><expr><name>pagetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Buffer</name></type>
<name>extent_readbuffer_for_redo</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>extend</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EmaPageType</name></type> <name>pagetype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>max_eles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


    <if_stmt><if>if<condition>(<expr><name>blkno</name> <operator>&lt;</operator> <name>ESAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EOB</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>==</operator> <name>ESAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>MAX_EXTENTS</name> <operator>%</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EOB</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>&lt;</operator> <name>EMAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>ESAS_PER_PAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_ESA</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>==</operator> <name>EMAPAGE_OFFSET</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>MAX_EXTENTS</name> <operator>%</operator> <name>ESAS_PER_PAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_ESA</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>&lt;</operator> <name>EMA_FORK_BLOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EMA</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>blkno</name> <operator>==</operator> <name>EMA_FORK_BLOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>max_eles</name> <operator>=</operator> <name>MAX_EXTENTS</name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pagetype</name> <operator>=</operator> <name>EmaPageType_EMA</name></expr>;</expr_stmt>
    </block_content>}</block></if>    
    <else>else <comment type="block">/*(blkno &gt;= EMA_FORK_BLOCKS) */</comment>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"blocknumber too larger "</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ema page number cannot be greater than %d"</literal></expr></argument>,
                               <argument><expr><name>EMA_FORK_BLOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><name>smgr</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we haven't cached the size of the FSM yet, check it first.  Also
     * recheck if the requested block seems to be past end, since our cached
     * value might be stale.  (We send smgr inval messages on truncation, but
     * not on extension.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
        <name>blkno</name> <operator>&gt;=</operator> <name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>smgrexists</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle requests beyond EOF */</comment>
    <if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&gt;=</operator> <name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>extend</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>extent_extend_block_for_redo</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>InvalidBuffer</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Use ZERO_ON_ERROR mode, and initialize the page if necessary. The FSM
     * information is not accurate anyway, so it's better to clear corrupt
     * pages than error out. Since the FSM changes are not WAL-logged, the
     * so-called torn page problem on crash can lead to pages with corrupt
     * headers, for example.
     */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_ZERO_ON_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageInit_shard</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidShardID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name>pagetype</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>EmaPageType_EOB</name></expr>:</case>
                <expr_stmt><expr><call><name>eob_init_page</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max_eles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EmaPageType_ESA</name></expr>:</case>
                <expr_stmt><expr><call><name>esa_init_page</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max_eles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>EmaPageType_EMA</name></expr>:</case>
                <expr_stmt><expr><call><name>ema_init_page</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max_eles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"page type %d is not supported."</literal></expr></argument>, <argument><expr><name>pagetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>extent_extend_block</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>ema_nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>ema_nblocks_now</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//PageInit(pg, BLCKSZ, 0);</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*
     * We use the relation extension lock to lock out other backends trying to
     * extend the FSM at the same time. It also locks out extension of the
     * main fork, unnecessarily, but extending the FSM happens seldom enough
     * that it doesn't seem worthwhile to have a separate lock tag type for
     * it.
     *
     * Note that another backend might have extended or created the relation
     * by the time we get the lock.
     */</comment>
    <expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Might have to re-open if a cache flush happened */</comment>
    <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the FSM file first if it doesn't exist.  If smgr_fsm_nblocks is
     * positive then it must exist, no need for an smgrexists call.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
         <name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>==</operator> <name>InvalidBlockNumber</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ema_nblocks_now</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>ema_nblocks_now</name> <operator>&lt;</operator> <name>ema_nblocks</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name>ema_nblocks_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name>ema_nblocks_now</name></expr></argument>,
                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ema_nblocks_now</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Update local cache with the up-to-date size */</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>=</operator> <name>ema_nblocks_now</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extent_extend_block_for_redo</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>ema_nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>ema_nblocks_now</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//PageInit(pg, BLCKSZ, 0);</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>smgr</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Create the FSM file first if it doesn't exist.  If smgr_fsm_nblocks is
     * positive then it must exist, no need for an smgrexists call.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
         <name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>==</operator> <name>InvalidBlockNumber</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>smgrexists</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ema_nblocks_now</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>ema_nblocks_now</name> <operator>&lt;</operator> <name>ema_nblocks</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name>ema_nblocks_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name>ema_nblocks_now</name></expr></argument>,
                   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ema_nblocks_now</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Update local cache with the up-to-date size */</comment>
    <expr_stmt><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_ema_nblocks</name></name> <operator>=</operator> <name>ema_nblocks_now</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*---------------------------------------------------------------------------
 *
 * Shard List lock manager
 *
 *---------------------------------------------------------------------------
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
void 
LockShardList(Relation rel, ShardID sid, LWLockMode mode)
{
    LWLock * lock = &amp;(LWLockPadded *)MainLWLockArray[SHARDLIST_LOCK_OFFSET + sid].lock;
    LWLockAcquire(lock, mode);
}

void 
UnlockShardList(Relation rel, ShardID sid)
{
    LWLock * lock = &amp;(LWLockPadded *)MainLWLockArray[SHARDLIST_LOCK_OFFSET + sid].lock;
    LWLockRelease(lock);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*-----------------------------------------------------------------------------
 *
 *         EOB Page
 *
 *-----------------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type> 
<name>eob_init_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>max_bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EOBPage</name></type> <name>eob_pg</name> <init>= <expr><operator>(</operator><name>EOBPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <name>EOB_INVALID_FIRST_FREE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name><operator>.</operator><name>nwords</name></name> <operator>=</operator> <name>EOBS_PER_PAGE</name> <operator>/</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>max_bits</name></name> <operator>=</operator> <name>max_bits</name></expr>;</expr_stmt>

    <comment type="line">//TODO: write xlog</comment>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>eob_clean_page</name><parameter_list>(<parameter><decl><type><name>EOBPage</name></type> <name>eob_pg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <name>EOB_INVALID_FIRST_FREE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>bms_clean_members</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>eob_truncate_page</name><parameter_list>(<parameter><decl><type><name>EOBPage</name></type> <name>eob_pg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_bms_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>bms_trun_members</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name></name></expr></argument>, <argument><expr><name>local_bms_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>=</operator> <name>local_bms_offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <call><name>EOB_FIRST_FREE</name><argument_list>(<argument><expr><name>eob_pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>EOBAddress</name></type> 
<name>eob_eid_to_address</name><parameter_list>(<parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ExtentID is invalid"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ExtentID must be less than %d."</literal></expr></argument>,
                               <argument><expr><name>MAX_EXTENTS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>EOBPAGE_OFFSET</name> <operator>+</operator> <name>eid</name> <operator>/</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>=</operator> <name>eid</name> <operator>%</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>

    <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type> 
<name>eob_address_to_eid</name><parameter_list>(<parameter><decl><type><name>EOBAddress</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>eid</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EOBAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        ereport(PANIC,
                    (errcode(ERRCODE_INTERNAL_ERROR),
                     errmsg("EOBAddress is invalid"),
                     errdetail("EOBAddress is (%d,%d).",
                               addr.physical_page_number, addr.local_bms_offset)));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>InvalidExtentID</name></expr>;</return>
        
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>eid</name> <operator>=</operator> <operator>(</operator><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>-</operator> <name>EOBPAGE_OFFSET</name><operator>)</operator><operator>*</operator><name>EOBS_PER_PAGE</name> <operator>+</operator> <name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
    <return>return <expr><name>eid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> 
<name>eob_extent_is_free</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type> <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBPage</name></type> <name>eob_pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eob_pg</name> <operator>=</operator> <operator>(</operator><name>EOBPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> 
<name>eob_mark_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setfree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type> <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBPage</name></type> <name>eob_pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eob_pg</name> <operator>=</operator> <operator>(</operator><name>EOBPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>&gt;=</operator> <name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* exceed the max eob bit */</comment>
        <decl_stmt><decl><type><name>EOBAddress</name></type> <name>max_eob</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>max_eob</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>max_eob</name><operator>.</operator><name>local_bms_offset</name></name> <operator>=</operator> <name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"set eob failed, setting(eob bit:%d) is exceed the bound of table(max extent: %d)."</literal></expr></argument>,
                <argument><expr><name>eid</name></expr></argument>, <argument><expr><call><name>eob_address_to_eid</name><argument_list>(<argument><expr><name>max_eob</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>setfree</name></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><call><name>bms_add_member</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>&gt;</operator> <name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>    
        <expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>==</operator> <name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * the first empty extent is be occupied, find next empty extent.
             */</comment>
            <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <call><name>EOB_NEXT_FREE</name><argument_list>(<argument><expr><name>eob_pg</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>eob_page_mark_extent</name><parameter_list>(<parameter><decl><type><name>EOBPage</name></type> <name>eob_pg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_bms_offset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setfree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>setfree</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_add_member</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name></name><operator>)</operator></expr></argument>, <argument><expr><name>local_bms_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>&gt;</operator> <name>local_bms_offset</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <name>local_bms_offset</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>eob_pg</name><operator>-&gt;</operator><name>eob_bits</name></name><operator>)</operator></expr></argument>, <argument><expr><name>local_bms_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>==</operator> <name>local_bms_offset</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <call><name>EOB_NEXT_FREE</name><argument_list>(<argument><expr><name>eob_pg</name></expr></argument>, <argument><expr><name>local_bms_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>eob_get_free_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>blk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>     <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBPage</name></type>    <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>next_free</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    
    <for>for<control>(<init><expr><name>blk</name> <operator>=</operator> <name>EOBPAGE_OFFSET</name></expr>;</init> <condition><expr><name>blk</name> <operator>&lt;</operator> <name>ESAPAGE_OFFSET</name></expr>;</condition> <incr><expr><name>blk</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>    <name>need_move_first_free</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>next_free</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>        
        
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                                   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EOBPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EOB_FIRSTFREE_IS_FREE</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>next_free</name> <operator>=</operator> <call><name>EOB_NEXT_FREE</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>need_move_first_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>next_free</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>next_free</name> <operator>=</operator> <call><name>EOB_FIRST_FREE</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>next_free</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>need_move_first_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

        <if_stmt><if>if<condition>(<expr><name>need_move_first_free</name></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <name>next_free</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>next_free</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>(<expr><name>next_free</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table is too large, and there is no space to extend."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>blk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>=</operator> <name>next_free</name></expr>;</expr_stmt>
    <return>return <expr><call><name>eob_address_to_eid</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>eob_get_free_extent_and_set_busy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>blk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>     <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBPage</name></type>    <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>next_free</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    
    <for>for<control>(<init><expr><name>blk</name> <operator>=</operator> <name>EOBPAGE_OFFSET</name></expr>;</init> <condition><expr><name>blk</name> <operator>&lt;</operator> <name>ESAPAGE_OFFSET</name></expr>;</condition> <incr><expr><name>blk</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>next_free</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>        
        
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                                   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EOBPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* this eob page has not be used.*/</comment>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EOB_FIRSTFREE_IS_FREE</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>next_free</name> <operator>=</operator> <call><name>EOB_NEXT_FREE</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <name>next_free</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>next_free</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>next_free</name> <operator>=</operator> <call><name>EOB_FIRST_FREE</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pg</name><operator>-&gt;</operator><name>first_empty_extent</name></name> <operator>=</operator> <name>next_free</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>next_free</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>eob_page_mark_extent</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name>next_free</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

        <if_stmt><if>if<condition>(<expr><name>next_free</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>(<expr><name>next_free</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//elog(ERROR, "table is too large, and there is no space to extend.");</comment>
        <return>return <expr><name>InvalidExtentID</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>blk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>=</operator> <name>next_free</name></expr>;</expr_stmt>
    <return>return <expr><call><name>eob_address_to_eid</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>eob_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>new_max_eid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>old_max_eid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>blkno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_blks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_last_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_blks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_last_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>xl_extent_cleaneob</name></type> <name>clean_xlrec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_extent_trunceob</name></type> <name>trunc_xlrec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>new_max_eid</name> <operator>&gt;=</operator> <name>old_max_eid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* init xlog data struct */</comment>
    <expr_stmt><expr><call><name>INIT_EXLOG_CLEANEOB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clean_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>clean_xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <expr_stmt><expr><call><name>INIT_EXLOG_TRUNCEOB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunc_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>trunc_xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <comment type="block">/*
     * clean all of eob pages if new heap is empty.
     */</comment>
    <if_stmt><if>if<condition>(<expr><name>new_max_eid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>old_blks</name> <operator>=</operator> <operator>(</operator><name>old_max_eid</name> <operator>+</operator> <name>EOBS_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>blkno</name> <operator>=</operator> <name>old_blks</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>blkno</name> <operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>blkno</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>EOBPAGE_OFFSET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>eob_clean_page</name><argument_list>(<argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* write xlog */</comment>            
            <expr_stmt><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>clean_xlrec</name></expr></argument>, <argument><expr><name>SizeOfCleanEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_COMMON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Clean EOB Page:[rel:%d/%d/%d]"</literal>
                            <literal type="string">"[ema block number:%d, eob block index:%d]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name>new_max_eid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name>old_max_eid</name> <operator>&gt;</operator> <name>new_max_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * computer which pages will be clean or truncate
     */</comment>
    <expr_stmt><expr><name>old_blks</name> <operator>=</operator> <name>old_max_eid</name> <operator>/</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>old_last_offset</name> <operator>=</operator> <name>old_max_eid</name> <operator>%</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>old_last_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>old_blks</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_last_offset</name> <operator>=</operator> <name>EOBS_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>new_blks</name> <operator>=</operator> <name>new_max_eid</name> <operator>/</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_last_offset</name> <operator>=</operator> <name>new_max_eid</name> <operator>%</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>new_last_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>new_blks</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_last_offset</name> <operator>=</operator> <name>EOBS_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * clean pages after the max page of new extent segement
     */</comment>
    <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>old_blks</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name>new_blks</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>EOBPAGE_OFFSET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,  <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>eob_clean_page</name><argument_list>( <argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write xlog */</comment>
        <expr_stmt><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>clean_xlrec</name></expr></argument>,  <argument><expr><name>SizeOfCleanEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>,  <argument><expr><name>XLOG_EXTENT_COMMON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Clean EOB Page:[rel:%d/%d/%d]"</literal>
                        <literal type="string">"[ema block number:%d, eob block index:%d]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name></expr></argument>,  <argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>blkno</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * truncate one page
     */</comment>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name>blkno</name> <operator>==</operator> <name>new_blks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>EOBPAGE_OFFSET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>eob_truncate_page</name><argument_list>(<argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_last_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* write xlog */</comment>
    <expr_stmt><expr><name><name>trunc_xlrec</name><operator>.</operator><name>pageno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trunc_xlrec</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>new_last_offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>trunc_xlrec</name></expr></argument>, <argument><expr><name>SizeOfTruncEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_COMMON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Truncate EOB Page:[rel:%d/%d/%d]"</literal>
                    <literal type="string">"[ema block number:%d, eob block index:%d, new offset:%d]"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>trunc_xlrec</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 *
 *         ESA Page
 *
 *-----------------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type> 
<name>esa_init_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>max_anchors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ESAPage</name></type> <name>esa_pg</name> <init>= <expr><operator>(</operator><name>ESAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>max_anchors</name></name> <operator>=</operator> <name>max_anchors</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>+</operator><literal type="number">4</literal> <operator>&lt;=</operator> <name>max_anchors</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_head</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_tail</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scan_head</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scan_tail</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>scan_head</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>scan_tail</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>scan_head</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>scan_tail</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for<control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_anchors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_head</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_tail</name>  <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>ESAAddress</name></type> 
<name>esa_sid_to_address</name><parameter_list>(<parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ESAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>esa_offset</name> <init>=     <expr><name>ESAPAGE_OFFSET</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>esas_per_page</name> <init>= <expr><name>ESAS_PER_PAGE</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ShardID is invalid"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ShardID must be less than %d."</literal></expr></argument>,
                               <argument><expr><name>InvalidShardID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>esa_offset</name> <operator>+</operator> <name>sid</name> <operator>/</operator> <name>esas_per_page</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <name>sid</name> <operator>%</operator> <name>esas_per_page</name></expr>;</expr_stmt>

    <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ShardID</name></type> 
<name>esa_address_to_eid</name><parameter_list>(<parameter><decl><type><name>ESAAddress</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>sid</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ESAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ESAAddress is invalid"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ESAAddress is (%d,%d)."</literal></expr></argument>,
                               <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>sid</name> <operator>=</operator> <operator>(</operator><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>-</operator> <name>ESAPAGE_OFFSET</name><operator>)</operator><operator>*</operator><name>ESAS_PER_PAGE</name> <operator>+</operator> <name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
    <return>return <expr><name>sid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * NOTICE: caller MUST have been acquired the lock on buffer page before calling this method.
 */</comment>
<function><type><name>void</name></type> 
<name>esa_page_set_anchor</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type>    <name>set_flags</name></decl></parameter>,
                    <parameter><decl><type><name>ExtentID</name></type> <name>scan_head</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>scan_tail</name></decl></parameter>,
                    <parameter><decl><type><name>ExtentID</name></type> <name>alloc_head</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>alloc_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ESAPage</name></type> <name>esa_pg</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>ESAS_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of esa page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ExtentID must be less than %d."</literal></expr></argument>,
                           <argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>esa_pg</name> <operator>=</operator> <operator>(</operator><name>ESAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>ESA_SETFLAG_SCANHEAD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_head</name> <operator>=</operator> <name>scan_head</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>ESA_SETFLAG_SCANTAIL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_tail</name> <operator>=</operator> <name>scan_tail</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>ESA_SETFLAG_ALLOCHEAD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>alloc_head</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>ESA_SETFLAG_ALLOCTAIL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>alloc_tail</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>esa_set_anchor</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>int</name></type>    <name>set_flags</name></decl></parameter>,
            <parameter><decl><type><name>ExtentID</name></type> <name>scan_head</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>scan_tail</name></decl></parameter>,
            <parameter><decl><type><name>ExtentID</name></type> <name>alloc_head</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>alloc_tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>ESAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>    <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>ESAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>esa_page_set_anchor</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>set_flags</name></expr></argument>, 
                    <argument><expr><name>scan_head</name></expr></argument>, <argument><expr><name>scan_tail</name></expr></argument>, <argument><expr><name>alloc_head</name></expr></argument>, <argument><expr><name>alloc_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>EMAShardAnchor</name></type> 
<name>esa_get_anchor</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>ESAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>    <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ESAPage</name></type> <name>esa_pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ESAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>esa_pg</name> <operator>=</operator> <operator>(</operator><name>ESAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>anchor</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 *
 *         EMA Page
 *
 *-----------------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type> 
<name>ema_init_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>max_emes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_pg</name> <init>= <expr><operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ema_pg</name><operator>-&gt;</operator><name>max_emes</name></name> <operator>=</operator> <name>max_emes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_clean_page</name><parameter_list>(<parameter><decl><type><name>EMAPage</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>ema</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtentMappingElement</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>page</name><operator>-&gt;</operator><name>max_emes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_truncate_page</name><parameter_list>(<parameter><decl><type><name>EMAPage</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>ema</name></name> <operator>+</operator> <name>last_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtentMappingElement</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>page</name><operator>-&gt;</operator><name>max_emes</name></name> <operator>-</operator> <name>last_offset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>=</operator> <name>last_offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_init_eme</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type> <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>EMAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ema_page_init_eme</name><argument_list>(<argument><expr><name>pg</name></expr></argument>,<argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,<argument><expr><name>sid</name></expr></argument>,<argument><expr><name>MAX_FREESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_page_init_eme</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EMESetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_free_eme</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type> <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>EMAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ema_page_free_eme</name><argument_list>(<argument><expr><name>pg</name></expr></argument>,<argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_page_free_eme</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
        
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EMESetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>EMAAddress</name></type> 
<name>ema_eid_to_address</name><parameter_list>(<parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ExtentID is invalid"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ExtentID must be less than %d."</literal></expr></argument>,
                               <argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>EMAPAGE_OFFSET</name> <operator>+</operator> <name>eid</name> <operator>/</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <name>eid</name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>

    <return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type> 
<name>ema_address_to_eid</name><parameter_list>(<parameter><decl><type><name>EMAAddress</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>eid</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EMAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        ereport(PANIC,
                    (errcode(ERRCODE_INTERNAL_ERROR),
                     errmsg("EMAAddress is invalid"),
                     errdetail("EMAAddress is (%d,%d).",
                               addr.physical_page_number, addr.local_idx)));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>InvalidExtentID</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>eid</name> <operator>=</operator> <operator>(</operator><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>-</operator> <name>EMAPAGE_OFFSET</name><operator>)</operator><operator>*</operator><name>EMES_PER_PAGE</name> <operator>+</operator> <name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
    <return>return <expr><name>eid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>ema_next_alloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>curr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error_if_free</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_occupied</name></decl></parameter>, <parameter><decl><type><name>ShardID</name> <modifier>*</modifier></type><name>sid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hwm</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>curr_eme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAPage</name></type>        <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_extent</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>curr_eme</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>curr_eme</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name> <operator>&gt;=</operator> <name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extent %d is not exist in EMA page."</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>error_if_free</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExtentAssertEMEIsOccup</name><argument_list>(<argument><expr><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>next_extent</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_next</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>is_occupied</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>is_occupied</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>sid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sid</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>hwm</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>hwm</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>hwm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>freespace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>freespace</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>next_extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>ema_prev_alloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>curr</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>freespace</name></decl></parameter>, <parameter><decl><type><name>ShardID</name> <modifier>*</modifier></type><name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>curr_eme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAPage</name></type>        <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>prev_extent</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>curr_eme</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>curr_eme</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//ExtentAssertEMEIsOccup(pg-&gt;ema[curr_eme.local_idx]);</comment>
    <expr_stmt><expr><name>prev_extent</name> <operator>=</operator> <call><name>EMEGetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>freespace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>freespace</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>sid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sid</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>prev_extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>ema_next_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>curr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error_if_free</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_occupied</name></decl></parameter>, <parameter><decl><type><name>ShardID</name> <modifier>*</modifier></type><name>sid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hwm</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>curr_eme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAPage</name></type>        <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_extent</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>curr_eme</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>curr_eme</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>error_if_free</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExtentAssertEMEIsOccup</name><argument_list>(<argument><expr><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>next_extent</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_next</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>is_occupied</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>is_occupied</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>sid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sid</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>hwm</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>hwm</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>hwm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>freespace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>freespace</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>next_extent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>ema_prev_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>curr</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>freespace</name></decl></parameter>, <parameter><decl><type><name>ShardID</name> <modifier>*</modifier></type><name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>curr_eme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAPage</name></type>        <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>prev_extent</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>curr_eme</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>curr_eme</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//ExtentAssertEMEIsOccup(pg-&gt;ema[curr_eme.local_idx]);</comment>
    <expr_stmt><expr><name>prev_extent</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_prev</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>freespace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>freespace</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>sid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sid</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>curr_eme</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>prev_extent</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ExtentMappingElement</name> <modifier>*</modifier></type>
<name>ema_get_eme</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentMappingElement</name> <modifier>*</modifier></type><name>eme</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>eme</name> <operator>=</operator> <call><name>ema_page_get_eme</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>eme</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtentMappingElement</name> <modifier>*</modifier></type> 
<name>ema_page_get_eme</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentMappingElement</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ExtentMappingElement</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtentMappingElement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtentMappingElement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>ema_get_eme_extract</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, 
                    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_occupied</name></decl></parameter>, <parameter><decl><type><name>ShardID</name>     <modifier>*</modifier></type><name>sid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hwm</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>freespace</name></decl></parameter>)</parameter_list>

<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ema_page_get_eme_extract</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>is_occupied</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>hwm</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> 
<name>ema_page_get_eme_extract</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>, 
                                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_occupied</name></decl></parameter>, <parameter><decl><type><name>ShardID</name>     <modifier>*</modifier></type><name>sid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hwm</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>is_occupied</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>is_occupied</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>is_occupied</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>sid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>sid</name> <operator>=</operator> <operator>(</operator><name>ShardID</name><operator>)</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>hwm</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>hwm</name> <operator>=</operator> <name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>hwm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>freespace</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>freespace</name> <operator>=</operator> <operator>(</operator><name>uint8</name><operator>)</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ema_set_eme_hwm</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>hwm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type> <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>EMAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ema_page_set_eme_hwm</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>hwm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_page_set_eme_hwm</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>hwm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
        
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>is_occupied</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">//TODO: rebuild eme</comment>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ema_set_eme_freespace</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>EMAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExtentAssertEMEIsOccup</name><argument_list>(<argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ema</name><index>[<expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ema_page_set_eme_freespace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * write xlog
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_FREESPACE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_UPDATE_EME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Update Extent Freespace:[rel:%d/%d/%d]"</literal>
                    <literal type="string">"[eid:%d, ema block number:%d, offset:%d, freespace:%d]"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name>eid</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_page_set_eme_freespace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
        
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_rnode_set_eme_freespace</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>     <name>ema_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type> <name>pg</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>RBM_ZERO_ON_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"rnode:%d/%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ema_page_set_eme_freespace</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>ema_set_eme_link</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>set_flags</name></decl></parameter>, 
                    <parameter><decl><type><name>ExtentID</name></type> <name>scan_prev</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>scan_next</name></decl></parameter>, 
                    <parameter><decl><type><name>ExtentID</name></type> <name>alloc_prev</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>alloc_next</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type> <name>pg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>EMAAddressIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get block from ema file failed."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"reloid:%d, block number:%d"</literal></expr></argument>,
                               <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ema_page_set_eme_link</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>set_flags</name></expr></argument>,
                        <argument><expr><name>scan_prev</name></expr></argument>, <argument><expr><name>scan_next</name></expr></argument>, <argument><expr><name>alloc_prev</name></expr></argument>, <argument><expr><name>alloc_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>ema_page_set_eme_link</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>set_flags</name></decl></parameter>, 
                    <parameter><decl><type><name>ExtentID</name></type> <name>scan_prev</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>scan_next</name></decl></parameter>, 
                    <parameter><decl><type><name>ExtentID</name></type> <name>alloc_prev</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>alloc_next</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
        
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExtentAssertEMEIsOccup</name><argument_list>(<argument><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_SCANPREV</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name>scan_prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_SCANNEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>scan_next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_ALLOCPREV</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>EMESetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>alloc_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_ALLOCNEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name>alloc_next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_page_set_eme</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>local_index</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>set_flags</name></decl></parameter>, <parameter><decl><type><name>ExtentMappingElement</name> <modifier>*</modifier></type><name>tempEME</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
        
    <if_stmt><if>if<condition>(<expr><name>local_index</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local index of EMA page"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local_index must be less than %ld."</literal></expr></argument>,
                           <argument><expr><name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_SHARDID</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name><name>tempEME</name><operator>-&gt;</operator><name>shardid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_FREESPACE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <name><name>tempEME</name><operator>-&gt;</operator><name>max_freespace</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_HWM</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name><name>tempEME</name><operator>-&gt;</operator><name>hwm</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_OCCUPIED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <name><name>tempEME</name><operator>-&gt;</operator><name>is_occupied</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>    
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_SCANPREV</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name><name>tempEME</name><operator>-&gt;</operator><name>scan_prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_SCANNEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name><name>tempEME</name><operator>-&gt;</operator><name>scan_next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_ALLOCPREV</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>EMESetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>EMEGetAllocPrev</name><argument_list>(<argument><expr><name>tempEME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name>set_flags</name> <operator>&amp;</operator> <name>EMA_SETFLAG_ALLOCNEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>local_index</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name><name>tempEME</name><operator>-&gt;</operator><name>alloc_next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>set_flags</name> <operator>==</operator> <name>EMA_SETFLAG_INIT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ema_page_init_eme</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name>local_index</name></expr></argument>, <argument><expr><name><name>tempEME</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>, <argument><expr><name><name>tempEME</name><operator>-&gt;</operator><name>max_freespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>set_flags</name> <operator>==</operator> <name>EMA_SETFLAG_CLEAN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ema_page_free_eme</name><argument_list>(<argument><expr><name>pg</name></expr></argument>, <argument><expr><name>local_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_page_extend_eme</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>pg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_emes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cleaneme</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clean_start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clean_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_page</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>ema_page</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>n_emes</name> <operator>&lt;=</operator> <name><name>ema_page</name><operator>-&gt;</operator><name>n_emes</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>cleaneme</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <name>clean_start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>clean_end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name><operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name><operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EMESetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ema_page</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>ema_page</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>=</operator> <name>n_emes</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ema_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>new_max_eid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>old_max_eid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>blkno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_blks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_last_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_blks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_last_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>xl_extent_cleanema</name></type> <name>clean_xlrec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_extent_truncema</name></type> <name>trunc_xlrec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>new_max_eid</name> <operator>&gt;=</operator> <name>old_max_eid</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* init xlog data struct */</comment>
    <expr_stmt><expr><call><name>INIT_EXLOG_CLEANEMA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clean_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>clean_xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <expr_stmt><expr><call><name>INIT_EXLOG_TRUNCEMA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunc_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>trunc_xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <comment type="block">/*
     * clean all of ema pages if new heap is empty.
     */</comment>
    <if_stmt><if>if<condition>(<expr><name>new_max_eid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>old_blks</name> <operator>=</operator> <operator>(</operator><name>old_max_eid</name> <operator>+</operator> <name>EMES_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>EMES_PER_PAGE</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>blkno</name> <operator>=</operator> <name>old_blks</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>blkno</name> <operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>blkno</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>EMAPAGE_OFFSET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>( <argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ema_clean_page</name><argument_list>( <argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* write xlog */</comment>            
            <expr_stmt><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>( <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>clean_xlrec</name></expr></argument>, <argument><expr><name>SizeOfCleanEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_COMMON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                      <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Clean EME Page:[rel:%d/%d/%d]"</literal>
                              <literal type="string">"[ema block number:%d, ema page index:%d]"</literal></expr></argument>,
                              <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                              <argument><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name>new_max_eid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name>old_max_eid</name> <operator>&gt;</operator> <name>new_max_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * computer which pages will be clean or truncate
     */</comment>
    <expr_stmt><expr><name>old_blks</name> <operator>=</operator> <name>old_max_eid</name> <operator>/</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>old_last_offset</name> <operator>=</operator> <name>old_max_eid</name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>old_last_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>old_blks</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>old_last_offset</name> <operator>=</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>new_blks</name> <operator>=</operator> <name>new_max_eid</name><operator>/</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_last_offset</name> <operator>=</operator> <name>new_max_eid</name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>new_last_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>new_blks</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_last_offset</name> <operator>=</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * clean pages after the max page of new extent segement
     */</comment>
    <expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>old_blks</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name>new_blks</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>EMAPAGE_OFFSET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ema_clean_page</name><argument_list>(<argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write xlog */</comment>
        <expr_stmt><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>clean_xlrec</name></expr></argument>, <argument><expr><name>SizeOfCleanEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_COMMON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Clean EME Page:[rel:%d/%d/%d]"</literal>
                        <literal type="string">"[ema block number:%d, ema page index:%d]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name><name>clean_xlrec</name><operator>.</operator><name>pageno</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>blkno</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * truncate one page
     */</comment>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name>blkno</name> <operator>==</operator> <name>new_blks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>EMAPAGE_OFFSET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ema_truncate_page</name><argument_list>(<argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_last_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* write xlog */</comment>
    <expr_stmt><expr><name><name>trunc_xlrec</name><operator>.</operator><name>pageno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trunc_xlrec</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>new_last_offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>trunc_xlrec</name></expr></argument>, <argument><expr><name>SizeOfTruncEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_COMMON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Truncate EME Page:[rel:%d/%d/%d]"</literal>
                    <literal type="string">"[ema block number:%d, ema page index:%d, offset:%d]"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name><name>trunc_xlrec</name><operator>.</operator><name>pageno</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>trunc_xlrec</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------------------
 *
 *         list operation
 *
 *-----------------------------------------------------------------------------
 */</comment>

<function><type><name>bool</name></type>
<name>shard_add_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>targ_eme_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>targ_eme_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAPage</name></type>        <name>targ_eme_pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name></type>        <name>targ_eme_page</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * check EME is free
     */</comment>
    <expr_stmt><expr><name>targ_eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>targ_eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>targ_eme_page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>targ_eme_pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>targ_eme_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>&lt;=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"internal error: system is trying to add a nonexist extent to shardlist."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* extent is occupied */</comment>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* 
     * add this extent to alloc list and scan list 
     * If system crash in this point, the free extent will be leaked.
     */</comment>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * both two lists is empty
         */</comment>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name></decl>;</decl_stmt>    
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAPage</name></type> <name>esa_pg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * get buffer for esa 
         * registered block no: 0
         */</comment>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * lock buffer for target eme.
         * recheck whether the target eme is free.
         * registered block no: 1
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* extent is occupied */</comment>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update anchor
         */</comment>
        <expr_stmt><expr><name>esa_pg</name> <operator>=</operator> <operator>(</operator><name>ESAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_head</name>  <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_tail</name>  <operator>=</operator> <name>eid</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * update target EME 
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssertEMEIsFree</name><argument_list>(<argument><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <comment type="block">/*write xlog*/</comment>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_ATTACH_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AttachExtent:[rel:%d/%d/%d][mode:1:scanlist is empty]"</literal>
                        <literal type="string">"[sid:%d, eid:%d]"</literal>
                        <literal type="string">"[setesa:blocknum=%d,offset=%d,scanhead=%d,scantail=%d,allochead=%d,alloctail=%d]"</literal>
                        <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,freespace=MAX_FREESPACE]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* alloc list is emtpy, but scan list is not empty */</comment>

        <comment type="block">/*
         * if free extentid is precede scan list head, insert this extent to list head.
         */</comment>
        <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&lt;</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name></decl>;</decl_stmt> 
            <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ESAPage</name></type> <name>esa_pg</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * get buffer for esa 
             * registered block no: 0
             */</comment>
            <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,  <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>( <argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>,  <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * lock buffer for target eme.
             * recheck whether the target eme is free.
             * registered block no: 1
             */</comment>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* extent is occupied */</comment>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,  <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
            <comment type="block">/*
             * update anchor
             */</comment>
            <expr_stmt><expr><name>esa_pg</name> <operator>=</operator> <operator>(</operator><name>ESAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>( <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator>  <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator>  <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_head</name>  <operator>=</operator>  <name>eid</name></expr>;</expr_stmt>
    
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/*
             * update target EME 
             */</comment>
            <expr_stmt><expr><call><name>ExtentAssertEMEIsFree</name><argument_list>(<argument><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>

            <comment type="block">/*write xlog*/</comment>
            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOC</name> <operator>|</operator> <name>ESA_SETFLAG_SCANHEAD</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>        
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_ATTACH_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AttachExtent:[rel:%d/%d/%d][mode2:insert extent into "</literal>
                                                        <literal type="string">"the head of scanlist and alloclist is null]"</literal>
                            <literal type="string">"[sid:%d, eid:%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,scanhead=%d,allochead=%d,alloctail=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,scannext=%d,freespace=MAX_FREESPACE]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name></decl>;</decl_stmt> 
            <decl_stmt><decl><type><name>Buffer</name></type> <name>left_buf</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAAddress</name></type> <name>left_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ESAPage</name></type> <name>esa_pg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Page</name></type>    <name>left_page</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>left_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtentID</name></type>    <name>e_left</name></decl>, <decl><type ref="prev"/><name>e_right</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>e_left</name> <operator>=</operator> <name>e_right</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* search point to insert to scan list */</comment>
            <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>e_right</name> <operator>=</operator> <call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><name>e_left</name> <operator>==</operator> <name>eid</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* error: this free extent has been already added to scan list. */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call>
                    <operator>||</operator> <operator>(</operator><name>e_left</name> <operator>&lt;</operator> <name>eid</name> <operator>&amp;&amp;</operator> <name>eid</name> <operator>&lt;</operator> <name>e_right</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>e_left</name> <operator>=</operator> <name>e_right</name></expr>;</expr_stmt>
            </block_content>}</block></while>            
    
            <comment type="block">/*
             * get buffer for esa 
             * registered block no: 0
             */</comment>
            <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * get buffer for left eme
             * registered block no: 1
             */</comment>
            <expr_stmt><expr><name>left_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><name>left_buf</name> <operator>=</operator> <name>targ_eme_buf</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>left_page</name> <operator>=</operator> <name>targ_eme_page</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>left_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>left_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>left_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>left_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>left_page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * lock buffer for target eme.
             * recheck whether the target eme is free.
             * registered block no: 2
             */</comment>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* extent is occupied */</comment>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * if eid is at same page as e_left, targ_eme_buf will be transfered to left_buf for management.
             * we do like this is to ensure e_left is locked before locking buffer of target eme.
             */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>targ_eme_buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/*
             * update anchor
             */</comment>
            <expr_stmt><expr><name>esa_pg</name> <operator>=</operator> <operator>(</operator><name>ESAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_tail</name>  <operator>=</operator> <name>eid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * update left EME
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><name>left_page</name></expr></argument>, <argument><expr><name><name>left_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * update target EME 
             */</comment>
            <expr_stmt><expr><call><name>ExtentAssertEMEIsFree</name><argument_list>(<argument><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>e_right</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* 
             * write xlog
             */</comment>
            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* write xlog of esa */</comment>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOC</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>    
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>ESA_SETFLAG_SCANTAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* write xlog for insert point */</comment>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>left_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><name><name>left_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>left_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>left_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>left_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>left_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>left_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* write xlog for target eme */</comment>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>e_right</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_ATTACH_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>left_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt><empty_stmt>;</empty_stmt>

            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AttachExtent:[rel:%d/%d/%d][mode3:insert extent into "</literal>
                                                        <literal type="string">"internal of scanlist and alloclist is null]"</literal>
                            <literal type="string">"[sid:%d, eid:%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,allochead=%d,alloctail=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,scannext=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,scannext=%d,freespace=MAX_FREESPACE]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>left_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>left_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>e_right</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else  <comment type="block">/* anchor-&gt;alloc_head is valid */</comment>
    <block>{<block_content>
        <comment type="block">/*
        * both two lists are not empty.
        */</comment>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>scan_left</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>scan_right</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>alloc_left</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>alloc_right</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
        
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt> 
        <decl_stmt><decl><type><name>Buffer</name></type> <name>scan_left_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>alloc_left_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>scan_left_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>alloc_left_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAPage</name></type> <name>esa_pg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Page</name></type>    <name>scan_left_page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Page</name></type>    <name>alloc_left_page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>scan_left_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>alloc_left_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>targ_eme_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name>  <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_left_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alloc_left_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan_left_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan_left_addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>alloc_left_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>alloc_left_addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* 
             * alloc list is not empty, and scan list is empty
             * need to rebuild scan list 
             */</comment>
            <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %d extent was corrupted."</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* 
         * search insert point in scan list
         */</comment>
        <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&gt;</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><name>scan_left</name> <operator>=</operator> <name>scan_right</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>
            
            <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>scan_right</name> <operator>=</operator> <call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>scan_left</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                
                <if_stmt><if>if<condition>(<expr><name>scan_left</name> <operator>==</operator> <name>eid</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* error: this free extent has been already added to scan list. */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call>
                    <operator>||</operator> <operator>(</operator><name>scan_left</name> <operator>&lt;</operator> <name>eid</name> <operator>&amp;&amp;</operator> <name>eid</name> <operator>&lt;</operator> <name>scan_right</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>                

                <expr_stmt><expr><name>scan_left</name> <operator>=</operator> <name>scan_right</name></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * search insert point in alloc list
         */</comment>
        <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&gt;</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>alloc_left</name> <operator>=</operator> <name>alloc_right</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>

            <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>alloc_right</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>alloc_left</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                
                <if_stmt><if>if<condition>(<expr><name>alloc_left</name> <operator>==</operator> <name>eid</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* error: this free extent has been already added to scan list. */</comment>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call>
                    <operator>||</operator> <operator>(</operator><name>alloc_left</name> <operator>&lt;</operator> <name>eid</name> <operator>&amp;&amp;</operator> <name>eid</name> <operator>&lt;</operator> <name>alloc_right</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>                

                <expr_stmt><expr><name>alloc_left</name> <operator>=</operator> <name>alloc_right</name></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * get buffer for esa if need
         */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_right</name></expr></argument>)</argument_list></call> 
                <operator>||</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_right</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>esa_pg</name> <operator>=</operator> <operator>(</operator><name>ESAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * get buffer for alloc_left
         * registered block no : 1
         */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//only need to alloc head of esa and target eme.</comment>
            <expr_stmt><expr><name>alloc_left_buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>alloc_left_page</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>alloc_left_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><name>alloc_left_buf</name> <operator>=</operator> <name>targ_eme_buf</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>alloc_left_page</name> <operator>=</operator> <name>targ_eme_page</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>alloc_left_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>alloc_left_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>alloc_left_page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        
        <comment type="block">/*
         * get buffer for scan_left
         * registered block no : 2
         */</comment>        
        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>scan_left_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>, <argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><name>scan_left_buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>scan_left_page</name> <operator>=</operator> <name>alloc_left_page</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>        
                <comment type="block">/* buffer of target eme is transfered to scan left */</comment>    
                <expr_stmt><expr><name>scan_left_buf</name> <operator>=</operator> <name>targ_eme_buf</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>scan_left_page</name> <operator>=</operator> <name>targ_eme_page</name></expr>;</expr_stmt>    
            </block_content>}</block></if>        
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>scan_left_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>scan_left_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>scan_left_page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">//only need to alloc head of esa and target eme.</comment>
            <expr_stmt><expr><name>scan_left_buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>scan_left_page</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * lock buffer for target eme.
         * recheck whether the target eme is free.
         * registered block no: 3
         */</comment>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* extent is occupied */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call><operator>)</operator> 
                 <operator>||</operator> <operator>(</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>scan_left</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <comment type="line">//nothing to do</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><operator>(</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call><operator>)</operator> 
             <operator>||</operator> <operator>(</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>scan_left</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>targ_eme_buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * update anchor
         */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_right</name></expr></argument>)</argument_list></call> 
                <operator>||</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_right</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * insert new extent to the head of alloc list
                 */</comment>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>ESA_SETFLAG_ALLOCHEAD</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_head</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_right</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>ESA_SETFLAG_ALLOCTAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_tail</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * insert new extent to the head of scan list
                 */</comment>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>ESA_SETFLAG_SCANHEAD</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_head</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_right</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * append new extent to the tail of scan list
                 */</comment>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>ESA_SETFLAG_SCANTAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_pg</name><operator>-&gt;</operator><name>anchors</name><index>[<expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_tail</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>    
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * update alloc left eme
         */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><name>alloc_left_page</name></expr></argument>, <argument><expr><name><name>alloc_left_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>alloc_left_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>alloc_left_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>alloc_left_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>alloc_left_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>alloc_left_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>alloc_left_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>alloc_left_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/*
         * update scan left eme
         */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><name>scan_left_page</name></expr></argument>, <argument><expr><name><name>scan_left_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan_left_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>scan_left_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan_left_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_left_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scan_left_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>, <argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>scan_left_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            </block_content>}</block></if>
            <else>else 
            <block>{<block_content>
                <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scan_left_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>scan_left_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * update target eme
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssertEMEIsFree</name><argument_list>(<argument><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>max_freespace</name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> 
                        <ternary><condition><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>alloc_right</name></expr> </then><else>: <expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></else></ternary></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>targ_eme_pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> 
                        <ternary><condition><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>scan_right</name></expr> </then><else>: <expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></else></ternary></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>MAX_FREESPACE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <ternary><condition><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>scan_right</name></expr> </then><else>: <expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <ternary><condition><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>alloc_right</name></expr> </then><else>: <expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></else></ternary></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>        
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <comment type="block">/*
         * write xlog
         */</comment>
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_ATTACH_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>            
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>scan_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>alloc_left_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringInfoData</name></type> <name>esa_log</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 
             * log relation
             */</comment>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">"[trace extent]AttachExtent:[rel:%d/%d/%d][mode4:both scan list and alloclist are not empty]"</literal></expr></argument>,
                                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* 
             * log sid and eid 
             */</comment>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">"[sid:%d, eid:%d]"</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 
             * log esa 
             */</comment>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">"[setesa:blocknum=%d,offset=%d"</literal></expr></argument>,
                                <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">",allochead=%d"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">",alloctail=%d"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">",scanchead=%d"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">",scantail=%d"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* 
             *log scan extent 
             */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">"[setscaneme:blocknum=%d,offset=%d,scannext=%d]"</literal></expr></argument>,
                                <argument><expr><name><name>scan_left_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>scan_left_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                                <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* 
             * log alloc extent 
             */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">"[setalloceme:blocknum=%d,offset=%d,allocnext=%d]"</literal></expr></argument>,
                                <argument><expr><name><name>alloc_left_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>alloc_left_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                                <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* 
             * log target extent
             */</comment>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_log</name></expr></argument>, <argument><expr><literal type="string">"[settargeteme:blocknum=%d,offset=%d,sid=%d,freespace=MAX_FREESPACE,"</literal>
                                        <literal type="string">"scannext=%d, allocnext=%d]"</literal></expr></argument>,
                                <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>,
                                <argument><expr><ternary><condition><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>scan_left</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>scan_right</name></expr> </then><else>: <expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></else></ternary></expr></argument>,
                                <argument><expr><ternary><condition><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>alloc_left</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>alloc_right</name></expr> </then><else>: <expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>esa_log</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>shard_append_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_rebuild</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>EOBAddress</name></type>    <name>eob_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>eob_buf</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>xl_extent_extendeme</name></type> <name>xlrec_ex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_extent_extendeob</name></type> <name>xlrec_eob</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>INIT_EXLOG_EXTENDEOB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INIT_EXLOG_EXTENDEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>eob_addr</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* 
     * add this extent to alloc list and scan list 
     * If system crash in this point, the free extent will be leaked.
     */</comment>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name></decl>;</decl_stmt>    
        <decl_stmt><decl><type><name>Buffer</name></type> <name>eme_buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        * get buffer for eob
        * registered block no : 0
        */</comment>
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * get buffer for esa 
         * registered block no : 1
         */</comment>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * get buffer for target EME
         * registered block no : 2
         */</comment>
        <expr_stmt><expr><name>eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update eob
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>==</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>!=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend eob error, emes in eobpage:%d, extending eob local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
         
        <comment type="block">/*
         * update anchor
         */</comment>
        <expr_stmt><expr><call><name>esa_page_set_anchor</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name>ESA_SETFLAG_ALL</name></expr></argument>,
                            <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update target EME 
         */</comment>
        <expr_stmt><expr><call><name>ema_page_init_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>,
                            <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>==</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>!=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend extent error, emes in esapage:%d, extending extent local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>,
                        <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*write xlog*/</comment>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write eob xlog */</comment>        
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>n_eobs</name></name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>, <argument><expr><name>SizeOfExtendEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write esa xlog */</comment>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write eme xlog */</comment>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>for_rebuild</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>EMA_SETFLAG_EXTENDHEAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>extentid</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>eme_xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* eme page: n_emes */</comment>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name> <operator>=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_APPEND_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AppendExtent:[rel:%d/%d/%d][mode:1:scanlist is empty]"</literal>
                            <literal type="string">"[sid:%d, eid:%d, rebuild:%d]"</literal>
                            <literal type="string">"[seteob:blocknum=%d,offset=%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,scanhead=%d,scantail=%d,allochead=%d,alloctail=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,freespace=%d]"</literal>
                            <literal type="string">"[setemepage:blocknum=%d, n_emes=%d]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>for_rebuild</name></expr></argument>,
                            <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>ema_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>targ_eme_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>targ_eme_buf_idx</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>targ_eme_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>targ_eme_xlrec</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        * get buffer for eob
        * registered block no : 0
        */</comment>
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * lock esa page 
         * registered block no: 1
         */</comment>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 
         * lock eme page for scanlist
         * registered block no: 2
         */</comment>
        <expr_stmt><expr><name>eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * lock eme page for target eme if need
         * registered block no: 3
         */</comment>
        <expr_stmt><expr><name>targ_eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><name>targ_eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>targ_eme_buf_idx</name> <operator>=</operator> <name>targ_eme_buf</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>targ_eme_buf_idx</name> <operator>=</operator> <name>ema_buf</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update eob
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>==</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>!=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend eob error, emes in eobpage:%d, extending eob local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        
        <comment type="block">/* 
         * update esa page 
         */</comment>
        <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PAGE_SET_ESA_SCAN_TAIL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        
        <comment type="block">/* 
         * update eme page 
         */</comment>
        <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update target eme
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssertEMEIsFree</name><argument_list>(<argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ema_page_init_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>,
                            <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>==</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>!=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend extent error, emes in esapage:%d, extending extent local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>,
                        <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        * write xlog for eob
        */</comment>    
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>n_eobs</name></name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>, <argument><expr><name>SizeOfExtendEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * write xlog for esa
         */</comment>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOC</name> <operator>|</operator> <name>ESA_SETFLAG_SCANTAIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * write xlog for tail eme
         */</comment>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * write xlog for target eme
         */</comment>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>    
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>for_rebuild</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>EMA_SETFLAG_EXTENDHEAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>extentid</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>targ_eme_xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* eme page: n_emes */</comment>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name> <operator>=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        </block_content>}</block></if>            
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        </block_content>}</block></else></if_stmt>
        
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_APPEND_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AppendExtent:[rel:%d/%d/%d][mode:2:scanlist is not empty, alloclist is empty]"</literal>
                            <literal type="string">"[sid:%d, eid:%d, rebuild:%d]"</literal>
                            <literal type="string">"[seteob:blocknum=%d,offset=%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,scantail=%d,allochead=%d,alloctail=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,eid=%d,scannext=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,freespace=%d]"</literal>
                            <literal type="string">"[setemepage:blocknum=%d, n_emes=%d]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>for_rebuild</name></expr></argument>,
                            <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>,
                            <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>ema1_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt> 
        <decl_stmt><decl><type><name>Buffer</name></type> <name>ema2_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>targ_eme_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>targ_eme_buf_idx</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme1_addr</name></decl>, <decl><type ref="prev"/><name>eme2_addr</name></decl>, <decl><type ref="prev"/><name>targ_eme_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme1_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme2_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>targ_eme_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>        <name>targ_eme_pg_src</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 2: same as ema1_buf, 3: same as ema2_buf, 4: independent page */</comment>

        <expr_stmt><expr><call><name>XLogEnsureRecordSpace</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        * get buffer for eob
        * registered block no : 0
        */</comment>
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * lock esa page 
         * registered block no: 1
         */</comment>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 
         * lock page for alloclist
         * registered block no: 2
         */</comment>
        <expr_stmt><expr><name>eme1_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ema1_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * lock page for scanlist
         * registered block no: 3
         */</comment>
        <expr_stmt><expr><name>eme2_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><name>ema2_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * lock page for target eme
         * registered block no: 4
         */</comment>
        <expr_stmt><expr><name>targ_eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>targ_eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update eob
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>==</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>!=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend eob error, emes in eobpage:%d, extending eob local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>n_eobs</name></name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>, <argument><expr><name>SizeOfExtendEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* 
         * update esa page 
         */</comment>
        <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC_TAIL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PAGE_SET_ESA_SCAN_TAIL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOCTAIL</name> <operator>|</operator> <name>ESA_SETFLAG_SCANTAIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* 
         * update eme page 
         */</comment>
        <if_stmt><if>if<condition>(<expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>==</operator> <name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * alloc tail is same as scan tail.
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ema1_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name> <operator>|</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * both alloc tail and scan tail are in same page, but they are not equal.
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ema1_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * alloc tail and scan tail are not in same page.
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ema1_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>ema2_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* 
         * update target eme 
         */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>targ_eme_pg_src</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>targ_eme_buf_idx</name> <operator>=</operator> <name>ema1_buf</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>targ_eme_pg_src</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>targ_eme_buf_idx</name> <operator>=</operator> <name>ema2_buf</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>targ_eme_pg_src</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>targ_eme_buf_idx</name> <operator>=</operator> <name>targ_eme_buf</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>ExtentAssertEMEIsFree</name><argument_list>(<argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ema_page_init_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                                <argument><expr><name>sid</name></expr></argument>,
                                <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>==</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>!=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend extent error, emes in esapage:%d, extending extent local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>,
                        <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>targ_eme_buf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 
         * write xlog for target eme 
         */</comment>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>    
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>for_rebuild</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>|=</operator> <name>EMA_SETFLAG_EXTENDHEAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>extentid</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>targ_eme_xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><name>targ_eme_pg_src</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* eme page: n_emes */</comment>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><name>targ_eme_pg_src</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_APPEND_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        
        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AppendExtent:[rel:%d/%d/%d][mode:3:both scanlist and alloclist are not empty]"</literal>
                        <literal type="string">"[sid:%d, eid:%d, rebuild:%d]"</literal>
                        <literal type="string">"[seteob:blocknum=%d,offset=%d]"</literal>
                        <literal type="string">"[setesa:blocknum=%d,offset=%d,scantail=%d,alloctail=%d]"</literal>
                        <literal type="string">"[seteme1:blocknum=%d,offset=%d,eid=%d,allocnext=%d]"</literal>
                        <literal type="string">"[seteme2:blocknum=%d,offset=%d,eid=%d,scannext=%d]"</literal>
                        <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,freespace=%d]"</literal>
                        <literal type="string">"[setemepage:blocknum=%d, n_emes=%d]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>for_rebuild</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                        <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>,
                        <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * can not go here.
         */</comment>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//XLogFlush(recptr);</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Only append a extent to scanlist of one shard.
 * this function is used by RebuildExtent.
 */</comment>
<function><type><name>void</name></type>
<name>shard_append_extent_onlyscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>EOBAddress</name></type>    <name>eob_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type>        <name>eob_buf</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>xl_extent_extendeme</name></type> <name>xlrec_ex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_extent_extendeob</name></type> <name>xlrec_eob</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>INIT_EXLOG_EXTENDEOB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INIT_EXLOG_EXTENDEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>eob_addr</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* 
     * add this extent to alloc list and scan list 
     * If system crash in this point, the free extent will be leaked.
     */</comment>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name></decl>;</decl_stmt> 
        <decl_stmt><decl><type><name>Buffer</name></type> <name>eme_buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        * get buffer for eob
        * registered block no : 0
        */</comment>
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>,<argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * get buffer for esa 
         * registered block no : 1
         */</comment>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,  <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>( <argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>,  <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * get buffer for target EME
         * registered block no : 2
         */</comment>
        <expr_stmt><expr><name>eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>( <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>( <argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * update eob
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>==</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>!=</operator> <operator>(</operator><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend eob error, emes in eobpage:%d,  extending eob local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                

        <comment type="block">/*
         * update anchor
         */</comment>
        <expr_stmt><expr><call><name>PAGE_SET_ESA_SCAN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update target EME 
         */</comment>
        <expr_stmt><expr><call><name>ema_page_init_eme</name><argument_list>(  <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>,
                            <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>( <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>==</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>!=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend extent error, emes in esapage:%d, extending extent local idx: %d"</literal></expr></argument>,
                      <argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>,
                      <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*write xlog*/</comment>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write eob xlog */</comment>        
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>n_eobs</name></name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>, <argument><expr><name>SizeOfExtendEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write esa xlog */</comment>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_SCAN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* write eme xlog */</comment>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name>  <operator>=</operator>  <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name>  <operator>=</operator>  <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* eme page: n_emes */</comment>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name> <operator>=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>,  <argument><expr><name>XLOG_EXTENT_APPEND_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
              <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AppendExtentOnlyScan:[rel:%d/%d/%d][mode:1:scanlist is empty]"</literal>
                        <literal type="string">"[sid:%d, eid:%d]"</literal>
                        <literal type="string">"[seteob:blocknum=%d,offset=%d]"</literal>
                        <literal type="string">"[setesa:blocknum=%d,offset=%d,scanhead=%d,scantail=%d]"</literal>
                        <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,is_occupied=%d,freespace=%d,allpointer set to INVALIDEID]"</literal>
                        <literal type="string">"[setemepage:blocknum=%d, n_emes=%d]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                        <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>,
                        <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name></decl>, <decl><type ref="prev"/><name>ema_buf</name></decl>, <decl><type ref="prev"/><name>targ_eme_buf</name></decl>;</decl_stmt>    
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>targ_eme_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>targ_eme_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        * get buffer for eob
        * registered block no : 0
        */</comment>
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * lock esa page 
         * registered block no: 1
         */</comment>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 
         * lock eme page for scanlist
         * registered block no: 2
         */</comment>
        <expr_stmt><expr><name>eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * lock eme page for target eme if need
         * registered block no: 3
         */</comment>
        <expr_stmt><expr><name>targ_eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><name>targ_eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>targ_eme_buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update eob
         */</comment>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>==</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>!=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend eob error, emes in eobpage:%d, extending eob local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* 
         * update esa page 
         */</comment>     
        <expr_stmt><expr><call><name>PAGE_SET_ESA_SCAN_TAIL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        
        <comment type="block">/* 
         * update eme page 
         */</comment>
        <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * update target eme
         */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSICAL_TARG_EME_BUF</name></cpp:macro> <cpp:value>(BufferIsValid(targ_eme_buf) ? targ_eme_buf : ema_buf)</cpp:value></cpp:define>
        <expr_stmt><expr><call><name>ExtentAssertEMEIsFree</name><argument_list>(<argument><expr><operator>(</operator><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>ema</name><index>[<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ema_page_init_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>,
                            <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>==</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name> <operator>!=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend extent error, emes in esapage:%d, extending extent local idx: %d"</literal></expr></argument>,
                        <argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>,
                        <argument><expr><name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* write eob xlog */</comment>        
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>n_eobs</name></name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>, <argument><expr><name>SizeOfExtendEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * write xlog for esa
         */</comment>
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_SCANTAIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*
         * write xlog for tail eme
         */</comment>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * write xlog for target eme
         */</comment>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>targ_eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>max_freespace</name></name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targ_eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>hwm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* eme page: n_emes */</comment>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name> <operator>=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>PHYSICAL_TARG_EME_BUF</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec_ex</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>,  <argument><expr><name>targ_eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>            
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_ex</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>targ_eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_APPEND_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>,  <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,  <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>,  <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>( <argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>( <argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>( <argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>( <argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targ_eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]AppendExtentOnlyScan:[rel:%d/%d/%d][mode:1:scanlist is empty]"</literal>
                        <literal type="string">"[sid:%d, eid:%d]"</literal>
                        <literal type="string">"[seteob:blocknum=%d,offset=%d]"</literal>
                        <literal type="string">"[setesa:blocknum=%d,offset=%d,scantail=%d]"</literal>
                        <literal type="string">"[seteme:blocknum=%d,offset=%d,sid=%d,is_occupied=%d,freespace=%d,allpointer set to INVALIDEID]"</literal>
                        <literal type="string">"[setemepage:blocknum=%d, n_emes=%d]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                        <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name><name>eme_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>is_occupied</name></name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>,
                        <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>xlrec_ex</name><operator>.</operator><name>n_emes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>shard_add_extent_to_alloclist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_error</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type> <name>sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_alloc</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_scan</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * STEP 0: check if this extent is occupied?
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>occupied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>next_alloc</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>occupied</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ignore_error</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"this extent %d is not belong to any shard."</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    
    <comment type="block">/*
     * STEP 1: check if this extent is in alloc list?
     */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_alloc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>==</operator> <name>eid</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* extent is in alloclist now. */</comment>
        <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
     
    <comment type="block">/*
     * STEP 2: check if this extent is in scan list?
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>in_scanlist</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>in_scanlist</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>next_scan</name> <operator>=</operator> <call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_scan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>!=</operator> <name>eid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>in_scanlist</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* extent is not in scan list now. */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>in_scanlist</name></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"extentmap is inconsistent. extent %d with shardid %d is not in shard scan list."</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//shard_add_extent(rel, sid, eid);</comment>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * STEP3: add this extent into alloc list?
     */</comment>    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <comment type="block">/* only need to set anchor */</comment>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>addr</name> <init>= <expr><call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name> <init>= <expr><call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOC</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_MAKE_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]MakeAvailable:[rel:%d/%d/%d][mode1:and a extent to a empty scanlist]"</literal>
                        <literal type="string">"[sid:%d, eid:%d]"</literal>
                        <literal type="string">"[setesa:blocknum=%d,offset=%d,allochead=%d,alloctail=%d]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                        <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else  <comment type="block">/* anchor-&gt;alloc_head is valid */</comment>
    <block>{<block_content>
        <comment type="block">/*
        * STEP 2: add extent to alloc list
        */</comment>
        <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&lt;</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* add this extent to the head of alloclist */</comment>
            <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>ema_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAAddress</name></type> <name>ema_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>ema_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ema_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* 
             * get and lock esa buffer 
             */</comment>
            <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 
             * get and lock ema buffer 
             */</comment>
            <expr_stmt><expr><name>ema_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>ema_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* 
             * set next alloc extent of target extent to first extent in alloclist
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ema_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* 
             * set alloclist head to the target extent 
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC_HEAD</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/* 
             * write xlog
             */</comment>
            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* xlog for esa */</comment>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOCHEAD</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* xlog for eme */</comment>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ema_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>ema_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ema_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ema_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ema_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ema_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            
            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_MAKE_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]MakeAvailable:[rel:%d/%d/%d][mode2:insert a extent to the head of scanlist]"</literal>
                            <literal type="string">"[sid:%d, eid:%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,allochead=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,eid=%d,allocnext=%d]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>ema_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>ema_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eme1_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eme2_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>    
            <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme1_addr</name></decl>, <decl><type ref="prev"/><name>eme2_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme1_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme2_xlrec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtentID</name></type>    <name>e_left</name></decl>, <decl><type ref="prev"/><name>e_right</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* search point to insert to alloc list */</comment>            
            <expr_stmt><expr><name>e_left</name> <operator>=</operator> <name>e_right</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>

            <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>e_right</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                
                <if_stmt><if>if<condition>(<expr><name>e_left</name> <operator>==</operator> <name>eid</name> <operator>||</operator> <name>e_right</name> <operator>==</operator> <name>eid</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* error: this free extent has been already added to scan list. */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"system is trying to add a extent in alloc list to its alloc list again."</literal>
                                    <literal type="string">" shardid:%d, extentid:%d."</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call>
                    <operator>||</operator> <operator>(</operator><name>e_left</name> <operator>&lt;</operator> <name>eid</name> <operator>&amp;&amp;</operator> <name>eid</name> <operator>&lt;</operator> <name>e_right</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>                

                <expr_stmt><expr><name>e_left</name> <operator>=</operator> <name>e_right</name></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="block">/* 
             * get and lock esa buffer if needed 
             */</comment>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* 
             * get and lock insert point buffer 
             */</comment>
            <expr_stmt><expr><name>eme1_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eme1_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 
             * get and lock buffer which contain target extent if need
             */</comment>
            <expr_stmt><expr><name>eme2_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><name>eme2_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* 
             * set alloc next of insert pointer to target extent 
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>eme1_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* set next point of target extent if need */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name>e_right</name></expr>;</expr_stmt>
                
                <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>eme2_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* set alloc tail of esa if need*/</comment>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC_TAIL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOCTAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_MAKE_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>esa_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>eme2_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>eme2_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>esa_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_right</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]MakeAvailable:[rel:%d/%d/%d][mode3:insert a extent to scanlist]"</literal>
                                <literal type="string">"[sid:%d, eid:%d]"</literal>
                                <literal type="string">"[seteme1:blocknum=%d,offset=%d,eid=%d,allocnext=%d]"</literal>
                                <literal type="string">"[seteme2:blocknum=%d,offset=%d,eid=%d,allocnext=%d]"</literal></expr></argument>,
                                <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>e_right</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]MakeAvailable:[rel:%d/%d/%d][mode4:insert a extent to the tail of scanlist]"</literal>
                                <literal type="string">"[sid:%d, eid:%d]"</literal>
                                <literal type="string">"[setesa:blocknum=%d,offset=%d,alloctail=%d]"</literal>
                                <literal type="string">"[seteme1:blocknum=%d,offset=%d,eid=%d,allocnext=%d]"</literal></expr></argument>,
                                <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>e_left</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>shard_remove_extent_from_alloclist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_error</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_lock_shard</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>eid_not_exist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>        <name>sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>     <name>checking_sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>occupied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_alloc</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>next_alloc</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><operator>!</operator><name>ignore_error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>occupied</name> <operator>||</operator> <operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>ignore_error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend %d is not belong to any shard"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>need_lock_shard</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* 
     * add this extent to alloc list and scan list 
     * If system crash in this point, the free extent will be leaked.
     */</comment>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>!=</operator> <name>eid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_alloc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>ignore_error</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>need_lock_shard</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend %d is not belong to shard %d alloclist"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>eid_not_exist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>==</operator> <name>eid</name></expr>)</condition>
    <block>{<block_content>    
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
            
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>next_eid</name> <init>= <expr><call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checking_sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name></decl>, <decl><type ref="prev"/><name>eme_buf</name></decl>;</decl_stmt>    
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme_addr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* 
         * set anchor alloc head 
         */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC_HEAD</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>next_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOCHEAD</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_head</name></name> <operator>=</operator> <name>next_eid</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                                    <argument><expr><name>InvalidExtentID</name></expr></argument>, <argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOC</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 
         * set alloc next of eme removed
         */</comment>
        <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,<argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        

        <comment type="block">/*write xlog*/</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <comment type="block">/* write xlog */</comment>
            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_MAKE_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_eid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]RemoveFromAllocList:[rel:%d/%d/%d][mode1.1:remove head of scanlist]"</literal>
                            <literal type="string">"[sid:%d, eid:%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,allochead=%d]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,eid=%d,allocnext=InvalidExtentID]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>next_eid</name></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]RemoveFromAllocList:[rel:%d/%d/%d][mode1.2:remove head of scanlist]"</literal>
                            <literal type="string">"[sid:%d, eid:%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,allochead=InvalidExtentID,alloctail=InvalidExtentID]"</literal>
                            <literal type="string">"[seteme:blocknum=%d,offset=%d,eid=%d,allocnext=InvalidExtentID]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme1_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme2_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>curr</name></decl>, <decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checking_sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>next</name> <operator>==</operator> <name>eid</name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>eid_not_exist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eme1_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eme2_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>    
            <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme1_addr</name></decl>, <decl><type ref="prev"/><name>eme2_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_next</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

            <comment type="block">/*
             * lock buffer for esa page if need
             * register block no of xlog : 0
             */</comment>
            <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>==</operator> <name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * lock buffer for removing point
             * register block no of xlog : 1
             */</comment>
            <expr_stmt><expr><name>eme1_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eme1_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * lock buffer for target eme if need.
             * register block no of xlog : 2
             */</comment>
            <expr_stmt><expr><name>eme2_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>curr</name></expr></argument>,<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><name>eme2_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Buffer</name></type> <name>tmp</name> <init>= <expr><ternary><condition><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>eme2_buf</name></expr> </then><else>: <expr><name>eme1_buf</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>EMAPage</name></type> <name>pg</name> <init>= <expr><operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>next_next</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_next</name></expr>;</expr_stmt>            
            </block_content>}</block>
            
            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/*
             * update eme of removing point
             * set allocnext of current extent to next alloc of next 
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>eme1_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>alloc_next</name></name> <operator>=</operator> <name>next_next</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 
             * update target eme to be removed if need
             * set allocnext of next extent
             * it does not need to be updated if the target eme is the tail of alloc list.
             */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>    
                    <comment type="block">/*
                     * xlog is registered to buffer no.2 if target eme is not at same page as removing point eme.
                     */</comment>
                    <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,<argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>eme2_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * xlog is registered to buffer no.1 if target eme is at same page as removing point eme.
                     */</comment>
                    <expr_stmt><expr><call><name>PAGE_SET_EME_ALLOC_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,<argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_ALLOCNEXT</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme2_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * update alloc tail of esa if target eme is exactly right the tail of alloc list
             */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PAGE_SET_ESA_ALLOC_TAIL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                                        <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_ALLOCTAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>alloc_tail</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>    

            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_MAKE_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>esa_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>eme2_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>eme2_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>esa_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>==</operator> <name><name>anchor</name><operator>.</operator><name>alloc_tail</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]RemoveFromAllocList:[rel:%d/%d/%d][mode2.1:remove one extent from scanlist]"</literal>
                                    <literal type="string">"[sid:%d, eid:%d]"</literal>
                                    <literal type="string">"[setesa:blocknum=%d,offset=%d,alloctail=%d]"</literal>
                                    <literal type="string">"[seteme1:blocknum=%d,offset=%d,eid=%d,allocnext=%d]"</literal>
                                    <literal type="string">"[seteme2:blocknum=%d,offset=%d,eid=%d,allocnext=InvalidExtentID]"</literal></expr></argument>,
                                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                    <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                    <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>curr</name></expr></argument>,
                                    <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>,
                                    <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]RemoveFromAllocList:[rel:%d/%d/%d][mode2.2:remove one extent from scanlist]"</literal>
                                    <literal type="string">"[sid:%d, eid:%d]"</literal>
                                    <literal type="string">"[setesa:blocknum=%d,offset=%d,alloctail=%d]"</literal>
                                    <literal type="string">"[seteme1:blocknum=%d,offset=%d,eid=%d,allocnext=InvalidExtentID]"</literal></expr></argument>,
                                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                    <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                    <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>curr</name></expr></argument>,
                                    <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]RemoveFromAllocList:[rel:%d/%d/%d][mode2.3:remove one extent from scanlist]"</literal>
                                    <literal type="string">"[sid:%d, eid:%d]"</literal>
                                    <literal type="string">"[seteme1:blocknum=%d,offset=%d,eid=%d,allocnext=%d]"</literal>
                                    <literal type="string">"[seteme2:blocknum=%d,offset=%d,eid=%d,allocnext=InvalidExtentID]"</literal></expr></argument>,
                                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                    <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                    <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>,
                                    <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]RemoveFromAllocList:[rel:%d/%d/%d][mode2.4:remove one extent from scanlist]"</literal>
                                    <literal type="string">"[sid:%d, eid:%d]"</literal>
                                    <literal type="string">"[seteme1:blocknum=%d,offset=%d,eid=%d,allocnext=InvalidExtentID]"</literal></expr></argument>,
                                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                    <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                    <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>need_lock_shard</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>eid_not_exist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extent %d is not belong to shard %d"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>shard_remove_extent_from_scanlist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_error</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_lock_shard</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>eid_not_exist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>        <name>sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>     <name>checking_sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>occupied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_scan</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>next_scan</name> <operator>=</operator> <call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><operator>!</operator><name>ignore_error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>occupied</name> <operator>||</operator> <operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>ignore_error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend %d is not belong to any shard"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>need_lock_shard</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* 
     *.
     */</comment>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><name><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>!=</operator> <name>eid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_scan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>ignore_error</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>need_lock_shard</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extend %d is not belong to shard %d alloclist"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>eid_not_exist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>==</operator> <name>eid</name></expr>)</condition>
    <block>{<block_content>    
        <decl_stmt><decl><type><name>xl_extent_seteob</name></type> <name>eob_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>        
        <decl_stmt><decl><type><name>xl_extent_cleaneme</name></type> <name>eme_xlrec</name></decl>;</decl_stmt>
            
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>next_eid</name> <init>= <expr><call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checking_sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Buffer</name></type> <name>eob_buf</name></decl>, <decl><type ref="prev"/><name>esa_buf</name></decl>, <decl><type ref="prev"/><name>eme_buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EOBAddress</name></type> <name>eob_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme_addr</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETEOB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eob_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_CLEANEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * lock eob page 0
         */</comment>
        <expr_stmt><expr><name>eob_addr</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * lock esa page 1
         */</comment>
        <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * lock ema page 2
         */</comment>
        <expr_stmt><expr><name>eme_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eme_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * set eob page
         */</comment>
        <expr_stmt><expr><call><name>eob_page_mark_extent</name><argument_list>(<argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eob_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eob_xlrec</name><operator>.</operator><name>setfree</name></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        
        <comment type="block">/* 
         * set anchor scan head 
         */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_eid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PAGE_SET_ESA_SCAN_HEAD</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>next_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_SCANHEAD</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_head</name></name> <operator>=</operator> <name>next_eid</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>PAGE_SET_ESA_SCAN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                                    <argument><expr><name>InvalidExtentID</name></expr></argument>, <argument><expr><name>InvalidExtentID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_SCAN</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* 
         * set scan next of eme removed
         */</comment>
        <expr_stmt><expr><call><name>ema_page_free_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>eme_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        

        <comment type="block">/*write xlog*/</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
            <comment type="block">/* write xlog */</comment>
            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eob_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>eme_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme_xlrec</name></expr></argument>, <argument><expr><name>SizeOfCleanEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_DETACH_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_eid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]DeattachExtent:[rel:%d/%d/%d][mode1:scanlist has only one extent]"</literal>
                            <literal type="string">"[sid:%d, eid:%d]"</literal>
                            <literal type="string">"[freeob:blocknum=%d,offset=%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,scanhead=%d]"</literal>
                            <literal type="string">"[freeeme:blocknum=%d,offset=%d]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>next_eid</name></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]DeattachExtent:[rel:%d/%d/%d][mode2:remove a internal element of scanlist]"</literal>
                            <literal type="string">"[sid:%d, eid:%d]"</literal>
                            <literal type="string">"[freeob:blocknum=%d,offset=%d]"</literal>
                            <literal type="string">"[setesa:blocknum=%d,offset=%d,scanhead=InvalidExtentID,scantail=InvalidExtentID]"</literal>
                            <literal type="string">"[freeeme:blocknum=%d,offset=%d]"</literal></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                            <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                            <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                            <argument><expr><name><name>eme_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>xl_extent_seteob</name></type> <name>eob_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_setesa</name></type> <name>esa_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_seteme</name></type> <name>eme1_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>xl_extent_cleaneme</name></type> <name>eme2_xlrec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>curr</name></decl>, <decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>INIT_EXLOG_SETEOB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eob_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_SETESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>INIT_EXLOG_SETEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_EXLOG_CLEANEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>
        <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checking_sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>next</name> <operator>==</operator> <name>eid</name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>eid_not_exist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eob_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>esa_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eme1_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eme2_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type> <name>eme2_buf_alias</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EOBAddress</name></type> <name>eob_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ESAAddress</name></type> <name>esa_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAAddress</name></type> <name>eme1_addr</name></decl>, <decl><type ref="prev"/><name>eme2_addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExtentID</name></type>    <name>next_next</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>

            <comment type="block">/*
             * lock eob page 0
             */</comment>
            <expr_stmt><expr><name>eob_addr</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
            <comment type="block">/*
             * lock buffer for esa page if need
             * register block no of xlog : 1
             */</comment>
            <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>==</operator> <name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>esa_addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>esa_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * lock buffer for removing point
             * register block no of xlog : 2
             */</comment>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eme1_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eme1_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * lock buffer for target eme if need.
             * register block no of xlog : 3
             */</comment>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eme2_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EME_IN_SAME_PAGE</name><argument_list>(<argument><expr><name>curr</name></expr></argument>,<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><name>eme2_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>eme2_buf_alias</name> <operator>=</operator> <ternary><condition><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>eme2_buf</name></expr> </then><else>: <expr><name>eme1_buf</name></expr></else></ternary></expr>;</expr_stmt>        
            <expr_stmt><expr><name>next_next</name> <operator>=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>eme2_buf_alias</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ema</name><index>[<expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>]</index></name><operator>.</operator><name>alloc_next</name></expr>;</expr_stmt>            
            
            <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * 0 : set eob page
             */</comment>
            <expr_stmt><expr><call><name>eob_page_mark_extent</name><argument_list>(<argument><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eob_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eob_xlrec</name><operator>.</operator><name>setfree</name></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eob_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/*
             * 1: set esa page
             * update alloc tail of esa if target eme is exactly right the tail of alloc list
             */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PAGE_SET_ESA_SCAN_TAIL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,
                                        <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>ESA_SETFLAG_SCANTAIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>INIT_ESA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>esa_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>esa_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetESA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>    

            <comment type="block">/*
             * 2 : set removing point link
             * update eme of removing point
             * set allocnext of current extent to next alloc of next 
             */</comment>
            <expr_stmt><expr><call><name>PAGE_SET_EME_SCAN_NEXT</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>,<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>setflag</name></name> <operator>=</operator> <name>EMA_SETFLAG_SCANNEXT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INIT_EME</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>eme1_xlrec</name><operator>.</operator><name>eme</name><operator>.</operator><name>scan_next</name></name> <operator>=</operator> <name>next_next</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>eme1_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme1_xlrec</name></expr></argument>, <argument><expr><name>SizeOfSetEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 
             * 3: set target eme
             * update target eme to be removed if need
             * set allocnext of next extent
             * it does not need to be updated if the target eme is the tail of alloc list.
             */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>    
                    <comment type="block">/*
                     * xlog is registered to buffer no.3 if target eme is not at same page as removing point eme.
                     */</comment>
                    <expr_stmt><expr><call><name>ema_page_free_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>eme2_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfCleanEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/*
                     * xlog is registered to buffer no.2 if target eme is at same page as removing point eme.
                     */</comment>
                    <expr_stmt><expr><call><name>ema_page_free_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name><name>eme2_xlrec</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>eme2_xlrec</name></expr></argument>, <argument><expr><name>SizeOfCleanEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>            
            
            <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_DETACH_EXTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>esa_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>eme2_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>esa_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>esa_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme1_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>eme2_buf</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eme2_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    

            <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>==</operator> <name><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]DeattachExtent:[rel:%d/%d/%d][mode3:remove the tail of scanlist]"</literal>
                                <literal type="string">"[sid:%d, eid:%d]"</literal>
                                <literal type="string">"[freeeob:blocknum=%d,offset=%d]"</literal>
                                <literal type="string">"[setesa:blocknum=%d,offset=%d,scantail=%d]"</literal>
                                <literal type="string">"[seteme:blocknum=%d,offset=%d,scannext=%d]"</literal>
                                <literal type="string">"[cleaneme:blocknum=%d,offset=%d]"</literal></expr></argument>,
                                <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                                <argument><expr><name><name>esa_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>esa_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name><name>esa_xlrec</name><operator>.</operator><name>anchor</name><operator>.</operator><name>scan_tail</name></name></expr></argument>,
                                <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>,
                                <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]DeattachExtent:[rel:%d/%d/%d][mode4:remove a internal extent of scanlist]"</literal>
                                <literal type="string">"[sid:%d, eid:%d]"</literal>
                                <literal type="string">"[freeeob:blocknum=%d,offset=%d]"</literal>
                                <literal type="string">"[seteme:blocknum=%d,offset=%d,scannext=%d]"</literal>
                                <literal type="string">"[cleaneme:blocknum=%d,offset=%d]"</literal></expr></argument>,
                                <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                                <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>,
                                <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>,
                                <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme1_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>,
                                <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>eme2_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>need_lock_shard</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>eid_not_exist</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extent %d is not belong to shard %d"</literal></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>ExtentID</name></type> 
<name>shard_apply_free_extent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type>     <name>eid</name></decl>;</decl_stmt>
<label><name>reget_eid</name>:</label>
    <comment type="block">/* get free extent from eob page and set it */</comment>
    <expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>eob_get_free_extent_and_set_busy</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check this extentid is indeed free in page
      * TODO: check
      */</comment>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>InvalidExtentID</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* init eme */</comment>
    <comment type="line">//ema_init_eme(rel, eid, sid);</comment>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>shard_add_extent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>reget_eid</name>;</goto></block_content></block></if></if_stmt>
    <return>return <expr><name>eid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>repair_eme</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blk</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    
</block_content>}</block></function>

<comment type="block">/*
 * add new extent to shard list if there is no available extent
 */</comment>
<function><type><name>ExtentID</name></type>
<name>GetExtentWithFreeSpace</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>min_cat</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name> <init>= <expr><call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>e_idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>e_next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>result</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>        <name>avail</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>e_idx</name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>

        <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>e_idx</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ShardID</name></type> <name>e_sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>    <name>occupied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>e_next</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>e_idx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e_sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>occupied</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"eid %d is in the list of shard %d, but the occupation flag is false."</literal></expr></argument>,
                        <argument><expr><name>e_idx</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name>occupied</name> <operator>&amp;&amp;</operator> <name>e_sid</name> <operator>!=</operator> <name>sid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"eid %d is in the list of shard %d, but shardid of EME is %d."</literal></expr></argument>,
                        <argument><expr><name>e_idx</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>e_sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if<condition>(<expr><name>avail</name> <operator>&gt;=</operator> <name>min_cat</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>e_idx</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>e_idx</name> <operator>=</operator> <name>e_next</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>            
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>result</name> <operator>==</operator> <name>InvalidExtentID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>shard_apply_free_extent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extend extent for relation if no avaible extents.
 * eid is passed for check consistency extentmapping
 */</comment>
<function><type><name>void</name></type>
<name>ExtendExtentForShard</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>freespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_rebuild</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="line">//smgrnblocks(rel-&gt;rd_smgr, MAIN_FORKNUM);</comment>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>eob_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>ema_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBPage</name></type>    <name>eob_pg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAPage</name></type> <name>ema_pg</name></decl>;</decl_stmt>
    <comment type="line">//XLogRecPtr    recptr;</comment>

    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>ema_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>eob_addr</name></decl>;</decl_stmt>

    <comment type="line">//xl_extent_extendeob xlrec_eob;</comment>
    <comment type="line">//xl_extent_initeme xlrec_initeme;</comment>
    <comment type="line">//xl_extent_extendeme xlrec_ex;</comment>
    
    <decl_stmt><decl><type><name>bool</name></type>    <name>ema_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>eob_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="line">//INIT_EXLOG_EXTENDEOB(&amp;xlrec_eob);</comment>
    <comment type="line">//INIT_EXLOG_INITEME(&amp;xlrec_initeme);</comment>
    <comment type="line">//INIT_EXLOG_EXTENDEME(&amp;xlrec_ex);</comment>
    
    <comment type="block">/*
     * STEP 1: get page of  EOB
     * registred block no: 0
     */</comment>
    <block>{<block_content>
        <expr_stmt><expr><name>eob_addr</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>eob_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <goto>goto <name>extent_mapping_error</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>eob_pg</name> <operator>=</operator> <operator>(</operator><name>EOBPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>==</operator> <name><name>eob_pg</name><operator>-&gt;</operator><name>max_bits</name></name> <operator>&amp;&amp;</operator> <name><name>eob_pg</name><operator>-&gt;</operator><name>max_bits</name></name> <operator>==</operator> <name>EOBS_PER_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>!=</operator> <name><name>eob_pg</name><operator>-&gt;</operator><name>max_bits</name></name> <operator>||</operator> <name><name>eob_pg</name><operator>-&gt;</operator><name>max_bits</name></name> <operator>!=</operator> <name>EOBS_PER_PAGE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>eob_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>extent_mapping_error</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
        
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>eob_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <goto>goto <name>extent_mapping_error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>eob_pg</name> <operator>=</operator> <operator>(</operator><name>EOBPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>==</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>eob_pg</name><operator>-&gt;</operator><name>n_bits</name></name> <operator>!=</operator> <name><name>eob_addr</name><operator>.</operator><name>local_bms_offset</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>eob_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>extent_mapping_error</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    
    <comment type="block">/*
     * STEP 2: get page of EME
     * registred block no: 1
     */</comment>
    <block>{<block_content>
        <expr_stmt><expr><name>ema_addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ema_addr</name><operator>.</operator><name>local_idx</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>ema_addr</name><operator>.</operator><name>physical_page_number</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ema_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <goto>goto <name>extent_mapping_error</name>;</goto>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ema_pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>ema_pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>==</operator> <name><name>ema_pg</name><operator>-&gt;</operator><name>max_emes</name></name> <operator>&amp;&amp;</operator> <name><name>ema_pg</name><operator>-&gt;</operator><name>max_emes</name></name> <operator>==</operator> <name>EMES_PER_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name><name>ema_pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>!=</operator> <name><name>ema_pg</name><operator>-&gt;</operator><name>max_emes</name></name> <operator>||</operator> <name><name>ema_pg</name><operator>-&gt;</operator><name>max_emes</name></name> <operator>!=</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ema_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>extent_mapping_error</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>ema_addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ema_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <goto>goto <name>extent_mapping_error</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ema_pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><name><name>ema_pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>==</operator> <name><name>ema_addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>ema_pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>!=</operator> <name><name>ema_addr</name><operator>.</operator><name>local_idx</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ema_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>extent_mapping_error</name>;</goto>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    START_CRIT_SECTION();

    XLogBeginInsert();
    <comment type="block">/*
     * set page of EOB 
     */</comment>
    {
        eob_pg-&gt;n_bits++;
        MarkBufferDirty(eob_buf);
        <comment type="block">/* write xlog */</comment>        
        XLogRegisterBuffer(0, eob_buf, REGBUF_KEEP_DATA);
        xlrec_eob.slot = eob_addr.local_bms_offset;
        xlrec_eob.n_eobs = eob_pg-&gt;n_bits;
        XLogRegisterBufData(0, (char *)&amp;xlrec_eob, SizeOfExtendEOB);    
    }

    <comment type="block">/*
     * set page of EME
     */</comment>
    {
        <comment type="line">//ema_page_occup_eme(BufferGetPage(ema_buf), ema_addr.local_idx);</comment>
        ema_pg-&gt;n_emes++;
        MarkBufferDirty(ema_buf);

        <comment type="block">/* write xlog */</comment>
        XLogRegisterBuffer(1, ema_buf, REGBUF_KEEP_DATA);
        <comment type="line">//xlrec_initeme.slot = ema_addr.local_idx;</comment>
        <comment type="line">//xlrec_initeme.freespace = 0;</comment>
        <comment type="line">//xlrec_initeme.shardid = 0;</comment>
        <comment type="line">//XLogRegisterBufData(1, (char *)&amp;xlrec_initeme, SizeOfInitEME);</comment>
        xlrec_ex.n_emes = ema_pg-&gt;n_emes;
        XLogRegisterBufData(1, (char *)&amp;xlrec_ex, SizeOfExtendEME);
    }

    recptr = XLogInsert(RM_EXTENT_ID, XLOG_EXTENT_NEW_EXTENT);
    PageSetLSN(BufferGetPage(eob_buf), recptr);
    PageSetLSN(BufferGetPage(ema_buf), recptr);
    END_CRIT_SECTION();
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * STEP 3: link to shard lists(scan list and alloc list)
     */</comment>
    <if_stmt><if>if<condition>(<expr><name>freespace</name> <operator>&gt;</operator> <name>EXTENT_SAVED_MINCAT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>shard_append_extent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>, <argument><expr><name>for_rebuild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>shard_append_extent_onlyscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return;</return>
<label><name>extent_mapping_error</name>:</label>
    <if_stmt><if>if<condition>(<expr><name>ema_error</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extentmapping is error. ema_error:%d, eob_error:%d"</literal></expr></argument>, <argument><expr><name>ema_error</name></expr></argument>, <argument><expr><name>eob_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Only be called during rebuilding extent map.
 */</comment>
<function><type><name>void</name></type> 
<name>ExtendExtentForRebuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>tmp_eid</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>last_eid</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tmp_eid</name> <operator>=</operator> <call><name>extent_extend_for_rebuild</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* avoid infinite looping*/</comment>
        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>last_eid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>last_eid</name> <operator>==</operator> <name>tmp_eid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot extend relation %d/%d/%d extent eid from %d to %d"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name>last_eid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>tmp_eid</name> <operator>&gt;</operator> <name>eid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extentd relation %d/%d/%d error. "</literal>
                        <literal type="string">"Caller was supposed to extend up to %d, but actually extend to %d"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>tmp_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if<condition>(<expr><name>tmp_eid</name> <operator>==</operator> <name>eid</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>last_eid</name> <operator>=</operator> <name>tmp_eid</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>extent_extend_for_rebuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>XLogRecPtr</name></type>    <name>recptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>eob_old_max_eid</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EOBAddress</name></type> <name>eob_new_max_eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>   <name>eob_old_extent</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>ema_old_max_eid</name> <init>= <expr><block>{<expr><name>EMAPAGE_OFFSET</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAAddress</name></type> <name>ema_new_max_eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>   <name>ema_old_extent</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>target_eid</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>xl_extent_extendeob</name></type> <name>xlrec_eob</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_extent_extendeme</name></type> <name>xlrec_eme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>eob_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>ema_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>blkno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>bits</name></decl>;</decl_stmt>

    <comment type="block">/* find the old max eob*/</comment>
    <for>for<control>(<init><expr><name>blkno</name> <operator>=</operator> <name>EOBPAGE_OFFSET</name></expr>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>EOB_TOPPAGE</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>EOBPage_IS_EMPTY</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>eob_old_max_eid</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eob_old_max_eid</name><operator>.</operator><name>local_bms_offset</name></name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EOBPage_IS_FULL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* find the old max ema*/</comment>
    <for>for<control>(<init><expr><name>blkno</name> <operator>=</operator> <name>EMAPAGE_OFFSET</name></expr>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>EMA_TOPPAGE</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>EMAPage_IS_EMPTY</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>ema_old_max_eid</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ema_old_max_eid</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>EMAPage_IS_FULL</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>eob_old_extent</name> <operator>=</operator> <call><name>eob_address_to_eid</name><argument_list>(<argument><expr><name>eob_old_max_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ema_old_extent</name> <operator>=</operator> <call><name>ema_address_to_eid</name><argument_list>(<argument><expr><name>ema_old_max_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>eob_old_extent</name> <operator>!=</operator> <name>ema_old_extent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"eob max extentid %d isn't as same as ema max extentid %d."</literal></expr></argument>,
                    <argument><expr><name>eob_old_extent</name></expr></argument>,
                    <argument><expr><name>ema_old_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&lt;</operator> <name>eob_old_extent</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"eob page has error. max extent is %d, but heap is less than extent %d."</literal></expr></argument>,
                <argument><expr><name>eob_old_extent</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>eid</name> <operator>&lt;</operator> <name>ema_old_extent</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ema page has error. max extent is %d, but heap is less than extent %d."</literal></expr></argument>,
                <argument><expr><name>ema_old_extent</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Only one eob page and one emapage can be updated at one time.
     * Get the max eid which I can extend at this time
     */</comment>
    <expr_stmt><expr><name>target_eid</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>target_eid</name> <operator>-</operator> <name>eob_old_extent</name> <operator>&gt;</operator> <name>EOBS_PER_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>target_eid</name> <operator>=</operator> <name>eob_old_extent</name> <operator>+</operator> <name>EOBS_PER_PAGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>target_eid</name> <operator>-</operator> <name>ema_old_extent</name> <operator>&gt;</operator> <name>EMES_PER_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>target_eid</name> <operator>=</operator> <name>ema_old_extent</name> <operator>+</operator> <name>EMES_PER_PAGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>eob_new_max_eid</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>target_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ema_new_max_eid</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>target_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name><name>eob_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name> <operator>&gt;</operator> <name><name>eob_old_max_eid</name><operator>.</operator><name>physical_page_number</name></name>
        <operator>&amp;&amp;</operator> <name><name>eob_old_max_eid</name><operator>.</operator><name>local_bms_offset</name></name> <operator>&lt;</operator> <name>EOBS_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>eob_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name><name>eob_old_max_eid</name><operator>.</operator><name>physical_page_number</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>eob_new_max_eid</name><operator>.</operator><name>local_bms_offset</name></name> <operator>=</operator> <name>EOBS_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>target_eid</name> <operator>=</operator> <call><name>eob_address_to_eid</name><argument_list>(<argument><expr><name>eob_new_max_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>ema_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name> <operator>&gt;</operator> <name><name>ema_old_max_eid</name><operator>.</operator><name>physical_page_number</name></name>
        <operator>&amp;&amp;</operator> <name><name>ema_old_max_eid</name><operator>.</operator><name>local_idx</name></name> <operator>&lt;</operator> <name>EMES_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ema_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name> <operator>=</operator> <name><name>ema_old_max_eid</name><operator>.</operator><name>physical_page_number</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ema_new_max_eid</name><operator>.</operator><name>local_idx</name></name> <operator>=</operator> <name>EMES_PER_PAGE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>target_eid</name> <operator>&gt;</operator> <call><name>ema_address_to_eid</name><argument_list>(<argument><expr><name>ema_new_max_eid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>target_eid</name> <operator>=</operator> <call><name>ema_address_to_eid</name><argument_list>(<argument><expr><name>ema_new_max_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>eob_new_max_eid</name> <operator>=</operator> <call><name>eob_eid_to_address</name><argument_list>(<argument><expr><name>target_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ema_new_max_eid</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name>target_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>INIT_EXLOG_EXTENDEOB</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INIT_EXLOG_EXTENDEME</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec_eme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* lock eob buffer */</comment>
    <expr_stmt><expr><name>eob_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>eob_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    

    <comment type="block">/* lock ema buffer */</comment>
    <expr_stmt><expr><name>ema_buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>ema_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* update eob page and write xlog */</comment>
    <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <name><name>eob_new_max_eid</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>n_eobs</name></name> <operator>=</operator> <name><name>eob_new_max_eid</name><operator>.</operator><name>local_bms_offset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>EXTEND_EOB_FLAGS_SETFREE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <name><name>eob_new_max_eid</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</expr_stmt>
    
    <for>for<control>(<init><expr><name>bits</name> <operator>=</operator> <call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name></expr>;</init> <condition><expr><name>bits</name> <operator>&lt;=</operator> <name><name>eob_new_max_eid</name><operator>.</operator><name>local_bms_offset</name></name></expr>;</condition> <incr><expr><name>bits</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>bms_add_member</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eob_bits</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>    
    <expr_stmt><expr><call><name>BufferGetEOBPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_bits</name> <operator>=</operator> <name><name>eob_new_max_eid</name><operator>.</operator><name>local_bms_offset</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    
    <comment type="block">/* update ema page and write xlog */</comment>
    <expr_stmt><expr><name><name>xlrec_eme</name><operator>.</operator><name>n_emes</name></name> <operator>=</operator> <name><name>ema_new_max_eid</name><operator>.</operator><name>local_idx</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xlrec_eme</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>EXTEND_EME_FLAGS_SETFREE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xlrec_eme</name><operator>.</operator><name>setfree_start</name></name> <operator>=</operator> <call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xlrec_eme</name><operator>.</operator><name>setfree_end</name></name> <operator>=</operator> <name><name>ema_new_max_eid</name><operator>.</operator><name>local_idx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ema_page_extend_eme</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>, 
                        <argument><expr><name><name>ema_new_max_eid</name><operator>.</operator><name>local_idx</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, 
                        <argument><expr><name>true</name></expr></argument>, 
                        <argument><expr><call><name>BufferGetEMAPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>n_emes</name></expr></argument>,
                        <argument><expr><name><name>ema_new_max_eid</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* write xlog */</comment>
    <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eob_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_eob</name></expr></argument>, <argument><expr><name>SizeOfExtendEOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ema_buf</name></expr></argument>, <argument><expr><name>REGBUF_KEEP_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlrec_eme</name></expr></argument>, <argument><expr><name>SizeOfExtendEME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_EXTEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>eob_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ema_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Extend Extents:[rel:%d/%d/%d]"</literal>
                    <literal type="string">"[new max eid:%d]"</literal>
                    <literal type="string">"[extend eob: ema block number:%d, n_bits:%d,"</literal>
                    <literal type="string">" setfree:%d, setfree_start:%d, setfree_end:%d]"</literal>
                    <literal type="string">"[extend ema: ema block number:%d, n_emes:%d,"</literal>
                    <literal type="string">" setfree:%d, setfree_start:%d, setfree_end:%d]"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name>target_eid</name></expr></argument>,
                    <argument><expr><name><name>eob_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>xlrec_eob</name><operator>.</operator><name>n_eobs</name></name></expr></argument>,
                    <argument><expr><name><name>xlrec_eob</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>EXTEND_EOB_FLAGS_SETFREE</name></expr></argument>, <argument><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_start</name></name></expr></argument>, <argument><expr><name><name>xlrec_eob</name><operator>.</operator><name>setfree_end</name></name></expr></argument>,
                    <argument><expr><name><name>ema_new_max_eid</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name><name>xlrec_eme</name><operator>.</operator><name>n_emes</name></name></expr></argument>,
                    <argument><expr><name><name>xlrec_eme</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>EXTEND_EME_FLAGS_SETFREE</name></expr></argument>, <argument><expr><name><name>xlrec_eme</name><operator>.</operator><name>setfree_start</name></name></expr></argument>, <argument><expr><name><name>xlrec_eme</name><operator>.</operator><name>setfree_end</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>target_eid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * these two types of extents can be free:
 *     1. extents belong to hidden shards
 *     2. extents which has no tuples.
 * caller have to make sure only these two types of extent will be freed
 */</comment>
<function><type><name>void</name></type>
<name>FreeExtent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//Buffer eob_buf;</comment>
    <comment type="line">//EOBPage eob_pg;</comment>
    <comment type="line">//EOBAddress eob_addr;</comment>
    <comment type="line">//XLogRecPtr    recptr;</comment>

    <decl_stmt><decl><type><name>bool</name></type>    <name>occupied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>    <name>sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>occupied</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shard_remove_extent_from_alloclist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shard_remove_extent_from_scanlist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>    
    <comment type="block">/*
     * STEP 1: get page of    EOB
     * registred block no: 0
     */</comment>
    {
        eob_addr = eob_eid_to_address(eid);    
        
        eob_buf = extent_readbuffer(rel, eob_addr.physical_page_number, true);
        ExtentAssert(BufferIsValid(eob_buf));
        LockBuffer(eob_buf, BUFFER_LOCK_EXCLUSIVE);
        eob_pg = (EOBPage)PageGetContents(BufferGetPage(eob_buf));
    }

    
    <comment type="block">/*
     * STEP 2: get page of EME
     * registred block no: 1
     */</comment>
    {
        ema_addr = ema_eid_to_address(eid);
    
        ema_buf = extent_readbuffer(rel, ema_addr.physical_page_number, true);
        ExtentAssert(BufferIsValid(ema_buf));

        LockBuffer(ema_buf, BUFFER_LOCK_EXCLUSIVE);
    }

    START_CRIT_SECTION();

    XLogBeginInsert();
    <comment type="block">/*
     * set page of EOB 
     */</comment>
    {        
        xl_extent_seteob xlrec;
        INIT_EXLOG_SETEOB(&amp;xlrec);
        
        eob_page_mark_extent(eob_pg, eob_addr.local_bms_offset, true);
        MarkBufferDirty(eob_buf);
        <comment type="block">/* write xlog */</comment>        
        XLogRegisterBuffer(0, eob_buf, REGBUF_KEEP_DATA);
        xlrec.slot = eob_addr.local_bms_offset;
        xlrec.setfree  = true;
        XLogRegisterBufData(0, (char *)&amp;xlrec, SizeOfSetEOB);    
    }

    <comment type="block">/*
     * set page of EME
     */</comment>
    {
        xl_extent_cleaneme xlrec;
        INIT_EXLOG_CLEANEME(&amp;xlrec);
        
        ema_page_free_eme(BufferGetPage(ema_buf), ema_addr.local_idx);
        MarkBufferDirty(ema_buf);

        <comment type="block">/* write xlog */</comment>
        XLogRegisterBuffer(1, ema_buf, REGBUF_KEEP_DATA);
        xlrec.slot = ema_addr.local_idx;
        XLogRegisterBufData(1, (char *)&amp;xlrec, SizeOfCleanEME);
    }


    recptr = XLogInsert(RM_EXTENT_ID, XLOG_EXTENT_DETACH_EXTENT);
    PageSetLSN(BufferGetPage(eob_buf), recptr);
    END_CRIT_SECTION();
    UnlockReleaseBuffer(eob_buf);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove extent from alloclist if it has not enough space to put more tuples in.
 * Shorten alloc list can reduce the time of locating extent for inserting rows. 
 * Only called when freespace changing.
 */</comment>
<function><type><name>void</name></type>
<name>MarkExtentFull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>shard_remove_extent_from_alloclist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>MarkExtentAvailable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ExtentID</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>shard_add_extent_to_alloclist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ExtentID</name></type>
<name>GetShardScanHead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name>anchor</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>ExtentID</name></type>
<name>RelOidGetShardScanHead</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>scanhead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>scanhead</name> <operator>=</operator> <call><name>GetShardScanHead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>scanhead</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int
next_free_extent(EOBPage eob_pg, int search_from)
{
    int word_idx;
    int bit_offset = -1;
    int word_slot = search_from / EOBWord_BITLEN ;

    for(word_idx = word_slot; word_idx &lt; EOBWORDS_PER_PAGE; word_idx++)
    {
        if (eob_pg-&gt;eob_bits[word_idx] != 0xFFFFFFFF)
        {
            bit_offset = find_first0_of_int(eob_pg-&gt;eob_bits[word_idx]);            
            break;
        }

        if(word_idx * EOBWord_BITLEN + bit_offset &gt;= eob_pg-&gt;n_bits)
        {
            break;
        }
    }

    if(bit_offset &lt; 0)
        return bit_offset;
    else
        return word_idx * EOBWord_BITLEN + bit_offset;
}


static uint32 find_zero_filters[] = {0xFFFF, 0xFF, 0xF, 0x3, 0x1};
static uint16 find_zero_offsets[] = {16, 8, 4, 2, 1};

static int
find_first0_of_int(EOBWord word)
{
    uint32 seg;
    int i=0;
    int     bit_offset = 0;
    int        ites = sizeof(find_zero_filters) / sizeof(int32);
    seg = word;

    if( word == 0xFFFFFFFF)
        return -1;    
    
    while ( i &lt; ites )
    {
        if((seg &amp; find_zero_filters[i]) == find_zero_filters[i])
        {
            bit_offset += find_zero_offsets[i];
            seg = (seg &gt;&gt; find_zero_offsets[i]) &amp; find_zero_filters[i];
        }
        else
        {
            seg = seg &amp; find_zero_filters[i];
        }
        
        i++;
    }

    return bit_offset;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*-------------------------------------------------------------------------------------------
 *  functions for user to inspect extent info
 *-------------------------------------------------------------------------------------------
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>     <name>eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>is_occupied</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>shardid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>freespace_cat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>hwm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>scan_next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>scan_prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>alloc_next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>alloc_prev</name></decl>;</decl_stmt>
}</block></struct></type><name>MctxStat</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>    <name>currIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>last_eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MctxStat</name></type>    <name><name>mctxstat</name><index>[<expr><name>EMES_PER_PAGE</name></expr>]</index></name></decl>;</decl_stmt>    
}</block></struct></type> <name>ShmMgr_State</name>;</typedef>

<function><type><name>Datum</name></type> <name>pg_extent_info_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENT_STAT_COLUMN_NUM</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>EXTENT_STAT_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"eid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"is_occupied"</literal></expr></argument>,
                         <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"freespace_cat"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"hwm"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"scan_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"scan_prev"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"alloc_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"alloc_prev"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mctx_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mctx_status</name>  <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>


    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name>MAX_EXTENTS</name></expr>)</condition>
    <block>{<block_content>
           <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>EXTENT_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>EXTENT_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MctxStat</name>    <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAPage</name></type>        <name>pg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name></expr>;</expr_stmt>

            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name> <operator>=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freespace_cat</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_prev</name> <operator>=</operator> <call><name>EMEGetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <name>EMES_PER_PAGE</name> 
            <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name><operator>)</operator> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>eid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>is_occupied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>freespace_cat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_extent_info_relname</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENT_STAT_COLUMN_NUM</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>             <name>relOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>string_to_reloid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>EXTENT_STAT_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"eid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"is_occupied"</literal></expr></argument>,
                         <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"freespace_cat"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"hwm"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"scan_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"scan_prev"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"alloc_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"alloc_prev"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mctx_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mctx_status</name>  <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>


    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name>MAX_EXTENTS</name></expr>)</condition>
    <block>{<block_content>
           <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>EXTENT_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>EXTENT_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MctxStat</name>    <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAPage</name></type>        <name>pg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name></expr>;</expr_stmt>

            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name> <operator>=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freespace_cat</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_prev</name> <operator>=</operator> <call><name>EMEGetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <name>EMES_PER_PAGE</name> 
            <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name><operator>)</operator> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>eid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>is_occupied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>freespace_cat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_shard_scan_list_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARD_SCAN_COLUMN_NUM</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>            <name>sid</name> <init>=  <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>        <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type>    <name>anchor</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shardid %d is invalid."</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>SHARD_SCAN_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"eid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"is_occupied"</literal></expr></argument>,
                         <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"freespace_cat"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"hwm"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"scan_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mctx_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mctx_status</name>  <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>curr</name> <init>= <expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>next</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>EMES_PER_PAGE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>     <name>is_occupied</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ShardID</name></type> <name>extent_sid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>        <name>hwm</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8</name></type>     <name>freespace</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_sid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hwm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <name>is_occupied</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>extent_sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freespace_cat</name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name>hwm</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>EMES_PER_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
           <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MctxStat</name>    <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>eid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>is_occupied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>freespace_cat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_shard_scan_list_relname</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARD_SCAN_COLUMN_NUM</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>            <name>sid</name> <init>=  <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>        <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type>    <name>anchor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>relOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shardid %d is invalid."</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>string_to_reloid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>SHARD_SCAN_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"eid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"is_occupied"</literal></expr></argument>,
                         <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"freespace_cat"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"hwm"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"scan_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mctx_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>scan_head</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mctx_status</name>  <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>curr</name> <init>= <expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>next</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>EMES_PER_PAGE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>     <name>is_occupied</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ShardID</name></type> <name>extent_sid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>        <name>hwm</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8</name></type>     <name>freespace</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ema_next_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_sid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hwm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <name>is_occupied</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>extent_sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freespace_cat</name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name>hwm</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>EMES_PER_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
           <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MctxStat</name>    <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>eid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>is_occupied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>freespace_cat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_shard_alloc_list_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARD_SCAN_COLUMN_NUM</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>            <name>sid</name> <init>=  <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>        <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type>    <name>anchor</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shardid %d is invalid."</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>SHARD_SCAN_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"eid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"is_occupied"</literal></expr></argument>,
                         <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"freespace_cat"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"hwm"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"alloc_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mctx_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mctx_status</name>  <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>curr</name> <init>= <expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>next</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>EMES_PER_PAGE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>     <name>is_occupied</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ShardID</name></type> <name>extent_sid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>        <name>hwm</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8</name></type>     <name>freespace</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_sid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hwm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <name>is_occupied</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>extent_sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freespace_cat</name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name>hwm</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>EMES_PER_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
           <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MctxStat</name>    <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>eid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>is_occupied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>freespace_cat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_shard_alloc_list_relname</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARD_SCAN_COLUMN_NUM</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardID</name></type>            <name>sid</name> <init>=  <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>        <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type>    <name>anchor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>relOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shardid %d is invalid."</literal></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>string_to_reloid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>SHARD_SCAN_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"eid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"is_occupied"</literal></expr></argument>,
                         <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"freespace_cat"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"hwm"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"alloc_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mctx_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>anchor</name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name><name>anchor</name><operator>.</operator><name>alloc_head</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mctx_status</name>  <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>,  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>,  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>curr</name> <init>= <expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExtentID</name></type> <name>next</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>EMES_PER_PAGE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>     <name>is_occupied</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ShardID</name></type> <name>extent_sid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>        <name>hwm</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8</name></type>     <name>freespace</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>ema_next_alloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_occupied</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extent_sid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hwm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <name>is_occupied</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name>extent_sid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freespace_cat</name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name>hwm</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_prev</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>EMES_PER_PAGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>last_eid</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>UnlockShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>       <name><name>values</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>SHARD_SCAN_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MctxStat</name>    <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>eid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>is_occupied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>freespace_cat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>inited</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>currIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EMAShardAnchor</name></type> <name><name>esa</name><index>[<expr><name>MAX_SHARDS</name></expr>]</index></name></decl>;</decl_stmt>    
}</block></struct></type> <name>ESA_State</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESA_STAT_COLUMN_NUM</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<function><type><name>Datum</name></type> <name>pg_shard_anchor_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ESA_State</name>   <modifier>*</modifier></type><name>esa_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>ESA_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>ESA_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ESAAddress</name></type>     <name>addr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ESA_STAT_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"pageno"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"slotinpage"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"scanhead"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"scantail"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"allochead"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"alloctail"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>esa_status</name> <operator>=</operator> <operator>(</operator><name>ESA_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ESA_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>esa_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>esa_status</name>  <operator>=</operator> <operator>(</operator><name>ESA_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>esa_status</name><operator>-&gt;</operator><name>inited</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>         <name>shardidx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>     <name>rel</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %d is not organized with extent."</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
                
        <for>for<control>(<init><expr><name>shardidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>  <condition><expr><name>shardidx</name> <operator>&lt;</operator> <name>MAX_SHARDS</name></expr>;</condition> <incr><expr><name>shardidx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name>shardidx</name></expr>]</index></name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>shardidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>        
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name>MAX_SHARDS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>scan_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>scan_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>alloc_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>alloc_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_shard_anchor_relname</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ESAAddress</name></type>     <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>relOid</name> <init>= <expr><call><name>string_to_reloid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ESA_State</name>   <modifier>*</modifier></type><name>esa_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>ESA_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>ESA_STAT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ESA_STAT_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>( <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>( <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"pageno"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>( <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"slotinpage"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>( <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"scanhead"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>( <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"scantail"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>( <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"allochead"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>( <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"alloctail"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>esa_status</name> <operator>=</operator> <operator>(</operator><name>ESA_State</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ESA_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>esa_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>esa_status</name>  <operator>=</operator> <operator>(</operator><name>ESA_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>esa_status</name><operator>-&gt;</operator><name>inited</name></name></expr> )</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relation</name></type>     <name>rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>         <name>shardidx</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,  <argument><expr><literal type="string">"relation %s is not organized with extent."</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <for>for<control>(<init><expr><name>shardidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>  <condition><expr><name>shardidx</name> <operator>&lt;</operator> <name>MAX_SHARDS</name></expr>;</condition> <incr><expr><name>shardidx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name>shardidx</name></expr>]</index></name> <operator>=</operator> <call><name>esa_get_anchor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>shardidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>        
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&gt;=</operator> <name>MAX_SHARDS</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>esa_sid_to_address</name><argument_list>(<argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>( <argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>( <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>( <argument><expr><name><name>addr</name><operator>.</operator><name>local_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>( <argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>scan_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>( <argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>scan_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>( <argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>alloc_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>( <argument><expr><name><name>esa_status</name><operator>-&gt;</operator><name>esa</name><index>[<expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>alloc_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>esa_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>,  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>,  <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>string_to_reloid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>str1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>str2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>schema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>        <name>reloid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>


    <expr_stmt><expr><name>str1</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">". "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>str1</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">". "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>str1</name> <operator>&amp;&amp;</operator> <name>str2</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>schema</name> <operator>=</operator> <name>str1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>relname</name> <operator>=</operator> <name>str2</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>str1</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>relname</name> <operator>=</operator> <name>str1</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table name %s is invalid."</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>schema</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>namespace_oid</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>namespace_oid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>namespace_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RelnameGetRelid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>reloid</name></expr>)</condition><block type="pseudo"><block_content>            
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table %s is not exist."</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>reloid</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>TruncateExtentMap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>start_eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>end_eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>eid</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>nblocks</name> <operator>%</operator> <name>PAGES_PER_EXTENTS</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"truncation extentmap must begin with start point of a extent."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>start_eid</name> <operator>=</operator> <name>nblocks</name> <operator>/</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end_eid</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]TruncateExtentMap:[rel:%d/%d/%d]start"</literal>
                    <literal type="string">"[starteid:%d, endeid:%d]"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name>start_eid</name></expr></argument>, <argument><expr><name>end_eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <for>for<control>(<init><expr><name>eid</name> <operator>=</operator> <name>end_eid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>eid</name> <operator>&gt;=</operator> <name>start_eid</name> <operator>&amp;&amp;</operator> <call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>eid</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FreeExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>eob_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>start_eid</name></expr></argument>, <argument><expr><name>end_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ema_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>start_eid</name></expr></argument>, <argument><expr><name>end_eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]TruncateExtentMap:[rel:%d/%d/%d]end"</literal>
                    <literal type="string">"[starteid:%d, endeid:%d]"</literal></expr></argument>,
                    <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                    <argument><expr><name>start_eid</name></expr></argument>, <argument><expr><name>end_eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RebuildExtentMap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    
    <decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>        
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>eid</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>begin_skip</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type>    <name>total_extents</name> <init>= <expr><operator>(</operator><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>PAGES_PER_EXTENTS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>PAGES_PER_EXTENTS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>xl_extent_truncate</name></type> <name>xlrec</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %s storage is not organized by extent."</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * truncate exist extent file 
     */</comment>        
    <comment type="line">//TODO: write xlog for truncate extent file</comment>
    <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>smgrdounlinkfork</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>EXTENT_FORKNUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
	<comment type="block">/*
     * clean up the rnode infomation in rel crypt hash table
     */</comment>
	<expr_stmt><expr><call><name>remove_rel_crypt_hash_elem</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_relcrypt</name></name><operator>)</operator></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>INIT_EXLOG_TRUNCATE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>xlrec</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfTruncateExtentSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_EXTENT_ID</name></expr></argument>, <argument><expr><name>XLOG_EXTENT_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*
     * rebuild extentmap of main data
     */</comment>
    <for>for<control>(<init><expr><name>eid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>eid</name> <operator>&lt;</operator> <name>total_extents</name></expr>;</condition> <incr><expr><name>eid</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Buffer</name></type>        <name>data_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Page</name></type>        <name>data_pg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ShardID</name></type>        <name>page_sid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint8</name></type>        <name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>blk</name> <operator>=</operator> <name>eid</name> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>data_buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtentAssert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>data_pg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>page_sid</name> <operator>=</operator> <call><name>PageGetShardId</name><argument_list>(<argument><expr><name>data_pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if<condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>data_pg</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>page_sid</name> <operator>==</operator> <name>InvalidShardID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>begin_skip</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>begin_skip</name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>begin_skip</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExtendExtentForRebuild</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>begin_skip</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>page_sid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"block %d of relation %d/%d/%d has invalid shardid %d"</literal></expr></argument>,
                            <argument><expr><name>blk</name></expr></argument>,
                            <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                            <argument><expr><name>page_sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>        

        <expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>GetMaxAvailWithExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExtendExtentForShard</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page_sid</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>begin_skip</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ExtendExtentForRebuild</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>total_extents</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>begin_skip</name> <operator>=</operator> <name>InvalidExtentID</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/*
     * rebuild extentmap of toast if any
     */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>RelationHasToast</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * lock has be hold already at main table.
         */</comment>
        <decl_stmt><decl><type><name>Relation</name></type> <name>toast_rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>RebuildExtentMap</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check extent info
 */</comment>
 <typedef>typedef <type><enum>enum <name>CheckExtentErrCode</name>
<block>{
    <decl><name>CEEC_NO_ERROR</name></decl>,
    <decl><name>CEEC_BLOCK_NOT_EXIST_IN_HEAP</name></decl>,
    <decl><name>CEEC_EXTENT_NOT_OCCUPIED_IN_CATALOG</name></decl>,
    <decl><name>CEEC_SHARDID_NOT_SAME</name></decl>,
    <decl><name>CEEC_CATALOG_CORRUPTED</name></decl>,
    <decl><name>CEEC_MAX_ERRCODE</name></decl>
}</block></enum></type><name>CheckExtentErrCode</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>     <name>eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CheckExtentErrCode</name></type>    <name>errtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>page_shardid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>is_occupied</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>shardid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>freespace_cat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>hwm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>scan_next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>scan_prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>alloc_next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>alloc_prev</name></decl>;</decl_stmt>
}</block></struct></type><name>CheckExtent</name>;</typedef>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>CheckExtentError</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><literal type="string">"NO_ERROR"</literal></expr>,
    <expr><literal type="string">"BLOCK_NOT_EXIST_IN_HEAP"</literal></expr>,
    <expr><literal type="string">"EXTENT_NOT_OCCUPIED_IN_CATALOG"</literal></expr>,
    <expr><literal type="string">"SHARDID_NOT_SAME"</literal></expr>,
    <expr><literal type="string">"CATALOG_CORRUPTED"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>    <name>currIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>last_eid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CheckExtent</name></type>    <name><name>mctxstat</name><index>[<expr><name>EMES_PER_PAGE</name></expr>]</index></name></decl>;</decl_stmt>    
}</block></struct></type> <name>CheckExtent_State</name>;</typedef>

<function><type><specifier>static</specifier> 
<name>void</name></type> <name>check_extent_catalog</name><parameter_list>(<parameter><decl><type><name>CheckExtent</name> <modifier>*</modifier></type><name>catalog</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>page_is_new</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if<condition>(<expr><name><name>catalog</name><operator>-&gt;</operator><name>errtype</name></name> <operator>!=</operator> <name>CEEC_NO_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>page_is_new</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>catalog</name><operator>-&gt;</operator><name>is_occupied</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name><name>catalog</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>catalog</name><operator>-&gt;</operator><name>shardid</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator>
            <operator>||</operator> <call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>catalog</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call>
            <operator>||</operator> <call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>catalog</name><operator>-&gt;</operator><name>scan_prev</name></name></expr></argument>)</argument_list></call>
            <operator>||</operator> <call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>catalog</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call>
            <operator>||</operator> <call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>catalog</name><operator>-&gt;</operator><name>alloc_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>catalog</name><operator>-&gt;</operator><name>errtype</name></name> <operator>=</operator> <name>CEEC_CATALOG_CORRUPTED</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name><name>catalog</name><operator>-&gt;</operator><name>page_shardid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>catalog</name><operator>-&gt;</operator><name>errtype</name></name> <operator>=</operator> <name>CEEC_EXTENT_NOT_OCCUPIED_IN_CATALOG</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name><name>catalog</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>catalog</name><operator>-&gt;</operator><name>errtype</name></name> <operator>=</operator> <name>CEEC_CATALOG_CORRUPTED</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>catalog</name><operator>-&gt;</operator><name>shardid</name></name> <operator>!=</operator> <name><name>catalog</name><operator>-&gt;</operator><name>page_shardid</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>catalog</name><operator>-&gt;</operator><name>errtype</name></name> <operator>=</operator> <name>CEEC_SHARDID_NOT_SAME</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>pg_check_extent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_EXTENT_COLUMN_NUM</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>relOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CheckExtent_State</name>    <modifier>*</modifier></type><name>mctx_status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>   <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
                * Switch to memory context appropriate for multiple function calls
                */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>CHECK_EXTENT_COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"eid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"error_type"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>,
                         <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"page_shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"is_occupied"</literal></expr></argument>,
                         <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"extent_shardid"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"freespace_cat"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"hwm"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"scan_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"scan_prev"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"alloc_next"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="string">"alloc_prev"</literal></expr></argument>,
                         <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mctx_status</name> <operator>=</operator> <operator>(</operator><name>CheckExtent_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckExtent_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mctx_status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mctx_status</name>  <operator>=</operator> <operator>(</operator><name>CheckExtent_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>&lt;</operator> <name>MAX_EXTENTS</name></expr>)</condition>
    <block>{<block_content>
           <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>CHECK_EXTENT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>CHECK_EXTENT_COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CheckExtent</name>    <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Buffer</name></type>         <name>buf</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAPage</name></type>        <name>pg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EMAAddress</name></type>    <name>addr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>( <argument><expr><name>funcctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>ema_eid_to_address</name><argument_list>(<argument><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>extent_readbuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,  <argument><expr><name><name>addr</name><operator>.</operator><name>physical_page_number</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr> )</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>( <argument><expr><name>funcctx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pg</name> <operator>=</operator> <operator>(</operator><name>EMAPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>n_emes</name></name></expr>;</expr_stmt>

            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_next</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>alloc_prev</name> <operator>=</operator> <call><name>EMEGetAllocPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name> <operator>=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_occupied</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shardid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>freespace_cat</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>max_freespace</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hwm</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_next</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name> <operator>=</operator> <name><name>pg</name><operator>-&gt;</operator><name>ema</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scan_prev</name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ExtentID</name></type> <name>eid</name> <init>= <expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eid</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Buffer</name></type>    <name>data_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>errtype</name><operator>=</operator> <name>CEEC_NO_ERROR</name></expr>;</expr_stmt>
                    
                <expr_stmt><expr><name>data_buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>page_shardid</name> <operator>=</operator> <name>InvalidShardID</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>errtype</name><operator>=</operator> <name>CEEC_BLOCK_NOT_EXIST_IN_HEAP</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>page_shardid</name> <operator>=</operator> <name>InvalidShardID</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>check_extent_catalog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>page_shardid</name> <operator>=</operator> <call><name>PageGetShardId</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>check_extent_catalog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                
                <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                        
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <name>EMES_PER_PAGE</name> 
            <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name><operator>)</operator> <operator>&gt;=</operator> <name><name>mctx_status</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>stat</name> <operator>=</operator> <operator>&amp;</operator><name><name>mctx_status</name><operator>-&gt;</operator><name>mctxstat</name><index>[<expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>%</operator> <name>EMES_PER_PAGE</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>eid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>errtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>CheckExtentError</name><index>[<expr><name><name>stat</name><operator>-&gt;</operator><name>errtype</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>page_shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>is_occupied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>freespace_cat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>scan_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>alloc_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mctx_status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
</block_content>}</block></function>

</unit>
